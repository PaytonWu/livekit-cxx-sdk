// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video_frame.proto

#include "video_frame.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace livekit {
namespace proto {
PROTOBUF_CONSTEXPR NewVideoStreamRequest::NewVideoStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.track_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.normalize_stride_)*/false} {}
struct NewVideoStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewVideoStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewVideoStreamRequestDefaultTypeInternal() {}
  union {
    NewVideoStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewVideoStreamRequestDefaultTypeInternal _NewVideoStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR NewVideoStreamResponse::NewVideoStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_)*/nullptr} {}
struct NewVideoStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewVideoStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewVideoStreamResponseDefaultTypeInternal() {}
  union {
    NewVideoStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewVideoStreamResponseDefaultTypeInternal _NewVideoStreamResponse_default_instance_;
PROTOBUF_CONSTEXPR VideoStreamFromParticipantRequest::VideoStreamFromParticipantRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.track_source_)*/0
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.normalize_stride_)*/false} {}
struct VideoStreamFromParticipantRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoStreamFromParticipantRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoStreamFromParticipantRequestDefaultTypeInternal() {}
  union {
    VideoStreamFromParticipantRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoStreamFromParticipantRequestDefaultTypeInternal _VideoStreamFromParticipantRequest_default_instance_;
PROTOBUF_CONSTEXPR VideoStreamFromParticipantResponse::VideoStreamFromParticipantResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_)*/nullptr} {}
struct VideoStreamFromParticipantResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoStreamFromParticipantResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoStreamFromParticipantResponseDefaultTypeInternal() {}
  union {
    VideoStreamFromParticipantResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoStreamFromParticipantResponseDefaultTypeInternal _VideoStreamFromParticipantResponse_default_instance_;
PROTOBUF_CONSTEXPR NewVideoSourceRequest::NewVideoSourceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resolution_)*/nullptr
  , /*decltype(_impl_.type_)*/0} {}
struct NewVideoSourceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewVideoSourceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewVideoSourceRequestDefaultTypeInternal() {}
  union {
    NewVideoSourceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewVideoSourceRequestDefaultTypeInternal _NewVideoSourceRequest_default_instance_;
PROTOBUF_CONSTEXPR NewVideoSourceResponse::NewVideoSourceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_)*/nullptr} {}
struct NewVideoSourceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewVideoSourceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewVideoSourceResponseDefaultTypeInternal() {}
  union {
    NewVideoSourceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewVideoSourceResponseDefaultTypeInternal _NewVideoSourceResponse_default_instance_;
PROTOBUF_CONSTEXPR CaptureVideoFrameRequest::CaptureVideoFrameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr
  , /*decltype(_impl_.source_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.timestamp_us_)*/int64_t{0}
  , /*decltype(_impl_.rotation_)*/0} {}
struct CaptureVideoFrameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureVideoFrameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureVideoFrameRequestDefaultTypeInternal() {}
  union {
    CaptureVideoFrameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureVideoFrameRequestDefaultTypeInternal _CaptureVideoFrameRequest_default_instance_;
PROTOBUF_CONSTEXPR CaptureVideoFrameResponse::CaptureVideoFrameResponse(
    ::_pbi::ConstantInitialized) {}
struct CaptureVideoFrameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureVideoFrameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureVideoFrameResponseDefaultTypeInternal() {}
  union {
    CaptureVideoFrameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureVideoFrameResponseDefaultTypeInternal _CaptureVideoFrameResponse_default_instance_;
PROTOBUF_CONSTEXPR VideoConvertRequest::VideoConvertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr
  , /*decltype(_impl_.flip_y_)*/false
  , /*decltype(_impl_.dst_type_)*/0} {}
struct VideoConvertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoConvertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoConvertRequestDefaultTypeInternal() {}
  union {
    VideoConvertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoConvertRequestDefaultTypeInternal _VideoConvertRequest_default_instance_;
PROTOBUF_CONSTEXPR VideoConvertResponse::VideoConvertResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VideoConvertResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoConvertResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoConvertResponseDefaultTypeInternal() {}
  union {
    VideoConvertResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoConvertResponseDefaultTypeInternal _VideoConvertResponse_default_instance_;
PROTOBUF_CONSTEXPR VideoResolution::VideoResolution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.frame_rate_)*/0} {}
struct VideoResolutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoResolutionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoResolutionDefaultTypeInternal() {}
  union {
    VideoResolution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoResolutionDefaultTypeInternal _VideoResolution_default_instance_;
PROTOBUF_CONSTEXPR VideoBufferInfo_ComponentInfo::VideoBufferInfo_ComponentInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.stride_)*/0u
  , /*decltype(_impl_.size_)*/0u} {}
struct VideoBufferInfo_ComponentInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoBufferInfo_ComponentInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoBufferInfo_ComponentInfoDefaultTypeInternal() {}
  union {
    VideoBufferInfo_ComponentInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoBufferInfo_ComponentInfoDefaultTypeInternal _VideoBufferInfo_ComponentInfo_default_instance_;
PROTOBUF_CONSTEXPR VideoBufferInfo::VideoBufferInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.components_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.stride_)*/0u} {}
struct VideoBufferInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoBufferInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoBufferInfoDefaultTypeInternal() {}
  union {
    VideoBufferInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoBufferInfoDefaultTypeInternal _VideoBufferInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedVideoBuffer::OwnedVideoBuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedVideoBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedVideoBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedVideoBufferDefaultTypeInternal() {}
  union {
    OwnedVideoBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedVideoBufferDefaultTypeInternal _OwnedVideoBuffer_default_instance_;
PROTOBUF_CONSTEXPR VideoStreamInfo::VideoStreamInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct VideoStreamInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoStreamInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoStreamInfoDefaultTypeInternal() {}
  union {
    VideoStreamInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoStreamInfoDefaultTypeInternal _VideoStreamInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedVideoStream::OwnedVideoStream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedVideoStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedVideoStreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedVideoStreamDefaultTypeInternal() {}
  union {
    OwnedVideoStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedVideoStreamDefaultTypeInternal _OwnedVideoStream_default_instance_;
PROTOBUF_CONSTEXPR VideoStreamEvent::VideoStreamEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct VideoStreamEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoStreamEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoStreamEventDefaultTypeInternal() {}
  union {
    VideoStreamEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoStreamEventDefaultTypeInternal _VideoStreamEvent_default_instance_;
PROTOBUF_CONSTEXPR VideoFrameReceived::VideoFrameReceived(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr
  , /*decltype(_impl_.timestamp_us_)*/int64_t{0}
  , /*decltype(_impl_.rotation_)*/0} {}
struct VideoFrameReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoFrameReceivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoFrameReceivedDefaultTypeInternal() {}
  union {
    VideoFrameReceived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoFrameReceivedDefaultTypeInternal _VideoFrameReceived_default_instance_;
PROTOBUF_CONSTEXPR VideoStreamEOS::VideoStreamEOS(
    ::_pbi::ConstantInitialized) {}
struct VideoStreamEOSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoStreamEOSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoStreamEOSDefaultTypeInternal() {}
  union {
    VideoStreamEOS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoStreamEOSDefaultTypeInternal _VideoStreamEOS_default_instance_;
PROTOBUF_CONSTEXPR VideoSourceResolution::VideoSourceResolution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u} {}
struct VideoSourceResolutionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoSourceResolutionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoSourceResolutionDefaultTypeInternal() {}
  union {
    VideoSourceResolution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoSourceResolutionDefaultTypeInternal _VideoSourceResolution_default_instance_;
PROTOBUF_CONSTEXPR VideoSourceInfo::VideoSourceInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct VideoSourceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoSourceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoSourceInfoDefaultTypeInternal() {}
  union {
    VideoSourceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoSourceInfoDefaultTypeInternal _VideoSourceInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedVideoSource::OwnedVideoSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedVideoSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedVideoSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedVideoSourceDefaultTypeInternal() {}
  union {
    OwnedVideoSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedVideoSourceDefaultTypeInternal _OwnedVideoSource_default_instance_;
}  // namespace proto
}  // namespace livekit
static ::_pb::Metadata file_level_metadata_video_5fframe_2eproto[22];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_video_5fframe_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_video_5fframe_2eproto = nullptr;

const uint32_t TableStruct_video_5fframe_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _impl_.track_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamRequest, _impl_.normalize_stride_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoStreamResponse, _impl_.stream_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_.participant_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_.track_source_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantRequest, _impl_.normalize_stride_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamFromParticipantResponse, _impl_.stream_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceRequest, _impl_.resolution_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewVideoSourceResponse, _impl_.source_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _impl_.source_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _impl_.buffer_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _impl_.timestamp_us_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameRequest, _impl_.rotation_),
  1,
  0,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureVideoFrameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertRequest, _impl_.flip_y_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertRequest, _impl_.buffer_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertRequest, _impl_.dst_type_),
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoConvertResponse, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoResolution, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoResolution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoResolution, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoResolution, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoResolution, _impl_.frame_rate_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo_ComponentInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo_ComponentInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo_ComponentInfo, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo_ComponentInfo, _impl_.stride_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo_ComponentInfo, _impl_.size_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.stride_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoBufferInfo, _impl_.components_),
  0,
  1,
  3,
  2,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoBuffer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoBuffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoBuffer, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoBuffer, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamInfo, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoStream, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoStream, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoStream, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEvent, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEvent, _impl_.stream_handle_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEvent, _impl_.message_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoFrameReceived, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoFrameReceived, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoFrameReceived, _impl_.buffer_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoFrameReceived, _impl_.timestamp_us_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoFrameReceived, _impl_.rotation_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoStreamEOS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceResolution, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceResolution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceResolution, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceResolution, _impl_.height_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::VideoSourceInfo, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoSource, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedVideoSource, _impl_.info_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::livekit::proto::NewVideoStreamRequest)},
  { 14, 21, -1, sizeof(::livekit::proto::NewVideoStreamResponse)},
  { 22, 33, -1, sizeof(::livekit::proto::VideoStreamFromParticipantRequest)},
  { 38, 45, -1, sizeof(::livekit::proto::VideoStreamFromParticipantResponse)},
  { 46, 54, -1, sizeof(::livekit::proto::NewVideoSourceRequest)},
  { 56, 63, -1, sizeof(::livekit::proto::NewVideoSourceResponse)},
  { 64, 74, -1, sizeof(::livekit::proto::CaptureVideoFrameRequest)},
  { 78, -1, -1, sizeof(::livekit::proto::CaptureVideoFrameResponse)},
  { 84, 93, -1, sizeof(::livekit::proto::VideoConvertRequest)},
  { 96, -1, -1, sizeof(::livekit::proto::VideoConvertResponse)},
  { 105, 114, -1, sizeof(::livekit::proto::VideoResolution)},
  { 117, 126, -1, sizeof(::livekit::proto::VideoBufferInfo_ComponentInfo)},
  { 129, 141, -1, sizeof(::livekit::proto::VideoBufferInfo)},
  { 147, 155, -1, sizeof(::livekit::proto::OwnedVideoBuffer)},
  { 157, 164, -1, sizeof(::livekit::proto::VideoStreamInfo)},
  { 165, 173, -1, sizeof(::livekit::proto::OwnedVideoStream)},
  { 175, 185, -1, sizeof(::livekit::proto::VideoStreamEvent)},
  { 188, 197, -1, sizeof(::livekit::proto::VideoFrameReceived)},
  { 200, -1, -1, sizeof(::livekit::proto::VideoStreamEOS)},
  { 206, 214, -1, sizeof(::livekit::proto::VideoSourceResolution)},
  { 216, 223, -1, sizeof(::livekit::proto::VideoSourceInfo)},
  { 224, 232, -1, sizeof(::livekit::proto::OwnedVideoSource)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::livekit::proto::_NewVideoStreamRequest_default_instance_._instance,
  &::livekit::proto::_NewVideoStreamResponse_default_instance_._instance,
  &::livekit::proto::_VideoStreamFromParticipantRequest_default_instance_._instance,
  &::livekit::proto::_VideoStreamFromParticipantResponse_default_instance_._instance,
  &::livekit::proto::_NewVideoSourceRequest_default_instance_._instance,
  &::livekit::proto::_NewVideoSourceResponse_default_instance_._instance,
  &::livekit::proto::_CaptureVideoFrameRequest_default_instance_._instance,
  &::livekit::proto::_CaptureVideoFrameResponse_default_instance_._instance,
  &::livekit::proto::_VideoConvertRequest_default_instance_._instance,
  &::livekit::proto::_VideoConvertResponse_default_instance_._instance,
  &::livekit::proto::_VideoResolution_default_instance_._instance,
  &::livekit::proto::_VideoBufferInfo_ComponentInfo_default_instance_._instance,
  &::livekit::proto::_VideoBufferInfo_default_instance_._instance,
  &::livekit::proto::_OwnedVideoBuffer_default_instance_._instance,
  &::livekit::proto::_VideoStreamInfo_default_instance_._instance,
  &::livekit::proto::_OwnedVideoStream_default_instance_._instance,
  &::livekit::proto::_VideoStreamEvent_default_instance_._instance,
  &::livekit::proto::_VideoFrameReceived_default_instance_._instance,
  &::livekit::proto::_VideoStreamEOS_default_instance_._instance,
  &::livekit::proto::_VideoSourceResolution_default_instance_._instance,
  &::livekit::proto::_VideoSourceInfo_default_instance_._instance,
  &::livekit::proto::_OwnedVideoSource_default_instance_._instance,
};

const char descriptor_table_protodef_video_5fframe_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021video_frame.proto\022\rlivekit.proto\032\014hand"
  "le.proto\032\013track.proto\"\245\001\n\025NewVideoStream"
  "Request\022\024\n\014track_handle\030\001 \002(\004\022,\n\004type\030\002 "
  "\002(\0162\036.livekit.proto.VideoStreamType\022.\n\006f"
  "ormat\030\003 \001(\0162\036.livekit.proto.VideoBufferT"
  "ype\022\030\n\020normalize_stride\030\004 \001(\010\"I\n\026NewVide"
  "oStreamResponse\022/\n\006stream\030\001 \002(\0132\037.liveki"
  "t.proto.OwnedVideoStream\"\351\001\n!VideoStream"
  "FromParticipantRequest\022\032\n\022participant_ha"
  "ndle\030\001 \002(\004\022,\n\004type\030\002 \002(\0162\036.livekit.proto"
  ".VideoStreamType\0220\n\014track_source\030\003 \002(\0162\032"
  ".livekit.proto.TrackSource\022.\n\006format\030\004 \001"
  "(\0162\036.livekit.proto.VideoBufferType\022\030\n\020no"
  "rmalize_stride\030\005 \001(\010\"U\n\"VideoStreamFromP"
  "articipantResponse\022/\n\006stream\030\001 \002(\0132\037.liv"
  "ekit.proto.OwnedVideoStream\"\177\n\025NewVideoS"
  "ourceRequest\022,\n\004type\030\001 \002(\0162\036.livekit.pro"
  "to.VideoSourceType\0228\n\nresolution\030\002 \002(\0132$"
  ".livekit.proto.VideoSourceResolution\"I\n\026"
  "NewVideoSourceResponse\022/\n\006source\030\001 \002(\0132\037"
  ".livekit.proto.OwnedVideoSource\"\247\001\n\030Capt"
  "ureVideoFrameRequest\022\025\n\rsource_handle\030\001 "
  "\002(\004\022.\n\006buffer\030\002 \002(\0132\036.livekit.proto.Vide"
  "oBufferInfo\022\024\n\014timestamp_us\030\003 \002(\003\022.\n\010rot"
  "ation\030\004 \002(\0162\034.livekit.proto.VideoRotatio"
  "n\"\033\n\031CaptureVideoFrameResponse\"\207\001\n\023Video"
  "ConvertRequest\022\016\n\006flip_y\030\001 \001(\010\022.\n\006buffer"
  "\030\002 \002(\0132\036.livekit.proto.VideoBufferInfo\0220"
  "\n\010dst_type\030\003 \002(\0162\036.livekit.proto.VideoBu"
  "fferType\"e\n\024VideoConvertResponse\022\017\n\005erro"
  "r\030\001 \001(\tH\000\0221\n\006buffer\030\002 \001(\0132\037.livekit.prot"
  "o.OwnedVideoBufferH\000B\t\n\007message\"D\n\017Video"
  "Resolution\022\r\n\005width\030\001 \002(\r\022\016\n\006height\030\002 \002("
  "\r\022\022\n\nframe_rate\030\003 \002(\001\"\203\002\n\017VideoBufferInf"
  "o\022,\n\004type\030\001 \002(\0162\036.livekit.proto.VideoBuf"
  "ferType\022\r\n\005width\030\002 \002(\r\022\016\n\006height\030\003 \002(\r\022\020"
  "\n\010data_ptr\030\004 \002(\004\022\016\n\006stride\030\006 \001(\r\022@\n\ncomp"
  "onents\030\007 \003(\0132,.livekit.proto.VideoBuffer"
  "Info.ComponentInfo\032\?\n\rComponentInfo\022\020\n\010d"
  "ata_ptr\030\001 \002(\004\022\016\n\006stride\030\002 \002(\r\022\014\n\004size\030\003 "
  "\002(\r\"o\n\020OwnedVideoBuffer\022-\n\006handle\030\001 \002(\0132"
  "\035.livekit.proto.FfiOwnedHandle\022,\n\004info\030\002"
  " \002(\0132\036.livekit.proto.VideoBufferInfo\"\?\n\017"
  "VideoStreamInfo\022,\n\004type\030\001 \002(\0162\036.livekit."
  "proto.VideoStreamType\"o\n\020OwnedVideoStrea"
  "m\022-\n\006handle\030\001 \002(\0132\035.livekit.proto.FfiOwn"
  "edHandle\022,\n\004info\030\002 \002(\0132\036.livekit.proto.V"
  "ideoStreamInfo\"\237\001\n\020VideoStreamEvent\022\025\n\rs"
  "tream_handle\030\001 \002(\004\022;\n\016frame_received\030\002 \001"
  "(\0132!.livekit.proto.VideoFrameReceivedH\000\022"
  ",\n\003eos\030\003 \001(\0132\035.livekit.proto.VideoStream"
  "EOSH\000B\t\n\007message\"\213\001\n\022VideoFrameReceived\022"
  "/\n\006buffer\030\001 \002(\0132\037.livekit.proto.OwnedVid"
  "eoBuffer\022\024\n\014timestamp_us\030\002 \002(\003\022.\n\010rotati"
  "on\030\003 \002(\0162\034.livekit.proto.VideoRotation\"\020"
  "\n\016VideoStreamEOS\"6\n\025VideoSourceResolutio"
  "n\022\r\n\005width\030\001 \002(\r\022\016\n\006height\030\002 \002(\r\"\?\n\017Vide"
  "oSourceInfo\022,\n\004type\030\001 \002(\0162\036.livekit.prot"
  "o.VideoSourceType\"o\n\020OwnedVideoSource\022-\n"
  "\006handle\030\001 \002(\0132\035.livekit.proto.FfiOwnedHa"
  "ndle\022,\n\004info\030\002 \002(\0132\036.livekit.proto.Video"
  "SourceInfo*1\n\nVideoCodec\022\007\n\003VP8\020\000\022\010\n\004H26"
  "4\020\001\022\007\n\003AV1\020\002\022\007\n\003VP9\020\003*l\n\rVideoRotation\022\024"
  "\n\020VIDEO_ROTATION_0\020\000\022\025\n\021VIDEO_ROTATION_9"
  "0\020\001\022\026\n\022VIDEO_ROTATION_180\020\002\022\026\n\022VIDEO_ROT"
  "ATION_270\020\003*\201\001\n\017VideoBufferType\022\010\n\004RGBA\020"
  "\000\022\010\n\004ABGR\020\001\022\010\n\004ARGB\020\002\022\010\n\004BGRA\020\003\022\t\n\005RGB24"
  "\020\004\022\010\n\004I420\020\005\022\t\n\005I420A\020\006\022\010\n\004I422\020\007\022\010\n\004I44"
  "4\020\010\022\010\n\004I010\020\t\022\010\n\004NV12\020\n*Y\n\017VideoStreamTy"
  "pe\022\027\n\023VIDEO_STREAM_NATIVE\020\000\022\026\n\022VIDEO_STR"
  "EAM_WEBGL\020\001\022\025\n\021VIDEO_STREAM_HTML\020\002**\n\017Vi"
  "deoSourceType\022\027\n\023VIDEO_SOURCE_NATIVE\020\000B\020"
  "\252\002\rLiveKit.Proto"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_video_5fframe_2eproto_deps[2] = {
  &::descriptor_table_handle_2eproto,
  &::descriptor_table_track_2eproto,
};
static ::_pbi::once_flag descriptor_table_video_5fframe_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_video_5fframe_2eproto = {
    false, false, 2896, descriptor_table_protodef_video_5fframe_2eproto,
    "video_frame.proto",
    &descriptor_table_video_5fframe_2eproto_once, descriptor_table_video_5fframe_2eproto_deps, 2, 22,
    schemas, file_default_instances, TableStruct_video_5fframe_2eproto::offsets,
    file_level_metadata_video_5fframe_2eproto, file_level_enum_descriptors_video_5fframe_2eproto,
    file_level_service_descriptors_video_5fframe_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_video_5fframe_2eproto_getter() {
  return &descriptor_table_video_5fframe_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_video_5fframe_2eproto(&descriptor_table_video_5fframe_2eproto);
namespace livekit {
namespace proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoCodec_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_video_5fframe_2eproto);
  return file_level_enum_descriptors_video_5fframe_2eproto[0];
}
bool VideoCodec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoRotation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_video_5fframe_2eproto);
  return file_level_enum_descriptors_video_5fframe_2eproto[1];
}
bool VideoRotation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoBufferType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_video_5fframe_2eproto);
  return file_level_enum_descriptors_video_5fframe_2eproto[2];
}
bool VideoBufferType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoStreamType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_video_5fframe_2eproto);
  return file_level_enum_descriptors_video_5fframe_2eproto[3];
}
bool VideoStreamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_video_5fframe_2eproto);
  return file_level_enum_descriptors_video_5fframe_2eproto[4];
}
bool VideoSourceType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NewVideoStreamRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewVideoStreamRequest>()._impl_._has_bits_);
  static void set_has_track_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_normalize_stride(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

NewVideoStreamRequest::NewVideoStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewVideoStreamRequest)
}
NewVideoStreamRequest::NewVideoStreamRequest(const NewVideoStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewVideoStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.track_handle_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.normalize_stride_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.track_handle_, &from._impl_.track_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.normalize_stride_) -
    reinterpret_cast<char*>(&_impl_.track_handle_)) + sizeof(_impl_.normalize_stride_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewVideoStreamRequest)
}

inline void NewVideoStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.track_handle_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.normalize_stride_){false}
  };
}

NewVideoStreamRequest::~NewVideoStreamRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewVideoStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewVideoStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NewVideoStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewVideoStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewVideoStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.track_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.normalize_stride_) -
        reinterpret_cast<char*>(&_impl_.track_handle_)) + sizeof(_impl_.normalize_stride_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewVideoStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 track_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_track_handle(&has_bits);
          _impl_.track_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoStreamType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .livekit.proto.VideoBufferType format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoBufferType_IsValid(val))) {
            _internal_set_format(static_cast<::livekit::proto::VideoBufferType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool normalize_stride = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_normalize_stride(&has_bits);
          _impl_.normalize_stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewVideoStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewVideoStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 track_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_track_handle(), target);
  }

  // required .livekit.proto.VideoStreamType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional .livekit.proto.VideoBufferType format = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_format(), target);
  }

  // optional bool normalize_stride = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_normalize_stride(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewVideoStreamRequest)
  return target;
}

size_t NewVideoStreamRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewVideoStreamRequest)
  size_t total_size = 0;

  if (_internal_has_track_handle()) {
    // required uint64 track_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_handle());
  }

  if (_internal_has_type()) {
    // required .livekit.proto.VideoStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t NewVideoStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewVideoStreamRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 track_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_handle());

    // required .livekit.proto.VideoStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional .livekit.proto.VideoBufferType format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional bool normalize_stride = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewVideoStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewVideoStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewVideoStreamRequest::GetClassData() const { return &_class_data_; }


void NewVideoStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewVideoStreamRequest*>(&to_msg);
  auto& from = static_cast<const NewVideoStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewVideoStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.track_handle_ = from._impl_.track_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.normalize_stride_ = from._impl_.normalize_stride_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewVideoStreamRequest::CopyFrom(const NewVideoStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewVideoStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVideoStreamRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NewVideoStreamRequest::InternalSwap(NewVideoStreamRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewVideoStreamRequest, _impl_.normalize_stride_)
      + sizeof(NewVideoStreamRequest::_impl_.normalize_stride_)
      - PROTOBUF_FIELD_OFFSET(NewVideoStreamRequest, _impl_.track_handle_)>(
          reinterpret_cast<char*>(&_impl_.track_handle_),
          reinterpret_cast<char*>(&other->_impl_.track_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewVideoStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[0]);
}

// ===================================================================

class NewVideoStreamResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewVideoStreamResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedVideoStream& stream(const NewVideoStreamResponse* msg);
  static void set_has_stream(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedVideoStream&
NewVideoStreamResponse::_Internal::stream(const NewVideoStreamResponse* msg) {
  return *msg->_impl_.stream_;
}
NewVideoStreamResponse::NewVideoStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewVideoStreamResponse)
}
NewVideoStreamResponse::NewVideoStreamResponse(const NewVideoStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewVideoStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stream()) {
    _this->_impl_.stream_ = new ::livekit::proto::OwnedVideoStream(*from._impl_.stream_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewVideoStreamResponse)
}

inline void NewVideoStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}
  };
}

NewVideoStreamResponse::~NewVideoStreamResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewVideoStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewVideoStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stream_;
}

void NewVideoStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewVideoStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewVideoStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.stream_ != nullptr);
    _impl_.stream_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewVideoStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedVideoStream stream = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewVideoStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewVideoStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedVideoStream stream = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stream(this),
        _Internal::stream(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewVideoStreamResponse)
  return target;
}

size_t NewVideoStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewVideoStreamResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedVideoStream stream = 1;
  if (_internal_has_stream()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stream_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewVideoStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewVideoStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewVideoStreamResponse::GetClassData() const { return &_class_data_; }


void NewVideoStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewVideoStreamResponse*>(&to_msg);
  auto& from = static_cast<const NewVideoStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewVideoStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream()) {
    _this->_internal_mutable_stream()->::livekit::proto::OwnedVideoStream::MergeFrom(
        from._internal_stream());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewVideoStreamResponse::CopyFrom(const NewVideoStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewVideoStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVideoStreamResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_stream()) {
    if (!_impl_.stream_->IsInitialized()) return false;
  }
  return true;
}

void NewVideoStreamResponse::InternalSwap(NewVideoStreamResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_, other->_impl_.stream_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewVideoStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[1]);
}

// ===================================================================

class VideoStreamFromParticipantRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoStreamFromParticipantRequest>()._impl_._has_bits_);
  static void set_has_participant_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_track_source(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_normalize_stride(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VideoStreamFromParticipantRequest::VideoStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoStreamFromParticipantRequest)
}
VideoStreamFromParticipantRequest::VideoStreamFromParticipantRequest(const VideoStreamFromParticipantRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoStreamFromParticipantRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_handle_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.track_source_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.normalize_stride_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.participant_handle_, &from._impl_.participant_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.normalize_stride_) -
    reinterpret_cast<char*>(&_impl_.participant_handle_)) + sizeof(_impl_.normalize_stride_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoStreamFromParticipantRequest)
}

inline void VideoStreamFromParticipantRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_handle_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.track_source_){0}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.normalize_stride_){false}
  };
}

VideoStreamFromParticipantRequest::~VideoStreamFromParticipantRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoStreamFromParticipantRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoStreamFromParticipantRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoStreamFromParticipantRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoStreamFromParticipantRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoStreamFromParticipantRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.participant_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.normalize_stride_) -
        reinterpret_cast<char*>(&_impl_.participant_handle_)) + sizeof(_impl_.normalize_stride_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoStreamFromParticipantRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 participant_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_participant_handle(&has_bits);
          _impl_.participant_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoStreamType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.TrackSource track_source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::TrackSource_IsValid(val))) {
            _internal_set_track_source(static_cast<::livekit::proto::TrackSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .livekit.proto.VideoBufferType format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoBufferType_IsValid(val))) {
            _internal_set_format(static_cast<::livekit::proto::VideoBufferType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool normalize_stride = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_normalize_stride(&has_bits);
          _impl_.normalize_stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoStreamFromParticipantRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoStreamFromParticipantRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 participant_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_participant_handle(), target);
  }

  // required .livekit.proto.VideoStreamType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // required .livekit.proto.TrackSource track_source = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_track_source(), target);
  }

  // optional .livekit.proto.VideoBufferType format = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_format(), target);
  }

  // optional bool normalize_stride = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_normalize_stride(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoStreamFromParticipantRequest)
  return target;
}

size_t VideoStreamFromParticipantRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoStreamFromParticipantRequest)
  size_t total_size = 0;

  if (_internal_has_participant_handle()) {
    // required uint64 participant_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_participant_handle());
  }

  if (_internal_has_type()) {
    // required .livekit.proto.VideoStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_track_source()) {
    // required .livekit.proto.TrackSource track_source = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_track_source());
  }

  return total_size;
}
size_t VideoStreamFromParticipantRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoStreamFromParticipantRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint64 participant_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_participant_handle());

    // required .livekit.proto.VideoStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    // required .livekit.proto.TrackSource track_source = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_track_source());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional .livekit.proto.VideoBufferType format = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional bool normalize_stride = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoStreamFromParticipantRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoStreamFromParticipantRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoStreamFromParticipantRequest::GetClassData() const { return &_class_data_; }


void VideoStreamFromParticipantRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoStreamFromParticipantRequest*>(&to_msg);
  auto& from = static_cast<const VideoStreamFromParticipantRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoStreamFromParticipantRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.participant_handle_ = from._impl_.participant_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.track_source_ = from._impl_.track_source_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.normalize_stride_ = from._impl_.normalize_stride_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoStreamFromParticipantRequest::CopyFrom(const VideoStreamFromParticipantRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoStreamFromParticipantRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoStreamFromParticipantRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoStreamFromParticipantRequest::InternalSwap(VideoStreamFromParticipantRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoStreamFromParticipantRequest, _impl_.normalize_stride_)
      + sizeof(VideoStreamFromParticipantRequest::_impl_.normalize_stride_)
      - PROTOBUF_FIELD_OFFSET(VideoStreamFromParticipantRequest, _impl_.participant_handle_)>(
          reinterpret_cast<char*>(&_impl_.participant_handle_),
          reinterpret_cast<char*>(&other->_impl_.participant_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoStreamFromParticipantRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[2]);
}

// ===================================================================

class VideoStreamFromParticipantResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoStreamFromParticipantResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedVideoStream& stream(const VideoStreamFromParticipantResponse* msg);
  static void set_has_stream(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedVideoStream&
VideoStreamFromParticipantResponse::_Internal::stream(const VideoStreamFromParticipantResponse* msg) {
  return *msg->_impl_.stream_;
}
VideoStreamFromParticipantResponse::VideoStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoStreamFromParticipantResponse)
}
VideoStreamFromParticipantResponse::VideoStreamFromParticipantResponse(const VideoStreamFromParticipantResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoStreamFromParticipantResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stream()) {
    _this->_impl_.stream_ = new ::livekit::proto::OwnedVideoStream(*from._impl_.stream_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoStreamFromParticipantResponse)
}

inline void VideoStreamFromParticipantResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}
  };
}

VideoStreamFromParticipantResponse::~VideoStreamFromParticipantResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoStreamFromParticipantResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoStreamFromParticipantResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stream_;
}

void VideoStreamFromParticipantResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoStreamFromParticipantResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoStreamFromParticipantResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.stream_ != nullptr);
    _impl_.stream_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoStreamFromParticipantResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedVideoStream stream = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoStreamFromParticipantResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoStreamFromParticipantResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedVideoStream stream = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stream(this),
        _Internal::stream(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoStreamFromParticipantResponse)
  return target;
}

size_t VideoStreamFromParticipantResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoStreamFromParticipantResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedVideoStream stream = 1;
  if (_internal_has_stream()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stream_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoStreamFromParticipantResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoStreamFromParticipantResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoStreamFromParticipantResponse::GetClassData() const { return &_class_data_; }


void VideoStreamFromParticipantResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoStreamFromParticipantResponse*>(&to_msg);
  auto& from = static_cast<const VideoStreamFromParticipantResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoStreamFromParticipantResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream()) {
    _this->_internal_mutable_stream()->::livekit::proto::OwnedVideoStream::MergeFrom(
        from._internal_stream());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoStreamFromParticipantResponse::CopyFrom(const VideoStreamFromParticipantResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoStreamFromParticipantResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoStreamFromParticipantResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_stream()) {
    if (!_impl_.stream_->IsInitialized()) return false;
  }
  return true;
}

void VideoStreamFromParticipantResponse::InternalSwap(VideoStreamFromParticipantResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_, other->_impl_.stream_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoStreamFromParticipantResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[3]);
}

// ===================================================================

class NewVideoSourceRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewVideoSourceRequest>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::VideoSourceResolution& resolution(const NewVideoSourceRequest* msg);
  static void set_has_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::VideoSourceResolution&
NewVideoSourceRequest::_Internal::resolution(const NewVideoSourceRequest* msg) {
  return *msg->_impl_.resolution_;
}
NewVideoSourceRequest::NewVideoSourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewVideoSourceRequest)
}
NewVideoSourceRequest::NewVideoSourceRequest(const NewVideoSourceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewVideoSourceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resolution_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_resolution()) {
    _this->_impl_.resolution_ = new ::livekit::proto::VideoSourceResolution(*from._impl_.resolution_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewVideoSourceRequest)
}

inline void NewVideoSourceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resolution_){nullptr}
    , decltype(_impl_.type_){0}
  };
}

NewVideoSourceRequest::~NewVideoSourceRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewVideoSourceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewVideoSourceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.resolution_;
}

void NewVideoSourceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewVideoSourceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewVideoSourceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.resolution_ != nullptr);
    _impl_.resolution_->Clear();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewVideoSourceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.VideoSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoSourceResolution resolution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resolution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewVideoSourceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewVideoSourceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.VideoSourceType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required .livekit.proto.VideoSourceResolution resolution = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::resolution(this),
        _Internal::resolution(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewVideoSourceRequest)
  return target;
}

size_t NewVideoSourceRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewVideoSourceRequest)
  size_t total_size = 0;

  if (_internal_has_resolution()) {
    // required .livekit.proto.VideoSourceResolution resolution = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.resolution_);
  }

  if (_internal_has_type()) {
    // required .livekit.proto.VideoSourceType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t NewVideoSourceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewVideoSourceRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.VideoSourceResolution resolution = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.resolution_);

    // required .livekit.proto.VideoSourceType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewVideoSourceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewVideoSourceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewVideoSourceRequest::GetClassData() const { return &_class_data_; }


void NewVideoSourceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewVideoSourceRequest*>(&to_msg);
  auto& from = static_cast<const NewVideoSourceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewVideoSourceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_resolution()->::livekit::proto::VideoSourceResolution::MergeFrom(
          from._internal_resolution());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewVideoSourceRequest::CopyFrom(const NewVideoSourceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewVideoSourceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVideoSourceRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_resolution()) {
    if (!_impl_.resolution_->IsInitialized()) return false;
  }
  return true;
}

void NewVideoSourceRequest::InternalSwap(NewVideoSourceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewVideoSourceRequest, _impl_.type_)
      + sizeof(NewVideoSourceRequest::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(NewVideoSourceRequest, _impl_.resolution_)>(
          reinterpret_cast<char*>(&_impl_.resolution_),
          reinterpret_cast<char*>(&other->_impl_.resolution_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewVideoSourceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[4]);
}

// ===================================================================

class NewVideoSourceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewVideoSourceResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedVideoSource& source(const NewVideoSourceResponse* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedVideoSource&
NewVideoSourceResponse::_Internal::source(const NewVideoSourceResponse* msg) {
  return *msg->_impl_.source_;
}
NewVideoSourceResponse::NewVideoSourceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewVideoSourceResponse)
}
NewVideoSourceResponse::NewVideoSourceResponse(const NewVideoSourceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewVideoSourceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::livekit::proto::OwnedVideoSource(*from._impl_.source_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewVideoSourceResponse)
}

inline void NewVideoSourceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){nullptr}
  };
}

NewVideoSourceResponse::~NewVideoSourceResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewVideoSourceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewVideoSourceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.source_;
}

void NewVideoSourceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewVideoSourceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewVideoSourceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.source_ != nullptr);
    _impl_.source_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewVideoSourceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedVideoSource source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewVideoSourceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewVideoSourceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedVideoSource source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewVideoSourceResponse)
  return target;
}

size_t NewVideoSourceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewVideoSourceResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedVideoSource source = 1;
  if (_internal_has_source()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.source_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewVideoSourceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewVideoSourceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewVideoSourceResponse::GetClassData() const { return &_class_data_; }


void NewVideoSourceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewVideoSourceResponse*>(&to_msg);
  auto& from = static_cast<const NewVideoSourceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewVideoSourceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_source()) {
    _this->_internal_mutable_source()->::livekit::proto::OwnedVideoSource::MergeFrom(
        from._internal_source());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewVideoSourceResponse::CopyFrom(const NewVideoSourceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewVideoSourceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVideoSourceResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_source()) {
    if (!_impl_.source_->IsInitialized()) return false;
  }
  return true;
}

void NewVideoSourceResponse::InternalSwap(NewVideoSourceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.source_, other->_impl_.source_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewVideoSourceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[5]);
}

// ===================================================================

class CaptureVideoFrameRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CaptureVideoFrameRequest>()._impl_._has_bits_);
  static void set_has_source_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::VideoBufferInfo& buffer(const CaptureVideoFrameRequest* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_us(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::livekit::proto::VideoBufferInfo&
CaptureVideoFrameRequest::_Internal::buffer(const CaptureVideoFrameRequest* msg) {
  return *msg->_impl_.buffer_;
}
CaptureVideoFrameRequest::CaptureVideoFrameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.CaptureVideoFrameRequest)
}
CaptureVideoFrameRequest::CaptureVideoFrameRequest(const CaptureVideoFrameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaptureVideoFrameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.source_handle_){}
    , decltype(_impl_.timestamp_us_){}
    , decltype(_impl_.rotation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::VideoBufferInfo(*from._impl_.buffer_);
  }
  ::memcpy(&_impl_.source_handle_, &from._impl_.source_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotation_) -
    reinterpret_cast<char*>(&_impl_.source_handle_)) + sizeof(_impl_.rotation_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.CaptureVideoFrameRequest)
}

inline void CaptureVideoFrameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.source_handle_){uint64_t{0u}}
    , decltype(_impl_.timestamp_us_){int64_t{0}}
    , decltype(_impl_.rotation_){0}
  };
}

CaptureVideoFrameRequest::~CaptureVideoFrameRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.CaptureVideoFrameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureVideoFrameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void CaptureVideoFrameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaptureVideoFrameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.CaptureVideoFrameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.source_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rotation_) -
        reinterpret_cast<char*>(&_impl_.source_handle_)) + sizeof(_impl_.rotation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaptureVideoFrameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 source_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source_handle(&has_bits);
          _impl_.source_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoBufferInfo buffer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 timestamp_us = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp_us(&has_bits);
          _impl_.timestamp_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoRotation rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoRotation_IsValid(val))) {
            _internal_set_rotation(static_cast<::livekit::proto::VideoRotation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureVideoFrameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.CaptureVideoFrameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 source_handle = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_source_handle(), target);
  }

  // required .livekit.proto.VideoBufferInfo buffer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  // required int64 timestamp_us = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp_us(), target);
  }

  // required .livekit.proto.VideoRotation rotation = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_rotation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.CaptureVideoFrameRequest)
  return target;
}

size_t CaptureVideoFrameRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.CaptureVideoFrameRequest)
  size_t total_size = 0;

  if (_internal_has_buffer()) {
    // required .livekit.proto.VideoBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }

  if (_internal_has_source_handle()) {
    // required uint64 source_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_handle());
  }

  if (_internal_has_timestamp_us()) {
    // required int64 timestamp_us = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_us());
  }

  if (_internal_has_rotation()) {
    // required .livekit.proto.VideoRotation rotation = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rotation());
  }

  return total_size;
}
size_t CaptureVideoFrameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.CaptureVideoFrameRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .livekit.proto.VideoBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);

    // required uint64 source_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_handle());

    // required int64 timestamp_us = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_us());

    // required .livekit.proto.VideoRotation rotation = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rotation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureVideoFrameRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaptureVideoFrameRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureVideoFrameRequest::GetClassData() const { return &_class_data_; }


void CaptureVideoFrameRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaptureVideoFrameRequest*>(&to_msg);
  auto& from = static_cast<const CaptureVideoFrameRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.CaptureVideoFrameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buffer()->::livekit::proto::VideoBufferInfo::MergeFrom(
          from._internal_buffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.source_handle_ = from._impl_.source_handle_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_us_ = from._impl_.timestamp_us_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rotation_ = from._impl_.rotation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaptureVideoFrameRequest::CopyFrom(const CaptureVideoFrameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.CaptureVideoFrameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureVideoFrameRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void CaptureVideoFrameRequest::InternalSwap(CaptureVideoFrameRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaptureVideoFrameRequest, _impl_.rotation_)
      + sizeof(CaptureVideoFrameRequest::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(CaptureVideoFrameRequest, _impl_.buffer_)>(
          reinterpret_cast<char*>(&_impl_.buffer_),
          reinterpret_cast<char*>(&other->_impl_.buffer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaptureVideoFrameRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[6]);
}

// ===================================================================

class CaptureVideoFrameResponse::_Internal {
 public:
};

CaptureVideoFrameResponse::CaptureVideoFrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.CaptureVideoFrameResponse)
}
CaptureVideoFrameResponse::CaptureVideoFrameResponse(const CaptureVideoFrameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  CaptureVideoFrameResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.CaptureVideoFrameResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureVideoFrameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureVideoFrameResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CaptureVideoFrameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[7]);
}

// ===================================================================

class VideoConvertRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoConvertRequest>()._impl_._has_bits_);
  static void set_has_flip_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::VideoBufferInfo& buffer(const VideoConvertRequest* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dst_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::livekit::proto::VideoBufferInfo&
VideoConvertRequest::_Internal::buffer(const VideoConvertRequest* msg) {
  return *msg->_impl_.buffer_;
}
VideoConvertRequest::VideoConvertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoConvertRequest)
}
VideoConvertRequest::VideoConvertRequest(const VideoConvertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoConvertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.flip_y_){}
    , decltype(_impl_.dst_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::VideoBufferInfo(*from._impl_.buffer_);
  }
  ::memcpy(&_impl_.flip_y_, &from._impl_.flip_y_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dst_type_) -
    reinterpret_cast<char*>(&_impl_.flip_y_)) + sizeof(_impl_.dst_type_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoConvertRequest)
}

inline void VideoConvertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.flip_y_){false}
    , decltype(_impl_.dst_type_){0}
  };
}

VideoConvertRequest::~VideoConvertRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoConvertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoConvertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void VideoConvertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoConvertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoConvertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.flip_y_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dst_type_) -
        reinterpret_cast<char*>(&_impl_.flip_y_)) + sizeof(_impl_.dst_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoConvertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool flip_y = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_flip_y(&has_bits);
          _impl_.flip_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoBufferInfo buffer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoBufferType dst_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoBufferType_IsValid(val))) {
            _internal_set_dst_type(static_cast<::livekit::proto::VideoBufferType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoConvertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoConvertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool flip_y = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_flip_y(), target);
  }

  // required .livekit.proto.VideoBufferInfo buffer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.VideoBufferType dst_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_dst_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoConvertRequest)
  return target;
}

size_t VideoConvertRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoConvertRequest)
  size_t total_size = 0;

  if (_internal_has_buffer()) {
    // required .livekit.proto.VideoBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }

  if (_internal_has_dst_type()) {
    // required .livekit.proto.VideoBufferType dst_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dst_type());
  }

  return total_size;
}
size_t VideoConvertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoConvertRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .livekit.proto.VideoBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);

    // required .livekit.proto.VideoBufferType dst_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dst_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool flip_y = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoConvertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoConvertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoConvertRequest::GetClassData() const { return &_class_data_; }


void VideoConvertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoConvertRequest*>(&to_msg);
  auto& from = static_cast<const VideoConvertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoConvertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buffer()->::livekit::proto::VideoBufferInfo::MergeFrom(
          from._internal_buffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.flip_y_ = from._impl_.flip_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dst_type_ = from._impl_.dst_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoConvertRequest::CopyFrom(const VideoConvertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoConvertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoConvertRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void VideoConvertRequest::InternalSwap(VideoConvertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoConvertRequest, _impl_.dst_type_)
      + sizeof(VideoConvertRequest::_impl_.dst_type_)
      - PROTOBUF_FIELD_OFFSET(VideoConvertRequest, _impl_.buffer_)>(
          reinterpret_cast<char*>(&_impl_.buffer_),
          reinterpret_cast<char*>(&other->_impl_.buffer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoConvertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[8]);
}

// ===================================================================

class VideoConvertResponse::_Internal {
 public:
  static const ::livekit::proto::OwnedVideoBuffer& buffer(const VideoConvertResponse* msg);
};

const ::livekit::proto::OwnedVideoBuffer&
VideoConvertResponse::_Internal::buffer(const VideoConvertResponse* msg) {
  return *msg->_impl_.message_.buffer_;
}
void VideoConvertResponse::set_allocated_buffer(::livekit::proto::OwnedVideoBuffer* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    set_has_buffer();
    _impl_.message_.buffer_ = buffer;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoConvertResponse.buffer)
}
VideoConvertResponse::VideoConvertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoConvertResponse)
}
VideoConvertResponse::VideoConvertResponse(const VideoConvertResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoConvertResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case kBuffer: {
      _this->_internal_mutable_buffer()->::livekit::proto::OwnedVideoBuffer::MergeFrom(
          from._internal_buffer());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoConvertResponse)
}

inline void VideoConvertResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

VideoConvertResponse::~VideoConvertResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoConvertResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoConvertResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void VideoConvertResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoConvertResponse::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.VideoConvertResponse)
  switch (message_case()) {
    case kError: {
      _impl_.message_.error_.Destroy();
      break;
    }
    case kBuffer: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.buffer_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void VideoConvertResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoConvertResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoConvertResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.VideoConvertResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.OwnedVideoBuffer buffer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoConvertResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoConvertResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (message_case()) {
    case kError: {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "livekit.proto.VideoConvertResponse.error");
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_error(), target);
      break;
    }
    case kBuffer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::buffer(this),
          _Internal::buffer(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoConvertResponse)
  return target;
}

size_t VideoConvertResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoConvertResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // string error = 1;
    case kError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error());
      break;
    }
    // .livekit.proto.OwnedVideoBuffer buffer = 2;
    case kBuffer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.buffer_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoConvertResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoConvertResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoConvertResponse::GetClassData() const { return &_class_data_; }


void VideoConvertResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoConvertResponse*>(&to_msg);
  auto& from = static_cast<const VideoConvertResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoConvertResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case kBuffer: {
      _this->_internal_mutable_buffer()->::livekit::proto::OwnedVideoBuffer::MergeFrom(
          from._internal_buffer());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoConvertResponse::CopyFrom(const VideoConvertResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoConvertResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoConvertResponse::IsInitialized() const {
  switch (message_case()) {
    case kError: {
      break;
    }
    case kBuffer: {
      if (_internal_has_buffer()) {
        if (!_impl_.message_.buffer_->IsInitialized()) return false;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void VideoConvertResponse::InternalSwap(VideoConvertResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoConvertResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[9]);
}

// ===================================================================

class VideoResolution::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoResolution>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frame_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VideoResolution::VideoResolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoResolution)
}
VideoResolution::VideoResolution(const VideoResolution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoResolution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.frame_rate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.frame_rate_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.frame_rate_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoResolution)
}

inline void VideoResolution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.frame_rate_){0}
  };
}

VideoResolution::~VideoResolution() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoResolution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoResolution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoResolution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoResolution::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoResolution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.frame_rate_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.frame_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoResolution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double frame_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_frame_rate(&has_bits);
          _impl_.frame_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoResolution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoResolution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // required uint32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  // required double frame_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_frame_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoResolution)
  return target;
}

size_t VideoResolution::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoResolution)
  size_t total_size = 0;

  if (_internal_has_width()) {
    // required uint32 width = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  if (_internal_has_height()) {
    // required uint32 height = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  if (_internal_has_frame_rate()) {
    // required double frame_rate = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t VideoResolution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoResolution)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 width = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());

    // required uint32 height = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());

    // required double frame_rate = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoResolution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoResolution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoResolution::GetClassData() const { return &_class_data_; }


void VideoResolution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoResolution*>(&to_msg);
  auto& from = static_cast<const VideoResolution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoResolution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.frame_rate_ = from._impl_.frame_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoResolution::CopyFrom(const VideoResolution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoResolution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoResolution::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoResolution::InternalSwap(VideoResolution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoResolution, _impl_.frame_rate_)
      + sizeof(VideoResolution::_impl_.frame_rate_)
      - PROTOBUF_FIELD_OFFSET(VideoResolution, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoResolution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[10]);
}

// ===================================================================

class VideoBufferInfo_ComponentInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoBufferInfo_ComponentInfo>()._impl_._has_bits_);
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stride(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

VideoBufferInfo_ComponentInfo::VideoBufferInfo_ComponentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoBufferInfo.ComponentInfo)
}
VideoBufferInfo_ComponentInfo::VideoBufferInfo_ComponentInfo(const VideoBufferInfo_ComponentInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoBufferInfo_ComponentInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.stride_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.data_ptr_, &from._impl_.data_ptr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.data_ptr_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoBufferInfo.ComponentInfo)
}

inline void VideoBufferInfo_ComponentInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.stride_){0u}
    , decltype(_impl_.size_){0u}
  };
}

VideoBufferInfo_ComponentInfo::~VideoBufferInfo_ComponentInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoBufferInfo.ComponentInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoBufferInfo_ComponentInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoBufferInfo_ComponentInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoBufferInfo_ComponentInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.data_ptr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.data_ptr_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoBufferInfo_ComponentInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 data_ptr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 stride = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stride(&has_bits);
          _impl_.stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoBufferInfo_ComponentInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 data_ptr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_data_ptr(), target);
  }

  // required uint32 stride = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_stride(), target);
  }

  // required uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoBufferInfo.ComponentInfo)
  return target;
}

size_t VideoBufferInfo_ComponentInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  size_t total_size = 0;

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_stride()) {
    // required uint32 stride = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stride());
  }

  if (_internal_has_size()) {
    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return total_size;
}
size_t VideoBufferInfo_ComponentInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint64 data_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 stride = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stride());

    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoBufferInfo_ComponentInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoBufferInfo_ComponentInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoBufferInfo_ComponentInfo::GetClassData() const { return &_class_data_; }


void VideoBufferInfo_ComponentInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoBufferInfo_ComponentInfo*>(&to_msg);
  auto& from = static_cast<const VideoBufferInfo_ComponentInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stride_ = from._impl_.stride_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoBufferInfo_ComponentInfo::CopyFrom(const VideoBufferInfo_ComponentInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoBufferInfo.ComponentInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoBufferInfo_ComponentInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoBufferInfo_ComponentInfo::InternalSwap(VideoBufferInfo_ComponentInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoBufferInfo_ComponentInfo, _impl_.size_)
      + sizeof(VideoBufferInfo_ComponentInfo::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(VideoBufferInfo_ComponentInfo, _impl_.data_ptr_)>(
          reinterpret_cast<char*>(&_impl_.data_ptr_),
          reinterpret_cast<char*>(&other->_impl_.data_ptr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoBufferInfo_ComponentInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[11]);
}

// ===================================================================

class VideoBufferInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoBufferInfo>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stride(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

VideoBufferInfo::VideoBufferInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoBufferInfo)
}
VideoBufferInfo::VideoBufferInfo(const VideoBufferInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoBufferInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.components_){from._impl_.components_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.stride_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stride_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.stride_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoBufferInfo)
}

inline void VideoBufferInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.components_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.stride_){0u}
  };
}

VideoBufferInfo::~VideoBufferInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoBufferInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoBufferInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.components_.~RepeatedPtrField();
}

void VideoBufferInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoBufferInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoBufferInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.components_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.stride_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.stride_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoBufferInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.VideoBufferType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoBufferType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoBufferType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 data_ptr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 stride = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_stride(&has_bits);
          _impl_.stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .livekit.proto.VideoBufferInfo.ComponentInfo components = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_components(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoBufferInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoBufferInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.VideoBufferType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required uint32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_width(), target);
  }

  // required uint32 height = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_height(), target);
  }

  // required uint64 data_ptr = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_data_ptr(), target);
  }

  // optional uint32 stride = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_stride(), target);
  }

  // repeated .livekit.proto.VideoBufferInfo.ComponentInfo components = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_components_size()); i < n; i++) {
    const auto& repfield = this->_internal_components(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoBufferInfo)
  return target;
}

size_t VideoBufferInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoBufferInfo)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .livekit.proto.VideoBufferType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_width()) {
    // required uint32 width = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_height()) {
    // required uint32 height = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return total_size;
}
size_t VideoBufferInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoBufferInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .livekit.proto.VideoBufferType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    // required uint32 width = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());

    // required uint64 data_ptr = 4;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 height = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .livekit.proto.VideoBufferInfo.ComponentInfo components = 7;
  total_size += 1UL * this->_internal_components_size();
  for (const auto& msg : this->_impl_.components_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 stride = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stride());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoBufferInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoBufferInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoBufferInfo::GetClassData() const { return &_class_data_; }


void VideoBufferInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoBufferInfo*>(&to_msg);
  auto& from = static_cast<const VideoBufferInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoBufferInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.components_.MergeFrom(from._impl_.components_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.stride_ = from._impl_.stride_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoBufferInfo::CopyFrom(const VideoBufferInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoBufferInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoBufferInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.components_))
    return false;
  return true;
}

void VideoBufferInfo::InternalSwap(VideoBufferInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.components_.InternalSwap(&other->_impl_.components_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoBufferInfo, _impl_.stride_)
      + sizeof(VideoBufferInfo::_impl_.stride_)
      - PROTOBUF_FIELD_OFFSET(VideoBufferInfo, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoBufferInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[12]);
}

// ===================================================================

class OwnedVideoBuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedVideoBuffer>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedVideoBuffer* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::VideoBufferInfo& info(const OwnedVideoBuffer* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedVideoBuffer::_Internal::handle(const OwnedVideoBuffer* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::VideoBufferInfo&
OwnedVideoBuffer::_Internal::info(const OwnedVideoBuffer* msg) {
  return *msg->_impl_.info_;
}
void OwnedVideoBuffer::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedVideoBuffer::OwnedVideoBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedVideoBuffer)
}
OwnedVideoBuffer::OwnedVideoBuffer(const OwnedVideoBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedVideoBuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::VideoBufferInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedVideoBuffer)
}

inline void OwnedVideoBuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedVideoBuffer::~OwnedVideoBuffer() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedVideoBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedVideoBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedVideoBuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedVideoBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedVideoBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedVideoBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoBufferInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedVideoBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedVideoBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.VideoBufferInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedVideoBuffer)
  return target;
}

size_t OwnedVideoBuffer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedVideoBuffer)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.VideoBufferInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedVideoBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedVideoBuffer)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.VideoBufferInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedVideoBuffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedVideoBuffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedVideoBuffer::GetClassData() const { return &_class_data_; }


void OwnedVideoBuffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedVideoBuffer*>(&to_msg);
  auto& from = static_cast<const OwnedVideoBuffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedVideoBuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::VideoBufferInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedVideoBuffer::CopyFrom(const OwnedVideoBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedVideoBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedVideoBuffer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedVideoBuffer::InternalSwap(OwnedVideoBuffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedVideoBuffer, _impl_.info_)
      + sizeof(OwnedVideoBuffer::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedVideoBuffer, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedVideoBuffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[13]);
}

// ===================================================================

class VideoStreamInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoStreamInfo>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VideoStreamInfo::VideoStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoStreamInfo)
}
VideoStreamInfo::VideoStreamInfo(const VideoStreamInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoStreamInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoStreamInfo)
}

inline void VideoStreamInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
  };
}

VideoStreamInfo::~VideoStreamInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoStreamInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoStreamInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoStreamInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoStreamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoStreamInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoStreamInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.VideoStreamType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoStreamInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoStreamInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.VideoStreamType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoStreamInfo)
  return target;
}

size_t VideoStreamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoStreamInfo)
  size_t total_size = 0;

  // required .livekit.proto.VideoStreamType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoStreamInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoStreamInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoStreamInfo::GetClassData() const { return &_class_data_; }


void VideoStreamInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoStreamInfo*>(&to_msg);
  auto& from = static_cast<const VideoStreamInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoStreamInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoStreamInfo::CopyFrom(const VideoStreamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoStreamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoStreamInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoStreamInfo::InternalSwap(VideoStreamInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoStreamInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[14]);
}

// ===================================================================

class OwnedVideoStream::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedVideoStream>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedVideoStream* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::VideoStreamInfo& info(const OwnedVideoStream* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedVideoStream::_Internal::handle(const OwnedVideoStream* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::VideoStreamInfo&
OwnedVideoStream::_Internal::info(const OwnedVideoStream* msg) {
  return *msg->_impl_.info_;
}
void OwnedVideoStream::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedVideoStream::OwnedVideoStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedVideoStream)
}
OwnedVideoStream::OwnedVideoStream(const OwnedVideoStream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedVideoStream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::VideoStreamInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedVideoStream)
}

inline void OwnedVideoStream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedVideoStream::~OwnedVideoStream() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedVideoStream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedVideoStream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedVideoStream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedVideoStream::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedVideoStream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedVideoStream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoStreamInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedVideoStream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedVideoStream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.VideoStreamInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedVideoStream)
  return target;
}

size_t OwnedVideoStream::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedVideoStream)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.VideoStreamInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedVideoStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedVideoStream)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.VideoStreamInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedVideoStream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedVideoStream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedVideoStream::GetClassData() const { return &_class_data_; }


void OwnedVideoStream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedVideoStream*>(&to_msg);
  auto& from = static_cast<const OwnedVideoStream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedVideoStream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::VideoStreamInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedVideoStream::CopyFrom(const OwnedVideoStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedVideoStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedVideoStream::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedVideoStream::InternalSwap(OwnedVideoStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedVideoStream, _impl_.info_)
      + sizeof(OwnedVideoStream::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedVideoStream, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedVideoStream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[15]);
}

// ===================================================================

class VideoStreamEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoStreamEvent>()._impl_._has_bits_);
  static void set_has_stream_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::VideoFrameReceived& frame_received(const VideoStreamEvent* msg);
  static const ::livekit::proto::VideoStreamEOS& eos(const VideoStreamEvent* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::VideoFrameReceived&
VideoStreamEvent::_Internal::frame_received(const VideoStreamEvent* msg) {
  return *msg->_impl_.message_.frame_received_;
}
const ::livekit::proto::VideoStreamEOS&
VideoStreamEvent::_Internal::eos(const VideoStreamEvent* msg) {
  return *msg->_impl_.message_.eos_;
}
void VideoStreamEvent::set_allocated_frame_received(::livekit::proto::VideoFrameReceived* frame_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (frame_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_received);
    if (message_arena != submessage_arena) {
      frame_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_received, submessage_arena);
    }
    set_has_frame_received();
    _impl_.message_.frame_received_ = frame_received;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoStreamEvent.frame_received)
}
void VideoStreamEvent::set_allocated_eos(::livekit::proto::VideoStreamEOS* eos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (eos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eos);
    if (message_arena != submessage_arena) {
      eos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eos, submessage_arena);
    }
    set_has_eos();
    _impl_.message_.eos_ = eos;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoStreamEvent.eos)
}
VideoStreamEvent::VideoStreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoStreamEvent)
}
VideoStreamEvent::VideoStreamEvent(const VideoStreamEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoStreamEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_handle_){}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.stream_handle_ = from._impl_.stream_handle_;
  clear_has_message();
  switch (from.message_case()) {
    case kFrameReceived: {
      _this->_internal_mutable_frame_received()->::livekit::proto::VideoFrameReceived::MergeFrom(
          from._internal_frame_received());
      break;
    }
    case kEos: {
      _this->_internal_mutable_eos()->::livekit::proto::VideoStreamEOS::MergeFrom(
          from._internal_eos());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoStreamEvent)
}

inline void VideoStreamEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_handle_){uint64_t{0u}}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

VideoStreamEvent::~VideoStreamEvent() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoStreamEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoStreamEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void VideoStreamEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoStreamEvent::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.VideoStreamEvent)
  switch (message_case()) {
    case kFrameReceived: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.frame_received_;
      }
      break;
    }
    case kEos: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.eos_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void VideoStreamEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoStreamEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stream_handle_ = uint64_t{0u};
  clear_message();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoStreamEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 stream_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stream_handle(&has_bits);
          _impl_.stream_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.VideoFrameReceived frame_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_received(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.VideoStreamEOS eos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_eos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoStreamEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoStreamEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 stream_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stream_handle(), target);
  }

  switch (message_case()) {
    case kFrameReceived: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::frame_received(this),
          _Internal::frame_received(this).GetCachedSize(), target, stream);
      break;
    }
    case kEos: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::eos(this),
          _Internal::eos(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoStreamEvent)
  return target;
}

size_t VideoStreamEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoStreamEvent)
  size_t total_size = 0;

  // required uint64 stream_handle = 1;
  if (_internal_has_stream_handle()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stream_handle());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .livekit.proto.VideoFrameReceived frame_received = 2;
    case kFrameReceived: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.frame_received_);
      break;
    }
    // .livekit.proto.VideoStreamEOS eos = 3;
    case kEos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.eos_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoStreamEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoStreamEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoStreamEvent::GetClassData() const { return &_class_data_; }


void VideoStreamEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoStreamEvent*>(&to_msg);
  auto& from = static_cast<const VideoStreamEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoStreamEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream_handle()) {
    _this->_internal_set_stream_handle(from._internal_stream_handle());
  }
  switch (from.message_case()) {
    case kFrameReceived: {
      _this->_internal_mutable_frame_received()->::livekit::proto::VideoFrameReceived::MergeFrom(
          from._internal_frame_received());
      break;
    }
    case kEos: {
      _this->_internal_mutable_eos()->::livekit::proto::VideoStreamEOS::MergeFrom(
          from._internal_eos());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoStreamEvent::CopyFrom(const VideoStreamEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoStreamEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoStreamEvent::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (message_case()) {
    case kFrameReceived: {
      if (_internal_has_frame_received()) {
        if (!_impl_.message_.frame_received_->IsInitialized()) return false;
      }
      break;
    }
    case kEos: {
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void VideoStreamEvent::InternalSwap(VideoStreamEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_handle_, other->_impl_.stream_handle_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoStreamEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[16]);
}

// ===================================================================

class VideoFrameReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoFrameReceived>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedVideoBuffer& buffer(const VideoFrameReceived* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::livekit::proto::OwnedVideoBuffer&
VideoFrameReceived::_Internal::buffer(const VideoFrameReceived* msg) {
  return *msg->_impl_.buffer_;
}
VideoFrameReceived::VideoFrameReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoFrameReceived)
}
VideoFrameReceived::VideoFrameReceived(const VideoFrameReceived& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoFrameReceived* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.timestamp_us_){}
    , decltype(_impl_.rotation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::OwnedVideoBuffer(*from._impl_.buffer_);
  }
  ::memcpy(&_impl_.timestamp_us_, &from._impl_.timestamp_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotation_) -
    reinterpret_cast<char*>(&_impl_.timestamp_us_)) + sizeof(_impl_.rotation_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoFrameReceived)
}

inline void VideoFrameReceived::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.timestamp_us_){int64_t{0}}
    , decltype(_impl_.rotation_){0}
  };
}

VideoFrameReceived::~VideoFrameReceived() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoFrameReceived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoFrameReceived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void VideoFrameReceived::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoFrameReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoFrameReceived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.timestamp_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rotation_) -
        reinterpret_cast<char*>(&_impl_.timestamp_us_)) + sizeof(_impl_.rotation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoFrameReceived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedVideoBuffer buffer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 timestamp_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp_us(&has_bits);
          _impl_.timestamp_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoRotation rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoRotation_IsValid(val))) {
            _internal_set_rotation(static_cast<::livekit::proto::VideoRotation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoFrameReceived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoFrameReceived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedVideoBuffer buffer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  // required int64 timestamp_us = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_timestamp_us(), target);
  }

  // required .livekit.proto.VideoRotation rotation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_rotation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoFrameReceived)
  return target;
}

size_t VideoFrameReceived::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoFrameReceived)
  size_t total_size = 0;

  if (_internal_has_buffer()) {
    // required .livekit.proto.OwnedVideoBuffer buffer = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }

  if (_internal_has_timestamp_us()) {
    // required int64 timestamp_us = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_us());
  }

  if (_internal_has_rotation()) {
    // required .livekit.proto.VideoRotation rotation = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rotation());
  }

  return total_size;
}
size_t VideoFrameReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoFrameReceived)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .livekit.proto.OwnedVideoBuffer buffer = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);

    // required int64 timestamp_us = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_us());

    // required .livekit.proto.VideoRotation rotation = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_rotation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoFrameReceived::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoFrameReceived::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoFrameReceived::GetClassData() const { return &_class_data_; }


void VideoFrameReceived::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoFrameReceived*>(&to_msg);
  auto& from = static_cast<const VideoFrameReceived&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoFrameReceived)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buffer()->::livekit::proto::OwnedVideoBuffer::MergeFrom(
          from._internal_buffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_us_ = from._impl_.timestamp_us_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rotation_ = from._impl_.rotation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoFrameReceived::CopyFrom(const VideoFrameReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoFrameReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoFrameReceived::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void VideoFrameReceived::InternalSwap(VideoFrameReceived* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoFrameReceived, _impl_.rotation_)
      + sizeof(VideoFrameReceived::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(VideoFrameReceived, _impl_.buffer_)>(
          reinterpret_cast<char*>(&_impl_.buffer_),
          reinterpret_cast<char*>(&other->_impl_.buffer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoFrameReceived::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[17]);
}

// ===================================================================

class VideoStreamEOS::_Internal {
 public:
};

VideoStreamEOS::VideoStreamEOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoStreamEOS)
}
VideoStreamEOS::VideoStreamEOS(const VideoStreamEOS& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  VideoStreamEOS* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoStreamEOS)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoStreamEOS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoStreamEOS::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata VideoStreamEOS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[18]);
}

// ===================================================================

class VideoSourceResolution::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoSourceResolution>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

VideoSourceResolution::VideoSourceResolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoSourceResolution)
}
VideoSourceResolution::VideoSourceResolution(const VideoSourceResolution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoSourceResolution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoSourceResolution)
}

inline void VideoSourceResolution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
  };
}

VideoSourceResolution::~VideoSourceResolution() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoSourceResolution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoSourceResolution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoSourceResolution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoSourceResolution::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoSourceResolution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.height_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoSourceResolution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoSourceResolution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoSourceResolution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // required uint32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoSourceResolution)
  return target;
}

size_t VideoSourceResolution::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.VideoSourceResolution)
  size_t total_size = 0;

  if (_internal_has_width()) {
    // required uint32 width = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  if (_internal_has_height()) {
    // required uint32 height = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return total_size;
}
size_t VideoSourceResolution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoSourceResolution)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 width = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());

    // required uint32 height = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoSourceResolution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoSourceResolution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoSourceResolution::GetClassData() const { return &_class_data_; }


void VideoSourceResolution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoSourceResolution*>(&to_msg);
  auto& from = static_cast<const VideoSourceResolution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoSourceResolution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoSourceResolution::CopyFrom(const VideoSourceResolution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoSourceResolution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoSourceResolution::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoSourceResolution::InternalSwap(VideoSourceResolution* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoSourceResolution, _impl_.height_)
      + sizeof(VideoSourceResolution::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(VideoSourceResolution, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoSourceResolution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[19]);
}

// ===================================================================

class VideoSourceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoSourceInfo>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

VideoSourceInfo::VideoSourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.VideoSourceInfo)
}
VideoSourceInfo::VideoSourceInfo(const VideoSourceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VideoSourceInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.VideoSourceInfo)
}

inline void VideoSourceInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
  };
}

VideoSourceInfo::~VideoSourceInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.VideoSourceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoSourceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoSourceInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VideoSourceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.VideoSourceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VideoSourceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.VideoSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::VideoSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::VideoSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoSourceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.VideoSourceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.VideoSourceType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.VideoSourceInfo)
  return target;
}

size_t VideoSourceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.VideoSourceInfo)
  size_t total_size = 0;

  // required .livekit.proto.VideoSourceType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VideoSourceInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VideoSourceInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VideoSourceInfo::GetClassData() const { return &_class_data_; }


void VideoSourceInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VideoSourceInfo*>(&to_msg);
  auto& from = static_cast<const VideoSourceInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.VideoSourceInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VideoSourceInfo::CopyFrom(const VideoSourceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.VideoSourceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoSourceInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void VideoSourceInfo::InternalSwap(VideoSourceInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VideoSourceInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[20]);
}

// ===================================================================

class OwnedVideoSource::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedVideoSource>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedVideoSource* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::VideoSourceInfo& info(const OwnedVideoSource* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedVideoSource::_Internal::handle(const OwnedVideoSource* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::VideoSourceInfo&
OwnedVideoSource::_Internal::info(const OwnedVideoSource* msg) {
  return *msg->_impl_.info_;
}
void OwnedVideoSource::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedVideoSource::OwnedVideoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedVideoSource)
}
OwnedVideoSource::OwnedVideoSource(const OwnedVideoSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedVideoSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::VideoSourceInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedVideoSource)
}

inline void OwnedVideoSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedVideoSource::~OwnedVideoSource() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedVideoSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedVideoSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedVideoSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedVideoSource::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedVideoSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedVideoSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.VideoSourceInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedVideoSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedVideoSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.VideoSourceInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedVideoSource)
  return target;
}

size_t OwnedVideoSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedVideoSource)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.VideoSourceInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedVideoSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedVideoSource)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.VideoSourceInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedVideoSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedVideoSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedVideoSource::GetClassData() const { return &_class_data_; }


void OwnedVideoSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedVideoSource*>(&to_msg);
  auto& from = static_cast<const OwnedVideoSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedVideoSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::VideoSourceInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedVideoSource::CopyFrom(const OwnedVideoSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedVideoSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedVideoSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedVideoSource::InternalSwap(OwnedVideoSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedVideoSource, _impl_.info_)
      + sizeof(OwnedVideoSource::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedVideoSource, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedVideoSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_video_5fframe_2eproto_getter, &descriptor_table_video_5fframe_2eproto_once,
      file_level_metadata_video_5fframe_2eproto[21]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::livekit::proto::NewVideoStreamRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewVideoStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewVideoStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewVideoStreamResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewVideoStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewVideoStreamResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoStreamFromParticipantRequest*
Arena::CreateMaybeMessage< ::livekit::proto::VideoStreamFromParticipantRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoStreamFromParticipantRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoStreamFromParticipantResponse*
Arena::CreateMaybeMessage< ::livekit::proto::VideoStreamFromParticipantResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoStreamFromParticipantResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewVideoSourceRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewVideoSourceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewVideoSourceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewVideoSourceResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewVideoSourceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewVideoSourceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::CaptureVideoFrameRequest*
Arena::CreateMaybeMessage< ::livekit::proto::CaptureVideoFrameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::CaptureVideoFrameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::CaptureVideoFrameResponse*
Arena::CreateMaybeMessage< ::livekit::proto::CaptureVideoFrameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::CaptureVideoFrameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoConvertRequest*
Arena::CreateMaybeMessage< ::livekit::proto::VideoConvertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoConvertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoConvertResponse*
Arena::CreateMaybeMessage< ::livekit::proto::VideoConvertResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoConvertResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoResolution*
Arena::CreateMaybeMessage< ::livekit::proto::VideoResolution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoResolution >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoBufferInfo_ComponentInfo*
Arena::CreateMaybeMessage< ::livekit::proto::VideoBufferInfo_ComponentInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoBufferInfo_ComponentInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoBufferInfo*
Arena::CreateMaybeMessage< ::livekit::proto::VideoBufferInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoBufferInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedVideoBuffer*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedVideoBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedVideoBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoStreamInfo*
Arena::CreateMaybeMessage< ::livekit::proto::VideoStreamInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoStreamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedVideoStream*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedVideoStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedVideoStream >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoStreamEvent*
Arena::CreateMaybeMessage< ::livekit::proto::VideoStreamEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoStreamEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoFrameReceived*
Arena::CreateMaybeMessage< ::livekit::proto::VideoFrameReceived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoFrameReceived >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoStreamEOS*
Arena::CreateMaybeMessage< ::livekit::proto::VideoStreamEOS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoStreamEOS >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoSourceResolution*
Arena::CreateMaybeMessage< ::livekit::proto::VideoSourceResolution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoSourceResolution >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::VideoSourceInfo*
Arena::CreateMaybeMessage< ::livekit::proto::VideoSourceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::VideoSourceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedVideoSource*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedVideoSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedVideoSource >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
