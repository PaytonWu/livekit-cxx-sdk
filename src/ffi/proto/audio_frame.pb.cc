// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio_frame.proto

#include "audio_frame.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace livekit {
namespace proto {
PROTOBUF_CONSTEXPR NewAudioStreamRequest::NewAudioStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_filter_module_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_filter_options_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.num_channels_)*/0u} {}
struct NewAudioStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioStreamRequestDefaultTypeInternal() {}
  union {
    NewAudioStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioStreamRequestDefaultTypeInternal _NewAudioStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR NewAudioStreamResponse::NewAudioStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_)*/nullptr} {}
struct NewAudioStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioStreamResponseDefaultTypeInternal() {}
  union {
    NewAudioStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioStreamResponseDefaultTypeInternal _NewAudioStreamResponse_default_instance_;
PROTOBUF_CONSTEXPR AudioStreamFromParticipantRequest::AudioStreamFromParticipantRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_filter_module_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_filter_options_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.track_source_)*/0
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.num_channels_)*/0u} {}
struct AudioStreamFromParticipantRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioStreamFromParticipantRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioStreamFromParticipantRequestDefaultTypeInternal() {}
  union {
    AudioStreamFromParticipantRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioStreamFromParticipantRequestDefaultTypeInternal _AudioStreamFromParticipantRequest_default_instance_;
PROTOBUF_CONSTEXPR AudioStreamFromParticipantResponse::AudioStreamFromParticipantResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_)*/nullptr} {}
struct AudioStreamFromParticipantResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioStreamFromParticipantResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioStreamFromParticipantResponseDefaultTypeInternal() {}
  union {
    AudioStreamFromParticipantResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioStreamFromParticipantResponseDefaultTypeInternal _AudioStreamFromParticipantResponse_default_instance_;
PROTOBUF_CONSTEXPR NewAudioSourceRequest::NewAudioSourceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.options_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.num_channels_)*/0u
  , /*decltype(_impl_.queue_size_ms_)*/0u} {}
struct NewAudioSourceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioSourceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioSourceRequestDefaultTypeInternal() {}
  union {
    NewAudioSourceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioSourceRequestDefaultTypeInternal _NewAudioSourceRequest_default_instance_;
PROTOBUF_CONSTEXPR NewAudioSourceResponse::NewAudioSourceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_)*/nullptr} {}
struct NewAudioSourceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioSourceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioSourceResponseDefaultTypeInternal() {}
  union {
    NewAudioSourceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioSourceResponseDefaultTypeInternal _NewAudioSourceResponse_default_instance_;
PROTOBUF_CONSTEXPR CaptureAudioFrameRequest::CaptureAudioFrameRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr
  , /*decltype(_impl_.source_handle_)*/uint64_t{0u}} {}
struct CaptureAudioFrameRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureAudioFrameRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureAudioFrameRequestDefaultTypeInternal() {}
  union {
    CaptureAudioFrameRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureAudioFrameRequestDefaultTypeInternal _CaptureAudioFrameRequest_default_instance_;
PROTOBUF_CONSTEXPR CaptureAudioFrameResponse::CaptureAudioFrameResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.async_id_)*/uint64_t{0u}} {}
struct CaptureAudioFrameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureAudioFrameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureAudioFrameResponseDefaultTypeInternal() {}
  union {
    CaptureAudioFrameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureAudioFrameResponseDefaultTypeInternal _CaptureAudioFrameResponse_default_instance_;
PROTOBUF_CONSTEXPR CaptureAudioFrameCallback::CaptureAudioFrameCallback(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.async_id_)*/uint64_t{0u}} {}
struct CaptureAudioFrameCallbackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureAudioFrameCallbackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureAudioFrameCallbackDefaultTypeInternal() {}
  union {
    CaptureAudioFrameCallback _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureAudioFrameCallbackDefaultTypeInternal _CaptureAudioFrameCallback_default_instance_;
PROTOBUF_CONSTEXPR ClearAudioBufferRequest::ClearAudioBufferRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.source_handle_)*/uint64_t{0u}} {}
struct ClearAudioBufferRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearAudioBufferRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearAudioBufferRequestDefaultTypeInternal() {}
  union {
    ClearAudioBufferRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearAudioBufferRequestDefaultTypeInternal _ClearAudioBufferRequest_default_instance_;
PROTOBUF_CONSTEXPR ClearAudioBufferResponse::ClearAudioBufferResponse(
    ::_pbi::ConstantInitialized) {}
struct ClearAudioBufferResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearAudioBufferResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearAudioBufferResponseDefaultTypeInternal() {}
  union {
    ClearAudioBufferResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearAudioBufferResponseDefaultTypeInternal _ClearAudioBufferResponse_default_instance_;
PROTOBUF_CONSTEXPR NewAudioResamplerRequest::NewAudioResamplerRequest(
    ::_pbi::ConstantInitialized) {}
struct NewAudioResamplerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioResamplerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioResamplerRequestDefaultTypeInternal() {}
  union {
    NewAudioResamplerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioResamplerRequestDefaultTypeInternal _NewAudioResamplerRequest_default_instance_;
PROTOBUF_CONSTEXPR NewAudioResamplerResponse::NewAudioResamplerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resampler_)*/nullptr} {}
struct NewAudioResamplerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewAudioResamplerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewAudioResamplerResponseDefaultTypeInternal() {}
  union {
    NewAudioResamplerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewAudioResamplerResponseDefaultTypeInternal _NewAudioResamplerResponse_default_instance_;
PROTOBUF_CONSTEXPR RemixAndResampleRequest::RemixAndResampleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr
  , /*decltype(_impl_.resampler_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.num_channels_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u} {}
struct RemixAndResampleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemixAndResampleRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemixAndResampleRequestDefaultTypeInternal() {}
  union {
    RemixAndResampleRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemixAndResampleRequestDefaultTypeInternal _RemixAndResampleRequest_default_instance_;
PROTOBUF_CONSTEXPR RemixAndResampleResponse::RemixAndResampleResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buffer_)*/nullptr} {}
struct RemixAndResampleResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemixAndResampleResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemixAndResampleResponseDefaultTypeInternal() {}
  union {
    RemixAndResampleResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemixAndResampleResponseDefaultTypeInternal _RemixAndResampleResponse_default_instance_;
PROTOBUF_CONSTEXPR NewApmRequest::NewApmRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.echo_canceller_enabled_)*/false
  , /*decltype(_impl_.gain_controller_enabled_)*/false
  , /*decltype(_impl_.high_pass_filter_enabled_)*/false
  , /*decltype(_impl_.noise_suppression_enabled_)*/false} {}
struct NewApmRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewApmRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewApmRequestDefaultTypeInternal() {}
  union {
    NewApmRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewApmRequestDefaultTypeInternal _NewApmRequest_default_instance_;
PROTOBUF_CONSTEXPR NewApmResponse::NewApmResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apm_)*/nullptr} {}
struct NewApmResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewApmResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewApmResponseDefaultTypeInternal() {}
  union {
    NewApmResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewApmResponseDefaultTypeInternal _NewApmResponse_default_instance_;
PROTOBUF_CONSTEXPR ApmProcessStreamRequest::ApmProcessStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apm_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.num_channels_)*/0u} {}
struct ApmProcessStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApmProcessStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApmProcessStreamRequestDefaultTypeInternal() {}
  union {
    ApmProcessStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApmProcessStreamRequestDefaultTypeInternal _ApmProcessStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR ApmProcessStreamResponse::ApmProcessStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ApmProcessStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApmProcessStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApmProcessStreamResponseDefaultTypeInternal() {}
  union {
    ApmProcessStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApmProcessStreamResponseDefaultTypeInternal _ApmProcessStreamResponse_default_instance_;
PROTOBUF_CONSTEXPR ApmProcessReverseStreamRequest::ApmProcessReverseStreamRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.apm_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.num_channels_)*/0u} {}
struct ApmProcessReverseStreamRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApmProcessReverseStreamRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApmProcessReverseStreamRequestDefaultTypeInternal() {}
  union {
    ApmProcessReverseStreamRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApmProcessReverseStreamRequestDefaultTypeInternal _ApmProcessReverseStreamRequest_default_instance_;
PROTOBUF_CONSTEXPR ApmProcessReverseStreamResponse::ApmProcessReverseStreamResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ApmProcessReverseStreamResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApmProcessReverseStreamResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApmProcessReverseStreamResponseDefaultTypeInternal() {}
  union {
    ApmProcessReverseStreamResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApmProcessReverseStreamResponseDefaultTypeInternal _ApmProcessReverseStreamResponse_default_instance_;
PROTOBUF_CONSTEXPR NewSoxResamplerRequest::NewSoxResamplerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.input_rate_)*/0
  , /*decltype(_impl_.output_rate_)*/0
  , /*decltype(_impl_.num_channels_)*/0u
  , /*decltype(_impl_.input_data_type_)*/0
  , /*decltype(_impl_.output_data_type_)*/0
  , /*decltype(_impl_.quality_recipe_)*/0
  , /*decltype(_impl_.flags_)*/0u} {}
struct NewSoxResamplerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewSoxResamplerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewSoxResamplerRequestDefaultTypeInternal() {}
  union {
    NewSoxResamplerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewSoxResamplerRequestDefaultTypeInternal _NewSoxResamplerRequest_default_instance_;
PROTOBUF_CONSTEXPR NewSoxResamplerResponse::NewSoxResamplerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct NewSoxResamplerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NewSoxResamplerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NewSoxResamplerResponseDefaultTypeInternal() {}
  union {
    NewSoxResamplerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NewSoxResamplerResponseDefaultTypeInternal _NewSoxResamplerResponse_default_instance_;
PROTOBUF_CONSTEXPR PushSoxResamplerRequest::PushSoxResamplerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resampler_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u} {}
struct PushSoxResamplerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PushSoxResamplerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PushSoxResamplerRequestDefaultTypeInternal() {}
  union {
    PushSoxResamplerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PushSoxResamplerRequestDefaultTypeInternal _PushSoxResamplerRequest_default_instance_;
PROTOBUF_CONSTEXPR PushSoxResamplerResponse::PushSoxResamplerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u} {}
struct PushSoxResamplerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PushSoxResamplerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PushSoxResamplerResponseDefaultTypeInternal() {}
  union {
    PushSoxResamplerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PushSoxResamplerResponseDefaultTypeInternal _PushSoxResamplerResponse_default_instance_;
PROTOBUF_CONSTEXPR FlushSoxResamplerRequest::FlushSoxResamplerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.resampler_handle_)*/uint64_t{0u}} {}
struct FlushSoxResamplerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushSoxResamplerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushSoxResamplerRequestDefaultTypeInternal() {}
  union {
    FlushSoxResamplerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushSoxResamplerRequestDefaultTypeInternal _FlushSoxResamplerRequest_default_instance_;
PROTOBUF_CONSTEXPR FlushSoxResamplerResponse::FlushSoxResamplerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.size_)*/0u} {}
struct FlushSoxResamplerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushSoxResamplerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushSoxResamplerResponseDefaultTypeInternal() {}
  union {
    FlushSoxResamplerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushSoxResamplerResponseDefaultTypeInternal _FlushSoxResamplerResponse_default_instance_;
PROTOBUF_CONSTEXPR AudioFrameBufferInfo::AudioFrameBufferInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_ptr_)*/uint64_t{0u}
  , /*decltype(_impl_.num_channels_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.samples_per_channel_)*/0u} {}
struct AudioFrameBufferInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioFrameBufferInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioFrameBufferInfoDefaultTypeInternal() {}
  union {
    AudioFrameBufferInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioFrameBufferInfoDefaultTypeInternal _AudioFrameBufferInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedAudioFrameBuffer::OwnedAudioFrameBuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedAudioFrameBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedAudioFrameBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedAudioFrameBufferDefaultTypeInternal() {}
  union {
    OwnedAudioFrameBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedAudioFrameBufferDefaultTypeInternal _OwnedAudioFrameBuffer_default_instance_;
PROTOBUF_CONSTEXPR AudioStreamInfo::AudioStreamInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct AudioStreamInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioStreamInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioStreamInfoDefaultTypeInternal() {}
  union {
    AudioStreamInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioStreamInfoDefaultTypeInternal _AudioStreamInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedAudioStream::OwnedAudioStream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedAudioStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedAudioStreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedAudioStreamDefaultTypeInternal() {}
  union {
    OwnedAudioStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedAudioStreamDefaultTypeInternal _OwnedAudioStream_default_instance_;
PROTOBUF_CONSTEXPR AudioStreamEvent::AudioStreamEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stream_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AudioStreamEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioStreamEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioStreamEventDefaultTypeInternal() {}
  union {
    AudioStreamEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioStreamEventDefaultTypeInternal _AudioStreamEvent_default_instance_;
PROTOBUF_CONSTEXPR AudioFrameReceived::AudioFrameReceived(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.frame_)*/nullptr} {}
struct AudioFrameReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioFrameReceivedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioFrameReceivedDefaultTypeInternal() {}
  union {
    AudioFrameReceived _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioFrameReceivedDefaultTypeInternal _AudioFrameReceived_default_instance_;
PROTOBUF_CONSTEXPR AudioStreamEOS::AudioStreamEOS(
    ::_pbi::ConstantInitialized) {}
struct AudioStreamEOSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioStreamEOSDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioStreamEOSDefaultTypeInternal() {}
  union {
    AudioStreamEOS _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioStreamEOSDefaultTypeInternal _AudioStreamEOS_default_instance_;
PROTOBUF_CONSTEXPR AudioSourceOptions::AudioSourceOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.echo_cancellation_)*/false
  , /*decltype(_impl_.noise_suppression_)*/false
  , /*decltype(_impl_.auto_gain_control_)*/false} {}
struct AudioSourceOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioSourceOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioSourceOptionsDefaultTypeInternal() {}
  union {
    AudioSourceOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioSourceOptionsDefaultTypeInternal _AudioSourceOptions_default_instance_;
PROTOBUF_CONSTEXPR AudioSourceInfo::AudioSourceInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0} {}
struct AudioSourceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioSourceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioSourceInfoDefaultTypeInternal() {}
  union {
    AudioSourceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioSourceInfoDefaultTypeInternal _AudioSourceInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedAudioSource::OwnedAudioSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedAudioSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedAudioSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedAudioSourceDefaultTypeInternal() {}
  union {
    OwnedAudioSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedAudioSourceDefaultTypeInternal _OwnedAudioSource_default_instance_;
PROTOBUF_CONSTEXPR AudioResamplerInfo::AudioResamplerInfo(
    ::_pbi::ConstantInitialized) {}
struct AudioResamplerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioResamplerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioResamplerInfoDefaultTypeInternal() {}
  union {
    AudioResamplerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioResamplerInfoDefaultTypeInternal _AudioResamplerInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedAudioResampler::OwnedAudioResampler(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedAudioResamplerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedAudioResamplerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedAudioResamplerDefaultTypeInternal() {}
  union {
    OwnedAudioResampler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedAudioResamplerDefaultTypeInternal _OwnedAudioResampler_default_instance_;
PROTOBUF_CONSTEXPR OwnedApm::OwnedApm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr} {}
struct OwnedApmDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedApmDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedApmDefaultTypeInternal() {}
  union {
    OwnedApm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedApmDefaultTypeInternal _OwnedApm_default_instance_;
PROTOBUF_CONSTEXPR SoxResamplerInfo::SoxResamplerInfo(
    ::_pbi::ConstantInitialized) {}
struct SoxResamplerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SoxResamplerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SoxResamplerInfoDefaultTypeInternal() {}
  union {
    SoxResamplerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SoxResamplerInfoDefaultTypeInternal _SoxResamplerInfo_default_instance_;
PROTOBUF_CONSTEXPR OwnedSoxResampler::OwnedSoxResampler(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.handle_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct OwnedSoxResamplerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnedSoxResamplerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnedSoxResamplerDefaultTypeInternal() {}
  union {
    OwnedSoxResampler _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnedSoxResamplerDefaultTypeInternal _OwnedSoxResampler_default_instance_;
PROTOBUF_CONSTEXPR LoadAudioFilterPluginRequest::LoadAudioFilterPluginRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dependencies_)*/{}
  , /*decltype(_impl_.plugin_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.module_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoadAudioFilterPluginRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadAudioFilterPluginRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadAudioFilterPluginRequestDefaultTypeInternal() {}
  union {
    LoadAudioFilterPluginRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadAudioFilterPluginRequestDefaultTypeInternal _LoadAudioFilterPluginRequest_default_instance_;
PROTOBUF_CONSTEXPR LoadAudioFilterPluginResponse::LoadAudioFilterPluginResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct LoadAudioFilterPluginResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoadAudioFilterPluginResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoadAudioFilterPluginResponseDefaultTypeInternal() {}
  union {
    LoadAudioFilterPluginResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadAudioFilterPluginResponseDefaultTypeInternal _LoadAudioFilterPluginResponse_default_instance_;
}  // namespace proto
}  // namespace livekit
static ::_pb::Metadata file_level_metadata_audio_5fframe_2eproto[44];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_audio_5fframe_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_audio_5fframe_2eproto = nullptr;

const uint32_t TableStruct_audio_5fframe_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.track_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.audio_filter_module_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamRequest, _impl_.audio_filter_options_),
  2,
  3,
  4,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioStreamResponse, _impl_.stream_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.participant_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.track_source_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.audio_filter_module_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantRequest, _impl_.audio_filter_options_),
  2,
  3,
  4,
  5,
  6,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamFromParticipantResponse, _impl_.stream_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_.options_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceRequest, _impl_.queue_size_ms_),
  1,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioSourceResponse, _impl_.source_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameRequest, _impl_.source_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameRequest, _impl_.buffer_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameResponse, _impl_.async_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameCallback, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameCallback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameCallback, _impl_.async_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::CaptureAudioFrameCallback, _impl_.error_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ClearAudioBufferRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ClearAudioBufferRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ClearAudioBufferRequest, _impl_.source_handle_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ClearAudioBufferResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioResamplerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioResamplerResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioResamplerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewAudioResamplerResponse, _impl_.resampler_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _impl_.resampler_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _impl_.buffer_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleRequest, _impl_.sample_rate_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RemixAndResampleResponse, _impl_.buffer_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _impl_.echo_canceller_enabled_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _impl_.gain_controller_enabled_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _impl_.high_pass_filter_enabled_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmRequest, _impl_.noise_suppression_enabled_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewApmResponse, _impl_.apm_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_.apm_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamRequest, _impl_.num_channels_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessStreamResponse, _impl_.error_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_.apm_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamRequest, _impl_.num_channels_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::ApmProcessReverseStreamResponse, _impl_.error_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.input_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.output_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.input_data_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.output_data_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.quality_recipe_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerRequest, _impl_.flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::NewSoxResamplerResponse, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerRequest, _impl_.resampler_handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerRequest, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerRequest, _impl_.size_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerResponse, _impl_.output_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerResponse, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::PushSoxResamplerResponse, _impl_.error_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerRequest, _impl_.resampler_handle_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerResponse, _impl_.output_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerResponse, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FlushSoxResamplerResponse, _impl_.error_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _impl_.data_ptr_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _impl_.num_channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameBufferInfo, _impl_.samples_per_channel_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioFrameBuffer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioFrameBuffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioFrameBuffer, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioFrameBuffer, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamInfo, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioStream, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioStream, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioStream, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEvent, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEvent, _impl_.stream_handle_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEvent, _impl_.message_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameReceived, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameReceived, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioFrameReceived, _impl_.frame_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioStreamEOS, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceOptions, _impl_.echo_cancellation_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceOptions, _impl_.noise_suppression_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceOptions, _impl_.auto_gain_control_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioSourceInfo, _impl_.type_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioSource, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioSource, _impl_.info_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::AudioResamplerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioResampler, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioResampler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioResampler, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedAudioResampler, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedApm, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedApm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedApm, _impl_.handle_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SoxResamplerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedSoxResampler, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedSoxResampler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedSoxResampler, _impl_.handle_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::OwnedSoxResampler, _impl_.info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginRequest, _impl_.plugin_path_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginRequest, _impl_.dependencies_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginRequest, _impl_.module_id_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::LoadAudioFilterPluginResponse, _impl_.error_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::livekit::proto::NewAudioStreamRequest)},
  { 18, 25, -1, sizeof(::livekit::proto::NewAudioStreamResponse)},
  { 26, 39, -1, sizeof(::livekit::proto::AudioStreamFromParticipantRequest)},
  { 46, 53, -1, sizeof(::livekit::proto::AudioStreamFromParticipantResponse)},
  { 54, 65, -1, sizeof(::livekit::proto::NewAudioSourceRequest)},
  { 70, 77, -1, sizeof(::livekit::proto::NewAudioSourceResponse)},
  { 78, 86, -1, sizeof(::livekit::proto::CaptureAudioFrameRequest)},
  { 88, 95, -1, sizeof(::livekit::proto::CaptureAudioFrameResponse)},
  { 96, 104, -1, sizeof(::livekit::proto::CaptureAudioFrameCallback)},
  { 106, 113, -1, sizeof(::livekit::proto::ClearAudioBufferRequest)},
  { 114, -1, -1, sizeof(::livekit::proto::ClearAudioBufferResponse)},
  { 120, -1, -1, sizeof(::livekit::proto::NewAudioResamplerRequest)},
  { 126, 133, -1, sizeof(::livekit::proto::NewAudioResamplerResponse)},
  { 134, 144, -1, sizeof(::livekit::proto::RemixAndResampleRequest)},
  { 148, 155, -1, sizeof(::livekit::proto::RemixAndResampleResponse)},
  { 156, 166, -1, sizeof(::livekit::proto::NewApmRequest)},
  { 170, 177, -1, sizeof(::livekit::proto::NewApmResponse)},
  { 178, 189, -1, sizeof(::livekit::proto::ApmProcessStreamRequest)},
  { 194, 201, -1, sizeof(::livekit::proto::ApmProcessStreamResponse)},
  { 202, 213, -1, sizeof(::livekit::proto::ApmProcessReverseStreamRequest)},
  { 218, 225, -1, sizeof(::livekit::proto::ApmProcessReverseStreamResponse)},
  { 226, 239, -1, sizeof(::livekit::proto::NewSoxResamplerRequest)},
  { 246, -1, -1, sizeof(::livekit::proto::NewSoxResamplerResponse)},
  { 255, 264, -1, sizeof(::livekit::proto::PushSoxResamplerRequest)},
  { 267, 276, -1, sizeof(::livekit::proto::PushSoxResamplerResponse)},
  { 279, 286, -1, sizeof(::livekit::proto::FlushSoxResamplerRequest)},
  { 287, 296, -1, sizeof(::livekit::proto::FlushSoxResamplerResponse)},
  { 299, 309, -1, sizeof(::livekit::proto::AudioFrameBufferInfo)},
  { 313, 321, -1, sizeof(::livekit::proto::OwnedAudioFrameBuffer)},
  { 323, 330, -1, sizeof(::livekit::proto::AudioStreamInfo)},
  { 331, 339, -1, sizeof(::livekit::proto::OwnedAudioStream)},
  { 341, 351, -1, sizeof(::livekit::proto::AudioStreamEvent)},
  { 354, 361, -1, sizeof(::livekit::proto::AudioFrameReceived)},
  { 362, -1, -1, sizeof(::livekit::proto::AudioStreamEOS)},
  { 368, 377, -1, sizeof(::livekit::proto::AudioSourceOptions)},
  { 380, 387, -1, sizeof(::livekit::proto::AudioSourceInfo)},
  { 388, 396, -1, sizeof(::livekit::proto::OwnedAudioSource)},
  { 398, -1, -1, sizeof(::livekit::proto::AudioResamplerInfo)},
  { 404, 412, -1, sizeof(::livekit::proto::OwnedAudioResampler)},
  { 414, 421, -1, sizeof(::livekit::proto::OwnedApm)},
  { 422, -1, -1, sizeof(::livekit::proto::SoxResamplerInfo)},
  { 428, 436, -1, sizeof(::livekit::proto::OwnedSoxResampler)},
  { 438, 447, -1, sizeof(::livekit::proto::LoadAudioFilterPluginRequest)},
  { 450, 457, -1, sizeof(::livekit::proto::LoadAudioFilterPluginResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::livekit::proto::_NewAudioStreamRequest_default_instance_._instance,
  &::livekit::proto::_NewAudioStreamResponse_default_instance_._instance,
  &::livekit::proto::_AudioStreamFromParticipantRequest_default_instance_._instance,
  &::livekit::proto::_AudioStreamFromParticipantResponse_default_instance_._instance,
  &::livekit::proto::_NewAudioSourceRequest_default_instance_._instance,
  &::livekit::proto::_NewAudioSourceResponse_default_instance_._instance,
  &::livekit::proto::_CaptureAudioFrameRequest_default_instance_._instance,
  &::livekit::proto::_CaptureAudioFrameResponse_default_instance_._instance,
  &::livekit::proto::_CaptureAudioFrameCallback_default_instance_._instance,
  &::livekit::proto::_ClearAudioBufferRequest_default_instance_._instance,
  &::livekit::proto::_ClearAudioBufferResponse_default_instance_._instance,
  &::livekit::proto::_NewAudioResamplerRequest_default_instance_._instance,
  &::livekit::proto::_NewAudioResamplerResponse_default_instance_._instance,
  &::livekit::proto::_RemixAndResampleRequest_default_instance_._instance,
  &::livekit::proto::_RemixAndResampleResponse_default_instance_._instance,
  &::livekit::proto::_NewApmRequest_default_instance_._instance,
  &::livekit::proto::_NewApmResponse_default_instance_._instance,
  &::livekit::proto::_ApmProcessStreamRequest_default_instance_._instance,
  &::livekit::proto::_ApmProcessStreamResponse_default_instance_._instance,
  &::livekit::proto::_ApmProcessReverseStreamRequest_default_instance_._instance,
  &::livekit::proto::_ApmProcessReverseStreamResponse_default_instance_._instance,
  &::livekit::proto::_NewSoxResamplerRequest_default_instance_._instance,
  &::livekit::proto::_NewSoxResamplerResponse_default_instance_._instance,
  &::livekit::proto::_PushSoxResamplerRequest_default_instance_._instance,
  &::livekit::proto::_PushSoxResamplerResponse_default_instance_._instance,
  &::livekit::proto::_FlushSoxResamplerRequest_default_instance_._instance,
  &::livekit::proto::_FlushSoxResamplerResponse_default_instance_._instance,
  &::livekit::proto::_AudioFrameBufferInfo_default_instance_._instance,
  &::livekit::proto::_OwnedAudioFrameBuffer_default_instance_._instance,
  &::livekit::proto::_AudioStreamInfo_default_instance_._instance,
  &::livekit::proto::_OwnedAudioStream_default_instance_._instance,
  &::livekit::proto::_AudioStreamEvent_default_instance_._instance,
  &::livekit::proto::_AudioFrameReceived_default_instance_._instance,
  &::livekit::proto::_AudioStreamEOS_default_instance_._instance,
  &::livekit::proto::_AudioSourceOptions_default_instance_._instance,
  &::livekit::proto::_AudioSourceInfo_default_instance_._instance,
  &::livekit::proto::_OwnedAudioSource_default_instance_._instance,
  &::livekit::proto::_AudioResamplerInfo_default_instance_._instance,
  &::livekit::proto::_OwnedAudioResampler_default_instance_._instance,
  &::livekit::proto::_OwnedApm_default_instance_._instance,
  &::livekit::proto::_SoxResamplerInfo_default_instance_._instance,
  &::livekit::proto::_OwnedSoxResampler_default_instance_._instance,
  &::livekit::proto::_LoadAudioFilterPluginRequest_default_instance_._instance,
  &::livekit::proto::_LoadAudioFilterPluginResponse_default_instance_._instance,
};

const char descriptor_table_protodef_audio_5fframe_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021audio_frame.proto\022\rlivekit.proto\032\014hand"
  "le.proto\032\013track.proto\"\304\001\n\025NewAudioStream"
  "Request\022\024\n\014track_handle\030\001 \002(\004\022,\n\004type\030\002 "
  "\002(\0162\036.livekit.proto.AudioStreamType\022\023\n\013s"
  "ample_rate\030\003 \001(\r\022\024\n\014num_channels\030\004 \001(\r\022\036"
  "\n\026audio_filter_module_id\030\005 \001(\t\022\034\n\024audio_"
  "filter_options\030\006 \001(\t\"I\n\026NewAudioStreamRe"
  "sponse\022/\n\006stream\030\001 \002(\0132\037.livekit.proto.O"
  "wnedAudioStream\"\210\002\n!AudioStreamFromParti"
  "cipantRequest\022\032\n\022participant_handle\030\001 \002("
  "\004\022,\n\004type\030\002 \002(\0162\036.livekit.proto.AudioStr"
  "eamType\0220\n\014track_source\030\003 \001(\0162\032.livekit."
  "proto.TrackSource\022\023\n\013sample_rate\030\005 \001(\r\022\024"
  "\n\014num_channels\030\006 \001(\r\022\036\n\026audio_filter_mod"
  "ule_id\030\007 \001(\t\022\034\n\024audio_filter_options\030\010 \001"
  "(\t\"U\n\"AudioStreamFromParticipantResponse"
  "\022/\n\006stream\030\001 \002(\0132\037.livekit.proto.OwnedAu"
  "dioStream\"\273\001\n\025NewAudioSourceRequest\022,\n\004t"
  "ype\030\001 \002(\0162\036.livekit.proto.AudioSourceTyp"
  "e\0222\n\007options\030\002 \001(\0132!.livekit.proto.Audio"
  "SourceOptions\022\023\n\013sample_rate\030\003 \002(\r\022\024\n\014nu"
  "m_channels\030\004 \002(\r\022\025\n\rqueue_size_ms\030\005 \001(\r\""
  "I\n\026NewAudioSourceResponse\022/\n\006source\030\001 \002("
  "\0132\037.livekit.proto.OwnedAudioSource\"f\n\030Ca"
  "ptureAudioFrameRequest\022\025\n\rsource_handle\030"
  "\001 \002(\004\0223\n\006buffer\030\002 \002(\0132#.livekit.proto.Au"
  "dioFrameBufferInfo\"-\n\031CaptureAudioFrameR"
  "esponse\022\020\n\010async_id\030\001 \002(\004\"<\n\031CaptureAudi"
  "oFrameCallback\022\020\n\010async_id\030\001 \002(\004\022\r\n\005erro"
  "r\030\002 \001(\t\"0\n\027ClearAudioBufferRequest\022\025\n\rso"
  "urce_handle\030\001 \002(\004\"\032\n\030ClearAudioBufferRes"
  "ponse\"\032\n\030NewAudioResamplerRequest\"R\n\031New"
  "AudioResamplerResponse\0225\n\tresampler\030\001 \002("
  "\0132\".livekit.proto.OwnedAudioResampler\"\223\001"
  "\n\027RemixAndResampleRequest\022\030\n\020resampler_h"
  "andle\030\001 \002(\004\0223\n\006buffer\030\002 \002(\0132#.livekit.pr"
  "oto.AudioFrameBufferInfo\022\024\n\014num_channels"
  "\030\003 \002(\r\022\023\n\013sample_rate\030\004 \002(\r\"P\n\030RemixAndR"
  "esampleResponse\0224\n\006buffer\030\001 \002(\0132$.liveki"
  "t.proto.OwnedAudioFrameBuffer\"\225\001\n\rNewApm"
  "Request\022\036\n\026echo_canceller_enabled\030\001 \002(\010\022"
  "\037\n\027gain_controller_enabled\030\002 \002(\010\022 \n\030high"
  "_pass_filter_enabled\030\003 \002(\010\022!\n\031noise_supp"
  "ression_enabled\030\004 \002(\010\"6\n\016NewApmResponse\022"
  "$\n\003apm\030\001 \002(\0132\027.livekit.proto.OwnedApm\"x\n"
  "\027ApmProcessStreamRequest\022\022\n\napm_handle\030\001"
  " \002(\004\022\020\n\010data_ptr\030\002 \002(\004\022\014\n\004size\030\003 \002(\r\022\023\n\013"
  "sample_rate\030\004 \002(\r\022\024\n\014num_channels\030\005 \002(\r\""
  ")\n\030ApmProcessStreamResponse\022\r\n\005error\030\001 \001"
  "(\t\"\177\n\036ApmProcessReverseStreamRequest\022\022\n\n"
  "apm_handle\030\001 \002(\004\022\020\n\010data_ptr\030\002 \002(\004\022\014\n\004si"
  "ze\030\003 \002(\r\022\023\n\013sample_rate\030\004 \002(\r\022\024\n\014num_cha"
  "nnels\030\005 \002(\r\"0\n\037ApmProcessReverseStreamRe"
  "sponse\022\r\n\005error\030\001 \001(\t\"\234\002\n\026NewSoxResample"
  "rRequest\022\022\n\ninput_rate\030\001 \002(\001\022\023\n\013output_r"
  "ate\030\002 \002(\001\022\024\n\014num_channels\030\003 \002(\r\022<\n\017input"
  "_data_type\030\004 \002(\0162#.livekit.proto.SoxResa"
  "mplerDataType\022=\n\020output_data_type\030\005 \002(\0162"
  "#.livekit.proto.SoxResamplerDataType\0227\n\016"
  "quality_recipe\030\006 \002(\0162\037.livekit.proto.Sox"
  "QualityRecipe\022\r\n\005flags\030\007 \001(\r\"l\n\027NewSoxRe"
  "samplerResponse\0225\n\tresampler\030\001 \001(\0132 .liv"
  "ekit.proto.OwnedSoxResamplerH\000\022\017\n\005error\030"
  "\002 \001(\tH\000B\t\n\007message\"S\n\027PushSoxResamplerRe"
  "quest\022\030\n\020resampler_handle\030\001 \002(\004\022\020\n\010data_"
  "ptr\030\002 \002(\004\022\014\n\004size\030\003 \002(\r\"K\n\030PushSoxResamp"
  "lerResponse\022\022\n\noutput_ptr\030\001 \002(\004\022\014\n\004size\030"
  "\002 \002(\r\022\r\n\005error\030\003 \001(\t\"4\n\030FlushSoxResample"
  "rRequest\022\030\n\020resampler_handle\030\001 \002(\004\"L\n\031Fl"
  "ushSoxResamplerResponse\022\022\n\noutput_ptr\030\001 "
  "\002(\004\022\014\n\004size\030\002 \002(\r\022\r\n\005error\030\003 \001(\t\"p\n\024Audi"
  "oFrameBufferInfo\022\020\n\010data_ptr\030\001 \002(\004\022\024\n\014nu"
  "m_channels\030\002 \002(\r\022\023\n\013sample_rate\030\003 \002(\r\022\033\n"
  "\023samples_per_channel\030\004 \002(\r\"y\n\025OwnedAudio"
  "FrameBuffer\022-\n\006handle\030\001 \002(\0132\035.livekit.pr"
  "oto.FfiOwnedHandle\0221\n\004info\030\002 \002(\0132#.livek"
  "it.proto.AudioFrameBufferInfo\"\?\n\017AudioSt"
  "reamInfo\022,\n\004type\030\001 \002(\0162\036.livekit.proto.A"
  "udioStreamType\"o\n\020OwnedAudioStream\022-\n\006ha"
  "ndle\030\001 \002(\0132\035.livekit.proto.FfiOwnedHandl"
  "e\022,\n\004info\030\002 \002(\0132\036.livekit.proto.AudioStr"
  "eamInfo\"\237\001\n\020AudioStreamEvent\022\025\n\rstream_h"
  "andle\030\001 \002(\004\022;\n\016frame_received\030\002 \001(\0132!.li"
  "vekit.proto.AudioFrameReceivedH\000\022,\n\003eos\030"
  "\003 \001(\0132\035.livekit.proto.AudioStreamEOSH\000B\t"
  "\n\007message\"I\n\022AudioFrameReceived\0223\n\005frame"
  "\030\001 \002(\0132$.livekit.proto.OwnedAudioFrameBu"
  "ffer\"\020\n\016AudioStreamEOS\"e\n\022AudioSourceOpt"
  "ions\022\031\n\021echo_cancellation\030\001 \002(\010\022\031\n\021noise"
  "_suppression\030\002 \002(\010\022\031\n\021auto_gain_control\030"
  "\003 \002(\010\"\?\n\017AudioSourceInfo\022,\n\004type\030\002 \002(\0162\036"
  ".livekit.proto.AudioSourceType\"o\n\020OwnedA"
  "udioSource\022-\n\006handle\030\001 \002(\0132\035.livekit.pro"
  "to.FfiOwnedHandle\022,\n\004info\030\002 \002(\0132\036.liveki"
  "t.proto.AudioSourceInfo\"\024\n\022AudioResample"
  "rInfo\"u\n\023OwnedAudioResampler\022-\n\006handle\030\001"
  " \002(\0132\035.livekit.proto.FfiOwnedHandle\022/\n\004i"
  "nfo\030\002 \002(\0132!.livekit.proto.AudioResampler"
  "Info\"9\n\010OwnedApm\022-\n\006handle\030\001 \002(\0132\035.livek"
  "it.proto.FfiOwnedHandle\"\022\n\020SoxResamplerI"
  "nfo\"q\n\021OwnedSoxResampler\022-\n\006handle\030\001 \002(\013"
  "2\035.livekit.proto.FfiOwnedHandle\022-\n\004info\030"
  "\002 \002(\0132\037.livekit.proto.SoxResamplerInfo\"\\"
  "\n\034LoadAudioFilterPluginRequest\022\023\n\013plugin"
  "_path\030\001 \002(\t\022\024\n\014dependencies\030\002 \003(\t\022\021\n\tmod"
  "ule_id\030\003 \002(\t\".\n\035LoadAudioFilterPluginRes"
  "ponse\022\r\n\005error\030\001 \001(\t*J\n\024SoxResamplerData"
  "Type\022\030\n\024SOXR_DATATYPE_INT16I\020\000\022\030\n\024SOXR_D"
  "ATATYPE_INT16S\020\001*\213\001\n\020SoxQualityRecipe\022\026\n"
  "\022SOXR_QUALITY_QUICK\020\000\022\024\n\020SOXR_QUALITY_LO"
  "W\020\001\022\027\n\023SOXR_QUALITY_MEDIUM\020\002\022\025\n\021SOXR_QUA"
  "LITY_HIGH\020\003\022\031\n\025SOXR_QUALITY_VERYHIGH\020\004*\227"
  "\001\n\013SoxFlagBits\022\026\n\022SOXR_ROLLOFF_SMALL\020\000\022\027"
  "\n\023SOXR_ROLLOFF_MEDIUM\020\001\022\025\n\021SOXR_ROLLOFF_"
  "NONE\020\002\022\030\n\024SOXR_HIGH_PREC_CLOCK\020\003\022\031\n\025SOXR"
  "_DOUBLE_PRECISION\020\004\022\013\n\007SOXR_VR\020\005*A\n\017Audi"
  "oStreamType\022\027\n\023AUDIO_STREAM_NATIVE\020\000\022\025\n\021"
  "AUDIO_STREAM_HTML\020\001**\n\017AudioSourceType\022\027"
  "\n\023AUDIO_SOURCE_NATIVE\020\000B\020\252\002\rLiveKit.Prot"
  "o"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_audio_5fframe_2eproto_deps[2] = {
  &::descriptor_table_handle_2eproto,
  &::descriptor_table_track_2eproto,
};
static ::_pbi::once_flag descriptor_table_audio_5fframe_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_audio_5fframe_2eproto = {
    false, false, 4761, descriptor_table_protodef_audio_5fframe_2eproto,
    "audio_frame.proto",
    &descriptor_table_audio_5fframe_2eproto_once, descriptor_table_audio_5fframe_2eproto_deps, 2, 44,
    schemas, file_default_instances, TableStruct_audio_5fframe_2eproto::offsets,
    file_level_metadata_audio_5fframe_2eproto, file_level_enum_descriptors_audio_5fframe_2eproto,
    file_level_service_descriptors_audio_5fframe_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_audio_5fframe_2eproto_getter() {
  return &descriptor_table_audio_5fframe_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_audio_5fframe_2eproto(&descriptor_table_audio_5fframe_2eproto);
namespace livekit {
namespace proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxResamplerDataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_5fframe_2eproto);
  return file_level_enum_descriptors_audio_5fframe_2eproto[0];
}
bool SoxResamplerDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxQualityRecipe_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_5fframe_2eproto);
  return file_level_enum_descriptors_audio_5fframe_2eproto[1];
}
bool SoxQualityRecipe_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxFlagBits_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_5fframe_2eproto);
  return file_level_enum_descriptors_audio_5fframe_2eproto[2];
}
bool SoxFlagBits_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioStreamType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_5fframe_2eproto);
  return file_level_enum_descriptors_audio_5fframe_2eproto[3];
}
bool AudioStreamType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_audio_5fframe_2eproto);
  return file_level_enum_descriptors_audio_5fframe_2eproto[4];
}
bool AudioSourceType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NewAudioStreamRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewAudioStreamRequest>()._impl_._has_bits_);
  static void set_has_track_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audio_filter_module_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_filter_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

NewAudioStreamRequest::NewAudioStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioStreamRequest)
}
NewAudioStreamRequest::NewAudioStreamRequest(const NewAudioStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewAudioStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_filter_module_id_){}
    , decltype(_impl_.audio_filter_options_){}
    , decltype(_impl_.track_handle_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.num_channels_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_filter_module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_filter_module_id()) {
    _this->_impl_.audio_filter_module_id_.Set(from._internal_audio_filter_module_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.audio_filter_options_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_filter_options()) {
    _this->_impl_.audio_filter_options_.Set(from._internal_audio_filter_options(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.track_handle_, &from._impl_.track_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_channels_) -
    reinterpret_cast<char*>(&_impl_.track_handle_)) + sizeof(_impl_.num_channels_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioStreamRequest)
}

inline void NewAudioStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_filter_module_id_){}
    , decltype(_impl_.audio_filter_options_){}
    , decltype(_impl_.track_handle_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.num_channels_){0u}
  };
  _impl_.audio_filter_module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.audio_filter_options_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NewAudioStreamRequest::~NewAudioStreamRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewAudioStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewAudioStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_filter_module_id_.Destroy();
  _impl_.audio_filter_options_.Destroy();
}

void NewAudioStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewAudioStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewAudioStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.audio_filter_module_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.audio_filter_options_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.track_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_channels_) -
        reinterpret_cast<char*>(&_impl_.track_handle_)) + sizeof(_impl_.num_channels_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewAudioStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 track_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_track_handle(&has_bits);
          _impl_.track_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioStreamType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::AudioStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::AudioStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sample_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_channels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string audio_filter_module_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_audio_filter_module_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.NewAudioStreamRequest.audio_filter_module_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string audio_filter_options = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_audio_filter_options();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.NewAudioStreamRequest.audio_filter_options");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewAudioStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewAudioStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 track_handle = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_track_handle(), target);
  }

  // required .livekit.proto.AudioStreamType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional uint32 sample_rate = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sample_rate(), target);
  }

  // optional uint32 num_channels = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_channels(), target);
  }

  // optional string audio_filter_module_id = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_audio_filter_module_id().data(), static_cast<int>(this->_internal_audio_filter_module_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.NewAudioStreamRequest.audio_filter_module_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_audio_filter_module_id(), target);
  }

  // optional string audio_filter_options = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_audio_filter_options().data(), static_cast<int>(this->_internal_audio_filter_options().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.NewAudioStreamRequest.audio_filter_options");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_audio_filter_options(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewAudioStreamRequest)
  return target;
}

size_t NewAudioStreamRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewAudioStreamRequest)
  size_t total_size = 0;

  if (_internal_has_track_handle()) {
    // required uint64 track_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_handle());
  }

  if (_internal_has_type()) {
    // required .livekit.proto.AudioStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t NewAudioStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewAudioStreamRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint64 track_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_track_handle());

    // required .livekit.proto.AudioStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string audio_filter_module_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_audio_filter_module_id());
    }

    // optional string audio_filter_options = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_audio_filter_options());
    }

  }
  if (cached_has_bits & 0x00000030u) {
    // optional uint32 sample_rate = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
    }

    // optional uint32 num_channels = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewAudioStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioStreamRequest::GetClassData() const { return &_class_data_; }


void NewAudioStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewAudioStreamRequest*>(&to_msg);
  auto& from = static_cast<const NewAudioStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewAudioStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_audio_filter_module_id(from._internal_audio_filter_module_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_audio_filter_options(from._internal_audio_filter_options());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.track_handle_ = from._impl_.track_handle_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewAudioStreamRequest::CopyFrom(const NewAudioStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewAudioStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewAudioStreamRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NewAudioStreamRequest::InternalSwap(NewAudioStreamRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_filter_module_id_, lhs_arena,
      &other->_impl_.audio_filter_module_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_filter_options_, lhs_arena,
      &other->_impl_.audio_filter_options_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewAudioStreamRequest, _impl_.num_channels_)
      + sizeof(NewAudioStreamRequest::_impl_.num_channels_)
      - PROTOBUF_FIELD_OFFSET(NewAudioStreamRequest, _impl_.track_handle_)>(
          reinterpret_cast<char*>(&_impl_.track_handle_),
          reinterpret_cast<char*>(&other->_impl_.track_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewAudioStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[0]);
}

// ===================================================================

class NewAudioStreamResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewAudioStreamResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioStream& stream(const NewAudioStreamResponse* msg);
  static void set_has_stream(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioStream&
NewAudioStreamResponse::_Internal::stream(const NewAudioStreamResponse* msg) {
  return *msg->_impl_.stream_;
}
NewAudioStreamResponse::NewAudioStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioStreamResponse)
}
NewAudioStreamResponse::NewAudioStreamResponse(const NewAudioStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewAudioStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stream()) {
    _this->_impl_.stream_ = new ::livekit::proto::OwnedAudioStream(*from._impl_.stream_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioStreamResponse)
}

inline void NewAudioStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}
  };
}

NewAudioStreamResponse::~NewAudioStreamResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewAudioStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewAudioStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stream_;
}

void NewAudioStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewAudioStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewAudioStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.stream_ != nullptr);
    _impl_.stream_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewAudioStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioStream stream = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewAudioStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewAudioStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioStream stream = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stream(this),
        _Internal::stream(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewAudioStreamResponse)
  return target;
}

size_t NewAudioStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewAudioStreamResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioStream stream = 1;
  if (_internal_has_stream()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stream_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewAudioStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioStreamResponse::GetClassData() const { return &_class_data_; }


void NewAudioStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewAudioStreamResponse*>(&to_msg);
  auto& from = static_cast<const NewAudioStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewAudioStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream()) {
    _this->_internal_mutable_stream()->::livekit::proto::OwnedAudioStream::MergeFrom(
        from._internal_stream());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewAudioStreamResponse::CopyFrom(const NewAudioStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewAudioStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewAudioStreamResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_stream()) {
    if (!_impl_.stream_->IsInitialized()) return false;
  }
  return true;
}

void NewAudioStreamResponse::InternalSwap(NewAudioStreamResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_, other->_impl_.stream_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewAudioStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[1]);
}

// ===================================================================

class AudioStreamFromParticipantRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStreamFromParticipantRequest>()._impl_._has_bits_);
  static void set_has_participant_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_track_source(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_audio_filter_module_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_filter_options(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

AudioStreamFromParticipantRequest::AudioStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioStreamFromParticipantRequest)
}
AudioStreamFromParticipantRequest::AudioStreamFromParticipantRequest(const AudioStreamFromParticipantRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioStreamFromParticipantRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_filter_module_id_){}
    , decltype(_impl_.audio_filter_options_){}
    , decltype(_impl_.participant_handle_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.track_source_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.num_channels_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.audio_filter_module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_filter_module_id()) {
    _this->_impl_.audio_filter_module_id_.Set(from._internal_audio_filter_module_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.audio_filter_options_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_audio_filter_options()) {
    _this->_impl_.audio_filter_options_.Set(from._internal_audio_filter_options(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.participant_handle_, &from._impl_.participant_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_channels_) -
    reinterpret_cast<char*>(&_impl_.participant_handle_)) + sizeof(_impl_.num_channels_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioStreamFromParticipantRequest)
}

inline void AudioStreamFromParticipantRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_filter_module_id_){}
    , decltype(_impl_.audio_filter_options_){}
    , decltype(_impl_.participant_handle_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.track_source_){0}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.num_channels_){0u}
  };
  _impl_.audio_filter_module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.audio_filter_options_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AudioStreamFromParticipantRequest::~AudioStreamFromParticipantRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioStreamFromParticipantRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioStreamFromParticipantRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.audio_filter_module_id_.Destroy();
  _impl_.audio_filter_options_.Destroy();
}

void AudioStreamFromParticipantRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioStreamFromParticipantRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioStreamFromParticipantRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.audio_filter_module_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.audio_filter_options_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.participant_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_channels_) -
        reinterpret_cast<char*>(&_impl_.participant_handle_)) + sizeof(_impl_.num_channels_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioStreamFromParticipantRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 participant_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_participant_handle(&has_bits);
          _impl_.participant_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioStreamType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::AudioStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::AudioStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .livekit.proto.TrackSource track_source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::TrackSource_IsValid(val))) {
            _internal_set_track_source(static_cast<::livekit::proto::TrackSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sample_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string audio_filter_module_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_audio_filter_module_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string audio_filter_options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_audio_filter_options();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioStreamFromParticipantRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioStreamFromParticipantRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 participant_handle = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_participant_handle(), target);
  }

  // required .livekit.proto.AudioStreamType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional .livekit.proto.TrackSource track_source = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_track_source(), target);
  }

  // optional uint32 sample_rate = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sample_rate(), target);
  }

  // optional uint32 num_channels = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_num_channels(), target);
  }

  // optional string audio_filter_module_id = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_audio_filter_module_id().data(), static_cast<int>(this->_internal_audio_filter_module_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_audio_filter_module_id(), target);
  }

  // optional string audio_filter_options = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_audio_filter_options().data(), static_cast<int>(this->_internal_audio_filter_options().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_audio_filter_options(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioStreamFromParticipantRequest)
  return target;
}

size_t AudioStreamFromParticipantRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.AudioStreamFromParticipantRequest)
  size_t total_size = 0;

  if (_internal_has_participant_handle()) {
    // required uint64 participant_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_participant_handle());
  }

  if (_internal_has_type()) {
    // required .livekit.proto.AudioStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t AudioStreamFromParticipantRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioStreamFromParticipantRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint64 participant_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_participant_handle());

    // required .livekit.proto.AudioStreamType type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string audio_filter_module_id = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_audio_filter_module_id());
    }

    // optional string audio_filter_options = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_audio_filter_options());
    }

  }
  if (cached_has_bits & 0x00000070u) {
    // optional .livekit.proto.TrackSource track_source = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_track_source());
    }

    // optional uint32 sample_rate = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
    }

    // optional uint32 num_channels = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioStreamFromParticipantRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioStreamFromParticipantRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioStreamFromParticipantRequest::GetClassData() const { return &_class_data_; }


void AudioStreamFromParticipantRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioStreamFromParticipantRequest*>(&to_msg);
  auto& from = static_cast<const AudioStreamFromParticipantRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioStreamFromParticipantRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_audio_filter_module_id(from._internal_audio_filter_module_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_audio_filter_options(from._internal_audio_filter_options());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.participant_handle_ = from._impl_.participant_handle_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.track_source_ = from._impl_.track_source_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioStreamFromParticipantRequest::CopyFrom(const AudioStreamFromParticipantRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioStreamFromParticipantRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamFromParticipantRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AudioStreamFromParticipantRequest::InternalSwap(AudioStreamFromParticipantRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_filter_module_id_, lhs_arena,
      &other->_impl_.audio_filter_module_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.audio_filter_options_, lhs_arena,
      &other->_impl_.audio_filter_options_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioStreamFromParticipantRequest, _impl_.num_channels_)
      + sizeof(AudioStreamFromParticipantRequest::_impl_.num_channels_)
      - PROTOBUF_FIELD_OFFSET(AudioStreamFromParticipantRequest, _impl_.participant_handle_)>(
          reinterpret_cast<char*>(&_impl_.participant_handle_),
          reinterpret_cast<char*>(&other->_impl_.participant_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioStreamFromParticipantRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[2]);
}

// ===================================================================

class AudioStreamFromParticipantResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStreamFromParticipantResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioStream& stream(const AudioStreamFromParticipantResponse* msg);
  static void set_has_stream(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioStream&
AudioStreamFromParticipantResponse::_Internal::stream(const AudioStreamFromParticipantResponse* msg) {
  return *msg->_impl_.stream_;
}
AudioStreamFromParticipantResponse::AudioStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioStreamFromParticipantResponse)
}
AudioStreamFromParticipantResponse::AudioStreamFromParticipantResponse(const AudioStreamFromParticipantResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioStreamFromParticipantResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stream()) {
    _this->_impl_.stream_ = new ::livekit::proto::OwnedAudioStream(*from._impl_.stream_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioStreamFromParticipantResponse)
}

inline void AudioStreamFromParticipantResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_){nullptr}
  };
}

AudioStreamFromParticipantResponse::~AudioStreamFromParticipantResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioStreamFromParticipantResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioStreamFromParticipantResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stream_;
}

void AudioStreamFromParticipantResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioStreamFromParticipantResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioStreamFromParticipantResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.stream_ != nullptr);
    _impl_.stream_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioStreamFromParticipantResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioStream stream = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stream(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioStreamFromParticipantResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioStreamFromParticipantResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioStream stream = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stream(this),
        _Internal::stream(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioStreamFromParticipantResponse)
  return target;
}

size_t AudioStreamFromParticipantResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioStreamFromParticipantResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioStream stream = 1;
  if (_internal_has_stream()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stream_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioStreamFromParticipantResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioStreamFromParticipantResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioStreamFromParticipantResponse::GetClassData() const { return &_class_data_; }


void AudioStreamFromParticipantResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioStreamFromParticipantResponse*>(&to_msg);
  auto& from = static_cast<const AudioStreamFromParticipantResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioStreamFromParticipantResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream()) {
    _this->_internal_mutable_stream()->::livekit::proto::OwnedAudioStream::MergeFrom(
        from._internal_stream());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioStreamFromParticipantResponse::CopyFrom(const AudioStreamFromParticipantResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioStreamFromParticipantResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamFromParticipantResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_stream()) {
    if (!_impl_.stream_->IsInitialized()) return false;
  }
  return true;
}

void AudioStreamFromParticipantResponse::InternalSwap(AudioStreamFromParticipantResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_, other->_impl_.stream_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioStreamFromParticipantResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[3]);
}

// ===================================================================

class NewAudioSourceRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewAudioSourceRequest>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::AudioSourceOptions& options(const NewAudioSourceRequest* msg);
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_queue_size_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

const ::livekit::proto::AudioSourceOptions&
NewAudioSourceRequest::_Internal::options(const NewAudioSourceRequest* msg) {
  return *msg->_impl_.options_;
}
NewAudioSourceRequest::NewAudioSourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioSourceRequest)
}
NewAudioSourceRequest::NewAudioSourceRequest(const NewAudioSourceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewAudioSourceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.num_channels_){}
    , decltype(_impl_.queue_size_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_options()) {
    _this->_impl_.options_ = new ::livekit::proto::AudioSourceOptions(*from._impl_.options_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.queue_size_ms_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.queue_size_ms_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioSourceRequest)
}

inline void NewAudioSourceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.options_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.num_channels_){0u}
    , decltype(_impl_.queue_size_ms_){0u}
  };
}

NewAudioSourceRequest::~NewAudioSourceRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewAudioSourceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewAudioSourceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.options_;
}

void NewAudioSourceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewAudioSourceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewAudioSourceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.options_ != nullptr);
    _impl_.options_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.queue_size_ms_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.queue_size_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewAudioSourceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.AudioSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::AudioSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::AudioSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .livekit.proto.AudioSourceOptions options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sample_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 queue_size_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_queue_size_ms(&has_bits);
          _impl_.queue_size_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewAudioSourceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewAudioSourceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.AudioSourceType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .livekit.proto.AudioSourceOptions options = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  // required uint32 sample_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sample_rate(), target);
  }

  // required uint32 num_channels = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_num_channels(), target);
  }

  // optional uint32 queue_size_ms = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_queue_size_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewAudioSourceRequest)
  return target;
}

size_t NewAudioSourceRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewAudioSourceRequest)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .livekit.proto.AudioSourceType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_sample_rate()) {
    // required uint32 sample_rate = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  return total_size;
}
size_t NewAudioSourceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewAudioSourceRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required .livekit.proto.AudioSourceType type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    // required uint32 sample_rate = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());

    // required uint32 num_channels = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .livekit.proto.AudioSourceOptions options = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.options_);
  }

  // optional uint32 queue_size_ms = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_queue_size_ms());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioSourceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewAudioSourceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioSourceRequest::GetClassData() const { return &_class_data_; }


void NewAudioSourceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewAudioSourceRequest*>(&to_msg);
  auto& from = static_cast<const NewAudioSourceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewAudioSourceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_options()->::livekit::proto::AudioSourceOptions::MergeFrom(
          from._internal_options());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.queue_size_ms_ = from._impl_.queue_size_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewAudioSourceRequest::CopyFrom(const NewAudioSourceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewAudioSourceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewAudioSourceRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_options()) {
    if (!_impl_.options_->IsInitialized()) return false;
  }
  return true;
}

void NewAudioSourceRequest::InternalSwap(NewAudioSourceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewAudioSourceRequest, _impl_.queue_size_ms_)
      + sizeof(NewAudioSourceRequest::_impl_.queue_size_ms_)
      - PROTOBUF_FIELD_OFFSET(NewAudioSourceRequest, _impl_.options_)>(
          reinterpret_cast<char*>(&_impl_.options_),
          reinterpret_cast<char*>(&other->_impl_.options_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewAudioSourceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[4]);
}

// ===================================================================

class NewAudioSourceResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewAudioSourceResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioSource& source(const NewAudioSourceResponse* msg);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioSource&
NewAudioSourceResponse::_Internal::source(const NewAudioSourceResponse* msg) {
  return *msg->_impl_.source_;
}
NewAudioSourceResponse::NewAudioSourceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioSourceResponse)
}
NewAudioSourceResponse::NewAudioSourceResponse(const NewAudioSourceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewAudioSourceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_source()) {
    _this->_impl_.source_ = new ::livekit::proto::OwnedAudioSource(*from._impl_.source_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioSourceResponse)
}

inline void NewAudioSourceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_){nullptr}
  };
}

NewAudioSourceResponse::~NewAudioSourceResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewAudioSourceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewAudioSourceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.source_;
}

void NewAudioSourceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewAudioSourceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewAudioSourceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.source_ != nullptr);
    _impl_.source_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewAudioSourceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioSource source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewAudioSourceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewAudioSourceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioSource source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::source(this),
        _Internal::source(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewAudioSourceResponse)
  return target;
}

size_t NewAudioSourceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewAudioSourceResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioSource source = 1;
  if (_internal_has_source()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.source_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioSourceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewAudioSourceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioSourceResponse::GetClassData() const { return &_class_data_; }


void NewAudioSourceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewAudioSourceResponse*>(&to_msg);
  auto& from = static_cast<const NewAudioSourceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewAudioSourceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_source()) {
    _this->_internal_mutable_source()->::livekit::proto::OwnedAudioSource::MergeFrom(
        from._internal_source());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewAudioSourceResponse::CopyFrom(const NewAudioSourceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewAudioSourceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewAudioSourceResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_source()) {
    if (!_impl_.source_->IsInitialized()) return false;
  }
  return true;
}

void NewAudioSourceResponse::InternalSwap(NewAudioSourceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.source_, other->_impl_.source_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewAudioSourceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[5]);
}

// ===================================================================

class CaptureAudioFrameRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CaptureAudioFrameRequest>()._impl_._has_bits_);
  static void set_has_source_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::AudioFrameBufferInfo& buffer(const CaptureAudioFrameRequest* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::AudioFrameBufferInfo&
CaptureAudioFrameRequest::_Internal::buffer(const CaptureAudioFrameRequest* msg) {
  return *msg->_impl_.buffer_;
}
CaptureAudioFrameRequest::CaptureAudioFrameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.CaptureAudioFrameRequest)
}
CaptureAudioFrameRequest::CaptureAudioFrameRequest(const CaptureAudioFrameRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaptureAudioFrameRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.source_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::AudioFrameBufferInfo(*from._impl_.buffer_);
  }
  _this->_impl_.source_handle_ = from._impl_.source_handle_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.CaptureAudioFrameRequest)
}

inline void CaptureAudioFrameRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.source_handle_){uint64_t{0u}}
  };
}

CaptureAudioFrameRequest::~CaptureAudioFrameRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.CaptureAudioFrameRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureAudioFrameRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void CaptureAudioFrameRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaptureAudioFrameRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.CaptureAudioFrameRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaptureAudioFrameRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 source_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source_handle(&has_bits);
          _impl_.source_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureAudioFrameRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.CaptureAudioFrameRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 source_handle = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_source_handle(), target);
  }

  // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.CaptureAudioFrameRequest)
  return target;
}

size_t CaptureAudioFrameRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.CaptureAudioFrameRequest)
  size_t total_size = 0;

  if (_internal_has_buffer()) {
    // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }

  if (_internal_has_source_handle()) {
    // required uint64 source_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_handle());
  }

  return total_size;
}
size_t CaptureAudioFrameRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.CaptureAudioFrameRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);

    // required uint64 source_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_handle());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureAudioFrameRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaptureAudioFrameRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureAudioFrameRequest::GetClassData() const { return &_class_data_; }


void CaptureAudioFrameRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaptureAudioFrameRequest*>(&to_msg);
  auto& from = static_cast<const CaptureAudioFrameRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.CaptureAudioFrameRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buffer()->::livekit::proto::AudioFrameBufferInfo::MergeFrom(
          from._internal_buffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.source_handle_ = from._impl_.source_handle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaptureAudioFrameRequest::CopyFrom(const CaptureAudioFrameRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.CaptureAudioFrameRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureAudioFrameRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void CaptureAudioFrameRequest::InternalSwap(CaptureAudioFrameRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaptureAudioFrameRequest, _impl_.source_handle_)
      + sizeof(CaptureAudioFrameRequest::_impl_.source_handle_)
      - PROTOBUF_FIELD_OFFSET(CaptureAudioFrameRequest, _impl_.buffer_)>(
          reinterpret_cast<char*>(&_impl_.buffer_),
          reinterpret_cast<char*>(&other->_impl_.buffer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaptureAudioFrameRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[6]);
}

// ===================================================================

class CaptureAudioFrameResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CaptureAudioFrameResponse>()._impl_._has_bits_);
  static void set_has_async_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CaptureAudioFrameResponse::CaptureAudioFrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.CaptureAudioFrameResponse)
}
CaptureAudioFrameResponse::CaptureAudioFrameResponse(const CaptureAudioFrameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaptureAudioFrameResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.async_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.async_id_ = from._impl_.async_id_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.CaptureAudioFrameResponse)
}

inline void CaptureAudioFrameResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.async_id_){uint64_t{0u}}
  };
}

CaptureAudioFrameResponse::~CaptureAudioFrameResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.CaptureAudioFrameResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureAudioFrameResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CaptureAudioFrameResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaptureAudioFrameResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.CaptureAudioFrameResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaptureAudioFrameResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 async_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_async_id(&has_bits);
          _impl_.async_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureAudioFrameResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.CaptureAudioFrameResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 async_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_async_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.CaptureAudioFrameResponse)
  return target;
}

size_t CaptureAudioFrameResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.CaptureAudioFrameResponse)
  size_t total_size = 0;

  // required uint64 async_id = 1;
  if (_internal_has_async_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_async_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureAudioFrameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaptureAudioFrameResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureAudioFrameResponse::GetClassData() const { return &_class_data_; }


void CaptureAudioFrameResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaptureAudioFrameResponse*>(&to_msg);
  auto& from = static_cast<const CaptureAudioFrameResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.CaptureAudioFrameResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_async_id()) {
    _this->_internal_set_async_id(from._internal_async_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaptureAudioFrameResponse::CopyFrom(const CaptureAudioFrameResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.CaptureAudioFrameResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureAudioFrameResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CaptureAudioFrameResponse::InternalSwap(CaptureAudioFrameResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.async_id_, other->_impl_.async_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CaptureAudioFrameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[7]);
}

// ===================================================================

class CaptureAudioFrameCallback::_Internal {
 public:
  using HasBits = decltype(std::declval<CaptureAudioFrameCallback>()._impl_._has_bits_);
  static void set_has_async_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CaptureAudioFrameCallback::CaptureAudioFrameCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.CaptureAudioFrameCallback)
}
CaptureAudioFrameCallback::CaptureAudioFrameCallback(const CaptureAudioFrameCallback& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaptureAudioFrameCallback* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.async_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.async_id_ = from._impl_.async_id_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.CaptureAudioFrameCallback)
}

inline void CaptureAudioFrameCallback::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.async_id_){uint64_t{0u}}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CaptureAudioFrameCallback::~CaptureAudioFrameCallback() {
  // @@protoc_insertion_point(destructor:livekit.proto.CaptureAudioFrameCallback)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CaptureAudioFrameCallback::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void CaptureAudioFrameCallback::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaptureAudioFrameCallback::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.CaptureAudioFrameCallback)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaptureAudioFrameCallback::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 async_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_async_id(&has_bits);
          _impl_.async_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.CaptureAudioFrameCallback.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureAudioFrameCallback::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.CaptureAudioFrameCallback)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 async_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_async_id(), target);
  }

  // optional string error = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.CaptureAudioFrameCallback.error");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.CaptureAudioFrameCallback)
  return target;
}

size_t CaptureAudioFrameCallback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.CaptureAudioFrameCallback)
  size_t total_size = 0;

  // required uint64 async_id = 1;
  if (_internal_has_async_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_async_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureAudioFrameCallback::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaptureAudioFrameCallback::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureAudioFrameCallback::GetClassData() const { return &_class_data_; }


void CaptureAudioFrameCallback::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaptureAudioFrameCallback*>(&to_msg);
  auto& from = static_cast<const CaptureAudioFrameCallback&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.CaptureAudioFrameCallback)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.async_id_ = from._impl_.async_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaptureAudioFrameCallback::CopyFrom(const CaptureAudioFrameCallback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.CaptureAudioFrameCallback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureAudioFrameCallback::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CaptureAudioFrameCallback::InternalSwap(CaptureAudioFrameCallback* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  swap(_impl_.async_id_, other->_impl_.async_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CaptureAudioFrameCallback::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[8]);
}

// ===================================================================

class ClearAudioBufferRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ClearAudioBufferRequest>()._impl_._has_bits_);
  static void set_has_source_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ClearAudioBufferRequest::ClearAudioBufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ClearAudioBufferRequest)
}
ClearAudioBufferRequest::ClearAudioBufferRequest(const ClearAudioBufferRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ClearAudioBufferRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.source_handle_ = from._impl_.source_handle_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ClearAudioBufferRequest)
}

inline void ClearAudioBufferRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.source_handle_){uint64_t{0u}}
  };
}

ClearAudioBufferRequest::~ClearAudioBufferRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.ClearAudioBufferRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearAudioBufferRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearAudioBufferRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ClearAudioBufferRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.ClearAudioBufferRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ClearAudioBufferRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 source_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_source_handle(&has_bits);
          _impl_.source_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearAudioBufferRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.ClearAudioBufferRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 source_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_source_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.ClearAudioBufferRequest)
  return target;
}

size_t ClearAudioBufferRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.ClearAudioBufferRequest)
  size_t total_size = 0;

  // required uint64 source_handle = 1;
  if (_internal_has_source_handle()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_source_handle());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClearAudioBufferRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ClearAudioBufferRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClearAudioBufferRequest::GetClassData() const { return &_class_data_; }


void ClearAudioBufferRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ClearAudioBufferRequest*>(&to_msg);
  auto& from = static_cast<const ClearAudioBufferRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.ClearAudioBufferRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_source_handle()) {
    _this->_internal_set_source_handle(from._internal_source_handle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ClearAudioBufferRequest::CopyFrom(const ClearAudioBufferRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.ClearAudioBufferRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearAudioBufferRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ClearAudioBufferRequest::InternalSwap(ClearAudioBufferRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.source_handle_, other->_impl_.source_handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ClearAudioBufferRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[9]);
}

// ===================================================================

class ClearAudioBufferResponse::_Internal {
 public:
};

ClearAudioBufferResponse::ClearAudioBufferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ClearAudioBufferResponse)
}
ClearAudioBufferResponse::ClearAudioBufferResponse(const ClearAudioBufferResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  ClearAudioBufferResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ClearAudioBufferResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ClearAudioBufferResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ClearAudioBufferResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata ClearAudioBufferResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[10]);
}

// ===================================================================

class NewAudioResamplerRequest::_Internal {
 public:
};

NewAudioResamplerRequest::NewAudioResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioResamplerRequest)
}
NewAudioResamplerRequest::NewAudioResamplerRequest(const NewAudioResamplerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  NewAudioResamplerRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioResamplerRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioResamplerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioResamplerRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata NewAudioResamplerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[11]);
}

// ===================================================================

class NewAudioResamplerResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewAudioResamplerResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioResampler& resampler(const NewAudioResamplerResponse* msg);
  static void set_has_resampler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioResampler&
NewAudioResamplerResponse::_Internal::resampler(const NewAudioResamplerResponse* msg) {
  return *msg->_impl_.resampler_;
}
NewAudioResamplerResponse::NewAudioResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewAudioResamplerResponse)
}
NewAudioResamplerResponse::NewAudioResamplerResponse(const NewAudioResamplerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewAudioResamplerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_resampler()) {
    _this->_impl_.resampler_ = new ::livekit::proto::OwnedAudioResampler(*from._impl_.resampler_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewAudioResamplerResponse)
}

inline void NewAudioResamplerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_){nullptr}
  };
}

NewAudioResamplerResponse::~NewAudioResamplerResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewAudioResamplerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewAudioResamplerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.resampler_;
}

void NewAudioResamplerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewAudioResamplerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewAudioResamplerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.resampler_ != nullptr);
    _impl_.resampler_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewAudioResamplerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioResampler resampler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_resampler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewAudioResamplerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewAudioResamplerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioResampler resampler = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::resampler(this),
        _Internal::resampler(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewAudioResamplerResponse)
  return target;
}

size_t NewAudioResamplerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewAudioResamplerResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioResampler resampler = 1;
  if (_internal_has_resampler()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.resampler_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewAudioResamplerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewAudioResamplerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewAudioResamplerResponse::GetClassData() const { return &_class_data_; }


void NewAudioResamplerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewAudioResamplerResponse*>(&to_msg);
  auto& from = static_cast<const NewAudioResamplerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewAudioResamplerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_resampler()) {
    _this->_internal_mutable_resampler()->::livekit::proto::OwnedAudioResampler::MergeFrom(
        from._internal_resampler());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewAudioResamplerResponse::CopyFrom(const NewAudioResamplerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewAudioResamplerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewAudioResamplerResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_resampler()) {
    if (!_impl_.resampler_->IsInitialized()) return false;
  }
  return true;
}

void NewAudioResamplerResponse::InternalSwap(NewAudioResamplerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.resampler_, other->_impl_.resampler_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewAudioResamplerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[12]);
}

// ===================================================================

class RemixAndResampleRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RemixAndResampleRequest>()._impl_._has_bits_);
  static void set_has_resampler_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::AudioFrameBufferInfo& buffer(const RemixAndResampleRequest* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::livekit::proto::AudioFrameBufferInfo&
RemixAndResampleRequest::_Internal::buffer(const RemixAndResampleRequest* msg) {
  return *msg->_impl_.buffer_;
}
RemixAndResampleRequest::RemixAndResampleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RemixAndResampleRequest)
}
RemixAndResampleRequest::RemixAndResampleRequest(const RemixAndResampleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemixAndResampleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.resampler_handle_){}
    , decltype(_impl_.num_channels_){}
    , decltype(_impl_.sample_rate_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::AudioFrameBufferInfo(*from._impl_.buffer_);
  }
  ::memcpy(&_impl_.resampler_handle_, &from._impl_.resampler_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sample_rate_) -
    reinterpret_cast<char*>(&_impl_.resampler_handle_)) + sizeof(_impl_.sample_rate_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RemixAndResampleRequest)
}

inline void RemixAndResampleRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
    , decltype(_impl_.resampler_handle_){uint64_t{0u}}
    , decltype(_impl_.num_channels_){0u}
    , decltype(_impl_.sample_rate_){0u}
  };
}

RemixAndResampleRequest::~RemixAndResampleRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.RemixAndResampleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemixAndResampleRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void RemixAndResampleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemixAndResampleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RemixAndResampleRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.resampler_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sample_rate_) -
        reinterpret_cast<char*>(&_impl_.resampler_handle_)) + sizeof(_impl_.sample_rate_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemixAndResampleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 resampler_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_resampler_handle(&has_bits);
          _impl_.resampler_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sample_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemixAndResampleRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RemixAndResampleRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 resampler_handle = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_resampler_handle(), target);
  }

  // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  // required uint32 num_channels = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_channels(), target);
  }

  // required uint32 sample_rate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sample_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RemixAndResampleRequest)
  return target;
}

size_t RemixAndResampleRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.RemixAndResampleRequest)
  size_t total_size = 0;

  if (_internal_has_buffer()) {
    // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }

  if (_internal_has_resampler_handle()) {
    // required uint64 resampler_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resampler_handle());
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  if (_internal_has_sample_rate()) {
    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  return total_size;
}
size_t RemixAndResampleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RemixAndResampleRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);

    // required uint64 resampler_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resampler_handle());

    // required uint32 num_channels = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemixAndResampleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemixAndResampleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemixAndResampleRequest::GetClassData() const { return &_class_data_; }


void RemixAndResampleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemixAndResampleRequest*>(&to_msg);
  auto& from = static_cast<const RemixAndResampleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RemixAndResampleRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_buffer()->::livekit::proto::AudioFrameBufferInfo::MergeFrom(
          from._internal_buffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resampler_handle_ = from._impl_.resampler_handle_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemixAndResampleRequest::CopyFrom(const RemixAndResampleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RemixAndResampleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemixAndResampleRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void RemixAndResampleRequest::InternalSwap(RemixAndResampleRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemixAndResampleRequest, _impl_.sample_rate_)
      + sizeof(RemixAndResampleRequest::_impl_.sample_rate_)
      - PROTOBUF_FIELD_OFFSET(RemixAndResampleRequest, _impl_.buffer_)>(
          reinterpret_cast<char*>(&_impl_.buffer_),
          reinterpret_cast<char*>(&other->_impl_.buffer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemixAndResampleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[13]);
}

// ===================================================================

class RemixAndResampleResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RemixAndResampleResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioFrameBuffer& buffer(const RemixAndResampleResponse* msg);
  static void set_has_buffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioFrameBuffer&
RemixAndResampleResponse::_Internal::buffer(const RemixAndResampleResponse* msg) {
  return *msg->_impl_.buffer_;
}
RemixAndResampleResponse::RemixAndResampleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RemixAndResampleResponse)
}
RemixAndResampleResponse::RemixAndResampleResponse(const RemixAndResampleResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemixAndResampleResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_buffer()) {
    _this->_impl_.buffer_ = new ::livekit::proto::OwnedAudioFrameBuffer(*from._impl_.buffer_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RemixAndResampleResponse)
}

inline void RemixAndResampleResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buffer_){nullptr}
  };
}

RemixAndResampleResponse::~RemixAndResampleResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.RemixAndResampleResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemixAndResampleResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.buffer_;
}

void RemixAndResampleResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemixAndResampleResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RemixAndResampleResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.buffer_ != nullptr);
    _impl_.buffer_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemixAndResampleResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioFrameBuffer buffer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_buffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemixAndResampleResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RemixAndResampleResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioFrameBuffer buffer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::buffer(this),
        _Internal::buffer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RemixAndResampleResponse)
  return target;
}

size_t RemixAndResampleResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RemixAndResampleResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioFrameBuffer buffer = 1;
  if (_internal_has_buffer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.buffer_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemixAndResampleResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemixAndResampleResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemixAndResampleResponse::GetClassData() const { return &_class_data_; }


void RemixAndResampleResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemixAndResampleResponse*>(&to_msg);
  auto& from = static_cast<const RemixAndResampleResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RemixAndResampleResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_buffer()) {
    _this->_internal_mutable_buffer()->::livekit::proto::OwnedAudioFrameBuffer::MergeFrom(
        from._internal_buffer());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemixAndResampleResponse::CopyFrom(const RemixAndResampleResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RemixAndResampleResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemixAndResampleResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_buffer()) {
    if (!_impl_.buffer_->IsInitialized()) return false;
  }
  return true;
}

void RemixAndResampleResponse::InternalSwap(RemixAndResampleResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.buffer_, other->_impl_.buffer_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemixAndResampleResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[14]);
}

// ===================================================================

class NewApmRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewApmRequest>()._impl_._has_bits_);
  static void set_has_echo_canceller_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gain_controller_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_high_pass_filter_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_noise_suppression_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

NewApmRequest::NewApmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewApmRequest)
}
NewApmRequest::NewApmRequest(const NewApmRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewApmRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_canceller_enabled_){}
    , decltype(_impl_.gain_controller_enabled_){}
    , decltype(_impl_.high_pass_filter_enabled_){}
    , decltype(_impl_.noise_suppression_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.echo_canceller_enabled_, &from._impl_.echo_canceller_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.noise_suppression_enabled_) -
    reinterpret_cast<char*>(&_impl_.echo_canceller_enabled_)) + sizeof(_impl_.noise_suppression_enabled_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewApmRequest)
}

inline void NewApmRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_canceller_enabled_){false}
    , decltype(_impl_.gain_controller_enabled_){false}
    , decltype(_impl_.high_pass_filter_enabled_){false}
    , decltype(_impl_.noise_suppression_enabled_){false}
  };
}

NewApmRequest::~NewApmRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewApmRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewApmRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NewApmRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewApmRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewApmRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.echo_canceller_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.noise_suppression_enabled_) -
      reinterpret_cast<char*>(&_impl_.echo_canceller_enabled_)) + sizeof(_impl_.noise_suppression_enabled_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewApmRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool echo_canceller_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_echo_canceller_enabled(&has_bits);
          _impl_.echo_canceller_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool gain_controller_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_gain_controller_enabled(&has_bits);
          _impl_.gain_controller_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool high_pass_filter_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_high_pass_filter_enabled(&has_bits);
          _impl_.high_pass_filter_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool noise_suppression_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_noise_suppression_enabled(&has_bits);
          _impl_.noise_suppression_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewApmRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewApmRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool echo_canceller_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_echo_canceller_enabled(), target);
  }

  // required bool gain_controller_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_gain_controller_enabled(), target);
  }

  // required bool high_pass_filter_enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_high_pass_filter_enabled(), target);
  }

  // required bool noise_suppression_enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_noise_suppression_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewApmRequest)
  return target;
}

size_t NewApmRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewApmRequest)
  size_t total_size = 0;

  if (_internal_has_echo_canceller_enabled()) {
    // required bool echo_canceller_enabled = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_gain_controller_enabled()) {
    // required bool gain_controller_enabled = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_high_pass_filter_enabled()) {
    // required bool high_pass_filter_enabled = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_noise_suppression_enabled()) {
    // required bool noise_suppression_enabled = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t NewApmRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewApmRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bool echo_canceller_enabled = 1;
    total_size += 1 + 1;

    // required bool gain_controller_enabled = 2;
    total_size += 1 + 1;

    // required bool high_pass_filter_enabled = 3;
    total_size += 1 + 1;

    // required bool noise_suppression_enabled = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewApmRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewApmRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewApmRequest::GetClassData() const { return &_class_data_; }


void NewApmRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewApmRequest*>(&to_msg);
  auto& from = static_cast<const NewApmRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewApmRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.echo_canceller_enabled_ = from._impl_.echo_canceller_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gain_controller_enabled_ = from._impl_.gain_controller_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.high_pass_filter_enabled_ = from._impl_.high_pass_filter_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.noise_suppression_enabled_ = from._impl_.noise_suppression_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewApmRequest::CopyFrom(const NewApmRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewApmRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewApmRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NewApmRequest::InternalSwap(NewApmRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewApmRequest, _impl_.noise_suppression_enabled_)
      + sizeof(NewApmRequest::_impl_.noise_suppression_enabled_)
      - PROTOBUF_FIELD_OFFSET(NewApmRequest, _impl_.echo_canceller_enabled_)>(
          reinterpret_cast<char*>(&_impl_.echo_canceller_enabled_),
          reinterpret_cast<char*>(&other->_impl_.echo_canceller_enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewApmRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[15]);
}

// ===================================================================

class NewApmResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<NewApmResponse>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedApm& apm(const NewApmResponse* msg);
  static void set_has_apm(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedApm&
NewApmResponse::_Internal::apm(const NewApmResponse* msg) {
  return *msg->_impl_.apm_;
}
NewApmResponse::NewApmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewApmResponse)
}
NewApmResponse::NewApmResponse(const NewApmResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewApmResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_apm()) {
    _this->_impl_.apm_ = new ::livekit::proto::OwnedApm(*from._impl_.apm_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewApmResponse)
}

inline void NewApmResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_){nullptr}
  };
}

NewApmResponse::~NewApmResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewApmResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewApmResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.apm_;
}

void NewApmResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewApmResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewApmResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.apm_ != nullptr);
    _impl_.apm_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewApmResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedApm apm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_apm(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewApmResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewApmResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedApm apm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::apm(this),
        _Internal::apm(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewApmResponse)
  return target;
}

size_t NewApmResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewApmResponse)
  size_t total_size = 0;

  // required .livekit.proto.OwnedApm apm = 1;
  if (_internal_has_apm()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.apm_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewApmResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewApmResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewApmResponse::GetClassData() const { return &_class_data_; }


void NewApmResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewApmResponse*>(&to_msg);
  auto& from = static_cast<const NewApmResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewApmResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_apm()) {
    _this->_internal_mutable_apm()->::livekit::proto::OwnedApm::MergeFrom(
        from._internal_apm());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewApmResponse::CopyFrom(const NewApmResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewApmResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewApmResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_apm()) {
    if (!_impl_.apm_->IsInitialized()) return false;
  }
  return true;
}

void NewApmResponse::InternalSwap(NewApmResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.apm_, other->_impl_.apm_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewApmResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[16]);
}

// ===================================================================

class ApmProcessStreamRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ApmProcessStreamRequest>()._impl_._has_bits_);
  static void set_has_apm_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

ApmProcessStreamRequest::ApmProcessStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ApmProcessStreamRequest)
}
ApmProcessStreamRequest::ApmProcessStreamRequest(const ApmProcessStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApmProcessStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_handle_){}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.num_channels_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.apm_handle_, &from._impl_.apm_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_channels_) -
    reinterpret_cast<char*>(&_impl_.apm_handle_)) + sizeof(_impl_.num_channels_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ApmProcessStreamRequest)
}

inline void ApmProcessStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_handle_){uint64_t{0u}}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.num_channels_){0u}
  };
}

ApmProcessStreamRequest::~ApmProcessStreamRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.ApmProcessStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApmProcessStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ApmProcessStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApmProcessStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.ApmProcessStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.apm_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_channels_) -
        reinterpret_cast<char*>(&_impl_.apm_handle_)) + sizeof(_impl_.num_channels_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApmProcessStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 apm_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_apm_handle(&has_bits);
          _impl_.apm_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 data_ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sample_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApmProcessStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.ApmProcessStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 apm_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_apm_handle(), target);
  }

  // required uint64 data_ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_data_ptr(), target);
  }

  // required uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_size(), target);
  }

  // required uint32 sample_rate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sample_rate(), target);
  }

  // required uint32 num_channels = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_num_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.ApmProcessStreamRequest)
  return target;
}

size_t ApmProcessStreamRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.ApmProcessStreamRequest)
  size_t total_size = 0;

  if (_internal_has_apm_handle()) {
    // required uint64 apm_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_apm_handle());
  }

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_size()) {
    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  if (_internal_has_sample_rate()) {
    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  return total_size;
}
size_t ApmProcessStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.ApmProcessStreamRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint64 apm_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_apm_handle());

    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());

    // required uint32 num_channels = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApmProcessStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApmProcessStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApmProcessStreamRequest::GetClassData() const { return &_class_data_; }


void ApmProcessStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApmProcessStreamRequest*>(&to_msg);
  auto& from = static_cast<const ApmProcessStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.ApmProcessStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.apm_handle_ = from._impl_.apm_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApmProcessStreamRequest::CopyFrom(const ApmProcessStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.ApmProcessStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApmProcessStreamRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ApmProcessStreamRequest::InternalSwap(ApmProcessStreamRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApmProcessStreamRequest, _impl_.num_channels_)
      + sizeof(ApmProcessStreamRequest::_impl_.num_channels_)
      - PROTOBUF_FIELD_OFFSET(ApmProcessStreamRequest, _impl_.apm_handle_)>(
          reinterpret_cast<char*>(&_impl_.apm_handle_),
          reinterpret_cast<char*>(&other->_impl_.apm_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApmProcessStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[17]);
}

// ===================================================================

class ApmProcessStreamResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ApmProcessStreamResponse>()._impl_._has_bits_);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ApmProcessStreamResponse::ApmProcessStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ApmProcessStreamResponse)
}
ApmProcessStreamResponse::ApmProcessStreamResponse(const ApmProcessStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApmProcessStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ApmProcessStreamResponse)
}

inline void ApmProcessStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApmProcessStreamResponse::~ApmProcessStreamResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.ApmProcessStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApmProcessStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void ApmProcessStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApmProcessStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.ApmProcessStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApmProcessStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.ApmProcessStreamResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApmProcessStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.ApmProcessStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string error = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.ApmProcessStreamResponse.error");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.ApmProcessStreamResponse)
  return target;
}

size_t ApmProcessStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.ApmProcessStreamResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApmProcessStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApmProcessStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApmProcessStreamResponse::GetClassData() const { return &_class_data_; }


void ApmProcessStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApmProcessStreamResponse*>(&to_msg);
  auto& from = static_cast<const ApmProcessStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.ApmProcessStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error()) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApmProcessStreamResponse::CopyFrom(const ApmProcessStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.ApmProcessStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApmProcessStreamResponse::IsInitialized() const {
  return true;
}

void ApmProcessStreamResponse::InternalSwap(ApmProcessStreamResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ApmProcessStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[18]);
}

// ===================================================================

class ApmProcessReverseStreamRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ApmProcessReverseStreamRequest>()._impl_._has_bits_);
  static void set_has_apm_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

ApmProcessReverseStreamRequest::ApmProcessReverseStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ApmProcessReverseStreamRequest)
}
ApmProcessReverseStreamRequest::ApmProcessReverseStreamRequest(const ApmProcessReverseStreamRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApmProcessReverseStreamRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_handle_){}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.num_channels_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.apm_handle_, &from._impl_.apm_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_channels_) -
    reinterpret_cast<char*>(&_impl_.apm_handle_)) + sizeof(_impl_.num_channels_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ApmProcessReverseStreamRequest)
}

inline void ApmProcessReverseStreamRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.apm_handle_){uint64_t{0u}}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.num_channels_){0u}
  };
}

ApmProcessReverseStreamRequest::~ApmProcessReverseStreamRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.ApmProcessReverseStreamRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApmProcessReverseStreamRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ApmProcessReverseStreamRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApmProcessReverseStreamRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.ApmProcessReverseStreamRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.apm_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_channels_) -
        reinterpret_cast<char*>(&_impl_.apm_handle_)) + sizeof(_impl_.num_channels_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApmProcessReverseStreamRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 apm_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_apm_handle(&has_bits);
          _impl_.apm_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 data_ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sample_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApmProcessReverseStreamRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.ApmProcessReverseStreamRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 apm_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_apm_handle(), target);
  }

  // required uint64 data_ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_data_ptr(), target);
  }

  // required uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_size(), target);
  }

  // required uint32 sample_rate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sample_rate(), target);
  }

  // required uint32 num_channels = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_num_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.ApmProcessReverseStreamRequest)
  return target;
}

size_t ApmProcessReverseStreamRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.ApmProcessReverseStreamRequest)
  size_t total_size = 0;

  if (_internal_has_apm_handle()) {
    // required uint64 apm_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_apm_handle());
  }

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_size()) {
    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  if (_internal_has_sample_rate()) {
    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  return total_size;
}
size_t ApmProcessReverseStreamRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.ApmProcessReverseStreamRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required uint64 apm_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_apm_handle());

    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

    // required uint32 sample_rate = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());

    // required uint32 num_channels = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApmProcessReverseStreamRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApmProcessReverseStreamRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApmProcessReverseStreamRequest::GetClassData() const { return &_class_data_; }


void ApmProcessReverseStreamRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApmProcessReverseStreamRequest*>(&to_msg);
  auto& from = static_cast<const ApmProcessReverseStreamRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.ApmProcessReverseStreamRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.apm_handle_ = from._impl_.apm_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApmProcessReverseStreamRequest::CopyFrom(const ApmProcessReverseStreamRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.ApmProcessReverseStreamRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApmProcessReverseStreamRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ApmProcessReverseStreamRequest::InternalSwap(ApmProcessReverseStreamRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApmProcessReverseStreamRequest, _impl_.num_channels_)
      + sizeof(ApmProcessReverseStreamRequest::_impl_.num_channels_)
      - PROTOBUF_FIELD_OFFSET(ApmProcessReverseStreamRequest, _impl_.apm_handle_)>(
          reinterpret_cast<char*>(&_impl_.apm_handle_),
          reinterpret_cast<char*>(&other->_impl_.apm_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApmProcessReverseStreamRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[19]);
}

// ===================================================================

class ApmProcessReverseStreamResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ApmProcessReverseStreamResponse>()._impl_._has_bits_);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ApmProcessReverseStreamResponse::ApmProcessReverseStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.ApmProcessReverseStreamResponse)
}
ApmProcessReverseStreamResponse::ApmProcessReverseStreamResponse(const ApmProcessReverseStreamResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApmProcessReverseStreamResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.ApmProcessReverseStreamResponse)
}

inline void ApmProcessReverseStreamResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApmProcessReverseStreamResponse::~ApmProcessReverseStreamResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.ApmProcessReverseStreamResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApmProcessReverseStreamResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void ApmProcessReverseStreamResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApmProcessReverseStreamResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.ApmProcessReverseStreamResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApmProcessReverseStreamResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.ApmProcessReverseStreamResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApmProcessReverseStreamResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.ApmProcessReverseStreamResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string error = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.ApmProcessReverseStreamResponse.error");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.ApmProcessReverseStreamResponse)
  return target;
}

size_t ApmProcessReverseStreamResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.ApmProcessReverseStreamResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApmProcessReverseStreamResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApmProcessReverseStreamResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApmProcessReverseStreamResponse::GetClassData() const { return &_class_data_; }


void ApmProcessReverseStreamResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApmProcessReverseStreamResponse*>(&to_msg);
  auto& from = static_cast<const ApmProcessReverseStreamResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.ApmProcessReverseStreamResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error()) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApmProcessReverseStreamResponse::CopyFrom(const ApmProcessReverseStreamResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.ApmProcessReverseStreamResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApmProcessReverseStreamResponse::IsInitialized() const {
  return true;
}

void ApmProcessReverseStreamResponse::InternalSwap(ApmProcessReverseStreamResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ApmProcessReverseStreamResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[20]);
}

// ===================================================================

class NewSoxResamplerRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<NewSoxResamplerRequest>()._impl_._has_bits_);
  static void set_has_input_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_output_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_input_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_output_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_quality_recipe(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

NewSoxResamplerRequest::NewSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewSoxResamplerRequest)
}
NewSoxResamplerRequest::NewSoxResamplerRequest(const NewSoxResamplerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewSoxResamplerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_rate_){}
    , decltype(_impl_.output_rate_){}
    , decltype(_impl_.num_channels_){}
    , decltype(_impl_.input_data_type_){}
    , decltype(_impl_.output_data_type_){}
    , decltype(_impl_.quality_recipe_){}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.input_rate_, &from._impl_.input_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.input_rate_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewSoxResamplerRequest)
}

inline void NewSoxResamplerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.input_rate_){0}
    , decltype(_impl_.output_rate_){0}
    , decltype(_impl_.num_channels_){0u}
    , decltype(_impl_.input_data_type_){0}
    , decltype(_impl_.output_data_type_){0}
    , decltype(_impl_.quality_recipe_){0}
    , decltype(_impl_.flags_){0u}
  };
}

NewSoxResamplerRequest::~NewSoxResamplerRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewSoxResamplerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewSoxResamplerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NewSoxResamplerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewSoxResamplerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.input_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.input_rate_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewSoxResamplerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required double input_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_input_rate(&has_bits);
          _impl_.input_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double output_rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_output_rate(&has_bits);
          _impl_.output_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.SoxResamplerDataType input_data_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::SoxResamplerDataType_IsValid(val))) {
            _internal_set_input_data_type(static_cast<::livekit::proto::SoxResamplerDataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.SoxResamplerDataType output_data_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::SoxResamplerDataType_IsValid(val))) {
            _internal_set_output_data_type(static_cast<::livekit::proto::SoxResamplerDataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::SoxQualityRecipe_IsValid(val))) {
            _internal_set_quality_recipe(static_cast<::livekit::proto::SoxQualityRecipe>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewSoxResamplerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required double input_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_input_rate(), target);
  }

  // required double output_rate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_output_rate(), target);
  }

  // required uint32 num_channels = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_channels(), target);
  }

  // required .livekit.proto.SoxResamplerDataType input_data_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_input_data_type(), target);
  }

  // required .livekit.proto.SoxResamplerDataType output_data_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_output_data_type(), target);
  }

  // required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_quality_recipe(), target);
  }

  // optional uint32 flags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewSoxResamplerRequest)
  return target;
}

size_t NewSoxResamplerRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.NewSoxResamplerRequest)
  size_t total_size = 0;

  if (_internal_has_input_rate()) {
    // required double input_rate = 1;
    total_size += 1 + 8;
  }

  if (_internal_has_output_rate()) {
    // required double output_rate = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  if (_internal_has_input_data_type()) {
    // required .livekit.proto.SoxResamplerDataType input_data_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_input_data_type());
  }

  if (_internal_has_output_data_type()) {
    // required .livekit.proto.SoxResamplerDataType output_data_type = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_output_data_type());
  }

  if (_internal_has_quality_recipe()) {
    // required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_quality_recipe());
  }

  return total_size;
}
size_t NewSoxResamplerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewSoxResamplerRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required double input_rate = 1;
    total_size += 1 + 8;

    // required double output_rate = 2;
    total_size += 1 + 8;

    // required uint32 num_channels = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

    // required .livekit.proto.SoxResamplerDataType input_data_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_input_data_type());

    // required .livekit.proto.SoxResamplerDataType output_data_type = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_output_data_type());

    // required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_quality_recipe());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 flags = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000040u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewSoxResamplerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewSoxResamplerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewSoxResamplerRequest::GetClassData() const { return &_class_data_; }


void NewSoxResamplerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewSoxResamplerRequest*>(&to_msg);
  auto& from = static_cast<const NewSoxResamplerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewSoxResamplerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.input_rate_ = from._impl_.input_rate_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.output_rate_ = from._impl_.output_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.input_data_type_ = from._impl_.input_data_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.output_data_type_ = from._impl_.output_data_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.quality_recipe_ = from._impl_.quality_recipe_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewSoxResamplerRequest::CopyFrom(const NewSoxResamplerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewSoxResamplerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewSoxResamplerRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void NewSoxResamplerRequest::InternalSwap(NewSoxResamplerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NewSoxResamplerRequest, _impl_.flags_)
      + sizeof(NewSoxResamplerRequest::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(NewSoxResamplerRequest, _impl_.input_rate_)>(
          reinterpret_cast<char*>(&_impl_.input_rate_),
          reinterpret_cast<char*>(&other->_impl_.input_rate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NewSoxResamplerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[21]);
}

// ===================================================================

class NewSoxResamplerResponse::_Internal {
 public:
  static const ::livekit::proto::OwnedSoxResampler& resampler(const NewSoxResamplerResponse* msg);
};

const ::livekit::proto::OwnedSoxResampler&
NewSoxResamplerResponse::_Internal::resampler(const NewSoxResamplerResponse* msg) {
  return *msg->_impl_.message_.resampler_;
}
void NewSoxResamplerResponse::set_allocated_resampler(::livekit::proto::OwnedSoxResampler* resampler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (resampler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resampler);
    if (message_arena != submessage_arena) {
      resampler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resampler, submessage_arena);
    }
    set_has_resampler();
    _impl_.message_.resampler_ = resampler;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewSoxResamplerResponse.resampler)
}
NewSoxResamplerResponse::NewSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.NewSoxResamplerResponse)
}
NewSoxResamplerResponse::NewSoxResamplerResponse(const NewSoxResamplerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NewSoxResamplerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kResampler: {
      _this->_internal_mutable_resampler()->::livekit::proto::OwnedSoxResampler::MergeFrom(
          from._internal_resampler());
      break;
    }
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.NewSoxResamplerResponse)
}

inline void NewSoxResamplerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

NewSoxResamplerResponse::~NewSoxResamplerResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.NewSoxResamplerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NewSoxResamplerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void NewSoxResamplerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NewSoxResamplerResponse::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.NewSoxResamplerResponse)
  switch (message_case()) {
    case kResampler: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.resampler_;
      }
      break;
    }
    case kError: {
      _impl_.message_.error_.Destroy();
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void NewSoxResamplerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.NewSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NewSoxResamplerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.proto.OwnedSoxResampler resampler = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_resampler(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.NewSoxResamplerResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NewSoxResamplerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.NewSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (message_case()) {
    case kResampler: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::resampler(this),
          _Internal::resampler(this).GetCachedSize(), target, stream);
      break;
    }
    case kError: {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "livekit.proto.NewSoxResamplerResponse.error");
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_error(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.NewSoxResamplerResponse)
  return target;
}

size_t NewSoxResamplerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.NewSoxResamplerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .livekit.proto.OwnedSoxResampler resampler = 1;
    case kResampler: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.resampler_);
      break;
    }
    // string error = 2;
    case kError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NewSoxResamplerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NewSoxResamplerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NewSoxResamplerResponse::GetClassData() const { return &_class_data_; }


void NewSoxResamplerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NewSoxResamplerResponse*>(&to_msg);
  auto& from = static_cast<const NewSoxResamplerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.NewSoxResamplerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kResampler: {
      _this->_internal_mutable_resampler()->::livekit::proto::OwnedSoxResampler::MergeFrom(
          from._internal_resampler());
      break;
    }
    case kError: {
      _this->_internal_set_error(from._internal_error());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NewSoxResamplerResponse::CopyFrom(const NewSoxResamplerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.NewSoxResamplerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewSoxResamplerResponse::IsInitialized() const {
  switch (message_case()) {
    case kResampler: {
      if (_internal_has_resampler()) {
        if (!_impl_.message_.resampler_->IsInitialized()) return false;
      }
      break;
    }
    case kError: {
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void NewSoxResamplerResponse::InternalSwap(NewSoxResamplerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata NewSoxResamplerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[22]);
}

// ===================================================================

class PushSoxResamplerRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<PushSoxResamplerRequest>()._impl_._has_bits_);
  static void set_has_resampler_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

PushSoxResamplerRequest::PushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.PushSoxResamplerRequest)
}
PushSoxResamplerRequest::PushSoxResamplerRequest(const PushSoxResamplerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PushSoxResamplerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_handle_){}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.resampler_handle_, &from._impl_.resampler_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.resampler_handle_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.PushSoxResamplerRequest)
}

inline void PushSoxResamplerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_handle_){uint64_t{0u}}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
  };
}

PushSoxResamplerRequest::~PushSoxResamplerRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.PushSoxResamplerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PushSoxResamplerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PushSoxResamplerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PushSoxResamplerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.PushSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.resampler_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.resampler_handle_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PushSoxResamplerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 resampler_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_resampler_handle(&has_bits);
          _impl_.resampler_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 data_ptr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushSoxResamplerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.PushSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 resampler_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_resampler_handle(), target);
  }

  // required uint64 data_ptr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_data_ptr(), target);
  }

  // required uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.PushSoxResamplerRequest)
  return target;
}

size_t PushSoxResamplerRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.PushSoxResamplerRequest)
  size_t total_size = 0;

  if (_internal_has_resampler_handle()) {
    // required uint64 resampler_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resampler_handle());
  }

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_size()) {
    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return total_size;
}
size_t PushSoxResamplerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.PushSoxResamplerRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint64 resampler_handle = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resampler_handle());

    // required uint64 data_ptr = 2;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 size = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PushSoxResamplerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PushSoxResamplerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PushSoxResamplerRequest::GetClassData() const { return &_class_data_; }


void PushSoxResamplerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PushSoxResamplerRequest*>(&to_msg);
  auto& from = static_cast<const PushSoxResamplerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.PushSoxResamplerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.resampler_handle_ = from._impl_.resampler_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PushSoxResamplerRequest::CopyFrom(const PushSoxResamplerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.PushSoxResamplerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushSoxResamplerRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PushSoxResamplerRequest::InternalSwap(PushSoxResamplerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PushSoxResamplerRequest, _impl_.size_)
      + sizeof(PushSoxResamplerRequest::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(PushSoxResamplerRequest, _impl_.resampler_handle_)>(
          reinterpret_cast<char*>(&_impl_.resampler_handle_),
          reinterpret_cast<char*>(&other->_impl_.resampler_handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PushSoxResamplerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[23]);
}

// ===================================================================

class PushSoxResamplerResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<PushSoxResamplerResponse>()._impl_._has_bits_);
  static void set_has_output_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

PushSoxResamplerResponse::PushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.PushSoxResamplerResponse)
}
PushSoxResamplerResponse::PushSoxResamplerResponse(const PushSoxResamplerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PushSoxResamplerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.output_ptr_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.output_ptr_, &from._impl_.output_ptr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.output_ptr_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.PushSoxResamplerResponse)
}

inline void PushSoxResamplerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.output_ptr_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PushSoxResamplerResponse::~PushSoxResamplerResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.PushSoxResamplerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PushSoxResamplerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void PushSoxResamplerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PushSoxResamplerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.PushSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.output_ptr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.output_ptr_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PushSoxResamplerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 output_ptr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_output_ptr(&has_bits);
          _impl_.output_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.PushSoxResamplerResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushSoxResamplerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.PushSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 output_ptr = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_output_ptr(), target);
  }

  // required uint32 size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  // optional string error = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.PushSoxResamplerResponse.error");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.PushSoxResamplerResponse)
  return target;
}

size_t PushSoxResamplerResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.PushSoxResamplerResponse)
  size_t total_size = 0;

  if (_internal_has_output_ptr()) {
    // required uint64 output_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_output_ptr());
  }

  if (_internal_has_size()) {
    // required uint32 size = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return total_size;
}
size_t PushSoxResamplerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.PushSoxResamplerResponse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 output_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_output_ptr());

    // required uint32 size = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PushSoxResamplerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PushSoxResamplerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PushSoxResamplerResponse::GetClassData() const { return &_class_data_; }


void PushSoxResamplerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PushSoxResamplerResponse*>(&to_msg);
  auto& from = static_cast<const PushSoxResamplerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.PushSoxResamplerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.output_ptr_ = from._impl_.output_ptr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PushSoxResamplerResponse::CopyFrom(const PushSoxResamplerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.PushSoxResamplerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushSoxResamplerResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PushSoxResamplerResponse::InternalSwap(PushSoxResamplerResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PushSoxResamplerResponse, _impl_.size_)
      + sizeof(PushSoxResamplerResponse::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(PushSoxResamplerResponse, _impl_.output_ptr_)>(
          reinterpret_cast<char*>(&_impl_.output_ptr_),
          reinterpret_cast<char*>(&other->_impl_.output_ptr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PushSoxResamplerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[24]);
}

// ===================================================================

class FlushSoxResamplerRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FlushSoxResamplerRequest>()._impl_._has_bits_);
  static void set_has_resampler_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FlushSoxResamplerRequest::FlushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FlushSoxResamplerRequest)
}
FlushSoxResamplerRequest::FlushSoxResamplerRequest(const FlushSoxResamplerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushSoxResamplerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_handle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.resampler_handle_ = from._impl_.resampler_handle_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FlushSoxResamplerRequest)
}

inline void FlushSoxResamplerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.resampler_handle_){uint64_t{0u}}
  };
}

FlushSoxResamplerRequest::~FlushSoxResamplerRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.FlushSoxResamplerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushSoxResamplerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlushSoxResamplerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushSoxResamplerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.FlushSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.resampler_handle_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushSoxResamplerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 resampler_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_resampler_handle(&has_bits);
          _impl_.resampler_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushSoxResamplerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.FlushSoxResamplerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 resampler_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_resampler_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.FlushSoxResamplerRequest)
  return target;
}

size_t FlushSoxResamplerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.FlushSoxResamplerRequest)
  size_t total_size = 0;

  // required uint64 resampler_handle = 1;
  if (_internal_has_resampler_handle()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resampler_handle());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushSoxResamplerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushSoxResamplerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushSoxResamplerRequest::GetClassData() const { return &_class_data_; }


void FlushSoxResamplerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushSoxResamplerRequest*>(&to_msg);
  auto& from = static_cast<const FlushSoxResamplerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.FlushSoxResamplerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_resampler_handle()) {
    _this->_internal_set_resampler_handle(from._internal_resampler_handle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushSoxResamplerRequest::CopyFrom(const FlushSoxResamplerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.FlushSoxResamplerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushSoxResamplerRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FlushSoxResamplerRequest::InternalSwap(FlushSoxResamplerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.resampler_handle_, other->_impl_.resampler_handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushSoxResamplerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[25]);
}

// ===================================================================

class FlushSoxResamplerResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FlushSoxResamplerResponse>()._impl_._has_bits_);
  static void set_has_output_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

FlushSoxResamplerResponse::FlushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FlushSoxResamplerResponse)
}
FlushSoxResamplerResponse::FlushSoxResamplerResponse(const FlushSoxResamplerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushSoxResamplerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.output_ptr_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.output_ptr_, &from._impl_.output_ptr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.output_ptr_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FlushSoxResamplerResponse)
}

inline void FlushSoxResamplerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
    , decltype(_impl_.output_ptr_){uint64_t{0u}}
    , decltype(_impl_.size_){0u}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlushSoxResamplerResponse::~FlushSoxResamplerResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.FlushSoxResamplerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushSoxResamplerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void FlushSoxResamplerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushSoxResamplerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.FlushSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.output_ptr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.output_ptr_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushSoxResamplerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 output_ptr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_output_ptr(&has_bits);
          _impl_.output_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FlushSoxResamplerResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushSoxResamplerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.FlushSoxResamplerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 output_ptr = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_output_ptr(), target);
  }

  // required uint32 size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_size(), target);
  }

  // optional string error = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FlushSoxResamplerResponse.error");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.FlushSoxResamplerResponse)
  return target;
}

size_t FlushSoxResamplerResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.FlushSoxResamplerResponse)
  size_t total_size = 0;

  if (_internal_has_output_ptr()) {
    // required uint64 output_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_output_ptr());
  }

  if (_internal_has_size()) {
    // required uint32 size = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());
  }

  return total_size;
}
size_t FlushSoxResamplerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.FlushSoxResamplerResponse)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 output_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_output_ptr());

    // required uint32 size = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushSoxResamplerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushSoxResamplerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushSoxResamplerResponse::GetClassData() const { return &_class_data_; }


void FlushSoxResamplerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushSoxResamplerResponse*>(&to_msg);
  auto& from = static_cast<const FlushSoxResamplerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.FlushSoxResamplerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.output_ptr_ = from._impl_.output_ptr_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushSoxResamplerResponse::CopyFrom(const FlushSoxResamplerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.FlushSoxResamplerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushSoxResamplerResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FlushSoxResamplerResponse::InternalSwap(FlushSoxResamplerResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlushSoxResamplerResponse, _impl_.size_)
      + sizeof(FlushSoxResamplerResponse::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(FlushSoxResamplerResponse, _impl_.output_ptr_)>(
          reinterpret_cast<char*>(&_impl_.output_ptr_),
          reinterpret_cast<char*>(&other->_impl_.output_ptr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushSoxResamplerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[26]);
}

// ===================================================================

class AudioFrameBufferInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioFrameBufferInfo>()._impl_._has_bits_);
  static void set_has_data_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_samples_per_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

AudioFrameBufferInfo::AudioFrameBufferInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioFrameBufferInfo)
}
AudioFrameBufferInfo::AudioFrameBufferInfo(const AudioFrameBufferInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioFrameBufferInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_ptr_){}
    , decltype(_impl_.num_channels_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.samples_per_channel_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.data_ptr_, &from._impl_.data_ptr_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.samples_per_channel_) -
    reinterpret_cast<char*>(&_impl_.data_ptr_)) + sizeof(_impl_.samples_per_channel_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioFrameBufferInfo)
}

inline void AudioFrameBufferInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_ptr_){uint64_t{0u}}
    , decltype(_impl_.num_channels_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.samples_per_channel_){0u}
  };
}

AudioFrameBufferInfo::~AudioFrameBufferInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioFrameBufferInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioFrameBufferInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioFrameBufferInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioFrameBufferInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioFrameBufferInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.data_ptr_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.samples_per_channel_) -
        reinterpret_cast<char*>(&_impl_.data_ptr_)) + sizeof(_impl_.samples_per_channel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioFrameBufferInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 data_ptr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_data_ptr(&has_bits);
          _impl_.data_ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 num_channels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_channels(&has_bits);
          _impl_.num_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sample_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 samples_per_channel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_samples_per_channel(&has_bits);
          _impl_.samples_per_channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioFrameBufferInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioFrameBufferInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 data_ptr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_data_ptr(), target);
  }

  // required uint32 num_channels = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_channels(), target);
  }

  // required uint32 sample_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sample_rate(), target);
  }

  // required uint32 samples_per_channel = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_samples_per_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioFrameBufferInfo)
  return target;
}

size_t AudioFrameBufferInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.AudioFrameBufferInfo)
  size_t total_size = 0;

  if (_internal_has_data_ptr()) {
    // required uint64 data_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());
  }

  if (_internal_has_num_channels()) {
    // required uint32 num_channels = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());
  }

  if (_internal_has_sample_rate()) {
    // required uint32 sample_rate = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  if (_internal_has_samples_per_channel()) {
    // required uint32 samples_per_channel = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_samples_per_channel());
  }

  return total_size;
}
size_t AudioFrameBufferInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioFrameBufferInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint64 data_ptr = 1;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_data_ptr());

    // required uint32 num_channels = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_channels());

    // required uint32 sample_rate = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());

    // required uint32 samples_per_channel = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_samples_per_channel());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioFrameBufferInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioFrameBufferInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioFrameBufferInfo::GetClassData() const { return &_class_data_; }


void AudioFrameBufferInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioFrameBufferInfo*>(&to_msg);
  auto& from = static_cast<const AudioFrameBufferInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioFrameBufferInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.data_ptr_ = from._impl_.data_ptr_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.samples_per_channel_ = from._impl_.samples_per_channel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioFrameBufferInfo::CopyFrom(const AudioFrameBufferInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioFrameBufferInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioFrameBufferInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AudioFrameBufferInfo::InternalSwap(AudioFrameBufferInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioFrameBufferInfo, _impl_.samples_per_channel_)
      + sizeof(AudioFrameBufferInfo::_impl_.samples_per_channel_)
      - PROTOBUF_FIELD_OFFSET(AudioFrameBufferInfo, _impl_.data_ptr_)>(
          reinterpret_cast<char*>(&_impl_.data_ptr_),
          reinterpret_cast<char*>(&other->_impl_.data_ptr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioFrameBufferInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[27]);
}

// ===================================================================

class OwnedAudioFrameBuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedAudioFrameBuffer>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedAudioFrameBuffer* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::AudioFrameBufferInfo& info(const OwnedAudioFrameBuffer* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedAudioFrameBuffer::_Internal::handle(const OwnedAudioFrameBuffer* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::AudioFrameBufferInfo&
OwnedAudioFrameBuffer::_Internal::info(const OwnedAudioFrameBuffer* msg) {
  return *msg->_impl_.info_;
}
void OwnedAudioFrameBuffer::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedAudioFrameBuffer::OwnedAudioFrameBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedAudioFrameBuffer)
}
OwnedAudioFrameBuffer::OwnedAudioFrameBuffer(const OwnedAudioFrameBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedAudioFrameBuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::AudioFrameBufferInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedAudioFrameBuffer)
}

inline void OwnedAudioFrameBuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedAudioFrameBuffer::~OwnedAudioFrameBuffer() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedAudioFrameBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedAudioFrameBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedAudioFrameBuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedAudioFrameBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedAudioFrameBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedAudioFrameBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioFrameBufferInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedAudioFrameBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedAudioFrameBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.AudioFrameBufferInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedAudioFrameBuffer)
  return target;
}

size_t OwnedAudioFrameBuffer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedAudioFrameBuffer)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.AudioFrameBufferInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedAudioFrameBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedAudioFrameBuffer)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.AudioFrameBufferInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedAudioFrameBuffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedAudioFrameBuffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedAudioFrameBuffer::GetClassData() const { return &_class_data_; }


void OwnedAudioFrameBuffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedAudioFrameBuffer*>(&to_msg);
  auto& from = static_cast<const OwnedAudioFrameBuffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedAudioFrameBuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::AudioFrameBufferInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedAudioFrameBuffer::CopyFrom(const OwnedAudioFrameBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedAudioFrameBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedAudioFrameBuffer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedAudioFrameBuffer::InternalSwap(OwnedAudioFrameBuffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedAudioFrameBuffer, _impl_.info_)
      + sizeof(OwnedAudioFrameBuffer::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedAudioFrameBuffer, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedAudioFrameBuffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[28]);
}

// ===================================================================

class AudioStreamInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStreamInfo>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AudioStreamInfo::AudioStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioStreamInfo)
}
AudioStreamInfo::AudioStreamInfo(const AudioStreamInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioStreamInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioStreamInfo)
}

inline void AudioStreamInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
  };
}

AudioStreamInfo::~AudioStreamInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioStreamInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioStreamInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioStreamInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioStreamInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioStreamInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioStreamInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.AudioStreamType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::AudioStreamType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::AudioStreamType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioStreamInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioStreamInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.AudioStreamType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioStreamInfo)
  return target;
}

size_t AudioStreamInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioStreamInfo)
  size_t total_size = 0;

  // required .livekit.proto.AudioStreamType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioStreamInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioStreamInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioStreamInfo::GetClassData() const { return &_class_data_; }


void AudioStreamInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioStreamInfo*>(&to_msg);
  auto& from = static_cast<const AudioStreamInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioStreamInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioStreamInfo::CopyFrom(const AudioStreamInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioStreamInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AudioStreamInfo::InternalSwap(AudioStreamInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioStreamInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[29]);
}

// ===================================================================

class OwnedAudioStream::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedAudioStream>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedAudioStream* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::AudioStreamInfo& info(const OwnedAudioStream* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedAudioStream::_Internal::handle(const OwnedAudioStream* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::AudioStreamInfo&
OwnedAudioStream::_Internal::info(const OwnedAudioStream* msg) {
  return *msg->_impl_.info_;
}
void OwnedAudioStream::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedAudioStream::OwnedAudioStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedAudioStream)
}
OwnedAudioStream::OwnedAudioStream(const OwnedAudioStream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedAudioStream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::AudioStreamInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedAudioStream)
}

inline void OwnedAudioStream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedAudioStream::~OwnedAudioStream() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedAudioStream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedAudioStream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedAudioStream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedAudioStream::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedAudioStream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedAudioStream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioStreamInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedAudioStream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedAudioStream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.AudioStreamInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedAudioStream)
  return target;
}

size_t OwnedAudioStream::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedAudioStream)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.AudioStreamInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedAudioStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedAudioStream)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.AudioStreamInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedAudioStream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedAudioStream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedAudioStream::GetClassData() const { return &_class_data_; }


void OwnedAudioStream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedAudioStream*>(&to_msg);
  auto& from = static_cast<const OwnedAudioStream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedAudioStream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::AudioStreamInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedAudioStream::CopyFrom(const OwnedAudioStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedAudioStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedAudioStream::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedAudioStream::InternalSwap(OwnedAudioStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedAudioStream, _impl_.info_)
      + sizeof(OwnedAudioStream::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedAudioStream, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedAudioStream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[30]);
}

// ===================================================================

class AudioStreamEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioStreamEvent>()._impl_._has_bits_);
  static void set_has_stream_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::AudioFrameReceived& frame_received(const AudioStreamEvent* msg);
  static const ::livekit::proto::AudioStreamEOS& eos(const AudioStreamEvent* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::AudioFrameReceived&
AudioStreamEvent::_Internal::frame_received(const AudioStreamEvent* msg) {
  return *msg->_impl_.message_.frame_received_;
}
const ::livekit::proto::AudioStreamEOS&
AudioStreamEvent::_Internal::eos(const AudioStreamEvent* msg) {
  return *msg->_impl_.message_.eos_;
}
void AudioStreamEvent::set_allocated_frame_received(::livekit::proto::AudioFrameReceived* frame_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (frame_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_received);
    if (message_arena != submessage_arena) {
      frame_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_received, submessage_arena);
    }
    set_has_frame_received();
    _impl_.message_.frame_received_ = frame_received;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioStreamEvent.frame_received)
}
void AudioStreamEvent::set_allocated_eos(::livekit::proto::AudioStreamEOS* eos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (eos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eos);
    if (message_arena != submessage_arena) {
      eos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eos, submessage_arena);
    }
    set_has_eos();
    _impl_.message_.eos_ = eos;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioStreamEvent.eos)
}
AudioStreamEvent::AudioStreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioStreamEvent)
}
AudioStreamEvent::AudioStreamEvent(const AudioStreamEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioStreamEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_handle_){}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.stream_handle_ = from._impl_.stream_handle_;
  clear_has_message();
  switch (from.message_case()) {
    case kFrameReceived: {
      _this->_internal_mutable_frame_received()->::livekit::proto::AudioFrameReceived::MergeFrom(
          from._internal_frame_received());
      break;
    }
    case kEos: {
      _this->_internal_mutable_eos()->::livekit::proto::AudioStreamEOS::MergeFrom(
          from._internal_eos());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioStreamEvent)
}

inline void AudioStreamEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stream_handle_){uint64_t{0u}}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

AudioStreamEvent::~AudioStreamEvent() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioStreamEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioStreamEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void AudioStreamEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioStreamEvent::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.AudioStreamEvent)
  switch (message_case()) {
    case kFrameReceived: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.frame_received_;
      }
      break;
    }
    case kEos: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.eos_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void AudioStreamEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioStreamEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stream_handle_ = uint64_t{0u};
  clear_message();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioStreamEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 stream_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_stream_handle(&has_bits);
          _impl_.stream_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.AudioFrameReceived frame_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_received(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.AudioStreamEOS eos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_eos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioStreamEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioStreamEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 stream_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_stream_handle(), target);
  }

  switch (message_case()) {
    case kFrameReceived: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::frame_received(this),
          _Internal::frame_received(this).GetCachedSize(), target, stream);
      break;
    }
    case kEos: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::eos(this),
          _Internal::eos(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioStreamEvent)
  return target;
}

size_t AudioStreamEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioStreamEvent)
  size_t total_size = 0;

  // required uint64 stream_handle = 1;
  if (_internal_has_stream_handle()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_stream_handle());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .livekit.proto.AudioFrameReceived frame_received = 2;
    case kFrameReceived: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.frame_received_);
      break;
    }
    // .livekit.proto.AudioStreamEOS eos = 3;
    case kEos: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.eos_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioStreamEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioStreamEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioStreamEvent::GetClassData() const { return &_class_data_; }


void AudioStreamEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioStreamEvent*>(&to_msg);
  auto& from = static_cast<const AudioStreamEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioStreamEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stream_handle()) {
    _this->_internal_set_stream_handle(from._internal_stream_handle());
  }
  switch (from.message_case()) {
    case kFrameReceived: {
      _this->_internal_mutable_frame_received()->::livekit::proto::AudioFrameReceived::MergeFrom(
          from._internal_frame_received());
      break;
    }
    case kEos: {
      _this->_internal_mutable_eos()->::livekit::proto::AudioStreamEOS::MergeFrom(
          from._internal_eos());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioStreamEvent::CopyFrom(const AudioStreamEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioStreamEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioStreamEvent::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (message_case()) {
    case kFrameReceived: {
      if (_internal_has_frame_received()) {
        if (!_impl_.message_.frame_received_->IsInitialized()) return false;
      }
      break;
    }
    case kEos: {
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void AudioStreamEvent::InternalSwap(AudioStreamEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.stream_handle_, other->_impl_.stream_handle_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioStreamEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[31]);
}

// ===================================================================

class AudioFrameReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioFrameReceived>()._impl_._has_bits_);
  static const ::livekit::proto::OwnedAudioFrameBuffer& frame(const AudioFrameReceived* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::OwnedAudioFrameBuffer&
AudioFrameReceived::_Internal::frame(const AudioFrameReceived* msg) {
  return *msg->_impl_.frame_;
}
AudioFrameReceived::AudioFrameReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioFrameReceived)
}
AudioFrameReceived::AudioFrameReceived(const AudioFrameReceived& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioFrameReceived* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frame_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_frame()) {
    _this->_impl_.frame_ = new ::livekit::proto::OwnedAudioFrameBuffer(*from._impl_.frame_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioFrameReceived)
}

inline void AudioFrameReceived::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.frame_){nullptr}
  };
}

AudioFrameReceived::~AudioFrameReceived() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioFrameReceived)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioFrameReceived::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.frame_;
}

void AudioFrameReceived::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioFrameReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioFrameReceived)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.frame_ != nullptr);
    _impl_.frame_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioFrameReceived::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.OwnedAudioFrameBuffer frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioFrameReceived::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioFrameReceived)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.OwnedAudioFrameBuffer frame = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioFrameReceived)
  return target;
}

size_t AudioFrameReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioFrameReceived)
  size_t total_size = 0;

  // required .livekit.proto.OwnedAudioFrameBuffer frame = 1;
  if (_internal_has_frame()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.frame_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioFrameReceived::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioFrameReceived::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioFrameReceived::GetClassData() const { return &_class_data_; }


void AudioFrameReceived::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioFrameReceived*>(&to_msg);
  auto& from = static_cast<const AudioFrameReceived&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioFrameReceived)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_frame()) {
    _this->_internal_mutable_frame()->::livekit::proto::OwnedAudioFrameBuffer::MergeFrom(
        from._internal_frame());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioFrameReceived::CopyFrom(const AudioFrameReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioFrameReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioFrameReceived::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_frame()) {
    if (!_impl_.frame_->IsInitialized()) return false;
  }
  return true;
}

void AudioFrameReceived::InternalSwap(AudioFrameReceived* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.frame_, other->_impl_.frame_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioFrameReceived::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[32]);
}

// ===================================================================

class AudioStreamEOS::_Internal {
 public:
};

AudioStreamEOS::AudioStreamEOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioStreamEOS)
}
AudioStreamEOS::AudioStreamEOS(const AudioStreamEOS& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AudioStreamEOS* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioStreamEOS)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioStreamEOS::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioStreamEOS::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AudioStreamEOS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[33]);
}

// ===================================================================

class AudioSourceOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioSourceOptions>()._impl_._has_bits_);
  static void set_has_echo_cancellation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_noise_suppression(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auto_gain_control(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AudioSourceOptions::AudioSourceOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioSourceOptions)
}
AudioSourceOptions::AudioSourceOptions(const AudioSourceOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioSourceOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_cancellation_){}
    , decltype(_impl_.noise_suppression_){}
    , decltype(_impl_.auto_gain_control_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.echo_cancellation_, &from._impl_.echo_cancellation_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auto_gain_control_) -
    reinterpret_cast<char*>(&_impl_.echo_cancellation_)) + sizeof(_impl_.auto_gain_control_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioSourceOptions)
}

inline void AudioSourceOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.echo_cancellation_){false}
    , decltype(_impl_.noise_suppression_){false}
    , decltype(_impl_.auto_gain_control_){false}
  };
}

AudioSourceOptions::~AudioSourceOptions() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioSourceOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioSourceOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioSourceOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioSourceOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioSourceOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.echo_cancellation_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.auto_gain_control_) -
      reinterpret_cast<char*>(&_impl_.echo_cancellation_)) + sizeof(_impl_.auto_gain_control_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioSourceOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool echo_cancellation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_echo_cancellation(&has_bits);
          _impl_.echo_cancellation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool noise_suppression = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_noise_suppression(&has_bits);
          _impl_.noise_suppression_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool auto_gain_control = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_auto_gain_control(&has_bits);
          _impl_.auto_gain_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioSourceOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioSourceOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool echo_cancellation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_echo_cancellation(), target);
  }

  // required bool noise_suppression = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_noise_suppression(), target);
  }

  // required bool auto_gain_control = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_auto_gain_control(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioSourceOptions)
  return target;
}

size_t AudioSourceOptions::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.AudioSourceOptions)
  size_t total_size = 0;

  if (_internal_has_echo_cancellation()) {
    // required bool echo_cancellation = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_noise_suppression()) {
    // required bool noise_suppression = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_auto_gain_control()) {
    // required bool auto_gain_control = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t AudioSourceOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioSourceOptions)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bool echo_cancellation = 1;
    total_size += 1 + 1;

    // required bool noise_suppression = 2;
    total_size += 1 + 1;

    // required bool auto_gain_control = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioSourceOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioSourceOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioSourceOptions::GetClassData() const { return &_class_data_; }


void AudioSourceOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioSourceOptions*>(&to_msg);
  auto& from = static_cast<const AudioSourceOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioSourceOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.echo_cancellation_ = from._impl_.echo_cancellation_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.noise_suppression_ = from._impl_.noise_suppression_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auto_gain_control_ = from._impl_.auto_gain_control_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioSourceOptions::CopyFrom(const AudioSourceOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioSourceOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioSourceOptions::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AudioSourceOptions::InternalSwap(AudioSourceOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioSourceOptions, _impl_.auto_gain_control_)
      + sizeof(AudioSourceOptions::_impl_.auto_gain_control_)
      - PROTOBUF_FIELD_OFFSET(AudioSourceOptions, _impl_.echo_cancellation_)>(
          reinterpret_cast<char*>(&_impl_.echo_cancellation_),
          reinterpret_cast<char*>(&other->_impl_.echo_cancellation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioSourceOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[34]);
}

// ===================================================================

class AudioSourceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioSourceInfo>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

AudioSourceInfo::AudioSourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioSourceInfo)
}
AudioSourceInfo::AudioSourceInfo(const AudioSourceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AudioSourceInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioSourceInfo)
}

inline void AudioSourceInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
  };
}

AudioSourceInfo::~AudioSourceInfo() {
  // @@protoc_insertion_point(destructor:livekit.proto.AudioSourceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioSourceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioSourceInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AudioSourceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.AudioSourceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AudioSourceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.AudioSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::AudioSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::livekit::proto::AudioSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioSourceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.AudioSourceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.AudioSourceType type = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.AudioSourceInfo)
  return target;
}

size_t AudioSourceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.AudioSourceInfo)
  size_t total_size = 0;

  // required .livekit.proto.AudioSourceType type = 2;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioSourceInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AudioSourceInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioSourceInfo::GetClassData() const { return &_class_data_; }


void AudioSourceInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AudioSourceInfo*>(&to_msg);
  auto& from = static_cast<const AudioSourceInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.AudioSourceInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AudioSourceInfo::CopyFrom(const AudioSourceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.AudioSourceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioSourceInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void AudioSourceInfo::InternalSwap(AudioSourceInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AudioSourceInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[35]);
}

// ===================================================================

class OwnedAudioSource::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedAudioSource>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedAudioSource* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::AudioSourceInfo& info(const OwnedAudioSource* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedAudioSource::_Internal::handle(const OwnedAudioSource* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::AudioSourceInfo&
OwnedAudioSource::_Internal::info(const OwnedAudioSource* msg) {
  return *msg->_impl_.info_;
}
void OwnedAudioSource::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedAudioSource::OwnedAudioSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedAudioSource)
}
OwnedAudioSource::OwnedAudioSource(const OwnedAudioSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedAudioSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::AudioSourceInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedAudioSource)
}

inline void OwnedAudioSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedAudioSource::~OwnedAudioSource() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedAudioSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedAudioSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedAudioSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedAudioSource::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedAudioSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedAudioSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioSourceInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedAudioSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedAudioSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.AudioSourceInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedAudioSource)
  return target;
}

size_t OwnedAudioSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedAudioSource)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.AudioSourceInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedAudioSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedAudioSource)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.AudioSourceInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedAudioSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedAudioSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedAudioSource::GetClassData() const { return &_class_data_; }


void OwnedAudioSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedAudioSource*>(&to_msg);
  auto& from = static_cast<const OwnedAudioSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedAudioSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::AudioSourceInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedAudioSource::CopyFrom(const OwnedAudioSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedAudioSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedAudioSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void OwnedAudioSource::InternalSwap(OwnedAudioSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedAudioSource, _impl_.info_)
      + sizeof(OwnedAudioSource::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedAudioSource, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedAudioSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[36]);
}

// ===================================================================

class AudioResamplerInfo::_Internal {
 public:
};

AudioResamplerInfo::AudioResamplerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.AudioResamplerInfo)
}
AudioResamplerInfo::AudioResamplerInfo(const AudioResamplerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  AudioResamplerInfo* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.AudioResamplerInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AudioResamplerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AudioResamplerInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata AudioResamplerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[37]);
}

// ===================================================================

class OwnedAudioResampler::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedAudioResampler>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedAudioResampler* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::AudioResamplerInfo& info(const OwnedAudioResampler* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedAudioResampler::_Internal::handle(const OwnedAudioResampler* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::AudioResamplerInfo&
OwnedAudioResampler::_Internal::info(const OwnedAudioResampler* msg) {
  return *msg->_impl_.info_;
}
void OwnedAudioResampler::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedAudioResampler::OwnedAudioResampler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedAudioResampler)
}
OwnedAudioResampler::OwnedAudioResampler(const OwnedAudioResampler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedAudioResampler* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::AudioResamplerInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedAudioResampler)
}

inline void OwnedAudioResampler::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedAudioResampler::~OwnedAudioResampler() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedAudioResampler)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedAudioResampler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedAudioResampler::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedAudioResampler::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedAudioResampler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedAudioResampler::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.AudioResamplerInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedAudioResampler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedAudioResampler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.AudioResamplerInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedAudioResampler)
  return target;
}

size_t OwnedAudioResampler::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedAudioResampler)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.AudioResamplerInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedAudioResampler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedAudioResampler)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.AudioResamplerInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedAudioResampler::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedAudioResampler::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedAudioResampler::GetClassData() const { return &_class_data_; }


void OwnedAudioResampler::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedAudioResampler*>(&to_msg);
  auto& from = static_cast<const OwnedAudioResampler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedAudioResampler)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::AudioResamplerInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedAudioResampler::CopyFrom(const OwnedAudioResampler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedAudioResampler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedAudioResampler::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  return true;
}

void OwnedAudioResampler::InternalSwap(OwnedAudioResampler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedAudioResampler, _impl_.info_)
      + sizeof(OwnedAudioResampler::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedAudioResampler, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedAudioResampler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[38]);
}

// ===================================================================

class OwnedApm::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedApm>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedApm* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedApm::_Internal::handle(const OwnedApm* msg) {
  return *msg->_impl_.handle_;
}
void OwnedApm::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedApm::OwnedApm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedApm)
}
OwnedApm::OwnedApm(const OwnedApm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedApm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedApm)
}

inline void OwnedApm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
  };
}

OwnedApm::~OwnedApm() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedApm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedApm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
}

void OwnedApm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedApm::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedApm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.handle_ != nullptr);
    _impl_.handle_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedApm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedApm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedApm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedApm)
  return target;
}

size_t OwnedApm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedApm)
  size_t total_size = 0;

  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (_internal_has_handle()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedApm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedApm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedApm::GetClassData() const { return &_class_data_; }


void OwnedApm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedApm*>(&to_msg);
  auto& from = static_cast<const OwnedApm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedApm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_handle()) {
    _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
        from._internal_handle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedApm::CopyFrom(const OwnedApm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedApm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedApm::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  return true;
}

void OwnedApm::InternalSwap(OwnedApm* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.handle_, other->_impl_.handle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedApm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[39]);
}

// ===================================================================

class SoxResamplerInfo::_Internal {
 public:
};

SoxResamplerInfo::SoxResamplerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.SoxResamplerInfo)
}
SoxResamplerInfo::SoxResamplerInfo(const SoxResamplerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  SoxResamplerInfo* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.SoxResamplerInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SoxResamplerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SoxResamplerInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SoxResamplerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[40]);
}

// ===================================================================

class OwnedSoxResampler::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnedSoxResampler>()._impl_._has_bits_);
  static const ::livekit::proto::FfiOwnedHandle& handle(const OwnedSoxResampler* msg);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::SoxResamplerInfo& info(const OwnedSoxResampler* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::FfiOwnedHandle&
OwnedSoxResampler::_Internal::handle(const OwnedSoxResampler* msg) {
  return *msg->_impl_.handle_;
}
const ::livekit::proto::SoxResamplerInfo&
OwnedSoxResampler::_Internal::info(const OwnedSoxResampler* msg) {
  return *msg->_impl_.info_;
}
void OwnedSoxResampler::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
OwnedSoxResampler::OwnedSoxResampler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.OwnedSoxResampler)
}
OwnedSoxResampler::OwnedSoxResampler(const OwnedSoxResampler& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnedSoxResampler* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_handle()) {
    _this->_impl_.handle_ = new ::livekit::proto::FfiOwnedHandle(*from._impl_.handle_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::livekit::proto::SoxResamplerInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.OwnedSoxResampler)
}

inline void OwnedSoxResampler::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.handle_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
}

OwnedSoxResampler::~OwnedSoxResampler() {
  // @@protoc_insertion_point(destructor:livekit.proto.OwnedSoxResampler)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnedSoxResampler::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.handle_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void OwnedSoxResampler::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnedSoxResampler::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.OwnedSoxResampler)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.handle_ != nullptr);
      _impl_.handle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnedSoxResampler::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.FfiOwnedHandle handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.SoxResamplerInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnedSoxResampler::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.OwnedSoxResampler)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handle(this),
        _Internal::handle(this).GetCachedSize(), target, stream);
  }

  // required .livekit.proto.SoxResamplerInfo info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.OwnedSoxResampler)
  return target;
}

size_t OwnedSoxResampler::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.OwnedSoxResampler)
  size_t total_size = 0;

  if (_internal_has_handle()) {
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);
  }

  if (_internal_has_info()) {
    // required .livekit.proto.SoxResamplerInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return total_size;
}
size_t OwnedSoxResampler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.OwnedSoxResampler)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.FfiOwnedHandle handle = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.handle_);

    // required .livekit.proto.SoxResamplerInfo info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnedSoxResampler::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnedSoxResampler::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnedSoxResampler::GetClassData() const { return &_class_data_; }


void OwnedSoxResampler::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnedSoxResampler*>(&to_msg);
  auto& from = static_cast<const OwnedSoxResampler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.OwnedSoxResampler)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_handle()->::livekit::proto::FfiOwnedHandle::MergeFrom(
          from._internal_handle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::livekit::proto::SoxResamplerInfo::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnedSoxResampler::CopyFrom(const OwnedSoxResampler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.OwnedSoxResampler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnedSoxResampler::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_handle()) {
    if (!_impl_.handle_->IsInitialized()) return false;
  }
  return true;
}

void OwnedSoxResampler::InternalSwap(OwnedSoxResampler* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnedSoxResampler, _impl_.info_)
      + sizeof(OwnedSoxResampler::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(OwnedSoxResampler, _impl_.handle_)>(
          reinterpret_cast<char*>(&_impl_.handle_),
          reinterpret_cast<char*>(&other->_impl_.handle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnedSoxResampler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[41]);
}

// ===================================================================

class LoadAudioFilterPluginRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadAudioFilterPluginRequest>()._impl_._has_bits_);
  static void set_has_plugin_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_module_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

LoadAudioFilterPluginRequest::LoadAudioFilterPluginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.LoadAudioFilterPluginRequest)
}
LoadAudioFilterPluginRequest::LoadAudioFilterPluginRequest(const LoadAudioFilterPluginRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadAudioFilterPluginRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dependencies_){from._impl_.dependencies_}
    , decltype(_impl_.plugin_path_){}
    , decltype(_impl_.module_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.plugin_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugin_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_plugin_path()) {
    _this->_impl_.plugin_path_.Set(from._internal_plugin_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_module_id()) {
    _this->_impl_.module_id_.Set(from._internal_module_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.LoadAudioFilterPluginRequest)
}

inline void LoadAudioFilterPluginRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dependencies_){arena}
    , decltype(_impl_.plugin_path_){}
    , decltype(_impl_.module_id_){}
  };
  _impl_.plugin_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plugin_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.module_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadAudioFilterPluginRequest::~LoadAudioFilterPluginRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.LoadAudioFilterPluginRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadAudioFilterPluginRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dependencies_.~RepeatedPtrField();
  _impl_.plugin_path_.Destroy();
  _impl_.module_id_.Destroy();
}

void LoadAudioFilterPluginRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadAudioFilterPluginRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.LoadAudioFilterPluginRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dependencies_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.plugin_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.module_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadAudioFilterPluginRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string plugin_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_plugin_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.LoadAudioFilterPluginRequest.plugin_path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string dependencies = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dependencies();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "livekit.proto.LoadAudioFilterPluginRequest.dependencies");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required string module_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_module_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.LoadAudioFilterPluginRequest.module_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadAudioFilterPluginRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.LoadAudioFilterPluginRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string plugin_path = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_plugin_path().data(), static_cast<int>(this->_internal_plugin_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.LoadAudioFilterPluginRequest.plugin_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_plugin_path(), target);
  }

  // repeated string dependencies = 2;
  for (int i = 0, n = this->_internal_dependencies_size(); i < n; i++) {
    const auto& s = this->_internal_dependencies(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.LoadAudioFilterPluginRequest.dependencies");
    target = stream->WriteString(2, s, target);
  }

  // required string module_id = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_module_id().data(), static_cast<int>(this->_internal_module_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.LoadAudioFilterPluginRequest.module_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_module_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.LoadAudioFilterPluginRequest)
  return target;
}

size_t LoadAudioFilterPluginRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.LoadAudioFilterPluginRequest)
  size_t total_size = 0;

  if (_internal_has_plugin_path()) {
    // required string plugin_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_plugin_path());
  }

  if (_internal_has_module_id()) {
    // required string module_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_module_id());
  }

  return total_size;
}
size_t LoadAudioFilterPluginRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.LoadAudioFilterPluginRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string plugin_path = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_plugin_path());

    // required string module_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_module_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string dependencies = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.dependencies_.size());
  for (int i = 0, n = _impl_.dependencies_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.dependencies_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadAudioFilterPluginRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadAudioFilterPluginRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadAudioFilterPluginRequest::GetClassData() const { return &_class_data_; }


void LoadAudioFilterPluginRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadAudioFilterPluginRequest*>(&to_msg);
  auto& from = static_cast<const LoadAudioFilterPluginRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.LoadAudioFilterPluginRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dependencies_.MergeFrom(from._impl_.dependencies_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_plugin_path(from._internal_plugin_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_module_id(from._internal_module_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadAudioFilterPluginRequest::CopyFrom(const LoadAudioFilterPluginRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.LoadAudioFilterPluginRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAudioFilterPluginRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void LoadAudioFilterPluginRequest::InternalSwap(LoadAudioFilterPluginRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dependencies_.InternalSwap(&other->_impl_.dependencies_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.plugin_path_, lhs_arena,
      &other->_impl_.plugin_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.module_id_, lhs_arena,
      &other->_impl_.module_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadAudioFilterPluginRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[42]);
}

// ===================================================================

class LoadAudioFilterPluginResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadAudioFilterPluginResponse>()._impl_._has_bits_);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoadAudioFilterPluginResponse::LoadAudioFilterPluginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.LoadAudioFilterPluginResponse)
}
LoadAudioFilterPluginResponse::LoadAudioFilterPluginResponse(const LoadAudioFilterPluginResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoadAudioFilterPluginResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.LoadAudioFilterPluginResponse)
}

inline void LoadAudioFilterPluginResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.error_){}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoadAudioFilterPluginResponse::~LoadAudioFilterPluginResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.LoadAudioFilterPluginResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoadAudioFilterPluginResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_.Destroy();
}

void LoadAudioFilterPluginResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoadAudioFilterPluginResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.LoadAudioFilterPluginResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.error_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadAudioFilterPluginResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.LoadAudioFilterPluginResponse.error");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoadAudioFilterPluginResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.LoadAudioFilterPluginResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string error = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.LoadAudioFilterPluginResponse.error");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.LoadAudioFilterPluginResponse)
  return target;
}

size_t LoadAudioFilterPluginResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.LoadAudioFilterPluginResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadAudioFilterPluginResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoadAudioFilterPluginResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadAudioFilterPluginResponse::GetClassData() const { return &_class_data_; }


void LoadAudioFilterPluginResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoadAudioFilterPluginResponse*>(&to_msg);
  auto& from = static_cast<const LoadAudioFilterPluginResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.LoadAudioFilterPluginResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error()) {
    _this->_internal_set_error(from._internal_error());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadAudioFilterPluginResponse::CopyFrom(const LoadAudioFilterPluginResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.LoadAudioFilterPluginResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadAudioFilterPluginResponse::IsInitialized() const {
  return true;
}

void LoadAudioFilterPluginResponse::InternalSwap(LoadAudioFilterPluginResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadAudioFilterPluginResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_audio_5fframe_2eproto_getter, &descriptor_table_audio_5fframe_2eproto_once,
      file_level_metadata_audio_5fframe_2eproto[43]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioStreamRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioStreamResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioStreamResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioStreamFromParticipantRequest*
Arena::CreateMaybeMessage< ::livekit::proto::AudioStreamFromParticipantRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioStreamFromParticipantRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioStreamFromParticipantResponse*
Arena::CreateMaybeMessage< ::livekit::proto::AudioStreamFromParticipantResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioStreamFromParticipantResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioSourceRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioSourceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioSourceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioSourceResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioSourceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioSourceResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::CaptureAudioFrameRequest*
Arena::CreateMaybeMessage< ::livekit::proto::CaptureAudioFrameRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::CaptureAudioFrameRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::CaptureAudioFrameResponse*
Arena::CreateMaybeMessage< ::livekit::proto::CaptureAudioFrameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::CaptureAudioFrameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::CaptureAudioFrameCallback*
Arena::CreateMaybeMessage< ::livekit::proto::CaptureAudioFrameCallback >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::CaptureAudioFrameCallback >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ClearAudioBufferRequest*
Arena::CreateMaybeMessage< ::livekit::proto::ClearAudioBufferRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ClearAudioBufferRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ClearAudioBufferResponse*
Arena::CreateMaybeMessage< ::livekit::proto::ClearAudioBufferResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ClearAudioBufferResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioResamplerRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioResamplerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioResamplerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewAudioResamplerResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewAudioResamplerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewAudioResamplerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RemixAndResampleRequest*
Arena::CreateMaybeMessage< ::livekit::proto::RemixAndResampleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RemixAndResampleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RemixAndResampleResponse*
Arena::CreateMaybeMessage< ::livekit::proto::RemixAndResampleResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RemixAndResampleResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewApmRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewApmRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewApmRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewApmResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewApmResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewApmResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ApmProcessStreamRequest*
Arena::CreateMaybeMessage< ::livekit::proto::ApmProcessStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ApmProcessStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ApmProcessStreamResponse*
Arena::CreateMaybeMessage< ::livekit::proto::ApmProcessStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ApmProcessStreamResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ApmProcessReverseStreamRequest*
Arena::CreateMaybeMessage< ::livekit::proto::ApmProcessReverseStreamRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ApmProcessReverseStreamRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::ApmProcessReverseStreamResponse*
Arena::CreateMaybeMessage< ::livekit::proto::ApmProcessReverseStreamResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::ApmProcessReverseStreamResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewSoxResamplerRequest*
Arena::CreateMaybeMessage< ::livekit::proto::NewSoxResamplerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewSoxResamplerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::NewSoxResamplerResponse*
Arena::CreateMaybeMessage< ::livekit::proto::NewSoxResamplerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::NewSoxResamplerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::PushSoxResamplerRequest*
Arena::CreateMaybeMessage< ::livekit::proto::PushSoxResamplerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::PushSoxResamplerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::PushSoxResamplerResponse*
Arena::CreateMaybeMessage< ::livekit::proto::PushSoxResamplerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::PushSoxResamplerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FlushSoxResamplerRequest*
Arena::CreateMaybeMessage< ::livekit::proto::FlushSoxResamplerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FlushSoxResamplerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FlushSoxResamplerResponse*
Arena::CreateMaybeMessage< ::livekit::proto::FlushSoxResamplerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FlushSoxResamplerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioFrameBufferInfo*
Arena::CreateMaybeMessage< ::livekit::proto::AudioFrameBufferInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioFrameBufferInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedAudioFrameBuffer*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedAudioFrameBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedAudioFrameBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioStreamInfo*
Arena::CreateMaybeMessage< ::livekit::proto::AudioStreamInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioStreamInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedAudioStream*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedAudioStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedAudioStream >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioStreamEvent*
Arena::CreateMaybeMessage< ::livekit::proto::AudioStreamEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioStreamEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioFrameReceived*
Arena::CreateMaybeMessage< ::livekit::proto::AudioFrameReceived >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioFrameReceived >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioStreamEOS*
Arena::CreateMaybeMessage< ::livekit::proto::AudioStreamEOS >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioStreamEOS >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioSourceOptions*
Arena::CreateMaybeMessage< ::livekit::proto::AudioSourceOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioSourceOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioSourceInfo*
Arena::CreateMaybeMessage< ::livekit::proto::AudioSourceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioSourceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedAudioSource*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedAudioSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedAudioSource >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::AudioResamplerInfo*
Arena::CreateMaybeMessage< ::livekit::proto::AudioResamplerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::AudioResamplerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedAudioResampler*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedAudioResampler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedAudioResampler >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedApm*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedApm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedApm >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::SoxResamplerInfo*
Arena::CreateMaybeMessage< ::livekit::proto::SoxResamplerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::SoxResamplerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::OwnedSoxResampler*
Arena::CreateMaybeMessage< ::livekit::proto::OwnedSoxResampler >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::OwnedSoxResampler >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::LoadAudioFilterPluginRequest*
Arena::CreateMaybeMessage< ::livekit::proto::LoadAudioFilterPluginRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::LoadAudioFilterPluginRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::LoadAudioFilterPluginResponse*
Arena::CreateMaybeMessage< ::livekit::proto::LoadAudioFilterPluginResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::LoadAudioFilterPluginResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
