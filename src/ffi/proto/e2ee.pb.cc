// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: e2ee.proto

#include "e2ee.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace livekit {
namespace proto {
PROTOBUF_CONSTEXPR FrameCryptor::FrameCryptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_sid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0
  , /*decltype(_impl_.enabled_)*/false} {}
struct FrameCryptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameCryptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameCryptorDefaultTypeInternal() {}
  union {
    FrameCryptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameCryptorDefaultTypeInternal _FrameCryptor_default_instance_;
PROTOBUF_CONSTEXPR KeyProviderOptions::KeyProviderOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shared_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ratchet_salt_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ratchet_window_size_)*/0
  , /*decltype(_impl_.failure_tolerance_)*/0} {}
struct KeyProviderOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyProviderOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyProviderOptionsDefaultTypeInternal() {}
  union {
    KeyProviderOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyProviderOptionsDefaultTypeInternal _KeyProviderOptions_default_instance_;
PROTOBUF_CONSTEXPR E2eeOptions::E2eeOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_provider_options_)*/nullptr
  , /*decltype(_impl_.encryption_type_)*/0} {}
struct E2eeOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeOptionsDefaultTypeInternal() {}
  union {
    E2eeOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeOptionsDefaultTypeInternal _E2eeOptions_default_instance_;
PROTOBUF_CONSTEXPR E2eeManagerSetEnabledRequest::E2eeManagerSetEnabledRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct E2eeManagerSetEnabledRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeManagerSetEnabledRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeManagerSetEnabledRequestDefaultTypeInternal() {}
  union {
    E2eeManagerSetEnabledRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeManagerSetEnabledRequestDefaultTypeInternal _E2eeManagerSetEnabledRequest_default_instance_;
PROTOBUF_CONSTEXPR E2eeManagerSetEnabledResponse::E2eeManagerSetEnabledResponse(
    ::_pbi::ConstantInitialized) {}
struct E2eeManagerSetEnabledResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeManagerSetEnabledResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeManagerSetEnabledResponseDefaultTypeInternal() {}
  union {
    E2eeManagerSetEnabledResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeManagerSetEnabledResponseDefaultTypeInternal _E2eeManagerSetEnabledResponse_default_instance_;
PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsRequest::E2eeManagerGetFrameCryptorsRequest(
    ::_pbi::ConstantInitialized) {}
struct E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal() {}
  union {
    E2eeManagerGetFrameCryptorsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal _E2eeManagerGetFrameCryptorsRequest_default_instance_;
PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsResponse::E2eeManagerGetFrameCryptorsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.frame_cryptors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal() {}
  union {
    E2eeManagerGetFrameCryptorsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal _E2eeManagerGetFrameCryptorsResponse_default_instance_;
PROTOBUF_CONSTEXPR FrameCryptorSetEnabledRequest::FrameCryptorSetEnabledRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_sid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enabled_)*/false} {}
struct FrameCryptorSetEnabledRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameCryptorSetEnabledRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameCryptorSetEnabledRequestDefaultTypeInternal() {}
  union {
    FrameCryptorSetEnabledRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameCryptorSetEnabledRequestDefaultTypeInternal _FrameCryptorSetEnabledRequest_default_instance_;
PROTOBUF_CONSTEXPR FrameCryptorSetEnabledResponse::FrameCryptorSetEnabledResponse(
    ::_pbi::ConstantInitialized) {}
struct FrameCryptorSetEnabledResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameCryptorSetEnabledResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameCryptorSetEnabledResponseDefaultTypeInternal() {}
  union {
    FrameCryptorSetEnabledResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameCryptorSetEnabledResponseDefaultTypeInternal _FrameCryptorSetEnabledResponse_default_instance_;
PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexRequest::FrameCryptorSetKeyIndexRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_sid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0} {}
struct FrameCryptorSetKeyIndexRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameCryptorSetKeyIndexRequestDefaultTypeInternal() {}
  union {
    FrameCryptorSetKeyIndexRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameCryptorSetKeyIndexRequestDefaultTypeInternal _FrameCryptorSetKeyIndexRequest_default_instance_;
PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexResponse::FrameCryptorSetKeyIndexResponse(
    ::_pbi::ConstantInitialized) {}
struct FrameCryptorSetKeyIndexResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameCryptorSetKeyIndexResponseDefaultTypeInternal() {}
  union {
    FrameCryptorSetKeyIndexResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameCryptorSetKeyIndexResponseDefaultTypeInternal _FrameCryptorSetKeyIndexResponse_default_instance_;
PROTOBUF_CONSTEXPR SetSharedKeyRequest::SetSharedKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shared_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0} {}
struct SetSharedKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetSharedKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetSharedKeyRequestDefaultTypeInternal() {}
  union {
    SetSharedKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetSharedKeyRequestDefaultTypeInternal _SetSharedKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR SetSharedKeyResponse::SetSharedKeyResponse(
    ::_pbi::ConstantInitialized) {}
struct SetSharedKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetSharedKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetSharedKeyResponseDefaultTypeInternal() {}
  union {
    SetSharedKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetSharedKeyResponseDefaultTypeInternal _SetSharedKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR RatchetSharedKeyRequest::RatchetSharedKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_index_)*/0} {}
struct RatchetSharedKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RatchetSharedKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RatchetSharedKeyRequestDefaultTypeInternal() {}
  union {
    RatchetSharedKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RatchetSharedKeyRequestDefaultTypeInternal _RatchetSharedKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR RatchetSharedKeyResponse::RatchetSharedKeyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RatchetSharedKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RatchetSharedKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RatchetSharedKeyResponseDefaultTypeInternal() {}
  union {
    RatchetSharedKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RatchetSharedKeyResponseDefaultTypeInternal _RatchetSharedKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR GetSharedKeyRequest::GetSharedKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_index_)*/0} {}
struct GetSharedKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetSharedKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetSharedKeyRequestDefaultTypeInternal() {}
  union {
    GetSharedKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetSharedKeyRequestDefaultTypeInternal _GetSharedKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR GetSharedKeyResponse::GetSharedKeyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GetSharedKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetSharedKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetSharedKeyResponseDefaultTypeInternal() {}
  union {
    GetSharedKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetSharedKeyResponseDefaultTypeInternal _GetSharedKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR SetKeyRequest::SetKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0} {}
struct SetKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetKeyRequestDefaultTypeInternal() {}
  union {
    SetKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetKeyRequestDefaultTypeInternal _SetKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR SetKeyResponse::SetKeyResponse(
    ::_pbi::ConstantInitialized) {}
struct SetKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetKeyResponseDefaultTypeInternal() {}
  union {
    SetKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetKeyResponseDefaultTypeInternal _SetKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR RatchetKeyRequest::RatchetKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0} {}
struct RatchetKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RatchetKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RatchetKeyRequestDefaultTypeInternal() {}
  union {
    RatchetKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RatchetKeyRequestDefaultTypeInternal _RatchetKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR RatchetKeyResponse::RatchetKeyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.new_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct RatchetKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RatchetKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RatchetKeyResponseDefaultTypeInternal() {}
  union {
    RatchetKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RatchetKeyResponseDefaultTypeInternal _RatchetKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR GetKeyRequest::GetKeyRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.key_index_)*/0} {}
struct GetKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetKeyRequestDefaultTypeInternal() {}
  union {
    GetKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetKeyRequestDefaultTypeInternal _GetKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR GetKeyResponse::GetKeyResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct GetKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetKeyResponseDefaultTypeInternal() {}
  union {
    GetKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetKeyResponseDefaultTypeInternal _GetKeyResponse_default_instance_;
PROTOBUF_CONSTEXPR E2eeRequest::E2eeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.room_handle_)*/uint64_t{0u}
  , /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct E2eeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeRequestDefaultTypeInternal() {}
  union {
    E2eeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeRequestDefaultTypeInternal _E2eeRequest_default_instance_;
PROTOBUF_CONSTEXPR E2eeResponse::E2eeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct E2eeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR E2eeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~E2eeResponseDefaultTypeInternal() {}
  union {
    E2eeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 E2eeResponseDefaultTypeInternal _E2eeResponse_default_instance_;
}  // namespace proto
}  // namespace livekit
static ::_pb::Metadata file_level_metadata_e2ee_2eproto[25];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_e2ee_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_e2ee_2eproto = nullptr;

const uint32_t TableStruct_e2ee_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _impl_.track_sid_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _impl_.key_index_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptor, _impl_.enabled_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _impl_.shared_key_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _impl_.ratchet_window_size_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _impl_.ratchet_salt_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::KeyProviderOptions, _impl_.failure_tolerance_),
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeOptions, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeOptions, _impl_.encryption_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeOptions, _impl_.key_provider_options_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerSetEnabledRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerSetEnabledRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerSetEnabledRequest, _impl_.enabled_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerSetEnabledResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerGetFrameCryptorsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerGetFrameCryptorsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeManagerGetFrameCryptorsResponse, _impl_.frame_cryptors_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledRequest, _impl_.track_sid_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledRequest, _impl_.enabled_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetEnabledResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexRequest, _impl_.track_sid_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexRequest, _impl_.key_index_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::FrameCryptorSetKeyIndexResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetSharedKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetSharedKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetSharedKeyRequest, _impl_.shared_key_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetSharedKeyRequest, _impl_.key_index_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetSharedKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyRequest, _impl_.key_index_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetSharedKeyResponse, _impl_.new_key_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyRequest, _impl_.key_index_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetSharedKeyResponse, _impl_.key_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyRequest, _impl_.key_index_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::SetKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyRequest, _impl_.key_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::RatchetKeyResponse, _impl_.new_key_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyRequest, _impl_.key_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::GetKeyResponse, _impl_.key_),
  0,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeRequest, _impl_.room_handle_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeRequest, _impl_.message_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeResponse, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::proto::E2eeResponse, _impl_.message_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::livekit::proto::FrameCryptor)},
  { 14, 24, -1, sizeof(::livekit::proto::KeyProviderOptions)},
  { 28, 36, -1, sizeof(::livekit::proto::E2eeOptions)},
  { 38, 45, -1, sizeof(::livekit::proto::E2eeManagerSetEnabledRequest)},
  { 46, -1, -1, sizeof(::livekit::proto::E2eeManagerSetEnabledResponse)},
  { 52, -1, -1, sizeof(::livekit::proto::E2eeManagerGetFrameCryptorsRequest)},
  { 58, -1, -1, sizeof(::livekit::proto::E2eeManagerGetFrameCryptorsResponse)},
  { 65, 74, -1, sizeof(::livekit::proto::FrameCryptorSetEnabledRequest)},
  { 77, -1, -1, sizeof(::livekit::proto::FrameCryptorSetEnabledResponse)},
  { 83, 92, -1, sizeof(::livekit::proto::FrameCryptorSetKeyIndexRequest)},
  { 95, -1, -1, sizeof(::livekit::proto::FrameCryptorSetKeyIndexResponse)},
  { 101, 109, -1, sizeof(::livekit::proto::SetSharedKeyRequest)},
  { 111, -1, -1, sizeof(::livekit::proto::SetSharedKeyResponse)},
  { 117, 124, -1, sizeof(::livekit::proto::RatchetSharedKeyRequest)},
  { 125, 132, -1, sizeof(::livekit::proto::RatchetSharedKeyResponse)},
  { 133, 140, -1, sizeof(::livekit::proto::GetSharedKeyRequest)},
  { 141, 148, -1, sizeof(::livekit::proto::GetSharedKeyResponse)},
  { 149, 158, -1, sizeof(::livekit::proto::SetKeyRequest)},
  { 161, -1, -1, sizeof(::livekit::proto::SetKeyResponse)},
  { 167, 175, -1, sizeof(::livekit::proto::RatchetKeyRequest)},
  { 177, 184, -1, sizeof(::livekit::proto::RatchetKeyResponse)},
  { 185, 193, -1, sizeof(::livekit::proto::GetKeyRequest)},
  { 195, 202, -1, sizeof(::livekit::proto::GetKeyResponse)},
  { 203, 221, -1, sizeof(::livekit::proto::E2eeRequest)},
  { 232, -1, -1, sizeof(::livekit::proto::E2eeResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::livekit::proto::_FrameCryptor_default_instance_._instance,
  &::livekit::proto::_KeyProviderOptions_default_instance_._instance,
  &::livekit::proto::_E2eeOptions_default_instance_._instance,
  &::livekit::proto::_E2eeManagerSetEnabledRequest_default_instance_._instance,
  &::livekit::proto::_E2eeManagerSetEnabledResponse_default_instance_._instance,
  &::livekit::proto::_E2eeManagerGetFrameCryptorsRequest_default_instance_._instance,
  &::livekit::proto::_E2eeManagerGetFrameCryptorsResponse_default_instance_._instance,
  &::livekit::proto::_FrameCryptorSetEnabledRequest_default_instance_._instance,
  &::livekit::proto::_FrameCryptorSetEnabledResponse_default_instance_._instance,
  &::livekit::proto::_FrameCryptorSetKeyIndexRequest_default_instance_._instance,
  &::livekit::proto::_FrameCryptorSetKeyIndexResponse_default_instance_._instance,
  &::livekit::proto::_SetSharedKeyRequest_default_instance_._instance,
  &::livekit::proto::_SetSharedKeyResponse_default_instance_._instance,
  &::livekit::proto::_RatchetSharedKeyRequest_default_instance_._instance,
  &::livekit::proto::_RatchetSharedKeyResponse_default_instance_._instance,
  &::livekit::proto::_GetSharedKeyRequest_default_instance_._instance,
  &::livekit::proto::_GetSharedKeyResponse_default_instance_._instance,
  &::livekit::proto::_SetKeyRequest_default_instance_._instance,
  &::livekit::proto::_SetKeyResponse_default_instance_._instance,
  &::livekit::proto::_RatchetKeyRequest_default_instance_._instance,
  &::livekit::proto::_RatchetKeyResponse_default_instance_._instance,
  &::livekit::proto::_GetKeyRequest_default_instance_._instance,
  &::livekit::proto::_GetKeyResponse_default_instance_._instance,
  &::livekit::proto::_E2eeRequest_default_instance_._instance,
  &::livekit::proto::_E2eeResponse_default_instance_._instance,
};

const char descriptor_table_protodef_e2ee_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ne2ee.proto\022\rlivekit.proto\"c\n\014FrameCryp"
  "tor\022\034\n\024participant_identity\030\001 \002(\t\022\021\n\ttra"
  "ck_sid\030\002 \002(\t\022\021\n\tkey_index\030\003 \002(\005\022\017\n\007enabl"
  "ed\030\004 \002(\010\"v\n\022KeyProviderOptions\022\022\n\nshared"
  "_key\030\001 \001(\014\022\033\n\023ratchet_window_size\030\002 \002(\005\022"
  "\024\n\014ratchet_salt\030\003 \002(\014\022\031\n\021failure_toleran"
  "ce\030\004 \002(\005\"\206\001\n\013E2eeOptions\0226\n\017encryption_t"
  "ype\030\001 \002(\0162\035.livekit.proto.EncryptionType"
  "\022\?\n\024key_provider_options\030\002 \002(\0132!.livekit"
  ".proto.KeyProviderOptions\"/\n\034E2eeManager"
  "SetEnabledRequest\022\017\n\007enabled\030\001 \002(\010\"\037\n\035E2"
  "eeManagerSetEnabledResponse\"$\n\"E2eeManag"
  "erGetFrameCryptorsRequest\"Z\n#E2eeManager"
  "GetFrameCryptorsResponse\0223\n\016frame_crypto"
  "rs\030\001 \003(\0132\033.livekit.proto.FrameCryptor\"a\n"
  "\035FrameCryptorSetEnabledRequest\022\034\n\024partic"
  "ipant_identity\030\001 \002(\t\022\021\n\ttrack_sid\030\002 \002(\t\022"
  "\017\n\007enabled\030\003 \002(\010\" \n\036FrameCryptorSetEnabl"
  "edResponse\"d\n\036FrameCryptorSetKeyIndexReq"
  "uest\022\034\n\024participant_identity\030\001 \002(\t\022\021\n\ttr"
  "ack_sid\030\002 \002(\t\022\021\n\tkey_index\030\003 \002(\005\"!\n\037Fram"
  "eCryptorSetKeyIndexResponse\"<\n\023SetShared"
  "KeyRequest\022\022\n\nshared_key\030\001 \002(\014\022\021\n\tkey_in"
  "dex\030\002 \002(\005\"\026\n\024SetSharedKeyResponse\",\n\027Rat"
  "chetSharedKeyRequest\022\021\n\tkey_index\030\001 \002(\005\""
  "+\n\030RatchetSharedKeyResponse\022\017\n\007new_key\030\001"
  " \001(\014\"(\n\023GetSharedKeyRequest\022\021\n\tkey_index"
  "\030\001 \002(\005\"#\n\024GetSharedKeyResponse\022\013\n\003key\030\001 "
  "\001(\014\"M\n\rSetKeyRequest\022\034\n\024participant_iden"
  "tity\030\001 \002(\t\022\013\n\003key\030\002 \002(\014\022\021\n\tkey_index\030\003 \002"
  "(\005\"\020\n\016SetKeyResponse\"D\n\021RatchetKeyReques"
  "t\022\034\n\024participant_identity\030\001 \002(\t\022\021\n\tkey_i"
  "ndex\030\002 \002(\005\"%\n\022RatchetKeyResponse\022\017\n\007new_"
  "key\030\001 \001(\014\"@\n\rGetKeyRequest\022\034\n\024participan"
  "t_identity\030\001 \002(\t\022\021\n\tkey_index\030\002 \002(\005\"\035\n\016G"
  "etKeyResponse\022\013\n\003key\030\001 \001(\014\"\314\005\n\013E2eeReque"
  "st\022\023\n\013room_handle\030\001 \002(\004\022J\n\023manager_set_e"
  "nabled\030\002 \001(\0132+.livekit.proto.E2eeManager"
  "SetEnabledRequestH\000\022W\n\032manager_get_frame"
  "_cryptors\030\003 \001(\01321.livekit.proto.E2eeMana"
  "gerGetFrameCryptorsRequestH\000\022K\n\023cryptor_"
  "set_enabled\030\004 \001(\0132,.livekit.proto.FrameC"
  "ryptorSetEnabledRequestH\000\022N\n\025cryptor_set"
  "_key_index\030\005 \001(\0132-.livekit.proto.FrameCr"
  "yptorSetKeyIndexRequestH\000\022<\n\016set_shared_"
  "key\030\006 \001(\0132\".livekit.proto.SetSharedKeyRe"
  "questH\000\022D\n\022ratchet_shared_key\030\007 \001(\0132&.li"
  "vekit.proto.RatchetSharedKeyRequestH\000\022<\n"
  "\016get_shared_key\030\010 \001(\0132\".livekit.proto.Ge"
  "tSharedKeyRequestH\000\022/\n\007set_key\030\t \001(\0132\034.l"
  "ivekit.proto.SetKeyRequestH\000\0227\n\013ratchet_"
  "key\030\n \001(\0132 .livekit.proto.RatchetKeyRequ"
  "estH\000\022/\n\007get_key\030\013 \001(\0132\034.livekit.proto.G"
  "etKeyRequestH\000B\t\n\007message\"\302\005\n\014E2eeRespon"
  "se\022K\n\023manager_set_enabled\030\001 \001(\0132,.liveki"
  "t.proto.E2eeManagerSetEnabledResponseH\000\022"
  "X\n\032manager_get_frame_cryptors\030\002 \001(\01322.li"
  "vekit.proto.E2eeManagerGetFrameCryptorsR"
  "esponseH\000\022L\n\023cryptor_set_enabled\030\003 \001(\0132-"
  ".livekit.proto.FrameCryptorSetEnabledRes"
  "ponseH\000\022O\n\025cryptor_set_key_index\030\004 \001(\0132."
  ".livekit.proto.FrameCryptorSetKeyIndexRe"
  "sponseH\000\022=\n\016set_shared_key\030\005 \001(\0132#.livek"
  "it.proto.SetSharedKeyResponseH\000\022E\n\022ratch"
  "et_shared_key\030\006 \001(\0132\'.livekit.proto.Ratc"
  "hetSharedKeyResponseH\000\022=\n\016get_shared_key"
  "\030\007 \001(\0132#.livekit.proto.GetSharedKeyRespo"
  "nseH\000\0220\n\007set_key\030\010 \001(\0132\035.livekit.proto.S"
  "etKeyResponseH\000\0228\n\013ratchet_key\030\t \001(\0132!.l"
  "ivekit.proto.RatchetKeyResponseH\000\0220\n\007get"
  "_key\030\n \001(\0132\035.livekit.proto.GetKeyRespons"
  "eH\000B\t\n\007message*/\n\016EncryptionType\022\010\n\004NONE"
  "\020\000\022\007\n\003GCM\020\001\022\n\n\006CUSTOM\020\002*\210\001\n\017EncryptionSt"
  "ate\022\007\n\003NEW\020\000\022\006\n\002OK\020\001\022\025\n\021ENCRYPTION_FAILE"
  "D\020\002\022\025\n\021DECRYPTION_FAILED\020\003\022\017\n\013MISSING_KE"
  "Y\020\004\022\021\n\rKEY_RATCHETED\020\005\022\022\n\016INTERNAL_ERROR"
  "\020\006B\020\252\002\rLiveKit.Proto"
  ;
static ::_pbi::once_flag descriptor_table_e2ee_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_e2ee_2eproto = {
    false, false, 3060, descriptor_table_protodef_e2ee_2eproto,
    "e2ee.proto",
    &descriptor_table_e2ee_2eproto_once, nullptr, 0, 25,
    schemas, file_default_instances, TableStruct_e2ee_2eproto::offsets,
    file_level_metadata_e2ee_2eproto, file_level_enum_descriptors_e2ee_2eproto,
    file_level_service_descriptors_e2ee_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_e2ee_2eproto_getter() {
  return &descriptor_table_e2ee_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_e2ee_2eproto(&descriptor_table_e2ee_2eproto);
namespace livekit {
namespace proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_e2ee_2eproto);
  return file_level_enum_descriptors_e2ee_2eproto[0];
}
bool EncryptionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_e2ee_2eproto);
  return file_level_enum_descriptors_e2ee_2eproto[1];
}
bool EncryptionState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FrameCryptor::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameCryptor>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_track_sid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

FrameCryptor::FrameCryptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FrameCryptor)
}
FrameCryptor::FrameCryptor(const FrameCryptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameCryptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.key_index_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_track_sid()) {
    _this->_impl_.track_sid_.Set(from._internal_track_sid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.key_index_, &from._impl_.key_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.key_index_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FrameCryptor)
}

inline void FrameCryptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.key_index_){0}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameCryptor::~FrameCryptor() {
  // @@protoc_insertion_point(destructor:livekit.proto.FrameCryptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameCryptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
  _impl_.track_sid_.Destroy();
}

void FrameCryptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameCryptor::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.FrameCryptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.participant_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.track_sid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.key_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enabled_) -
        reinterpret_cast<char*>(&_impl_.key_index_)) + sizeof(_impl_.enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameCryptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptor.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string track_sid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_track_sid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptor.track_sid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameCryptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.FrameCryptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptor.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required string track_sid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_track_sid().data(), static_cast<int>(this->_internal_track_sid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptor.track_sid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_track_sid(), target);
  }

  // required int32 key_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_key_index(), target);
  }

  // required bool enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.FrameCryptor)
  return target;
}

size_t FrameCryptor::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.FrameCryptor)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_track_sid()) {
    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  if (_internal_has_enabled()) {
    // required bool enabled = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t FrameCryptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.FrameCryptor)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());

    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

    // required bool enabled = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameCryptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameCryptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameCryptor::GetClassData() const { return &_class_data_; }


void FrameCryptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameCryptor*>(&to_msg);
  auto& from = static_cast<const FrameCryptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.FrameCryptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_track_sid(from._internal_track_sid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameCryptor::CopyFrom(const FrameCryptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.FrameCryptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameCryptor::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FrameCryptor::InternalSwap(FrameCryptor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.track_sid_, lhs_arena,
      &other->_impl_.track_sid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameCryptor, _impl_.enabled_)
      + sizeof(FrameCryptor::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(FrameCryptor, _impl_.key_index_)>(
          reinterpret_cast<char*>(&_impl_.key_index_),
          reinterpret_cast<char*>(&other->_impl_.key_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameCryptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[0]);
}

// ===================================================================

class KeyProviderOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<KeyProviderOptions>()._impl_._has_bits_);
  static void set_has_shared_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ratchet_window_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ratchet_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_failure_tolerance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

KeyProviderOptions::KeyProviderOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.KeyProviderOptions)
}
KeyProviderOptions::KeyProviderOptions(const KeyProviderOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KeyProviderOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shared_key_){}
    , decltype(_impl_.ratchet_salt_){}
    , decltype(_impl_.ratchet_window_size_){}
    , decltype(_impl_.failure_tolerance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.shared_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shared_key()) {
    _this->_impl_.shared_key_.Set(from._internal_shared_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ratchet_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ratchet_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ratchet_salt()) {
    _this->_impl_.ratchet_salt_.Set(from._internal_ratchet_salt(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ratchet_window_size_, &from._impl_.ratchet_window_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.failure_tolerance_) -
    reinterpret_cast<char*>(&_impl_.ratchet_window_size_)) + sizeof(_impl_.failure_tolerance_));
  // @@protoc_insertion_point(copy_constructor:livekit.proto.KeyProviderOptions)
}

inline void KeyProviderOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shared_key_){}
    , decltype(_impl_.ratchet_salt_){}
    , decltype(_impl_.ratchet_window_size_){0}
    , decltype(_impl_.failure_tolerance_){0}
  };
  _impl_.shared_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ratchet_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ratchet_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyProviderOptions::~KeyProviderOptions() {
  // @@protoc_insertion_point(destructor:livekit.proto.KeyProviderOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KeyProviderOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shared_key_.Destroy();
  _impl_.ratchet_salt_.Destroy();
}

void KeyProviderOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KeyProviderOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.KeyProviderOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.shared_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ratchet_salt_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.ratchet_window_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.failure_tolerance_) -
        reinterpret_cast<char*>(&_impl_.ratchet_window_size_)) + sizeof(_impl_.failure_tolerance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyProviderOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes shared_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_shared_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 ratchet_window_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ratchet_window_size(&has_bits);
          _impl_.ratchet_window_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes ratchet_salt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ratchet_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 failure_tolerance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_failure_tolerance(&has_bits);
          _impl_.failure_tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KeyProviderOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.KeyProviderOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes shared_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_shared_key(), target);
  }

  // required int32 ratchet_window_size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_ratchet_window_size(), target);
  }

  // required bytes ratchet_salt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ratchet_salt(), target);
  }

  // required int32 failure_tolerance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_failure_tolerance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.KeyProviderOptions)
  return target;
}

size_t KeyProviderOptions::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.KeyProviderOptions)
  size_t total_size = 0;

  if (_internal_has_ratchet_salt()) {
    // required bytes ratchet_salt = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ratchet_salt());
  }

  if (_internal_has_ratchet_window_size()) {
    // required int32 ratchet_window_size = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ratchet_window_size());
  }

  if (_internal_has_failure_tolerance()) {
    // required int32 failure_tolerance = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failure_tolerance());
  }

  return total_size;
}
size_t KeyProviderOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.KeyProviderOptions)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required bytes ratchet_salt = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ratchet_salt());

    // required int32 ratchet_window_size = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ratchet_window_size());

    // required int32 failure_tolerance = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failure_tolerance());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes shared_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_shared_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyProviderOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KeyProviderOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyProviderOptions::GetClassData() const { return &_class_data_; }


void KeyProviderOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KeyProviderOptions*>(&to_msg);
  auto& from = static_cast<const KeyProviderOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.KeyProviderOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_shared_key(from._internal_shared_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ratchet_salt(from._internal_ratchet_salt());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ratchet_window_size_ = from._impl_.ratchet_window_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.failure_tolerance_ = from._impl_.failure_tolerance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyProviderOptions::CopyFrom(const KeyProviderOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.KeyProviderOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyProviderOptions::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void KeyProviderOptions::InternalSwap(KeyProviderOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shared_key_, lhs_arena,
      &other->_impl_.shared_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ratchet_salt_, lhs_arena,
      &other->_impl_.ratchet_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyProviderOptions, _impl_.failure_tolerance_)
      + sizeof(KeyProviderOptions::_impl_.failure_tolerance_)
      - PROTOBUF_FIELD_OFFSET(KeyProviderOptions, _impl_.ratchet_window_size_)>(
          reinterpret_cast<char*>(&_impl_.ratchet_window_size_),
          reinterpret_cast<char*>(&other->_impl_.ratchet_window_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyProviderOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[1]);
}

// ===================================================================

class E2eeOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<E2eeOptions>()._impl_._has_bits_);
  static void set_has_encryption_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::proto::KeyProviderOptions& key_provider_options(const E2eeOptions* msg);
  static void set_has_key_provider_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::livekit::proto::KeyProviderOptions&
E2eeOptions::_Internal::key_provider_options(const E2eeOptions* msg) {
  return *msg->_impl_.key_provider_options_;
}
E2eeOptions::E2eeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeOptions)
}
E2eeOptions::E2eeOptions(const E2eeOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  E2eeOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_provider_options_){nullptr}
    , decltype(_impl_.encryption_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_key_provider_options()) {
    _this->_impl_.key_provider_options_ = new ::livekit::proto::KeyProviderOptions(*from._impl_.key_provider_options_);
  }
  _this->_impl_.encryption_type_ = from._impl_.encryption_type_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeOptions)
}

inline void E2eeOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_provider_options_){nullptr}
    , decltype(_impl_.encryption_type_){0}
  };
}

E2eeOptions::~E2eeOptions() {
  // @@protoc_insertion_point(destructor:livekit.proto.E2eeOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void E2eeOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.key_provider_options_;
}

void E2eeOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void E2eeOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.E2eeOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.key_provider_options_ != nullptr);
    _impl_.key_provider_options_->Clear();
  }
  _impl_.encryption_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* E2eeOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .livekit.proto.EncryptionType encryption_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::livekit::proto::EncryptionType_IsValid(val))) {
            _internal_set_encryption_type(static_cast<::livekit::proto::EncryptionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .livekit.proto.KeyProviderOptions key_provider_options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_provider_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* E2eeOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.E2eeOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .livekit.proto.EncryptionType encryption_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_encryption_type(), target);
  }

  // required .livekit.proto.KeyProviderOptions key_provider_options = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key_provider_options(this),
        _Internal::key_provider_options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.E2eeOptions)
  return target;
}

size_t E2eeOptions::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.E2eeOptions)
  size_t total_size = 0;

  if (_internal_has_key_provider_options()) {
    // required .livekit.proto.KeyProviderOptions key_provider_options = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_provider_options_);
  }

  if (_internal_has_encryption_type()) {
    // required .livekit.proto.EncryptionType encryption_type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_encryption_type());
  }

  return total_size;
}
size_t E2eeOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.E2eeOptions)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .livekit.proto.KeyProviderOptions key_provider_options = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.key_provider_options_);

    // required .livekit.proto.EncryptionType encryption_type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_encryption_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    E2eeOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeOptions::GetClassData() const { return &_class_data_; }


void E2eeOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<E2eeOptions*>(&to_msg);
  auto& from = static_cast<const E2eeOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.E2eeOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_key_provider_options()->::livekit::proto::KeyProviderOptions::MergeFrom(
          from._internal_key_provider_options());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.encryption_type_ = from._impl_.encryption_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void E2eeOptions::CopyFrom(const E2eeOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.E2eeOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool E2eeOptions::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_key_provider_options()) {
    if (!_impl_.key_provider_options_->IsInitialized()) return false;
  }
  return true;
}

void E2eeOptions::InternalSwap(E2eeOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(E2eeOptions, _impl_.encryption_type_)
      + sizeof(E2eeOptions::_impl_.encryption_type_)
      - PROTOBUF_FIELD_OFFSET(E2eeOptions, _impl_.key_provider_options_)>(
          reinterpret_cast<char*>(&_impl_.key_provider_options_),
          reinterpret_cast<char*>(&other->_impl_.key_provider_options_));
}

::PROTOBUF_NAMESPACE_ID::Metadata E2eeOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[2]);
}

// ===================================================================

class E2eeManagerSetEnabledRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<E2eeManagerSetEnabledRequest>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

E2eeManagerSetEnabledRequest::E2eeManagerSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeManagerSetEnabledRequest)
}
E2eeManagerSetEnabledRequest::E2eeManagerSetEnabledRequest(const E2eeManagerSetEnabledRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  E2eeManagerSetEnabledRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeManagerSetEnabledRequest)
}

inline void E2eeManagerSetEnabledRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

E2eeManagerSetEnabledRequest::~E2eeManagerSetEnabledRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.E2eeManagerSetEnabledRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void E2eeManagerSetEnabledRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void E2eeManagerSetEnabledRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void E2eeManagerSetEnabledRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.E2eeManagerSetEnabledRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* E2eeManagerSetEnabledRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* E2eeManagerSetEnabledRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.E2eeManagerSetEnabledRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.E2eeManagerSetEnabledRequest)
  return target;
}

size_t E2eeManagerSetEnabledRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.E2eeManagerSetEnabledRequest)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeManagerSetEnabledRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    E2eeManagerSetEnabledRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeManagerSetEnabledRequest::GetClassData() const { return &_class_data_; }


void E2eeManagerSetEnabledRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<E2eeManagerSetEnabledRequest*>(&to_msg);
  auto& from = static_cast<const E2eeManagerSetEnabledRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.E2eeManagerSetEnabledRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void E2eeManagerSetEnabledRequest::CopyFrom(const E2eeManagerSetEnabledRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.E2eeManagerSetEnabledRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool E2eeManagerSetEnabledRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void E2eeManagerSetEnabledRequest::InternalSwap(E2eeManagerSetEnabledRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata E2eeManagerSetEnabledRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[3]);
}

// ===================================================================

class E2eeManagerSetEnabledResponse::_Internal {
 public:
};

E2eeManagerSetEnabledResponse::E2eeManagerSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeManagerSetEnabledResponse)
}
E2eeManagerSetEnabledResponse::E2eeManagerSetEnabledResponse(const E2eeManagerSetEnabledResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  E2eeManagerSetEnabledResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeManagerSetEnabledResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeManagerSetEnabledResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeManagerSetEnabledResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata E2eeManagerSetEnabledResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[4]);
}

// ===================================================================

class E2eeManagerGetFrameCryptorsRequest::_Internal {
 public:
};

E2eeManagerGetFrameCryptorsRequest::E2eeManagerGetFrameCryptorsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeManagerGetFrameCryptorsRequest)
}
E2eeManagerGetFrameCryptorsRequest::E2eeManagerGetFrameCryptorsRequest(const E2eeManagerGetFrameCryptorsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  E2eeManagerGetFrameCryptorsRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeManagerGetFrameCryptorsRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeManagerGetFrameCryptorsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeManagerGetFrameCryptorsRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata E2eeManagerGetFrameCryptorsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[5]);
}

// ===================================================================

class E2eeManagerGetFrameCryptorsResponse::_Internal {
 public:
};

E2eeManagerGetFrameCryptorsResponse::E2eeManagerGetFrameCryptorsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
}
E2eeManagerGetFrameCryptorsResponse::E2eeManagerGetFrameCryptorsResponse(const E2eeManagerGetFrameCryptorsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  E2eeManagerGetFrameCryptorsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_cryptors_){from._impl_.frame_cryptors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
}

inline void E2eeManagerGetFrameCryptorsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_cryptors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

E2eeManagerGetFrameCryptorsResponse::~E2eeManagerGetFrameCryptorsResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void E2eeManagerGetFrameCryptorsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.frame_cryptors_.~RepeatedPtrField();
}

void E2eeManagerGetFrameCryptorsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void E2eeManagerGetFrameCryptorsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.frame_cryptors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* E2eeManagerGetFrameCryptorsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .livekit.proto.FrameCryptor frame_cryptors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_frame_cryptors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* E2eeManagerGetFrameCryptorsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .livekit.proto.FrameCryptor frame_cryptors = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_frame_cryptors_size()); i < n; i++) {
    const auto& repfield = this->_internal_frame_cryptors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  return target;
}

size_t E2eeManagerGetFrameCryptorsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .livekit.proto.FrameCryptor frame_cryptors = 1;
  total_size += 1UL * this->_internal_frame_cryptors_size();
  for (const auto& msg : this->_impl_.frame_cryptors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeManagerGetFrameCryptorsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    E2eeManagerGetFrameCryptorsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeManagerGetFrameCryptorsResponse::GetClassData() const { return &_class_data_; }


void E2eeManagerGetFrameCryptorsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<E2eeManagerGetFrameCryptorsResponse*>(&to_msg);
  auto& from = static_cast<const E2eeManagerGetFrameCryptorsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.frame_cryptors_.MergeFrom(from._impl_.frame_cryptors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void E2eeManagerGetFrameCryptorsResponse::CopyFrom(const E2eeManagerGetFrameCryptorsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool E2eeManagerGetFrameCryptorsResponse::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.frame_cryptors_))
    return false;
  return true;
}

void E2eeManagerGetFrameCryptorsResponse::InternalSwap(E2eeManagerGetFrameCryptorsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.frame_cryptors_.InternalSwap(&other->_impl_.frame_cryptors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata E2eeManagerGetFrameCryptorsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[6]);
}

// ===================================================================

class FrameCryptorSetEnabledRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameCryptorSetEnabledRequest>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_track_sid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

FrameCryptorSetEnabledRequest::FrameCryptorSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FrameCryptorSetEnabledRequest)
}
FrameCryptorSetEnabledRequest::FrameCryptorSetEnabledRequest(const FrameCryptorSetEnabledRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameCryptorSetEnabledRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_track_sid()) {
    _this->_impl_.track_sid_.Set(from._internal_track_sid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FrameCryptorSetEnabledRequest)
}

inline void FrameCryptorSetEnabledRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameCryptorSetEnabledRequest::~FrameCryptorSetEnabledRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.FrameCryptorSetEnabledRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameCryptorSetEnabledRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
  _impl_.track_sid_.Destroy();
}

void FrameCryptorSetEnabledRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameCryptorSetEnabledRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.FrameCryptorSetEnabledRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.participant_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.track_sid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameCryptorSetEnabledRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptorSetEnabledRequest.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string track_sid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_track_sid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptorSetEnabledRequest.track_sid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required bool enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameCryptorSetEnabledRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.FrameCryptorSetEnabledRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptorSetEnabledRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required string track_sid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_track_sid().data(), static_cast<int>(this->_internal_track_sid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptorSetEnabledRequest.track_sid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_track_sid(), target);
  }

  // required bool enabled = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.FrameCryptorSetEnabledRequest)
  return target;
}

size_t FrameCryptorSetEnabledRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.FrameCryptorSetEnabledRequest)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_track_sid()) {
    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());
  }

  if (_internal_has_enabled()) {
    // required bool enabled = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t FrameCryptorSetEnabledRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.FrameCryptorSetEnabledRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());

    // required bool enabled = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameCryptorSetEnabledRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameCryptorSetEnabledRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameCryptorSetEnabledRequest::GetClassData() const { return &_class_data_; }


void FrameCryptorSetEnabledRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameCryptorSetEnabledRequest*>(&to_msg);
  auto& from = static_cast<const FrameCryptorSetEnabledRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.FrameCryptorSetEnabledRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_track_sid(from._internal_track_sid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameCryptorSetEnabledRequest::CopyFrom(const FrameCryptorSetEnabledRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.FrameCryptorSetEnabledRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameCryptorSetEnabledRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FrameCryptorSetEnabledRequest::InternalSwap(FrameCryptorSetEnabledRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.track_sid_, lhs_arena,
      &other->_impl_.track_sid_, rhs_arena
  );
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameCryptorSetEnabledRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[7]);
}

// ===================================================================

class FrameCryptorSetEnabledResponse::_Internal {
 public:
};

FrameCryptorSetEnabledResponse::FrameCryptorSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FrameCryptorSetEnabledResponse)
}
FrameCryptorSetEnabledResponse::FrameCryptorSetEnabledResponse(const FrameCryptorSetEnabledResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  FrameCryptorSetEnabledResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FrameCryptorSetEnabledResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameCryptorSetEnabledResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameCryptorSetEnabledResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata FrameCryptorSetEnabledResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[8]);
}

// ===================================================================

class FrameCryptorSetKeyIndexRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameCryptorSetKeyIndexRequest>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_track_sid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

FrameCryptorSetKeyIndexRequest::FrameCryptorSetKeyIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FrameCryptorSetKeyIndexRequest)
}
FrameCryptorSetKeyIndexRequest::FrameCryptorSetKeyIndexRequest(const FrameCryptorSetKeyIndexRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameCryptorSetKeyIndexRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_track_sid()) {
    _this->_impl_.track_sid_.Set(from._internal_track_sid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FrameCryptorSetKeyIndexRequest)
}

inline void FrameCryptorSetKeyIndexRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.track_sid_){}
    , decltype(_impl_.key_index_){0}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.track_sid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameCryptorSetKeyIndexRequest::~FrameCryptorSetKeyIndexRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.FrameCryptorSetKeyIndexRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameCryptorSetKeyIndexRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
  _impl_.track_sid_.Destroy();
}

void FrameCryptorSetKeyIndexRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameCryptorSetKeyIndexRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.participant_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.track_sid_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameCryptorSetKeyIndexRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string track_sid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_track_sid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameCryptorSetKeyIndexRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required string track_sid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_track_sid().data(), static_cast<int>(this->_internal_track_sid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_track_sid(), target);
  }

  // required int32 key_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.FrameCryptorSetKeyIndexRequest)
  return target;
}

size_t FrameCryptorSetKeyIndexRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_track_sid()) {
    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  return total_size;
}
size_t FrameCryptorSetKeyIndexRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required string track_sid = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_track_sid());

    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameCryptorSetKeyIndexRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameCryptorSetKeyIndexRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameCryptorSetKeyIndexRequest::GetClassData() const { return &_class_data_; }


void FrameCryptorSetKeyIndexRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameCryptorSetKeyIndexRequest*>(&to_msg);
  auto& from = static_cast<const FrameCryptorSetKeyIndexRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_track_sid(from._internal_track_sid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameCryptorSetKeyIndexRequest::CopyFrom(const FrameCryptorSetKeyIndexRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.FrameCryptorSetKeyIndexRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameCryptorSetKeyIndexRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FrameCryptorSetKeyIndexRequest::InternalSwap(FrameCryptorSetKeyIndexRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.track_sid_, lhs_arena,
      &other->_impl_.track_sid_, rhs_arena
  );
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameCryptorSetKeyIndexRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[9]);
}

// ===================================================================

class FrameCryptorSetKeyIndexResponse::_Internal {
 public:
};

FrameCryptorSetKeyIndexResponse::FrameCryptorSetKeyIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.FrameCryptorSetKeyIndexResponse)
}
FrameCryptorSetKeyIndexResponse::FrameCryptorSetKeyIndexResponse(const FrameCryptorSetKeyIndexResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  FrameCryptorSetKeyIndexResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.FrameCryptorSetKeyIndexResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameCryptorSetKeyIndexResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameCryptorSetKeyIndexResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata FrameCryptorSetKeyIndexResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[10]);
}

// ===================================================================

class SetSharedKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetSharedKeyRequest>()._impl_._has_bits_);
  static void set_has_shared_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SetSharedKeyRequest::SetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.SetSharedKeyRequest)
}
SetSharedKeyRequest::SetSharedKeyRequest(const SetSharedKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetSharedKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shared_key_){}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.shared_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shared_key()) {
    _this->_impl_.shared_key_.Set(from._internal_shared_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.SetSharedKeyRequest)
}

inline void SetSharedKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shared_key_){}
    , decltype(_impl_.key_index_){0}
  };
  _impl_.shared_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetSharedKeyRequest::~SetSharedKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.SetSharedKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetSharedKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.shared_key_.Destroy();
}

void SetSharedKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetSharedKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.SetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.shared_key_.ClearNonDefaultToEmpty();
  }
  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetSharedKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes shared_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_shared_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetSharedKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.SetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bytes shared_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_shared_key(), target);
  }

  // required int32 key_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.SetSharedKeyRequest)
  return target;
}

size_t SetSharedKeyRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.SetSharedKeyRequest)
  size_t total_size = 0;

  if (_internal_has_shared_key()) {
    // required bytes shared_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_shared_key());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  return total_size;
}
size_t SetSharedKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.SetSharedKeyRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes shared_key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_shared_key());

    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetSharedKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetSharedKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetSharedKeyRequest::GetClassData() const { return &_class_data_; }


void SetSharedKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetSharedKeyRequest*>(&to_msg);
  auto& from = static_cast<const SetSharedKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.SetSharedKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_shared_key(from._internal_shared_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetSharedKeyRequest::CopyFrom(const SetSharedKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.SetSharedKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetSharedKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SetSharedKeyRequest::InternalSwap(SetSharedKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shared_key_, lhs_arena,
      &other->_impl_.shared_key_, rhs_arena
  );
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetSharedKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[11]);
}

// ===================================================================

class SetSharedKeyResponse::_Internal {
 public:
};

SetSharedKeyResponse::SetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.SetSharedKeyResponse)
}
SetSharedKeyResponse::SetSharedKeyResponse(const SetSharedKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  SetSharedKeyResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.SetSharedKeyResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetSharedKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetSharedKeyResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SetSharedKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[12]);
}

// ===================================================================

class RatchetSharedKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RatchetSharedKeyRequest>()._impl_._has_bits_);
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RatchetSharedKeyRequest::RatchetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RatchetSharedKeyRequest)
}
RatchetSharedKeyRequest::RatchetSharedKeyRequest(const RatchetSharedKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RatchetSharedKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RatchetSharedKeyRequest)
}

inline void RatchetSharedKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_index_){0}
  };
}

RatchetSharedKeyRequest::~RatchetSharedKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.RatchetSharedKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RatchetSharedKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RatchetSharedKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RatchetSharedKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RatchetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RatchetSharedKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 key_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RatchetSharedKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RatchetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 key_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RatchetSharedKeyRequest)
  return target;
}

size_t RatchetSharedKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RatchetSharedKeyRequest)
  size_t total_size = 0;

  // required int32 key_index = 1;
  if (_internal_has_key_index()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RatchetSharedKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RatchetSharedKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RatchetSharedKeyRequest::GetClassData() const { return &_class_data_; }


void RatchetSharedKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RatchetSharedKeyRequest*>(&to_msg);
  auto& from = static_cast<const RatchetSharedKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RatchetSharedKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key_index()) {
    _this->_internal_set_key_index(from._internal_key_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RatchetSharedKeyRequest::CopyFrom(const RatchetSharedKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RatchetSharedKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RatchetSharedKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RatchetSharedKeyRequest::InternalSwap(RatchetSharedKeyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RatchetSharedKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[13]);
}

// ===================================================================

class RatchetSharedKeyResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RatchetSharedKeyResponse>()._impl_._has_bits_);
  static void set_has_new_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RatchetSharedKeyResponse::RatchetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RatchetSharedKeyResponse)
}
RatchetSharedKeyResponse::RatchetSharedKeyResponse(const RatchetSharedKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RatchetSharedKeyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.new_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_key()) {
    _this->_impl_.new_key_.Set(from._internal_new_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RatchetSharedKeyResponse)
}

inline void RatchetSharedKeyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_key_){}
  };
  _impl_.new_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RatchetSharedKeyResponse::~RatchetSharedKeyResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.RatchetSharedKeyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RatchetSharedKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_key_.Destroy();
}

void RatchetSharedKeyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RatchetSharedKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RatchetSharedKeyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.new_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RatchetSharedKeyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes new_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_new_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RatchetSharedKeyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RatchetSharedKeyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes new_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_new_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RatchetSharedKeyResponse)
  return target;
}

size_t RatchetSharedKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RatchetSharedKeyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes new_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_new_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RatchetSharedKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RatchetSharedKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RatchetSharedKeyResponse::GetClassData() const { return &_class_data_; }


void RatchetSharedKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RatchetSharedKeyResponse*>(&to_msg);
  auto& from = static_cast<const RatchetSharedKeyResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RatchetSharedKeyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_new_key()) {
    _this->_internal_set_new_key(from._internal_new_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RatchetSharedKeyResponse::CopyFrom(const RatchetSharedKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RatchetSharedKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RatchetSharedKeyResponse::IsInitialized() const {
  return true;
}

void RatchetSharedKeyResponse::InternalSwap(RatchetSharedKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_key_, lhs_arena,
      &other->_impl_.new_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RatchetSharedKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[14]);
}

// ===================================================================

class GetSharedKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetSharedKeyRequest>()._impl_._has_bits_);
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetSharedKeyRequest::GetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.GetSharedKeyRequest)
}
GetSharedKeyRequest::GetSharedKeyRequest(const GetSharedKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetSharedKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.GetSharedKeyRequest)
}

inline void GetSharedKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_index_){0}
  };
}

GetSharedKeyRequest::~GetSharedKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.GetSharedKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetSharedKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetSharedKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetSharedKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.GetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetSharedKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 key_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetSharedKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.GetSharedKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 key_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.GetSharedKeyRequest)
  return target;
}

size_t GetSharedKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.GetSharedKeyRequest)
  size_t total_size = 0;

  // required int32 key_index = 1;
  if (_internal_has_key_index()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetSharedKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetSharedKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetSharedKeyRequest::GetClassData() const { return &_class_data_; }


void GetSharedKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetSharedKeyRequest*>(&to_msg);
  auto& from = static_cast<const GetSharedKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.GetSharedKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key_index()) {
    _this->_internal_set_key_index(from._internal_key_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetSharedKeyRequest::CopyFrom(const GetSharedKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.GetSharedKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSharedKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GetSharedKeyRequest::InternalSwap(GetSharedKeyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetSharedKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[15]);
}

// ===================================================================

class GetSharedKeyResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetSharedKeyResponse>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetSharedKeyResponse::GetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.GetSharedKeyResponse)
}
GetSharedKeyResponse::GetSharedKeyResponse(const GetSharedKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetSharedKeyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.GetSharedKeyResponse)
}

inline void GetSharedKeyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetSharedKeyResponse::~GetSharedKeyResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.GetSharedKeyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetSharedKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void GetSharedKeyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetSharedKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.GetSharedKeyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetSharedKeyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetSharedKeyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.GetSharedKeyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.GetSharedKeyResponse)
  return target;
}

size_t GetSharedKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.GetSharedKeyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetSharedKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetSharedKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetSharedKeyResponse::GetClassData() const { return &_class_data_; }


void GetSharedKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetSharedKeyResponse*>(&to_msg);
  auto& from = static_cast<const GetSharedKeyResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.GetSharedKeyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetSharedKeyResponse::CopyFrom(const GetSharedKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.GetSharedKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSharedKeyResponse::IsInitialized() const {
  return true;
}

void GetSharedKeyResponse::InternalSwap(GetSharedKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetSharedKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[16]);
}

// ===================================================================

class SetKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SetKeyRequest>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

SetKeyRequest::SetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.SetKeyRequest)
}
SetKeyRequest::SetKeyRequest(const SetKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.SetKeyRequest)
}

inline void SetKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.key_index_){0}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SetKeyRequest::~SetKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.SetKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
  _impl_.key_.Destroy();
}

void SetKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.SetKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.participant_identity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.SetKeyRequest.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.SetKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.SetKeyRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required bytes key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // required int32 key_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.SetKeyRequest)
  return target;
}

size_t SetKeyRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.SetKeyRequest)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_key()) {
    // required bytes key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  return total_size;
}
size_t SetKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.SetKeyRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required bytes key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());

    // required int32 key_index = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetKeyRequest::GetClassData() const { return &_class_data_; }


void SetKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetKeyRequest*>(&to_msg);
  auto& from = static_cast<const SetKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.SetKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetKeyRequest::CopyFrom(const SetKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.SetKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SetKeyRequest::InternalSwap(SetKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[17]);
}

// ===================================================================

class SetKeyResponse::_Internal {
 public:
};

SetKeyResponse::SetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:livekit.proto.SetKeyResponse)
}
SetKeyResponse::SetKeyResponse(const SetKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  SetKeyResponse* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.proto.SetKeyResponse)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetKeyResponse::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SetKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[18]);
}

// ===================================================================

class RatchetKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RatchetKeyRequest>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RatchetKeyRequest::RatchetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RatchetKeyRequest)
}
RatchetKeyRequest::RatchetKeyRequest(const RatchetKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RatchetKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RatchetKeyRequest)
}

inline void RatchetKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_index_){0}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RatchetKeyRequest::~RatchetKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.RatchetKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RatchetKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
}

void RatchetKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RatchetKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RatchetKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.participant_identity_.ClearNonDefaultToEmpty();
  }
  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RatchetKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.RatchetKeyRequest.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RatchetKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RatchetKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.RatchetKeyRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required int32 key_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RatchetKeyRequest)
  return target;
}

size_t RatchetKeyRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.RatchetKeyRequest)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  return total_size;
}
size_t RatchetKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RatchetKeyRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RatchetKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RatchetKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RatchetKeyRequest::GetClassData() const { return &_class_data_; }


void RatchetKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RatchetKeyRequest*>(&to_msg);
  auto& from = static_cast<const RatchetKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RatchetKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RatchetKeyRequest::CopyFrom(const RatchetKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RatchetKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RatchetKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void RatchetKeyRequest::InternalSwap(RatchetKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RatchetKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[19]);
}

// ===================================================================

class RatchetKeyResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RatchetKeyResponse>()._impl_._has_bits_);
  static void set_has_new_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RatchetKeyResponse::RatchetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.RatchetKeyResponse)
}
RatchetKeyResponse::RatchetKeyResponse(const RatchetKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RatchetKeyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.new_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_key()) {
    _this->_impl_.new_key_.Set(from._internal_new_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.RatchetKeyResponse)
}

inline void RatchetKeyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.new_key_){}
  };
  _impl_.new_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RatchetKeyResponse::~RatchetKeyResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.RatchetKeyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RatchetKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.new_key_.Destroy();
}

void RatchetKeyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RatchetKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.RatchetKeyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.new_key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RatchetKeyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes new_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_new_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RatchetKeyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.RatchetKeyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes new_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_new_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.RatchetKeyResponse)
  return target;
}

size_t RatchetKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.RatchetKeyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes new_key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_new_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RatchetKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RatchetKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RatchetKeyResponse::GetClassData() const { return &_class_data_; }


void RatchetKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RatchetKeyResponse*>(&to_msg);
  auto& from = static_cast<const RatchetKeyResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.RatchetKeyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_new_key()) {
    _this->_internal_set_new_key(from._internal_new_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RatchetKeyResponse::CopyFrom(const RatchetKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.RatchetKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RatchetKeyResponse::IsInitialized() const {
  return true;
}

void RatchetKeyResponse::InternalSwap(RatchetKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.new_key_, lhs_arena,
      &other->_impl_.new_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RatchetKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[20]);
}

// ===================================================================

class GetKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetKeyRequest>()._impl_._has_bits_);
  static void set_has_participant_identity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GetKeyRequest::GetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.GetKeyRequest)
}
GetKeyRequest::GetKeyRequest(const GetKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetKeyRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_participant_identity()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.key_index_ = from._impl_.key_index_;
  // @@protoc_insertion_point(copy_constructor:livekit.proto.GetKeyRequest)
}

inline void GetKeyRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.key_index_){0}
  };
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetKeyRequest::~GetKeyRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.GetKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.participant_identity_.Destroy();
}

void GetKeyRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.GetKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.participant_identity_.ClearNonDefaultToEmpty();
  }
  _impl_.key_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string participant_identity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "livekit.proto.GetKeyRequest.participant_identity");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 key_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_key_index(&has_bits);
          _impl_.key_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.GetKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string participant_identity = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "livekit.proto.GetKeyRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_participant_identity(), target);
  }

  // required int32 key_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_key_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.GetKeyRequest)
  return target;
}

size_t GetKeyRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:livekit.proto.GetKeyRequest)
  size_t total_size = 0;

  if (_internal_has_participant_identity()) {
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  if (_internal_has_key_index()) {
    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());
  }

  return total_size;
}
size_t GetKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.GetKeyRequest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string participant_identity = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());

    // required int32 key_index = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetKeyRequest::GetClassData() const { return &_class_data_; }


void GetKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetKeyRequest*>(&to_msg);
  auto& from = static_cast<const GetKeyRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.GetKeyRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_participant_identity(from._internal_participant_identity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.key_index_ = from._impl_.key_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetKeyRequest::CopyFrom(const GetKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.GetKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetKeyRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GetKeyRequest::InternalSwap(GetKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  swap(_impl_.key_index_, other->_impl_.key_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetKeyRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[21]);
}

// ===================================================================

class GetKeyResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetKeyResponse>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetKeyResponse::GetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.GetKeyResponse)
}
GetKeyResponse::GetKeyResponse(const GetKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetKeyResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.GetKeyResponse)
}

inline void GetKeyResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetKeyResponse::~GetKeyResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.GetKeyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void GetKeyResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.GetKeyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.key_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetKeyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetKeyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.GetKeyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.GetKeyResponse)
  return target;
}

size_t GetKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.GetKeyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes key = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetKeyResponse::GetClassData() const { return &_class_data_; }


void GetKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetKeyResponse*>(&to_msg);
  auto& from = static_cast<const GetKeyResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.GetKeyResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_key()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetKeyResponse::CopyFrom(const GetKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.GetKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetKeyResponse::IsInitialized() const {
  return true;
}

void GetKeyResponse::InternalSwap(GetKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetKeyResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[22]);
}

// ===================================================================

class E2eeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<E2eeRequest>()._impl_._has_bits_);
  static void set_has_room_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::proto::E2eeManagerSetEnabledRequest& manager_set_enabled(const E2eeRequest* msg);
  static const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest& manager_get_frame_cryptors(const E2eeRequest* msg);
  static const ::livekit::proto::FrameCryptorSetEnabledRequest& cryptor_set_enabled(const E2eeRequest* msg);
  static const ::livekit::proto::FrameCryptorSetKeyIndexRequest& cryptor_set_key_index(const E2eeRequest* msg);
  static const ::livekit::proto::SetSharedKeyRequest& set_shared_key(const E2eeRequest* msg);
  static const ::livekit::proto::RatchetSharedKeyRequest& ratchet_shared_key(const E2eeRequest* msg);
  static const ::livekit::proto::GetSharedKeyRequest& get_shared_key(const E2eeRequest* msg);
  static const ::livekit::proto::SetKeyRequest& set_key(const E2eeRequest* msg);
  static const ::livekit::proto::RatchetKeyRequest& ratchet_key(const E2eeRequest* msg);
  static const ::livekit::proto::GetKeyRequest& get_key(const E2eeRequest* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::livekit::proto::E2eeManagerSetEnabledRequest&
E2eeRequest::_Internal::manager_set_enabled(const E2eeRequest* msg) {
  return *msg->_impl_.message_.manager_set_enabled_;
}
const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest&
E2eeRequest::_Internal::manager_get_frame_cryptors(const E2eeRequest* msg) {
  return *msg->_impl_.message_.manager_get_frame_cryptors_;
}
const ::livekit::proto::FrameCryptorSetEnabledRequest&
E2eeRequest::_Internal::cryptor_set_enabled(const E2eeRequest* msg) {
  return *msg->_impl_.message_.cryptor_set_enabled_;
}
const ::livekit::proto::FrameCryptorSetKeyIndexRequest&
E2eeRequest::_Internal::cryptor_set_key_index(const E2eeRequest* msg) {
  return *msg->_impl_.message_.cryptor_set_key_index_;
}
const ::livekit::proto::SetSharedKeyRequest&
E2eeRequest::_Internal::set_shared_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.set_shared_key_;
}
const ::livekit::proto::RatchetSharedKeyRequest&
E2eeRequest::_Internal::ratchet_shared_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.ratchet_shared_key_;
}
const ::livekit::proto::GetSharedKeyRequest&
E2eeRequest::_Internal::get_shared_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.get_shared_key_;
}
const ::livekit::proto::SetKeyRequest&
E2eeRequest::_Internal::set_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.set_key_;
}
const ::livekit::proto::RatchetKeyRequest&
E2eeRequest::_Internal::ratchet_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.ratchet_key_;
}
const ::livekit::proto::GetKeyRequest&
E2eeRequest::_Internal::get_key(const E2eeRequest* msg) {
  return *msg->_impl_.message_.get_key_;
}
void E2eeRequest::set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledRequest* manager_set_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (manager_set_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manager_set_enabled);
    if (message_arena != submessage_arena) {
      manager_set_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manager_set_enabled, submessage_arena);
    }
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = manager_set_enabled;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.manager_set_enabled)
}
void E2eeRequest::set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsRequest* manager_get_frame_cryptors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (manager_get_frame_cryptors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manager_get_frame_cryptors);
    if (message_arena != submessage_arena) {
      manager_get_frame_cryptors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manager_get_frame_cryptors, submessage_arena);
    }
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = manager_get_frame_cryptors;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
}
void E2eeRequest::set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledRequest* cryptor_set_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (cryptor_set_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cryptor_set_enabled);
    if (message_arena != submessage_arena) {
      cryptor_set_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cryptor_set_enabled, submessage_arena);
    }
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = cryptor_set_enabled;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.cryptor_set_enabled)
}
void E2eeRequest::set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexRequest* cryptor_set_key_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (cryptor_set_key_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cryptor_set_key_index);
    if (message_arena != submessage_arena) {
      cryptor_set_key_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cryptor_set_key_index, submessage_arena);
    }
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = cryptor_set_key_index;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.cryptor_set_key_index)
}
void E2eeRequest::set_allocated_set_shared_key(::livekit::proto::SetSharedKeyRequest* set_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (set_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_shared_key);
    if (message_arena != submessage_arena) {
      set_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_shared_key, submessage_arena);
    }
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = set_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.set_shared_key)
}
void E2eeRequest::set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyRequest* ratchet_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ratchet_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ratchet_shared_key);
    if (message_arena != submessage_arena) {
      ratchet_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ratchet_shared_key, submessage_arena);
    }
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = ratchet_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.ratchet_shared_key)
}
void E2eeRequest::set_allocated_get_shared_key(::livekit::proto::GetSharedKeyRequest* get_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (get_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_shared_key);
    if (message_arena != submessage_arena) {
      get_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_shared_key, submessage_arena);
    }
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = get_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.get_shared_key)
}
void E2eeRequest::set_allocated_set_key(::livekit::proto::SetKeyRequest* set_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (set_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_key);
    if (message_arena != submessage_arena) {
      set_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_key, submessage_arena);
    }
    set_has_set_key();
    _impl_.message_.set_key_ = set_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.set_key)
}
void E2eeRequest::set_allocated_ratchet_key(::livekit::proto::RatchetKeyRequest* ratchet_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ratchet_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ratchet_key);
    if (message_arena != submessage_arena) {
      ratchet_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ratchet_key, submessage_arena);
    }
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = ratchet_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.ratchet_key)
}
void E2eeRequest::set_allocated_get_key(::livekit::proto::GetKeyRequest* get_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (get_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_key);
    if (message_arena != submessage_arena) {
      get_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_key, submessage_arena);
    }
    set_has_get_key();
    _impl_.message_.get_key_ = get_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeRequest.get_key)
}
E2eeRequest::E2eeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeRequest)
}
E2eeRequest::E2eeRequest(const E2eeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  E2eeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.room_handle_){}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.room_handle_ = from._impl_.room_handle_;
  clear_has_message();
  switch (from.message_case()) {
    case kManagerSetEnabled: {
      _this->_internal_mutable_manager_set_enabled()->::livekit::proto::E2eeManagerSetEnabledRequest::MergeFrom(
          from._internal_manager_set_enabled());
      break;
    }
    case kManagerGetFrameCryptors: {
      _this->_internal_mutable_manager_get_frame_cryptors()->::livekit::proto::E2eeManagerGetFrameCryptorsRequest::MergeFrom(
          from._internal_manager_get_frame_cryptors());
      break;
    }
    case kCryptorSetEnabled: {
      _this->_internal_mutable_cryptor_set_enabled()->::livekit::proto::FrameCryptorSetEnabledRequest::MergeFrom(
          from._internal_cryptor_set_enabled());
      break;
    }
    case kCryptorSetKeyIndex: {
      _this->_internal_mutable_cryptor_set_key_index()->::livekit::proto::FrameCryptorSetKeyIndexRequest::MergeFrom(
          from._internal_cryptor_set_key_index());
      break;
    }
    case kSetSharedKey: {
      _this->_internal_mutable_set_shared_key()->::livekit::proto::SetSharedKeyRequest::MergeFrom(
          from._internal_set_shared_key());
      break;
    }
    case kRatchetSharedKey: {
      _this->_internal_mutable_ratchet_shared_key()->::livekit::proto::RatchetSharedKeyRequest::MergeFrom(
          from._internal_ratchet_shared_key());
      break;
    }
    case kGetSharedKey: {
      _this->_internal_mutable_get_shared_key()->::livekit::proto::GetSharedKeyRequest::MergeFrom(
          from._internal_get_shared_key());
      break;
    }
    case kSetKey: {
      _this->_internal_mutable_set_key()->::livekit::proto::SetKeyRequest::MergeFrom(
          from._internal_set_key());
      break;
    }
    case kRatchetKey: {
      _this->_internal_mutable_ratchet_key()->::livekit::proto::RatchetKeyRequest::MergeFrom(
          from._internal_ratchet_key());
      break;
    }
    case kGetKey: {
      _this->_internal_mutable_get_key()->::livekit::proto::GetKeyRequest::MergeFrom(
          from._internal_get_key());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeRequest)
}

inline void E2eeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.room_handle_){uint64_t{0u}}
    , decltype(_impl_.message_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

E2eeRequest::~E2eeRequest() {
  // @@protoc_insertion_point(destructor:livekit.proto.E2eeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void E2eeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void E2eeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void E2eeRequest::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.E2eeRequest)
  switch (message_case()) {
    case kManagerSetEnabled: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.manager_set_enabled_;
      }
      break;
    }
    case kManagerGetFrameCryptors: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.manager_get_frame_cryptors_;
      }
      break;
    }
    case kCryptorSetEnabled: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.cryptor_set_enabled_;
      }
      break;
    }
    case kCryptorSetKeyIndex: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.cryptor_set_key_index_;
      }
      break;
    }
    case kSetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.set_shared_key_;
      }
      break;
    }
    case kRatchetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ratchet_shared_key_;
      }
      break;
    }
    case kGetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.get_shared_key_;
      }
      break;
    }
    case kSetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.set_key_;
      }
      break;
    }
    case kRatchetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ratchet_key_;
      }
      break;
    }
    case kGetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.get_key_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void E2eeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.E2eeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.room_handle_ = uint64_t{0u};
  clear_message();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* E2eeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 room_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_room_handle(&has_bits);
          _impl_.room_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.E2eeManagerSetEnabledRequest manager_set_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_manager_set_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.E2eeManagerGetFrameCryptorsRequest manager_get_frame_cryptors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_manager_get_frame_cryptors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.FrameCryptorSetEnabledRequest cryptor_set_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cryptor_set_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.FrameCryptorSetKeyIndexRequest cryptor_set_key_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cryptor_set_key_index(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.SetSharedKeyRequest set_shared_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.RatchetSharedKeyRequest ratchet_shared_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ratchet_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.GetSharedKeyRequest get_shared_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.SetKeyRequest set_key = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.RatchetKeyRequest ratchet_key = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_ratchet_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.GetKeyRequest get_key = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* E2eeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.E2eeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 room_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_room_handle(), target);
  }

  switch (message_case()) {
    case kManagerSetEnabled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::manager_set_enabled(this),
          _Internal::manager_set_enabled(this).GetCachedSize(), target, stream);
      break;
    }
    case kManagerGetFrameCryptors: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::manager_get_frame_cryptors(this),
          _Internal::manager_get_frame_cryptors(this).GetCachedSize(), target, stream);
      break;
    }
    case kCryptorSetEnabled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::cryptor_set_enabled(this),
          _Internal::cryptor_set_enabled(this).GetCachedSize(), target, stream);
      break;
    }
    case kCryptorSetKeyIndex: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::cryptor_set_key_index(this),
          _Internal::cryptor_set_key_index(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::set_shared_key(this),
          _Internal::set_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kRatchetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::ratchet_shared_key(this),
          _Internal::ratchet_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::get_shared_key(this),
          _Internal::get_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::set_key(this),
          _Internal::set_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kRatchetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::ratchet_key(this),
          _Internal::ratchet_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::get_key(this),
          _Internal::get_key(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.E2eeRequest)
  return target;
}

size_t E2eeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.E2eeRequest)
  size_t total_size = 0;

  // required uint64 room_handle = 1;
  if (_internal_has_room_handle()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_room_handle());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .livekit.proto.E2eeManagerSetEnabledRequest manager_set_enabled = 2;
    case kManagerSetEnabled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.manager_set_enabled_);
      break;
    }
    // .livekit.proto.E2eeManagerGetFrameCryptorsRequest manager_get_frame_cryptors = 3;
    case kManagerGetFrameCryptors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.manager_get_frame_cryptors_);
      break;
    }
    // .livekit.proto.FrameCryptorSetEnabledRequest cryptor_set_enabled = 4;
    case kCryptorSetEnabled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.cryptor_set_enabled_);
      break;
    }
    // .livekit.proto.FrameCryptorSetKeyIndexRequest cryptor_set_key_index = 5;
    case kCryptorSetKeyIndex: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.cryptor_set_key_index_);
      break;
    }
    // .livekit.proto.SetSharedKeyRequest set_shared_key = 6;
    case kSetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.set_shared_key_);
      break;
    }
    // .livekit.proto.RatchetSharedKeyRequest ratchet_shared_key = 7;
    case kRatchetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ratchet_shared_key_);
      break;
    }
    // .livekit.proto.GetSharedKeyRequest get_shared_key = 8;
    case kGetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.get_shared_key_);
      break;
    }
    // .livekit.proto.SetKeyRequest set_key = 9;
    case kSetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.set_key_);
      break;
    }
    // .livekit.proto.RatchetKeyRequest ratchet_key = 10;
    case kRatchetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ratchet_key_);
      break;
    }
    // .livekit.proto.GetKeyRequest get_key = 11;
    case kGetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.get_key_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    E2eeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeRequest::GetClassData() const { return &_class_data_; }


void E2eeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<E2eeRequest*>(&to_msg);
  auto& from = static_cast<const E2eeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.E2eeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_room_handle()) {
    _this->_internal_set_room_handle(from._internal_room_handle());
  }
  switch (from.message_case()) {
    case kManagerSetEnabled: {
      _this->_internal_mutable_manager_set_enabled()->::livekit::proto::E2eeManagerSetEnabledRequest::MergeFrom(
          from._internal_manager_set_enabled());
      break;
    }
    case kManagerGetFrameCryptors: {
      _this->_internal_mutable_manager_get_frame_cryptors()->::livekit::proto::E2eeManagerGetFrameCryptorsRequest::MergeFrom(
          from._internal_manager_get_frame_cryptors());
      break;
    }
    case kCryptorSetEnabled: {
      _this->_internal_mutable_cryptor_set_enabled()->::livekit::proto::FrameCryptorSetEnabledRequest::MergeFrom(
          from._internal_cryptor_set_enabled());
      break;
    }
    case kCryptorSetKeyIndex: {
      _this->_internal_mutable_cryptor_set_key_index()->::livekit::proto::FrameCryptorSetKeyIndexRequest::MergeFrom(
          from._internal_cryptor_set_key_index());
      break;
    }
    case kSetSharedKey: {
      _this->_internal_mutable_set_shared_key()->::livekit::proto::SetSharedKeyRequest::MergeFrom(
          from._internal_set_shared_key());
      break;
    }
    case kRatchetSharedKey: {
      _this->_internal_mutable_ratchet_shared_key()->::livekit::proto::RatchetSharedKeyRequest::MergeFrom(
          from._internal_ratchet_shared_key());
      break;
    }
    case kGetSharedKey: {
      _this->_internal_mutable_get_shared_key()->::livekit::proto::GetSharedKeyRequest::MergeFrom(
          from._internal_get_shared_key());
      break;
    }
    case kSetKey: {
      _this->_internal_mutable_set_key()->::livekit::proto::SetKeyRequest::MergeFrom(
          from._internal_set_key());
      break;
    }
    case kRatchetKey: {
      _this->_internal_mutable_ratchet_key()->::livekit::proto::RatchetKeyRequest::MergeFrom(
          from._internal_ratchet_key());
      break;
    }
    case kGetKey: {
      _this->_internal_mutable_get_key()->::livekit::proto::GetKeyRequest::MergeFrom(
          from._internal_get_key());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void E2eeRequest::CopyFrom(const E2eeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.E2eeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool E2eeRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (message_case()) {
    case kManagerSetEnabled: {
      if (_internal_has_manager_set_enabled()) {
        if (!_impl_.message_.manager_set_enabled_->IsInitialized()) return false;
      }
      break;
    }
    case kManagerGetFrameCryptors: {
      break;
    }
    case kCryptorSetEnabled: {
      if (_internal_has_cryptor_set_enabled()) {
        if (!_impl_.message_.cryptor_set_enabled_->IsInitialized()) return false;
      }
      break;
    }
    case kCryptorSetKeyIndex: {
      if (_internal_has_cryptor_set_key_index()) {
        if (!_impl_.message_.cryptor_set_key_index_->IsInitialized()) return false;
      }
      break;
    }
    case kSetSharedKey: {
      if (_internal_has_set_shared_key()) {
        if (!_impl_.message_.set_shared_key_->IsInitialized()) return false;
      }
      break;
    }
    case kRatchetSharedKey: {
      if (_internal_has_ratchet_shared_key()) {
        if (!_impl_.message_.ratchet_shared_key_->IsInitialized()) return false;
      }
      break;
    }
    case kGetSharedKey: {
      if (_internal_has_get_shared_key()) {
        if (!_impl_.message_.get_shared_key_->IsInitialized()) return false;
      }
      break;
    }
    case kSetKey: {
      if (_internal_has_set_key()) {
        if (!_impl_.message_.set_key_->IsInitialized()) return false;
      }
      break;
    }
    case kRatchetKey: {
      if (_internal_has_ratchet_key()) {
        if (!_impl_.message_.ratchet_key_->IsInitialized()) return false;
      }
      break;
    }
    case kGetKey: {
      if (_internal_has_get_key()) {
        if (!_impl_.message_.get_key_->IsInitialized()) return false;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void E2eeRequest::InternalSwap(E2eeRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.room_handle_, other->_impl_.room_handle_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata E2eeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[23]);
}

// ===================================================================

class E2eeResponse::_Internal {
 public:
  static const ::livekit::proto::E2eeManagerSetEnabledResponse& manager_set_enabled(const E2eeResponse* msg);
  static const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse& manager_get_frame_cryptors(const E2eeResponse* msg);
  static const ::livekit::proto::FrameCryptorSetEnabledResponse& cryptor_set_enabled(const E2eeResponse* msg);
  static const ::livekit::proto::FrameCryptorSetKeyIndexResponse& cryptor_set_key_index(const E2eeResponse* msg);
  static const ::livekit::proto::SetSharedKeyResponse& set_shared_key(const E2eeResponse* msg);
  static const ::livekit::proto::RatchetSharedKeyResponse& ratchet_shared_key(const E2eeResponse* msg);
  static const ::livekit::proto::GetSharedKeyResponse& get_shared_key(const E2eeResponse* msg);
  static const ::livekit::proto::SetKeyResponse& set_key(const E2eeResponse* msg);
  static const ::livekit::proto::RatchetKeyResponse& ratchet_key(const E2eeResponse* msg);
  static const ::livekit::proto::GetKeyResponse& get_key(const E2eeResponse* msg);
};

const ::livekit::proto::E2eeManagerSetEnabledResponse&
E2eeResponse::_Internal::manager_set_enabled(const E2eeResponse* msg) {
  return *msg->_impl_.message_.manager_set_enabled_;
}
const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse&
E2eeResponse::_Internal::manager_get_frame_cryptors(const E2eeResponse* msg) {
  return *msg->_impl_.message_.manager_get_frame_cryptors_;
}
const ::livekit::proto::FrameCryptorSetEnabledResponse&
E2eeResponse::_Internal::cryptor_set_enabled(const E2eeResponse* msg) {
  return *msg->_impl_.message_.cryptor_set_enabled_;
}
const ::livekit::proto::FrameCryptorSetKeyIndexResponse&
E2eeResponse::_Internal::cryptor_set_key_index(const E2eeResponse* msg) {
  return *msg->_impl_.message_.cryptor_set_key_index_;
}
const ::livekit::proto::SetSharedKeyResponse&
E2eeResponse::_Internal::set_shared_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.set_shared_key_;
}
const ::livekit::proto::RatchetSharedKeyResponse&
E2eeResponse::_Internal::ratchet_shared_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.ratchet_shared_key_;
}
const ::livekit::proto::GetSharedKeyResponse&
E2eeResponse::_Internal::get_shared_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.get_shared_key_;
}
const ::livekit::proto::SetKeyResponse&
E2eeResponse::_Internal::set_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.set_key_;
}
const ::livekit::proto::RatchetKeyResponse&
E2eeResponse::_Internal::ratchet_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.ratchet_key_;
}
const ::livekit::proto::GetKeyResponse&
E2eeResponse::_Internal::get_key(const E2eeResponse* msg) {
  return *msg->_impl_.message_.get_key_;
}
void E2eeResponse::set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledResponse* manager_set_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (manager_set_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manager_set_enabled);
    if (message_arena != submessage_arena) {
      manager_set_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manager_set_enabled, submessage_arena);
    }
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = manager_set_enabled;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.manager_set_enabled)
}
void E2eeResponse::set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsResponse* manager_get_frame_cryptors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (manager_get_frame_cryptors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manager_get_frame_cryptors);
    if (message_arena != submessage_arena) {
      manager_get_frame_cryptors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manager_get_frame_cryptors, submessage_arena);
    }
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = manager_get_frame_cryptors;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
}
void E2eeResponse::set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledResponse* cryptor_set_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (cryptor_set_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cryptor_set_enabled);
    if (message_arena != submessage_arena) {
      cryptor_set_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cryptor_set_enabled, submessage_arena);
    }
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = cryptor_set_enabled;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.cryptor_set_enabled)
}
void E2eeResponse::set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexResponse* cryptor_set_key_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (cryptor_set_key_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cryptor_set_key_index);
    if (message_arena != submessage_arena) {
      cryptor_set_key_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cryptor_set_key_index, submessage_arena);
    }
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = cryptor_set_key_index;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.cryptor_set_key_index)
}
void E2eeResponse::set_allocated_set_shared_key(::livekit::proto::SetSharedKeyResponse* set_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (set_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_shared_key);
    if (message_arena != submessage_arena) {
      set_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_shared_key, submessage_arena);
    }
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = set_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.set_shared_key)
}
void E2eeResponse::set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyResponse* ratchet_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ratchet_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ratchet_shared_key);
    if (message_arena != submessage_arena) {
      ratchet_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ratchet_shared_key, submessage_arena);
    }
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = ratchet_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.ratchet_shared_key)
}
void E2eeResponse::set_allocated_get_shared_key(::livekit::proto::GetSharedKeyResponse* get_shared_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (get_shared_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_shared_key);
    if (message_arena != submessage_arena) {
      get_shared_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_shared_key, submessage_arena);
    }
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = get_shared_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.get_shared_key)
}
void E2eeResponse::set_allocated_set_key(::livekit::proto::SetKeyResponse* set_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (set_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_key);
    if (message_arena != submessage_arena) {
      set_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_key, submessage_arena);
    }
    set_has_set_key();
    _impl_.message_.set_key_ = set_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.set_key)
}
void E2eeResponse::set_allocated_ratchet_key(::livekit::proto::RatchetKeyResponse* ratchet_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (ratchet_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ratchet_key);
    if (message_arena != submessage_arena) {
      ratchet_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ratchet_key, submessage_arena);
    }
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = ratchet_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.ratchet_key)
}
void E2eeResponse::set_allocated_get_key(::livekit::proto::GetKeyResponse* get_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (get_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_key);
    if (message_arena != submessage_arena) {
      get_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_key, submessage_arena);
    }
    set_has_get_key();
    _impl_.message_.get_key_ = get_key;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeResponse.get_key)
}
E2eeResponse::E2eeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.proto.E2eeResponse)
}
E2eeResponse::E2eeResponse(const E2eeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  E2eeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kManagerSetEnabled: {
      _this->_internal_mutable_manager_set_enabled()->::livekit::proto::E2eeManagerSetEnabledResponse::MergeFrom(
          from._internal_manager_set_enabled());
      break;
    }
    case kManagerGetFrameCryptors: {
      _this->_internal_mutable_manager_get_frame_cryptors()->::livekit::proto::E2eeManagerGetFrameCryptorsResponse::MergeFrom(
          from._internal_manager_get_frame_cryptors());
      break;
    }
    case kCryptorSetEnabled: {
      _this->_internal_mutable_cryptor_set_enabled()->::livekit::proto::FrameCryptorSetEnabledResponse::MergeFrom(
          from._internal_cryptor_set_enabled());
      break;
    }
    case kCryptorSetKeyIndex: {
      _this->_internal_mutable_cryptor_set_key_index()->::livekit::proto::FrameCryptorSetKeyIndexResponse::MergeFrom(
          from._internal_cryptor_set_key_index());
      break;
    }
    case kSetSharedKey: {
      _this->_internal_mutable_set_shared_key()->::livekit::proto::SetSharedKeyResponse::MergeFrom(
          from._internal_set_shared_key());
      break;
    }
    case kRatchetSharedKey: {
      _this->_internal_mutable_ratchet_shared_key()->::livekit::proto::RatchetSharedKeyResponse::MergeFrom(
          from._internal_ratchet_shared_key());
      break;
    }
    case kGetSharedKey: {
      _this->_internal_mutable_get_shared_key()->::livekit::proto::GetSharedKeyResponse::MergeFrom(
          from._internal_get_shared_key());
      break;
    }
    case kSetKey: {
      _this->_internal_mutable_set_key()->::livekit::proto::SetKeyResponse::MergeFrom(
          from._internal_set_key());
      break;
    }
    case kRatchetKey: {
      _this->_internal_mutable_ratchet_key()->::livekit::proto::RatchetKeyResponse::MergeFrom(
          from._internal_ratchet_key());
      break;
    }
    case kGetKey: {
      _this->_internal_mutable_get_key()->::livekit::proto::GetKeyResponse::MergeFrom(
          from._internal_get_key());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.proto.E2eeResponse)
}

inline void E2eeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

E2eeResponse::~E2eeResponse() {
  // @@protoc_insertion_point(destructor:livekit.proto.E2eeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void E2eeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void E2eeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void E2eeResponse::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:livekit.proto.E2eeResponse)
  switch (message_case()) {
    case kManagerSetEnabled: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.manager_set_enabled_;
      }
      break;
    }
    case kManagerGetFrameCryptors: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.manager_get_frame_cryptors_;
      }
      break;
    }
    case kCryptorSetEnabled: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.cryptor_set_enabled_;
      }
      break;
    }
    case kCryptorSetKeyIndex: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.cryptor_set_key_index_;
      }
      break;
    }
    case kSetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.set_shared_key_;
      }
      break;
    }
    case kRatchetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ratchet_shared_key_;
      }
      break;
    }
    case kGetSharedKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.get_shared_key_;
      }
      break;
    }
    case kSetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.set_key_;
      }
      break;
    }
    case kRatchetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.ratchet_key_;
      }
      break;
    }
    case kGetKey: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.get_key_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void E2eeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.proto.E2eeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* E2eeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.proto.E2eeManagerSetEnabledResponse manager_set_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_manager_set_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.E2eeManagerGetFrameCryptorsResponse manager_get_frame_cryptors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_manager_get_frame_cryptors(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.FrameCryptorSetEnabledResponse cryptor_set_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cryptor_set_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.FrameCryptorSetKeyIndexResponse cryptor_set_key_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cryptor_set_key_index(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.SetSharedKeyResponse set_shared_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.RatchetSharedKeyResponse ratchet_shared_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ratchet_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.GetSharedKeyResponse get_shared_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_shared_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.SetKeyResponse set_key = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.RatchetKeyResponse ratchet_key = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_ratchet_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.proto.GetKeyResponse get_key = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* E2eeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.proto.E2eeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (message_case()) {
    case kManagerSetEnabled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::manager_set_enabled(this),
          _Internal::manager_set_enabled(this).GetCachedSize(), target, stream);
      break;
    }
    case kManagerGetFrameCryptors: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::manager_get_frame_cryptors(this),
          _Internal::manager_get_frame_cryptors(this).GetCachedSize(), target, stream);
      break;
    }
    case kCryptorSetEnabled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::cryptor_set_enabled(this),
          _Internal::cryptor_set_enabled(this).GetCachedSize(), target, stream);
      break;
    }
    case kCryptorSetKeyIndex: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::cryptor_set_key_index(this),
          _Internal::cryptor_set_key_index(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::set_shared_key(this),
          _Internal::set_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kRatchetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::ratchet_shared_key(this),
          _Internal::ratchet_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetSharedKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::get_shared_key(this),
          _Internal::get_shared_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::set_key(this),
          _Internal::set_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kRatchetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::ratchet_key(this),
          _Internal::ratchet_key(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetKey: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::get_key(this),
          _Internal::get_key(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.proto.E2eeResponse)
  return target;
}

size_t E2eeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.proto.E2eeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .livekit.proto.E2eeManagerSetEnabledResponse manager_set_enabled = 1;
    case kManagerSetEnabled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.manager_set_enabled_);
      break;
    }
    // .livekit.proto.E2eeManagerGetFrameCryptorsResponse manager_get_frame_cryptors = 2;
    case kManagerGetFrameCryptors: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.manager_get_frame_cryptors_);
      break;
    }
    // .livekit.proto.FrameCryptorSetEnabledResponse cryptor_set_enabled = 3;
    case kCryptorSetEnabled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.cryptor_set_enabled_);
      break;
    }
    // .livekit.proto.FrameCryptorSetKeyIndexResponse cryptor_set_key_index = 4;
    case kCryptorSetKeyIndex: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.cryptor_set_key_index_);
      break;
    }
    // .livekit.proto.SetSharedKeyResponse set_shared_key = 5;
    case kSetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.set_shared_key_);
      break;
    }
    // .livekit.proto.RatchetSharedKeyResponse ratchet_shared_key = 6;
    case kRatchetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ratchet_shared_key_);
      break;
    }
    // .livekit.proto.GetSharedKeyResponse get_shared_key = 7;
    case kGetSharedKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.get_shared_key_);
      break;
    }
    // .livekit.proto.SetKeyResponse set_key = 8;
    case kSetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.set_key_);
      break;
    }
    // .livekit.proto.RatchetKeyResponse ratchet_key = 9;
    case kRatchetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.ratchet_key_);
      break;
    }
    // .livekit.proto.GetKeyResponse get_key = 10;
    case kGetKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.get_key_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData E2eeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    E2eeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*E2eeResponse::GetClassData() const { return &_class_data_; }


void E2eeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<E2eeResponse*>(&to_msg);
  auto& from = static_cast<const E2eeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.proto.E2eeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kManagerSetEnabled: {
      _this->_internal_mutable_manager_set_enabled()->::livekit::proto::E2eeManagerSetEnabledResponse::MergeFrom(
          from._internal_manager_set_enabled());
      break;
    }
    case kManagerGetFrameCryptors: {
      _this->_internal_mutable_manager_get_frame_cryptors()->::livekit::proto::E2eeManagerGetFrameCryptorsResponse::MergeFrom(
          from._internal_manager_get_frame_cryptors());
      break;
    }
    case kCryptorSetEnabled: {
      _this->_internal_mutable_cryptor_set_enabled()->::livekit::proto::FrameCryptorSetEnabledResponse::MergeFrom(
          from._internal_cryptor_set_enabled());
      break;
    }
    case kCryptorSetKeyIndex: {
      _this->_internal_mutable_cryptor_set_key_index()->::livekit::proto::FrameCryptorSetKeyIndexResponse::MergeFrom(
          from._internal_cryptor_set_key_index());
      break;
    }
    case kSetSharedKey: {
      _this->_internal_mutable_set_shared_key()->::livekit::proto::SetSharedKeyResponse::MergeFrom(
          from._internal_set_shared_key());
      break;
    }
    case kRatchetSharedKey: {
      _this->_internal_mutable_ratchet_shared_key()->::livekit::proto::RatchetSharedKeyResponse::MergeFrom(
          from._internal_ratchet_shared_key());
      break;
    }
    case kGetSharedKey: {
      _this->_internal_mutable_get_shared_key()->::livekit::proto::GetSharedKeyResponse::MergeFrom(
          from._internal_get_shared_key());
      break;
    }
    case kSetKey: {
      _this->_internal_mutable_set_key()->::livekit::proto::SetKeyResponse::MergeFrom(
          from._internal_set_key());
      break;
    }
    case kRatchetKey: {
      _this->_internal_mutable_ratchet_key()->::livekit::proto::RatchetKeyResponse::MergeFrom(
          from._internal_ratchet_key());
      break;
    }
    case kGetKey: {
      _this->_internal_mutable_get_key()->::livekit::proto::GetKeyResponse::MergeFrom(
          from._internal_get_key());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void E2eeResponse::CopyFrom(const E2eeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.proto.E2eeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool E2eeResponse::IsInitialized() const {
  switch (message_case()) {
    case kManagerSetEnabled: {
      break;
    }
    case kManagerGetFrameCryptors: {
      if (_internal_has_manager_get_frame_cryptors()) {
        if (!_impl_.message_.manager_get_frame_cryptors_->IsInitialized()) return false;
      }
      break;
    }
    case kCryptorSetEnabled: {
      break;
    }
    case kCryptorSetKeyIndex: {
      break;
    }
    case kSetSharedKey: {
      break;
    }
    case kRatchetSharedKey: {
      break;
    }
    case kGetSharedKey: {
      break;
    }
    case kSetKey: {
      break;
    }
    case kRatchetKey: {
      break;
    }
    case kGetKey: {
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return true;
}

void E2eeResponse::InternalSwap(E2eeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata E2eeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_e2ee_2eproto_getter, &descriptor_table_e2ee_2eproto_once,
      file_level_metadata_e2ee_2eproto[24]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::livekit::proto::FrameCryptor*
Arena::CreateMaybeMessage< ::livekit::proto::FrameCryptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FrameCryptor >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::KeyProviderOptions*
Arena::CreateMaybeMessage< ::livekit::proto::KeyProviderOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::KeyProviderOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeOptions*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeManagerSetEnabledRequest*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeManagerSetEnabledRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeManagerSetEnabledRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeManagerSetEnabledResponse*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeManagerSetEnabledResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeManagerSetEnabledResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeManagerGetFrameCryptorsRequest*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeManagerGetFrameCryptorsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeManagerGetFrameCryptorsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeManagerGetFrameCryptorsResponse*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeManagerGetFrameCryptorsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeManagerGetFrameCryptorsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FrameCryptorSetEnabledRequest*
Arena::CreateMaybeMessage< ::livekit::proto::FrameCryptorSetEnabledRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FrameCryptorSetEnabledRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FrameCryptorSetEnabledResponse*
Arena::CreateMaybeMessage< ::livekit::proto::FrameCryptorSetEnabledResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FrameCryptorSetEnabledResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FrameCryptorSetKeyIndexRequest*
Arena::CreateMaybeMessage< ::livekit::proto::FrameCryptorSetKeyIndexRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FrameCryptorSetKeyIndexRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::FrameCryptorSetKeyIndexResponse*
Arena::CreateMaybeMessage< ::livekit::proto::FrameCryptorSetKeyIndexResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::FrameCryptorSetKeyIndexResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::SetSharedKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::SetSharedKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::SetSharedKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::SetSharedKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::SetSharedKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::SetSharedKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RatchetSharedKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::RatchetSharedKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RatchetSharedKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RatchetSharedKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::RatchetSharedKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RatchetSharedKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::GetSharedKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::GetSharedKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::GetSharedKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::GetSharedKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::GetSharedKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::GetSharedKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::SetKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::SetKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::SetKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::SetKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::SetKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::SetKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RatchetKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::RatchetKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RatchetKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::RatchetKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::RatchetKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::RatchetKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::GetKeyRequest*
Arena::CreateMaybeMessage< ::livekit::proto::GetKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::GetKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::GetKeyResponse*
Arena::CreateMaybeMessage< ::livekit::proto::GetKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::GetKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeRequest*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::proto::E2eeResponse*
Arena::CreateMaybeMessage< ::livekit::proto::E2eeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::proto::E2eeResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
