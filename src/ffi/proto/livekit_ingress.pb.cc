// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_ingress.proto

#include "livekit_ingress.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace livekit {
PROTOBUF_CONSTEXPR CreateIngressRequest::CreateIngressRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_metadata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.video_)*/nullptr
  , /*decltype(_impl_.input_type_)*/0
  , /*decltype(_impl_.bypass_transcoding_)*/false
  , /*decltype(_impl_.enable_transcoding_)*/false
  , /*decltype(_impl_.enabled_)*/false} {}
struct CreateIngressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateIngressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateIngressRequestDefaultTypeInternal() {}
  union {
    CreateIngressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateIngressRequestDefaultTypeInternal _CreateIngressRequest_default_instance_;
PROTOBUF_CONSTEXPR IngressAudioOptions::IngressAudioOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/0
  , /*decltype(_impl_.encoding_options_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct IngressAudioOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressAudioOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressAudioOptionsDefaultTypeInternal() {}
  union {
    IngressAudioOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressAudioOptionsDefaultTypeInternal _IngressAudioOptions_default_instance_;
PROTOBUF_CONSTEXPR IngressVideoOptions::IngressVideoOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_)*/0
  , /*decltype(_impl_.encoding_options_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct IngressVideoOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressVideoOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressVideoOptionsDefaultTypeInternal() {}
  union {
    IngressVideoOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressVideoOptionsDefaultTypeInternal _IngressVideoOptions_default_instance_;
PROTOBUF_CONSTEXPR IngressAudioEncodingOptions::IngressAudioEncodingOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.audio_codec_)*/0
  , /*decltype(_impl_.bitrate_)*/0u
  , /*decltype(_impl_.disable_dtx_)*/false
  , /*decltype(_impl_.channels_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IngressAudioEncodingOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressAudioEncodingOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressAudioEncodingOptionsDefaultTypeInternal() {}
  union {
    IngressAudioEncodingOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressAudioEncodingOptionsDefaultTypeInternal _IngressAudioEncodingOptions_default_instance_;
PROTOBUF_CONSTEXPR IngressVideoEncodingOptions::IngressVideoEncodingOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layers_)*/{}
  , /*decltype(_impl_.frame_rate_)*/0
  , /*decltype(_impl_.video_codec_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IngressVideoEncodingOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressVideoEncodingOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressVideoEncodingOptionsDefaultTypeInternal() {}
  union {
    IngressVideoEncodingOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressVideoEncodingOptionsDefaultTypeInternal _IngressVideoEncodingOptions_default_instance_;
PROTOBUF_CONSTEXPR IngressInfo::IngressInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ingress_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stream_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_metadata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.video_)*/nullptr
  , /*decltype(_impl_.state_)*/nullptr
  , /*decltype(_impl_.input_type_)*/0
  , /*decltype(_impl_.bypass_transcoding_)*/false
  , /*decltype(_impl_.enable_transcoding_)*/false
  , /*decltype(_impl_.reusable_)*/false
  , /*decltype(_impl_.enabled_)*/false} {}
struct IngressInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressInfoDefaultTypeInternal() {}
  union {
    IngressInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressInfoDefaultTypeInternal _IngressInfo_default_instance_;
PROTOBUF_CONSTEXPR IngressState::IngressState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracks_)*/{}
  , /*decltype(_impl_.error_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resource_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.video_)*/nullptr
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.started_at_)*/int64_t{0}
  , /*decltype(_impl_.ended_at_)*/int64_t{0}
  , /*decltype(_impl_.updated_at_)*/int64_t{0}
  , /*decltype(_impl_.status_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IngressStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IngressStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IngressStateDefaultTypeInternal() {}
  union {
    IngressState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IngressStateDefaultTypeInternal _IngressState_default_instance_;
PROTOBUF_CONSTEXPR InputVideoState::InputVideoState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mime_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.average_bitrate_)*/0u
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.framerate_)*/0
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InputVideoStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InputVideoStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InputVideoStateDefaultTypeInternal() {}
  union {
    InputVideoState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputVideoStateDefaultTypeInternal _InputVideoState_default_instance_;
PROTOBUF_CONSTEXPR InputAudioState::InputAudioState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mime_type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.average_bitrate_)*/0u
  , /*decltype(_impl_.channels_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InputAudioStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InputAudioStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InputAudioStateDefaultTypeInternal() {}
  union {
    InputAudioState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputAudioStateDefaultTypeInternal _InputAudioState_default_instance_;
PROTOBUF_CONSTEXPR UpdateIngressRequest::UpdateIngressRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ingress_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_identity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.participant_metadata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.video_)*/nullptr
  , /*decltype(_impl_.bypass_transcoding_)*/false
  , /*decltype(_impl_.enable_transcoding_)*/false
  , /*decltype(_impl_.enabled_)*/false} {}
struct UpdateIngressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateIngressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateIngressRequestDefaultTypeInternal() {}
  union {
    UpdateIngressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateIngressRequestDefaultTypeInternal _UpdateIngressRequest_default_instance_;
PROTOBUF_CONSTEXPR ListIngressRequest::ListIngressRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.room_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ingress_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListIngressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListIngressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListIngressRequestDefaultTypeInternal() {}
  union {
    ListIngressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListIngressRequestDefaultTypeInternal _ListIngressRequest_default_instance_;
PROTOBUF_CONSTEXPR ListIngressResponse::ListIngressResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.items_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListIngressResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListIngressResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListIngressResponseDefaultTypeInternal() {}
  union {
    ListIngressResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListIngressResponseDefaultTypeInternal _ListIngressResponse_default_instance_;
PROTOBUF_CONSTEXPR DeleteIngressRequest::DeleteIngressRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ingress_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteIngressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteIngressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteIngressRequestDefaultTypeInternal() {}
  union {
    DeleteIngressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteIngressRequestDefaultTypeInternal _DeleteIngressRequest_default_instance_;
}  // namespace livekit
static ::_pb::Metadata file_level_metadata_livekit_5fingress_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_livekit_5fingress_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_livekit_5fingress_2eproto = nullptr;

const uint32_t TableStruct_livekit_5fingress_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.input_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.room_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.participant_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.participant_metadata_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.bypass_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.enable_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.video_),
  PROTOBUF_FIELD_OFFSET(::livekit::CreateIngressRequest, _impl_.enabled_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioOptions, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioOptions, _impl_.source_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioOptions, _impl_.encoding_options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoOptions, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoOptions, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoOptions, _impl_.source_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoOptions, _impl_.encoding_options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioEncodingOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioEncodingOptions, _impl_.audio_codec_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioEncodingOptions, _impl_.bitrate_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioEncodingOptions, _impl_.disable_dtx_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressAudioEncodingOptions, _impl_.channels_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoEncodingOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoEncodingOptions, _impl_.video_codec_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoEncodingOptions, _impl_.frame_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressVideoEncodingOptions, _impl_.layers_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.ingress_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.stream_key_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.url_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.input_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.bypass_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.enable_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.video_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.room_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.participant_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.participant_metadata_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.reusable_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressInfo, _impl_.enabled_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.error_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.video_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.room_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.started_at_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.ended_at_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.updated_at_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.resource_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::IngressState, _impl_.tracks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _impl_.mime_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _impl_.average_bitrate_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputVideoState, _impl_.framerate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::InputAudioState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::InputAudioState, _impl_.mime_type_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputAudioState, _impl_.average_bitrate_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputAudioState, _impl_.channels_),
  PROTOBUF_FIELD_OFFSET(::livekit::InputAudioState, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.ingress_id_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.room_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.participant_identity_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.participant_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.participant_metadata_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.bypass_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.enable_transcoding_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.video_),
  PROTOBUF_FIELD_OFFSET(::livekit::UpdateIngressRequest, _impl_.enabled_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::ListIngressRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::ListIngressRequest, _impl_.room_name_),
  PROTOBUF_FIELD_OFFSET(::livekit::ListIngressRequest, _impl_.ingress_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::ListIngressResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::ListIngressResponse, _impl_.items_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::livekit::DeleteIngressRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::livekit::DeleteIngressRequest, _impl_.ingress_id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 18, -1, sizeof(::livekit::CreateIngressRequest)},
  { 30, -1, -1, sizeof(::livekit::IngressAudioOptions)},
  { 41, -1, -1, sizeof(::livekit::IngressVideoOptions)},
  { 52, -1, -1, sizeof(::livekit::IngressAudioEncodingOptions)},
  { 62, -1, -1, sizeof(::livekit::IngressVideoEncodingOptions)},
  { 71, 93, -1, sizeof(::livekit::IngressInfo)},
  { 109, -1, -1, sizeof(::livekit::IngressState)},
  { 125, -1, -1, sizeof(::livekit::InputVideoState)},
  { 136, -1, -1, sizeof(::livekit::InputAudioState)},
  { 146, 163, -1, sizeof(::livekit::UpdateIngressRequest)},
  { 174, -1, -1, sizeof(::livekit::ListIngressRequest)},
  { 182, -1, -1, sizeof(::livekit::ListIngressResponse)},
  { 189, -1, -1, sizeof(::livekit::DeleteIngressRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::livekit::_CreateIngressRequest_default_instance_._instance,
  &::livekit::_IngressAudioOptions_default_instance_._instance,
  &::livekit::_IngressVideoOptions_default_instance_._instance,
  &::livekit::_IngressAudioEncodingOptions_default_instance_._instance,
  &::livekit::_IngressVideoEncodingOptions_default_instance_._instance,
  &::livekit::_IngressInfo_default_instance_._instance,
  &::livekit::_IngressState_default_instance_._instance,
  &::livekit::_InputVideoState_default_instance_._instance,
  &::livekit::_InputAudioState_default_instance_._instance,
  &::livekit::_UpdateIngressRequest_default_instance_._instance,
  &::livekit::_ListIngressRequest_default_instance_._instance,
  &::livekit::_ListIngressResponse_default_instance_._instance,
  &::livekit::_DeleteIngressRequest_default_instance_._instance,
};

const char descriptor_table_protodef_livekit_5fingress_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025livekit_ingress.proto\022\007livekit\032\024liveki"
  "t_models.proto\"\231\003\n\024CreateIngressRequest\022"
  ")\n\ninput_type\030\001 \001(\0162\025.livekit.IngressInp"
  "ut\022\013\n\003url\030\t \001(\t\022\014\n\004name\030\002 \001(\t\022\021\n\troom_na"
  "me\030\003 \001(\t\022\034\n\024participant_identity\030\004 \001(\t\022\030"
  "\n\020participant_name\030\005 \001(\t\022\034\n\024participant_"
  "metadata\030\n \001(\t\022\036\n\022bypass_transcoding\030\010 \001"
  "(\010B\002\030\001\022\037\n\022enable_transcoding\030\013 \001(\010H\000\210\001\001\022"
  "+\n\005audio\030\006 \001(\0132\034.livekit.IngressAudioOpt"
  "ions\022+\n\005video\030\007 \001(\0132\034.livekit.IngressVid"
  "eoOptions\022\024\n\007enabled\030\014 \001(\010H\001\210\001\001B\025\n\023_enab"
  "le_transcodingB\n\n\010_enabled\"\315\001\n\023IngressAu"
  "dioOptions\022\014\n\004name\030\001 \001(\t\022$\n\006source\030\002 \001(\016"
  "2\024.livekit.TrackSource\0225\n\006preset\030\003 \001(\0162#"
  ".livekit.IngressAudioEncodingPresetH\000\0227\n"
  "\007options\030\004 \001(\0132$.livekit.IngressAudioEnc"
  "odingOptionsH\000B\022\n\020encoding_options\"\315\001\n\023I"
  "ngressVideoOptions\022\014\n\004name\030\001 \001(\t\022$\n\006sour"
  "ce\030\002 \001(\0162\024.livekit.TrackSource\0225\n\006preset"
  "\030\003 \001(\0162#.livekit.IngressVideoEncodingPre"
  "setH\000\0227\n\007options\030\004 \001(\0132$.livekit.Ingress"
  "VideoEncodingOptionsH\000B\022\n\020encoding_optio"
  "ns\"\177\n\033IngressAudioEncodingOptions\022(\n\013aud"
  "io_codec\030\001 \001(\0162\023.livekit.AudioCodec\022\017\n\007b"
  "itrate\030\002 \001(\r\022\023\n\013disable_dtx\030\003 \001(\010\022\020\n\010cha"
  "nnels\030\004 \001(\r\"\200\001\n\033IngressVideoEncodingOpti"
  "ons\022(\n\013video_codec\030\001 \001(\0162\023.livekit.Video"
  "Codec\022\022\n\nframe_rate\030\002 \001(\001\022#\n\006layers\030\003 \003("
  "\0132\023.livekit.VideoLayer\"\360\003\n\013IngressInfo\022\022"
  "\n\ningress_id\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\022\n\nstre"
  "am_key\030\003 \001(\t\022\013\n\003url\030\004 \001(\t\022)\n\ninput_type\030"
  "\005 \001(\0162\025.livekit.IngressInput\022\036\n\022bypass_t"
  "ranscoding\030\r \001(\010B\002\030\001\022\037\n\022enable_transcodi"
  "ng\030\017 \001(\010H\000\210\001\001\022+\n\005audio\030\006 \001(\0132\034.livekit.I"
  "ngressAudioOptions\022+\n\005video\030\007 \001(\0132\034.live"
  "kit.IngressVideoOptions\022\021\n\troom_name\030\010 \001"
  "(\t\022\034\n\024participant_identity\030\t \001(\t\022\030\n\020part"
  "icipant_name\030\n \001(\t\022\034\n\024participant_metada"
  "ta\030\016 \001(\t\022\020\n\010reusable\030\013 \001(\010\022$\n\005state\030\014 \001("
  "\0132\025.livekit.IngressState\022\024\n\007enabled\030\020 \001("
  "\010H\001\210\001\001B\025\n\023_enable_transcodingB\n\n\010_enable"
  "d\"\236\003\n\014IngressState\022,\n\006status\030\001 \001(\0162\034.liv"
  "ekit.IngressState.Status\022\r\n\005error\030\002 \001(\t\022"
  "\'\n\005video\030\003 \001(\0132\030.livekit.InputVideoState"
  "\022\'\n\005audio\030\004 \001(\0132\030.livekit.InputAudioStat"
  "e\022\017\n\007room_id\030\005 \001(\t\022\022\n\nstarted_at\030\007 \001(\003\022\020"
  "\n\010ended_at\030\010 \001(\003\022\022\n\nupdated_at\030\n \001(\003\022\023\n\013"
  "resource_id\030\t \001(\t\022\"\n\006tracks\030\006 \003(\0132\022.live"
  "kit.TrackInfo\"{\n\006Status\022\025\n\021ENDPOINT_INAC"
  "TIVE\020\000\022\026\n\022ENDPOINT_BUFFERING\020\001\022\027\n\023ENDPOI"
  "NT_PUBLISHING\020\002\022\022\n\016ENDPOINT_ERROR\020\003\022\025\n\021E"
  "NDPOINT_COMPLETE\020\004\"o\n\017InputVideoState\022\021\n"
  "\tmime_type\030\001 \001(\t\022\027\n\017average_bitrate\030\002 \001("
  "\r\022\r\n\005width\030\003 \001(\r\022\016\n\006height\030\004 \001(\r\022\021\n\tfram"
  "erate\030\005 \001(\001\"d\n\017InputAudioState\022\021\n\tmime_t"
  "ype\030\001 \001(\t\022\027\n\017average_bitrate\030\002 \001(\r\022\020\n\010ch"
  "annels\030\003 \001(\r\022\023\n\013sample_rate\030\004 \001(\r\"\221\003\n\024Up"
  "dateIngressRequest\022\022\n\ningress_id\030\001 \001(\t\022\014"
  "\n\004name\030\002 \001(\t\022\021\n\troom_name\030\003 \001(\t\022\034\n\024parti"
  "cipant_identity\030\004 \001(\t\022\030\n\020participant_nam"
  "e\030\005 \001(\t\022\034\n\024participant_metadata\030\t \001(\t\022#\n"
  "\022bypass_transcoding\030\010 \001(\010B\002\030\001H\000\210\001\001\022\037\n\022en"
  "able_transcoding\030\n \001(\010H\001\210\001\001\022+\n\005audio\030\006 \001"
  "(\0132\034.livekit.IngressAudioOptions\022+\n\005vide"
  "o\030\007 \001(\0132\034.livekit.IngressVideoOptions\022\024\n"
  "\007enabled\030\013 \001(\010H\002\210\001\001B\025\n\023_bypass_transcodi"
  "ngB\025\n\023_enable_transcodingB\n\n\010_enabled\";\n"
  "\022ListIngressRequest\022\021\n\troom_name\030\001 \001(\t\022\022"
  "\n\ningress_id\030\002 \001(\t\":\n\023ListIngressRespons"
  "e\022#\n\005items\030\001 \003(\0132\024.livekit.IngressInfo\"*"
  "\n\024DeleteIngressRequest\022\022\n\ningress_id\030\001 \001"
  "(\t*=\n\014IngressInput\022\016\n\nRTMP_INPUT\020\000\022\016\n\nWH"
  "IP_INPUT\020\001\022\r\n\tURL_INPUT\020\002*I\n\032IngressAudi"
  "oEncodingPreset\022\026\n\022OPUS_STEREO_96KBPS\020\000\022"
  "\023\n\017OPUS_MONO_64KBS\020\001*\204\003\n\032IngressVideoEnc"
  "odingPreset\022\034\n\030H264_720P_30FPS_3_LAYERS\020"
  "\000\022\035\n\031H264_1080P_30FPS_3_LAYERS\020\001\022\034\n\030H264"
  "_540P_25FPS_2_LAYERS\020\002\022\033\n\027H264_720P_30FP"
  "S_1_LAYER\020\003\022\034\n\030H264_1080P_30FPS_1_LAYER\020"
  "\004\022(\n$H264_720P_30FPS_3_LAYERS_HIGH_MOTIO"
  "N\020\005\022)\n%H264_1080P_30FPS_3_LAYERS_HIGH_MO"
  "TION\020\006\022(\n$H264_540P_25FPS_2_LAYERS_HIGH_"
  "MOTION\020\007\022\'\n#H264_720P_30FPS_1_LAYER_HIGH"
  "_MOTION\020\010\022(\n$H264_1080P_30FPS_1_LAYER_HI"
  "GH_MOTION\020\t2\245\002\n\007Ingress\022D\n\rCreateIngress"
  "\022\035.livekit.CreateIngressRequest\032\024.liveki"
  "t.IngressInfo\022D\n\rUpdateIngress\022\035.livekit"
  ".UpdateIngressRequest\032\024.livekit.IngressI"
  "nfo\022H\n\013ListIngress\022\033.livekit.ListIngress"
  "Request\032\034.livekit.ListIngressResponse\022D\n"
  "\rDeleteIngress\022\035.livekit.DeleteIngressRe"
  "quest\032\024.livekit.IngressInfoBFZ#github.co"
  "m/livekit/protocol/livekit\252\002\rLiveKit.Pro"
  "to\352\002\016LiveKit::Protob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_livekit_5fingress_2eproto_deps[1] = {
  &::descriptor_table_livekit_5fmodels_2eproto,
};
static ::_pbi::once_flag descriptor_table_livekit_5fingress_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_livekit_5fingress_2eproto = {
    false, false, 3747, descriptor_table_protodef_livekit_5fingress_2eproto,
    "livekit_ingress.proto",
    &descriptor_table_livekit_5fingress_2eproto_once, descriptor_table_livekit_5fingress_2eproto_deps, 1, 13,
    schemas, file_default_instances, TableStruct_livekit_5fingress_2eproto::offsets,
    file_level_metadata_livekit_5fingress_2eproto, file_level_enum_descriptors_livekit_5fingress_2eproto,
    file_level_service_descriptors_livekit_5fingress_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_livekit_5fingress_2eproto_getter() {
  return &descriptor_table_livekit_5fingress_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_livekit_5fingress_2eproto(&descriptor_table_livekit_5fingress_2eproto);
namespace livekit {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressState_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_livekit_5fingress_2eproto);
  return file_level_enum_descriptors_livekit_5fingress_2eproto[0];
}
bool IngressState_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr IngressState_Status IngressState::ENDPOINT_INACTIVE;
constexpr IngressState_Status IngressState::ENDPOINT_BUFFERING;
constexpr IngressState_Status IngressState::ENDPOINT_PUBLISHING;
constexpr IngressState_Status IngressState::ENDPOINT_ERROR;
constexpr IngressState_Status IngressState::ENDPOINT_COMPLETE;
constexpr IngressState_Status IngressState::Status_MIN;
constexpr IngressState_Status IngressState::Status_MAX;
constexpr int IngressState::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressInput_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_livekit_5fingress_2eproto);
  return file_level_enum_descriptors_livekit_5fingress_2eproto[1];
}
bool IngressInput_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressAudioEncodingPreset_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_livekit_5fingress_2eproto);
  return file_level_enum_descriptors_livekit_5fingress_2eproto[2];
}
bool IngressAudioEncodingPreset_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressVideoEncodingPreset_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_livekit_5fingress_2eproto);
  return file_level_enum_descriptors_livekit_5fingress_2eproto[3];
}
bool IngressVideoEncodingPreset_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CreateIngressRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateIngressRequest>()._impl_._has_bits_);
  static void set_has_enable_transcoding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::IngressAudioOptions& audio(const CreateIngressRequest* msg);
  static const ::livekit::IngressVideoOptions& video(const CreateIngressRequest* msg);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::livekit::IngressAudioOptions&
CreateIngressRequest::_Internal::audio(const CreateIngressRequest* msg) {
  return *msg->_impl_.audio_;
}
const ::livekit::IngressVideoOptions&
CreateIngressRequest::_Internal::video(const CreateIngressRequest* msg) {
  return *msg->_impl_.video_;
}
CreateIngressRequest::CreateIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.CreateIngressRequest)
}
CreateIngressRequest::CreateIngressRequest(const CreateIngressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateIngressRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.input_type_){}
    , decltype(_impl_.bypass_transcoding_){}
    , decltype(_impl_.enable_transcoding_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room_name().empty()) {
    _this->_impl_.room_name_.Set(from._internal_room_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_identity().empty()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_name().empty()) {
    _this->_impl_.participant_name_.Set(from._internal_participant_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_metadata().empty()) {
    _this->_impl_.participant_metadata_.Set(from._internal_participant_metadata(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::livekit::IngressAudioOptions(*from._impl_.audio_);
  }
  if (from._internal_has_video()) {
    _this->_impl_.video_ = new ::livekit::IngressVideoOptions(*from._impl_.video_);
  }
  ::memcpy(&_impl_.input_type_, &from._impl_.input_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.input_type_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:livekit.CreateIngressRequest)
}

inline void CreateIngressRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.input_type_){0}
    , decltype(_impl_.bypass_transcoding_){false}
    , decltype(_impl_.enable_transcoding_){false}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateIngressRequest::~CreateIngressRequest() {
  // @@protoc_insertion_point(destructor:livekit.CreateIngressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateIngressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.room_name_.Destroy();
  _impl_.participant_identity_.Destroy();
  _impl_.participant_name_.Destroy();
  _impl_.url_.Destroy();
  _impl_.participant_metadata_.Destroy();
  if (this != internal_default_instance()) delete _impl_.audio_;
  if (this != internal_default_instance()) delete _impl_.video_;
}

void CreateIngressRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateIngressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.CreateIngressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.room_name_.ClearToEmpty();
  _impl_.participant_identity_.ClearToEmpty();
  _impl_.participant_name_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  _impl_.participant_metadata_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
  ::memset(&_impl_.input_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bypass_transcoding_) -
      reinterpret_cast<char*>(&_impl_.input_type_)) + sizeof(_impl_.bypass_transcoding_));
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.enable_transcoding_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enabled_) -
        reinterpret_cast<char*>(&_impl_.enable_transcoding_)) + sizeof(_impl_.enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateIngressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.IngressInput input_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_input_type(static_cast<::livekit::IngressInput>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // string room_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_room_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.room_name"));
        } else
          goto handle_unusual;
        continue;
      // string participant_identity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.participant_identity"));
        } else
          goto handle_unusual;
        continue;
      // string participant_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_participant_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.participant_name"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressAudioOptions audio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressVideoOptions video = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_video(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bypass_transcoding = 8 [deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.bypass_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string url = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.url"));
        } else
          goto handle_unusual;
        continue;
      // string participant_metadata = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_participant_metadata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.CreateIngressRequest.participant_metadata"));
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_transcoding = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enable_transcoding(&has_bits);
          _impl_.enable_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateIngressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.CreateIngressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .livekit.IngressInput input_type = 1;
  if (this->_internal_input_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_input_type(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string room_name = 3;
  if (!this->_internal_room_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room_name().data(), static_cast<int>(this->_internal_room_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.room_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_room_name(), target);
  }

  // string participant_identity = 4;
  if (!this->_internal_participant_identity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_participant_identity(), target);
  }

  // string participant_name = 5;
  if (!this->_internal_participant_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_name().data(), static_cast<int>(this->_internal_participant_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.participant_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_participant_name(), target);
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::video(this),
        _Internal::video(this).GetCachedSize(), target, stream);
  }

  // bool bypass_transcoding = 8 [deprecated = true];
  if (this->_internal_bypass_transcoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_bypass_transcoding(), target);
  }

  // string url = 9;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.url");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_url(), target);
  }

  // string participant_metadata = 10;
  if (!this->_internal_participant_metadata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_metadata().data(), static_cast<int>(this->_internal_participant_metadata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.CreateIngressRequest.participant_metadata");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_participant_metadata(), target);
  }

  // optional bool enable_transcoding = 11;
  if (_internal_has_enable_transcoding()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_enable_transcoding(), target);
  }

  // optional bool enabled = 12;
  if (_internal_has_enabled()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.CreateIngressRequest)
  return target;
}

size_t CreateIngressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.CreateIngressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string room_name = 3;
  if (!this->_internal_room_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room_name());
  }

  // string participant_identity = 4;
  if (!this->_internal_participant_identity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  // string participant_name = 5;
  if (!this->_internal_participant_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_name());
  }

  // string url = 9;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string participant_metadata = 10;
  if (!this->_internal_participant_metadata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_metadata());
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_);
  }

  // .livekit.IngressInput input_type = 1;
  if (this->_internal_input_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_input_type());
  }

  // bool bypass_transcoding = 8 [deprecated = true];
  if (this->_internal_bypass_transcoding() != 0) {
    total_size += 1 + 1;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool enable_transcoding = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enabled = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateIngressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateIngressRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateIngressRequest::GetClassData() const { return &_class_data_; }


void CreateIngressRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateIngressRequest*>(&to_msg);
  auto& from = static_cast<const CreateIngressRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.CreateIngressRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_room_name().empty()) {
    _this->_internal_set_room_name(from._internal_room_name());
  }
  if (!from._internal_participant_identity().empty()) {
    _this->_internal_set_participant_identity(from._internal_participant_identity());
  }
  if (!from._internal_participant_name().empty()) {
    _this->_internal_set_participant_name(from._internal_participant_name());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (!from._internal_participant_metadata().empty()) {
    _this->_internal_set_participant_metadata(from._internal_participant_metadata());
  }
  if (from._internal_has_audio()) {
    _this->_internal_mutable_audio()->::livekit::IngressAudioOptions::MergeFrom(
        from._internal_audio());
  }
  if (from._internal_has_video()) {
    _this->_internal_mutable_video()->::livekit::IngressVideoOptions::MergeFrom(
        from._internal_video());
  }
  if (from._internal_input_type() != 0) {
    _this->_internal_set_input_type(from._internal_input_type());
  }
  if (from._internal_bypass_transcoding() != 0) {
    _this->_internal_set_bypass_transcoding(from._internal_bypass_transcoding());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.enable_transcoding_ = from._impl_.enable_transcoding_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateIngressRequest::CopyFrom(const CreateIngressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.CreateIngressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateIngressRequest::IsInitialized() const {
  return true;
}

void CreateIngressRequest::InternalSwap(CreateIngressRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_name_, lhs_arena,
      &other->_impl_.room_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_name_, lhs_arena,
      &other->_impl_.participant_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_metadata_, lhs_arena,
      &other->_impl_.participant_metadata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateIngressRequest, _impl_.enabled_)
      + sizeof(CreateIngressRequest::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(CreateIngressRequest, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateIngressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[0]);
}

// ===================================================================

class IngressAudioOptions::_Internal {
 public:
  static const ::livekit::IngressAudioEncodingOptions& options(const IngressAudioOptions* msg);
};

const ::livekit::IngressAudioEncodingOptions&
IngressAudioOptions::_Internal::options(const IngressAudioOptions* msg) {
  return *msg->_impl_.encoding_options_.options_;
}
void IngressAudioOptions::set_allocated_options(::livekit::IngressAudioEncodingOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_encoding_options();
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
    _impl_.encoding_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressAudioOptions.options)
}
IngressAudioOptions::IngressAudioOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressAudioOptions)
}
IngressAudioOptions::IngressAudioOptions(const IngressAudioOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressAudioOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.encoding_options_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.source_ = from._impl_.source_;
  clear_has_encoding_options();
  switch (from.encoding_options_case()) {
    case kPreset: {
      _this->_internal_set_preset(from._internal_preset());
      break;
    }
    case kOptions: {
      _this->_internal_mutable_options()->::livekit::IngressAudioEncodingOptions::MergeFrom(
          from._internal_options());
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.IngressAudioOptions)
}

inline void IngressAudioOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.source_){0}
    , decltype(_impl_.encoding_options_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_encoding_options();
}

IngressAudioOptions::~IngressAudioOptions() {
  // @@protoc_insertion_point(destructor:livekit.IngressAudioOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressAudioOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (has_encoding_options()) {
    clear_encoding_options();
  }
}

void IngressAudioOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressAudioOptions::clear_encoding_options() {
// @@protoc_insertion_point(one_of_clear_start:livekit.IngressAudioOptions)
  switch (encoding_options_case()) {
    case kPreset: {
      // No need to clear
      break;
    }
    case kOptions: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.encoding_options_.options_;
      }
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}


void IngressAudioOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressAudioOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.source_ = 0;
  clear_encoding_options();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressAudioOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressAudioOptions.name"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.TrackSource source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_source(static_cast<::livekit::TrackSource>(val));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressAudioEncodingPreset preset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_preset(static_cast<::livekit::IngressAudioEncodingPreset>(val));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressAudioEncodingOptions options = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressAudioOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressAudioOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressAudioOptions.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .livekit.TrackSource source = 2;
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_source(), target);
  }

  // .livekit.IngressAudioEncodingPreset preset = 3;
  if (_internal_has_preset()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_preset(), target);
  }

  // .livekit.IngressAudioEncodingOptions options = 4;
  if (_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressAudioOptions)
  return target;
}

size_t IngressAudioOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressAudioOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .livekit.TrackSource source = 2;
  if (this->_internal_source() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
  }

  switch (encoding_options_case()) {
    // .livekit.IngressAudioEncodingPreset preset = 3;
    case kPreset: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_preset());
      break;
    }
    // .livekit.IngressAudioEncodingOptions options = 4;
    case kOptions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.encoding_options_.options_);
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressAudioOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressAudioOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressAudioOptions::GetClassData() const { return &_class_data_; }


void IngressAudioOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressAudioOptions*>(&to_msg);
  auto& from = static_cast<const IngressAudioOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressAudioOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_source() != 0) {
    _this->_internal_set_source(from._internal_source());
  }
  switch (from.encoding_options_case()) {
    case kPreset: {
      _this->_internal_set_preset(from._internal_preset());
      break;
    }
    case kOptions: {
      _this->_internal_mutable_options()->::livekit::IngressAudioEncodingOptions::MergeFrom(
          from._internal_options());
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressAudioOptions::CopyFrom(const IngressAudioOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressAudioOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressAudioOptions::IsInitialized() const {
  return true;
}

void IngressAudioOptions::InternalSwap(IngressAudioOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.source_, other->_impl_.source_);
  swap(_impl_.encoding_options_, other->_impl_.encoding_options_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressAudioOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[1]);
}

// ===================================================================

class IngressVideoOptions::_Internal {
 public:
  static const ::livekit::IngressVideoEncodingOptions& options(const IngressVideoOptions* msg);
};

const ::livekit::IngressVideoEncodingOptions&
IngressVideoOptions::_Internal::options(const IngressVideoOptions* msg) {
  return *msg->_impl_.encoding_options_.options_;
}
void IngressVideoOptions::set_allocated_options(::livekit::IngressVideoEncodingOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_encoding_options();
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
    _impl_.encoding_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressVideoOptions.options)
}
IngressVideoOptions::IngressVideoOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressVideoOptions)
}
IngressVideoOptions::IngressVideoOptions(const IngressVideoOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressVideoOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.source_){}
    , decltype(_impl_.encoding_options_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.source_ = from._impl_.source_;
  clear_has_encoding_options();
  switch (from.encoding_options_case()) {
    case kPreset: {
      _this->_internal_set_preset(from._internal_preset());
      break;
    }
    case kOptions: {
      _this->_internal_mutable_options()->::livekit::IngressVideoEncodingOptions::MergeFrom(
          from._internal_options());
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:livekit.IngressVideoOptions)
}

inline void IngressVideoOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.source_){0}
    , decltype(_impl_.encoding_options_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_encoding_options();
}

IngressVideoOptions::~IngressVideoOptions() {
  // @@protoc_insertion_point(destructor:livekit.IngressVideoOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressVideoOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (has_encoding_options()) {
    clear_encoding_options();
  }
}

void IngressVideoOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressVideoOptions::clear_encoding_options() {
// @@protoc_insertion_point(one_of_clear_start:livekit.IngressVideoOptions)
  switch (encoding_options_case()) {
    case kPreset: {
      // No need to clear
      break;
    }
    case kOptions: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.encoding_options_.options_;
      }
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}


void IngressVideoOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressVideoOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.source_ = 0;
  clear_encoding_options();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressVideoOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressVideoOptions.name"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.TrackSource source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_source(static_cast<::livekit::TrackSource>(val));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressVideoEncodingPreset preset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_preset(static_cast<::livekit::IngressVideoEncodingPreset>(val));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressVideoEncodingOptions options = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressVideoOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressVideoOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressVideoOptions.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .livekit.TrackSource source = 2;
  if (this->_internal_source() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_source(), target);
  }

  // .livekit.IngressVideoEncodingPreset preset = 3;
  if (_internal_has_preset()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_preset(), target);
  }

  // .livekit.IngressVideoEncodingOptions options = 4;
  if (_internal_has_options()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::options(this),
        _Internal::options(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressVideoOptions)
  return target;
}

size_t IngressVideoOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressVideoOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .livekit.TrackSource source = 2;
  if (this->_internal_source() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
  }

  switch (encoding_options_case()) {
    // .livekit.IngressVideoEncodingPreset preset = 3;
    case kPreset: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_preset());
      break;
    }
    // .livekit.IngressVideoEncodingOptions options = 4;
    case kOptions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.encoding_options_.options_);
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressVideoOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressVideoOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressVideoOptions::GetClassData() const { return &_class_data_; }


void IngressVideoOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressVideoOptions*>(&to_msg);
  auto& from = static_cast<const IngressVideoOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressVideoOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_source() != 0) {
    _this->_internal_set_source(from._internal_source());
  }
  switch (from.encoding_options_case()) {
    case kPreset: {
      _this->_internal_set_preset(from._internal_preset());
      break;
    }
    case kOptions: {
      _this->_internal_mutable_options()->::livekit::IngressVideoEncodingOptions::MergeFrom(
          from._internal_options());
      break;
    }
    case ENCODING_OPTIONS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressVideoOptions::CopyFrom(const IngressVideoOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressVideoOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressVideoOptions::IsInitialized() const {
  return true;
}

void IngressVideoOptions::InternalSwap(IngressVideoOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.source_, other->_impl_.source_);
  swap(_impl_.encoding_options_, other->_impl_.encoding_options_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressVideoOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[2]);
}

// ===================================================================

class IngressAudioEncodingOptions::_Internal {
 public:
};

IngressAudioEncodingOptions::IngressAudioEncodingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressAudioEncodingOptions)
}
IngressAudioEncodingOptions::IngressAudioEncodingOptions(const IngressAudioEncodingOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressAudioEncodingOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_codec_){}
    , decltype(_impl_.bitrate_){}
    , decltype(_impl_.disable_dtx_){}
    , decltype(_impl_.channels_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.audio_codec_, &from._impl_.audio_codec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.channels_) -
    reinterpret_cast<char*>(&_impl_.audio_codec_)) + sizeof(_impl_.channels_));
  // @@protoc_insertion_point(copy_constructor:livekit.IngressAudioEncodingOptions)
}

inline void IngressAudioEncodingOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.audio_codec_){0}
    , decltype(_impl_.bitrate_){0u}
    , decltype(_impl_.disable_dtx_){false}
    , decltype(_impl_.channels_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IngressAudioEncodingOptions::~IngressAudioEncodingOptions() {
  // @@protoc_insertion_point(destructor:livekit.IngressAudioEncodingOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressAudioEncodingOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IngressAudioEncodingOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressAudioEncodingOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressAudioEncodingOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.audio_codec_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.channels_) -
      reinterpret_cast<char*>(&_impl_.audio_codec_)) + sizeof(_impl_.channels_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressAudioEncodingOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.AudioCodec audio_codec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_audio_codec(static_cast<::livekit::AudioCodec>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 bitrate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool disable_dtx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.disable_dtx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 channels = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressAudioEncodingOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressAudioEncodingOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .livekit.AudioCodec audio_codec = 1;
  if (this->_internal_audio_codec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_audio_codec(), target);
  }

  // uint32 bitrate = 2;
  if (this->_internal_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bitrate(), target);
  }

  // bool disable_dtx = 3;
  if (this->_internal_disable_dtx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_disable_dtx(), target);
  }

  // uint32 channels = 4;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressAudioEncodingOptions)
  return target;
}

size_t IngressAudioEncodingOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressAudioEncodingOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .livekit.AudioCodec audio_codec = 1;
  if (this->_internal_audio_codec() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_audio_codec());
  }

  // uint32 bitrate = 2;
  if (this->_internal_bitrate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate());
  }

  // bool disable_dtx = 3;
  if (this->_internal_disable_dtx() != 0) {
    total_size += 1 + 1;
  }

  // uint32 channels = 4;
  if (this->_internal_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channels());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressAudioEncodingOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressAudioEncodingOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressAudioEncodingOptions::GetClassData() const { return &_class_data_; }


void IngressAudioEncodingOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressAudioEncodingOptions*>(&to_msg);
  auto& from = static_cast<const IngressAudioEncodingOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressAudioEncodingOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_audio_codec() != 0) {
    _this->_internal_set_audio_codec(from._internal_audio_codec());
  }
  if (from._internal_bitrate() != 0) {
    _this->_internal_set_bitrate(from._internal_bitrate());
  }
  if (from._internal_disable_dtx() != 0) {
    _this->_internal_set_disable_dtx(from._internal_disable_dtx());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressAudioEncodingOptions::CopyFrom(const IngressAudioEncodingOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressAudioEncodingOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressAudioEncodingOptions::IsInitialized() const {
  return true;
}

void IngressAudioEncodingOptions::InternalSwap(IngressAudioEncodingOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IngressAudioEncodingOptions, _impl_.channels_)
      + sizeof(IngressAudioEncodingOptions::_impl_.channels_)
      - PROTOBUF_FIELD_OFFSET(IngressAudioEncodingOptions, _impl_.audio_codec_)>(
          reinterpret_cast<char*>(&_impl_.audio_codec_),
          reinterpret_cast<char*>(&other->_impl_.audio_codec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressAudioEncodingOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[3]);
}

// ===================================================================

class IngressVideoEncodingOptions::_Internal {
 public:
};

void IngressVideoEncodingOptions::clear_layers() {
  _impl_.layers_.Clear();
}
IngressVideoEncodingOptions::IngressVideoEncodingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressVideoEncodingOptions)
}
IngressVideoEncodingOptions::IngressVideoEncodingOptions(const IngressVideoEncodingOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressVideoEncodingOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layers_){from._impl_.layers_}
    , decltype(_impl_.frame_rate_){}
    , decltype(_impl_.video_codec_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.frame_rate_, &from._impl_.frame_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.video_codec_) -
    reinterpret_cast<char*>(&_impl_.frame_rate_)) + sizeof(_impl_.video_codec_));
  // @@protoc_insertion_point(copy_constructor:livekit.IngressVideoEncodingOptions)
}

inline void IngressVideoEncodingOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layers_){arena}
    , decltype(_impl_.frame_rate_){0}
    , decltype(_impl_.video_codec_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IngressVideoEncodingOptions::~IngressVideoEncodingOptions() {
  // @@protoc_insertion_point(destructor:livekit.IngressVideoEncodingOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressVideoEncodingOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layers_.~RepeatedPtrField();
}

void IngressVideoEncodingOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressVideoEncodingOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressVideoEncodingOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layers_.Clear();
  ::memset(&_impl_.frame_rate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.video_codec_) -
      reinterpret_cast<char*>(&_impl_.frame_rate_)) + sizeof(_impl_.video_codec_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressVideoEncodingOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.VideoCodec video_codec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_video_codec(static_cast<::livekit::VideoCodec>(val));
        } else
          goto handle_unusual;
        continue;
      // double frame_rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.frame_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .livekit.VideoLayer layers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressVideoEncodingOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressVideoEncodingOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .livekit.VideoCodec video_codec = 1;
  if (this->_internal_video_codec() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_video_codec(), target);
  }

  // double frame_rate = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frame_rate = this->_internal_frame_rate();
  uint64_t raw_frame_rate;
  memcpy(&raw_frame_rate, &tmp_frame_rate, sizeof(tmp_frame_rate));
  if (raw_frame_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_frame_rate(), target);
  }

  // repeated .livekit.VideoLayer layers = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_layers_size()); i < n; i++) {
    const auto& repfield = this->_internal_layers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressVideoEncodingOptions)
  return target;
}

size_t IngressVideoEncodingOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressVideoEncodingOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .livekit.VideoLayer layers = 3;
  total_size += 1UL * this->_internal_layers_size();
  for (const auto& msg : this->_impl_.layers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // double frame_rate = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frame_rate = this->_internal_frame_rate();
  uint64_t raw_frame_rate;
  memcpy(&raw_frame_rate, &tmp_frame_rate, sizeof(tmp_frame_rate));
  if (raw_frame_rate != 0) {
    total_size += 1 + 8;
  }

  // .livekit.VideoCodec video_codec = 1;
  if (this->_internal_video_codec() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_video_codec());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressVideoEncodingOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressVideoEncodingOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressVideoEncodingOptions::GetClassData() const { return &_class_data_; }


void IngressVideoEncodingOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressVideoEncodingOptions*>(&to_msg);
  auto& from = static_cast<const IngressVideoEncodingOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressVideoEncodingOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layers_.MergeFrom(from._impl_.layers_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frame_rate = from._internal_frame_rate();
  uint64_t raw_frame_rate;
  memcpy(&raw_frame_rate, &tmp_frame_rate, sizeof(tmp_frame_rate));
  if (raw_frame_rate != 0) {
    _this->_internal_set_frame_rate(from._internal_frame_rate());
  }
  if (from._internal_video_codec() != 0) {
    _this->_internal_set_video_codec(from._internal_video_codec());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressVideoEncodingOptions::CopyFrom(const IngressVideoEncodingOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressVideoEncodingOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressVideoEncodingOptions::IsInitialized() const {
  return true;
}

void IngressVideoEncodingOptions::InternalSwap(IngressVideoEncodingOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.layers_.InternalSwap(&other->_impl_.layers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IngressVideoEncodingOptions, _impl_.video_codec_)
      + sizeof(IngressVideoEncodingOptions::_impl_.video_codec_)
      - PROTOBUF_FIELD_OFFSET(IngressVideoEncodingOptions, _impl_.frame_rate_)>(
          reinterpret_cast<char*>(&_impl_.frame_rate_),
          reinterpret_cast<char*>(&other->_impl_.frame_rate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressVideoEncodingOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[4]);
}

// ===================================================================

class IngressInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<IngressInfo>()._impl_._has_bits_);
  static void set_has_enable_transcoding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::livekit::IngressAudioOptions& audio(const IngressInfo* msg);
  static const ::livekit::IngressVideoOptions& video(const IngressInfo* msg);
  static const ::livekit::IngressState& state(const IngressInfo* msg);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::livekit::IngressAudioOptions&
IngressInfo::_Internal::audio(const IngressInfo* msg) {
  return *msg->_impl_.audio_;
}
const ::livekit::IngressVideoOptions&
IngressInfo::_Internal::video(const IngressInfo* msg) {
  return *msg->_impl_.video_;
}
const ::livekit::IngressState&
IngressInfo::_Internal::state(const IngressInfo* msg) {
  return *msg->_impl_.state_;
}
IngressInfo::IngressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressInfo)
}
IngressInfo::IngressInfo(const IngressInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ingress_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.stream_key_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.input_type_){}
    , decltype(_impl_.bypass_transcoding_){}
    , decltype(_impl_.enable_transcoding_){}
    , decltype(_impl_.reusable_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ingress_id().empty()) {
    _this->_impl_.ingress_id_.Set(from._internal_ingress_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.stream_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stream_key().empty()) {
    _this->_impl_.stream_key_.Set(from._internal_stream_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room_name().empty()) {
    _this->_impl_.room_name_.Set(from._internal_room_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_identity().empty()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_name().empty()) {
    _this->_impl_.participant_name_.Set(from._internal_participant_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_metadata().empty()) {
    _this->_impl_.participant_metadata_.Set(from._internal_participant_metadata(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::livekit::IngressAudioOptions(*from._impl_.audio_);
  }
  if (from._internal_has_video()) {
    _this->_impl_.video_ = new ::livekit::IngressVideoOptions(*from._impl_.video_);
  }
  if (from._internal_has_state()) {
    _this->_impl_.state_ = new ::livekit::IngressState(*from._impl_.state_);
  }
  ::memcpy(&_impl_.input_type_, &from._impl_.input_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.input_type_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:livekit.IngressInfo)
}

inline void IngressInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ingress_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.stream_key_){}
    , decltype(_impl_.url_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.input_type_){0}
    , decltype(_impl_.bypass_transcoding_){false}
    , decltype(_impl_.enable_transcoding_){false}
    , decltype(_impl_.reusable_){false}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stream_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IngressInfo::~IngressInfo() {
  // @@protoc_insertion_point(destructor:livekit.IngressInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ingress_id_.Destroy();
  _impl_.name_.Destroy();
  _impl_.stream_key_.Destroy();
  _impl_.url_.Destroy();
  _impl_.room_name_.Destroy();
  _impl_.participant_identity_.Destroy();
  _impl_.participant_name_.Destroy();
  _impl_.participant_metadata_.Destroy();
  if (this != internal_default_instance()) delete _impl_.audio_;
  if (this != internal_default_instance()) delete _impl_.video_;
  if (this != internal_default_instance()) delete _impl_.state_;
}

void IngressInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ingress_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.stream_key_.ClearToEmpty();
  _impl_.url_.ClearToEmpty();
  _impl_.room_name_.ClearToEmpty();
  _impl_.participant_identity_.ClearToEmpty();
  _impl_.participant_name_.ClearToEmpty();
  _impl_.participant_metadata_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
  ::memset(&_impl_.input_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bypass_transcoding_) -
      reinterpret_cast<char*>(&_impl_.input_type_)) + sizeof(_impl_.bypass_transcoding_));
  _impl_.enable_transcoding_ = false;
  _impl_.reusable_ = false;
  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ingress_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ingress_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.ingress_id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // string stream_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_stream_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.stream_key"));
        } else
          goto handle_unusual;
        continue;
      // string url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.url"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressInput input_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_input_type(static_cast<::livekit::IngressInput>(val));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressAudioOptions audio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressVideoOptions video = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_video(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string room_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_room_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.room_name"));
        } else
          goto handle_unusual;
        continue;
      // string participant_identity = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.participant_identity"));
        } else
          goto handle_unusual;
        continue;
      // string participant_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_participant_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.participant_name"));
        } else
          goto handle_unusual;
        continue;
      // bool reusable = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.reusable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressState state = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bypass_transcoding = 13 [deprecated = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.bypass_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string participant_metadata = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_participant_metadata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressInfo.participant_metadata"));
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_transcoding = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_enable_transcoding(&has_bits);
          _impl_.enable_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ingress_id().data(), static_cast<int>(this->_internal_ingress_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.ingress_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ingress_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string stream_key = 3;
  if (!this->_internal_stream_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stream_key().data(), static_cast<int>(this->_internal_stream_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.stream_key");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_stream_key(), target);
  }

  // string url = 4;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_url(), target);
  }

  // .livekit.IngressInput input_type = 5;
  if (this->_internal_input_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_input_type(), target);
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::video(this),
        _Internal::video(this).GetCachedSize(), target, stream);
  }

  // string room_name = 8;
  if (!this->_internal_room_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room_name().data(), static_cast<int>(this->_internal_room_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.room_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_room_name(), target);
  }

  // string participant_identity = 9;
  if (!this->_internal_participant_identity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.participant_identity");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_participant_identity(), target);
  }

  // string participant_name = 10;
  if (!this->_internal_participant_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_name().data(), static_cast<int>(this->_internal_participant_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.participant_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_participant_name(), target);
  }

  // bool reusable = 11;
  if (this->_internal_reusable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_reusable(), target);
  }

  // .livekit.IngressState state = 12;
  if (this->_internal_has_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  // bool bypass_transcoding = 13 [deprecated = true];
  if (this->_internal_bypass_transcoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_bypass_transcoding(), target);
  }

  // string participant_metadata = 14;
  if (!this->_internal_participant_metadata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_metadata().data(), static_cast<int>(this->_internal_participant_metadata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressInfo.participant_metadata");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_participant_metadata(), target);
  }

  // optional bool enable_transcoding = 15;
  if (_internal_has_enable_transcoding()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_enable_transcoding(), target);
  }

  // optional bool enabled = 16;
  if (_internal_has_enabled()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressInfo)
  return target;
}

size_t IngressInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ingress_id());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string stream_key = 3;
  if (!this->_internal_stream_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stream_key());
  }

  // string url = 4;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string room_name = 8;
  if (!this->_internal_room_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room_name());
  }

  // string participant_identity = 9;
  if (!this->_internal_participant_identity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  // string participant_name = 10;
  if (!this->_internal_participant_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_name());
  }

  // string participant_metadata = 14;
  if (!this->_internal_participant_metadata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_metadata());
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_);
  }

  // .livekit.IngressState state = 12;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_);
  }

  // .livekit.IngressInput input_type = 5;
  if (this->_internal_input_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_input_type());
  }

  // bool bypass_transcoding = 13 [deprecated = true];
  if (this->_internal_bypass_transcoding() != 0) {
    total_size += 1 + 1;
  }

  // optional bool enable_transcoding = 15;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  // bool reusable = 11;
  if (this->_internal_reusable() != 0) {
    total_size += 1 + 1;
  }

  // optional bool enabled = 16;
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressInfo::GetClassData() const { return &_class_data_; }


void IngressInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressInfo*>(&to_msg);
  auto& from = static_cast<const IngressInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ingress_id().empty()) {
    _this->_internal_set_ingress_id(from._internal_ingress_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_stream_key().empty()) {
    _this->_internal_set_stream_key(from._internal_stream_key());
  }
  if (!from._internal_url().empty()) {
    _this->_internal_set_url(from._internal_url());
  }
  if (!from._internal_room_name().empty()) {
    _this->_internal_set_room_name(from._internal_room_name());
  }
  if (!from._internal_participant_identity().empty()) {
    _this->_internal_set_participant_identity(from._internal_participant_identity());
  }
  if (!from._internal_participant_name().empty()) {
    _this->_internal_set_participant_name(from._internal_participant_name());
  }
  if (!from._internal_participant_metadata().empty()) {
    _this->_internal_set_participant_metadata(from._internal_participant_metadata());
  }
  if (from._internal_has_audio()) {
    _this->_internal_mutable_audio()->::livekit::IngressAudioOptions::MergeFrom(
        from._internal_audio());
  }
  if (from._internal_has_video()) {
    _this->_internal_mutable_video()->::livekit::IngressVideoOptions::MergeFrom(
        from._internal_video());
  }
  if (from._internal_has_state()) {
    _this->_internal_mutable_state()->::livekit::IngressState::MergeFrom(
        from._internal_state());
  }
  if (from._internal_input_type() != 0) {
    _this->_internal_set_input_type(from._internal_input_type());
  }
  if (from._internal_bypass_transcoding() != 0) {
    _this->_internal_set_bypass_transcoding(from._internal_bypass_transcoding());
  }
  if (from._internal_has_enable_transcoding()) {
    _this->_internal_set_enable_transcoding(from._internal_enable_transcoding());
  }
  if (from._internal_reusable() != 0) {
    _this->_internal_set_reusable(from._internal_reusable());
  }
  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressInfo::CopyFrom(const IngressInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressInfo::IsInitialized() const {
  return true;
}

void IngressInfo::InternalSwap(IngressInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ingress_id_, lhs_arena,
      &other->_impl_.ingress_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stream_key_, lhs_arena,
      &other->_impl_.stream_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_name_, lhs_arena,
      &other->_impl_.room_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_name_, lhs_arena,
      &other->_impl_.participant_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_metadata_, lhs_arena,
      &other->_impl_.participant_metadata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IngressInfo, _impl_.enabled_)
      + sizeof(IngressInfo::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(IngressInfo, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[5]);
}

// ===================================================================

class IngressState::_Internal {
 public:
  static const ::livekit::InputVideoState& video(const IngressState* msg);
  static const ::livekit::InputAudioState& audio(const IngressState* msg);
};

const ::livekit::InputVideoState&
IngressState::_Internal::video(const IngressState* msg) {
  return *msg->_impl_.video_;
}
const ::livekit::InputAudioState&
IngressState::_Internal::audio(const IngressState* msg) {
  return *msg->_impl_.audio_;
}
void IngressState::clear_tracks() {
  _impl_.tracks_.Clear();
}
IngressState::IngressState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.IngressState)
}
IngressState::IngressState(const IngressState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IngressState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){from._impl_.tracks_}
    , decltype(_impl_.error_){}
    , decltype(_impl_.room_id_){}
    , decltype(_impl_.resource_id_){}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.started_at_){}
    , decltype(_impl_.ended_at_){}
    , decltype(_impl_.updated_at_){}
    , decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error().empty()) {
    _this->_impl_.error_.Set(from._internal_error(), 
      _this->GetArenaForAllocation());
  }
  _impl_.room_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room_id().empty()) {
    _this->_impl_.room_id_.Set(from._internal_room_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resource_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_resource_id().empty()) {
    _this->_impl_.resource_id_.Set(from._internal_resource_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_video()) {
    _this->_impl_.video_ = new ::livekit::InputVideoState(*from._impl_.video_);
  }
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::livekit::InputAudioState(*from._impl_.audio_);
  }
  ::memcpy(&_impl_.started_at_, &from._impl_.started_at_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.started_at_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:livekit.IngressState)
}

inline void IngressState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){arena}
    , decltype(_impl_.error_){}
    , decltype(_impl_.room_id_){}
    , decltype(_impl_.resource_id_){}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.started_at_){int64_t{0}}
    , decltype(_impl_.ended_at_){int64_t{0}}
    , decltype(_impl_.updated_at_){int64_t{0}}
    , decltype(_impl_.status_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.room_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resource_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IngressState::~IngressState() {
  // @@protoc_insertion_point(destructor:livekit.IngressState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IngressState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracks_.~RepeatedPtrField();
  _impl_.error_.Destroy();
  _impl_.room_id_.Destroy();
  _impl_.resource_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.video_;
  if (this != internal_default_instance()) delete _impl_.audio_;
}

void IngressState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IngressState::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.IngressState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracks_.Clear();
  _impl_.error_.ClearToEmpty();
  _impl_.room_id_.ClearToEmpty();
  _impl_.resource_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
  ::memset(&_impl_.started_at_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.status_) -
      reinterpret_cast<char*>(&_impl_.started_at_)) + sizeof(_impl_.status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IngressState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .livekit.IngressState.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::livekit::IngressState_Status>(val));
        } else
          goto handle_unusual;
        continue;
      // string error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressState.error"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.InputVideoState video = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_video(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.InputAudioState audio = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string room_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_room_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressState.room_id"));
        } else
          goto handle_unusual;
        continue;
      // repeated .livekit.TrackInfo tracks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tracks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 started_at = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.started_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 ended_at = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ended_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string resource_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_resource_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.IngressState.resource_id"));
        } else
          goto handle_unusual;
        continue;
      // int64 updated_at = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.updated_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IngressState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.IngressState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .livekit.IngressState.Status status = 1;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // string error = 2;
  if (!this->_internal_error().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressState.error");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error(), target);
  }

  // .livekit.InputVideoState video = 3;
  if (this->_internal_has_video()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::video(this),
        _Internal::video(this).GetCachedSize(), target, stream);
  }

  // .livekit.InputAudioState audio = 4;
  if (this->_internal_has_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // string room_id = 5;
  if (!this->_internal_room_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room_id().data(), static_cast<int>(this->_internal_room_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressState.room_id");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_room_id(), target);
  }

  // repeated .livekit.TrackInfo tracks = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tracks_size()); i < n; i++) {
    const auto& repfield = this->_internal_tracks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 started_at = 7;
  if (this->_internal_started_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_started_at(), target);
  }

  // int64 ended_at = 8;
  if (this->_internal_ended_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_ended_at(), target);
  }

  // string resource_id = 9;
  if (!this->_internal_resource_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resource_id().data(), static_cast<int>(this->_internal_resource_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.IngressState.resource_id");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_resource_id(), target);
  }

  // int64 updated_at = 10;
  if (this->_internal_updated_at() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_updated_at(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.IngressState)
  return target;
}

size_t IngressState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.IngressState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .livekit.TrackInfo tracks = 6;
  total_size += 1UL * this->_internal_tracks_size();
  for (const auto& msg : this->_impl_.tracks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string error = 2;
  if (!this->_internal_error().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  // string room_id = 5;
  if (!this->_internal_room_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room_id());
  }

  // string resource_id = 9;
  if (!this->_internal_resource_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource_id());
  }

  // .livekit.InputVideoState video = 3;
  if (this->_internal_has_video()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_);
  }

  // .livekit.InputAudioState audio = 4;
  if (this->_internal_has_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_);
  }

  // int64 started_at = 7;
  if (this->_internal_started_at() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_started_at());
  }

  // int64 ended_at = 8;
  if (this->_internal_ended_at() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ended_at());
  }

  // int64 updated_at = 10;
  if (this->_internal_updated_at() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_updated_at());
  }

  // .livekit.IngressState.Status status = 1;
  if (this->_internal_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IngressState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IngressState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IngressState::GetClassData() const { return &_class_data_; }


void IngressState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IngressState*>(&to_msg);
  auto& from = static_cast<const IngressState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.IngressState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracks_.MergeFrom(from._impl_.tracks_);
  if (!from._internal_error().empty()) {
    _this->_internal_set_error(from._internal_error());
  }
  if (!from._internal_room_id().empty()) {
    _this->_internal_set_room_id(from._internal_room_id());
  }
  if (!from._internal_resource_id().empty()) {
    _this->_internal_set_resource_id(from._internal_resource_id());
  }
  if (from._internal_has_video()) {
    _this->_internal_mutable_video()->::livekit::InputVideoState::MergeFrom(
        from._internal_video());
  }
  if (from._internal_has_audio()) {
    _this->_internal_mutable_audio()->::livekit::InputAudioState::MergeFrom(
        from._internal_audio());
  }
  if (from._internal_started_at() != 0) {
    _this->_internal_set_started_at(from._internal_started_at());
  }
  if (from._internal_ended_at() != 0) {
    _this->_internal_set_ended_at(from._internal_ended_at());
  }
  if (from._internal_updated_at() != 0) {
    _this->_internal_set_updated_at(from._internal_updated_at());
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IngressState::CopyFrom(const IngressState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.IngressState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IngressState::IsInitialized() const {
  return true;
}

void IngressState::InternalSwap(IngressState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracks_.InternalSwap(&other->_impl_.tracks_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_, lhs_arena,
      &other->_impl_.error_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_id_, lhs_arena,
      &other->_impl_.room_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resource_id_, lhs_arena,
      &other->_impl_.resource_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IngressState, _impl_.status_)
      + sizeof(IngressState::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(IngressState, _impl_.video_)>(
          reinterpret_cast<char*>(&_impl_.video_),
          reinterpret_cast<char*>(&other->_impl_.video_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IngressState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[6]);
}

// ===================================================================

class InputVideoState::_Internal {
 public:
};

InputVideoState::InputVideoState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.InputVideoState)
}
InputVideoState::InputVideoState(const InputVideoState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InputVideoState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.average_bitrate_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.framerate_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mime_type().empty()) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.average_bitrate_, &from._impl_.average_bitrate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.average_bitrate_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:livekit.InputVideoState)
}

inline void InputVideoState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.average_bitrate_){0u}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.framerate_){0}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InputVideoState::~InputVideoState() {
  // @@protoc_insertion_point(destructor:livekit.InputVideoState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InputVideoState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mime_type_.Destroy();
}

void InputVideoState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InputVideoState::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.InputVideoState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mime_type_.ClearToEmpty();
  ::memset(&_impl_.average_bitrate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.average_bitrate_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InputVideoState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mime_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.InputVideoState.mime_type"));
        } else
          goto handle_unusual;
        continue;
      // uint32 average_bitrate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.average_bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double framerate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InputVideoState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.InputVideoState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mime_type().data(), static_cast<int>(this->_internal_mime_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.InputVideoState.mime_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mime_type(), target);
  }

  // uint32 average_bitrate = 2;
  if (this->_internal_average_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_average_bitrate(), target);
  }

  // uint32 width = 3;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_width(), target);
  }

  // uint32 height = 4;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_height(), target);
  }

  // double framerate = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_framerate = this->_internal_framerate();
  uint64_t raw_framerate;
  memcpy(&raw_framerate, &tmp_framerate, sizeof(tmp_framerate));
  if (raw_framerate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_framerate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.InputVideoState)
  return target;
}

size_t InputVideoState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.InputVideoState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mime_type());
  }

  // uint32 average_bitrate = 2;
  if (this->_internal_average_bitrate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_average_bitrate());
  }

  // uint32 width = 3;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  // double framerate = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_framerate = this->_internal_framerate();
  uint64_t raw_framerate;
  memcpy(&raw_framerate, &tmp_framerate, sizeof(tmp_framerate));
  if (raw_framerate != 0) {
    total_size += 1 + 8;
  }

  // uint32 height = 4;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InputVideoState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InputVideoState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InputVideoState::GetClassData() const { return &_class_data_; }


void InputVideoState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InputVideoState*>(&to_msg);
  auto& from = static_cast<const InputVideoState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.InputVideoState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mime_type().empty()) {
    _this->_internal_set_mime_type(from._internal_mime_type());
  }
  if (from._internal_average_bitrate() != 0) {
    _this->_internal_set_average_bitrate(from._internal_average_bitrate());
  }
  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_framerate = from._internal_framerate();
  uint64_t raw_framerate;
  memcpy(&raw_framerate, &tmp_framerate, sizeof(tmp_framerate));
  if (raw_framerate != 0) {
    _this->_internal_set_framerate(from._internal_framerate());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InputVideoState::CopyFrom(const InputVideoState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.InputVideoState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputVideoState::IsInitialized() const {
  return true;
}

void InputVideoState::InternalSwap(InputVideoState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_type_, lhs_arena,
      &other->_impl_.mime_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InputVideoState, _impl_.height_)
      + sizeof(InputVideoState::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(InputVideoState, _impl_.average_bitrate_)>(
          reinterpret_cast<char*>(&_impl_.average_bitrate_),
          reinterpret_cast<char*>(&other->_impl_.average_bitrate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InputVideoState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[7]);
}

// ===================================================================

class InputAudioState::_Internal {
 public:
};

InputAudioState::InputAudioState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.InputAudioState)
}
InputAudioState::InputAudioState(const InputAudioState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InputAudioState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.average_bitrate_){}
    , decltype(_impl_.channels_){}
    , decltype(_impl_.sample_rate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mime_type().empty()) {
    _this->_impl_.mime_type_.Set(from._internal_mime_type(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.average_bitrate_, &from._impl_.average_bitrate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sample_rate_) -
    reinterpret_cast<char*>(&_impl_.average_bitrate_)) + sizeof(_impl_.sample_rate_));
  // @@protoc_insertion_point(copy_constructor:livekit.InputAudioState)
}

inline void InputAudioState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mime_type_){}
    , decltype(_impl_.average_bitrate_){0u}
    , decltype(_impl_.channels_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.mime_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InputAudioState::~InputAudioState() {
  // @@protoc_insertion_point(destructor:livekit.InputAudioState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InputAudioState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mime_type_.Destroy();
}

void InputAudioState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InputAudioState::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.InputAudioState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mime_type_.ClearToEmpty();
  ::memset(&_impl_.average_bitrate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.sample_rate_) -
      reinterpret_cast<char*>(&_impl_.average_bitrate_)) + sizeof(_impl_.sample_rate_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InputAudioState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string mime_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mime_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.InputAudioState.mime_type"));
        } else
          goto handle_unusual;
        continue;
      // uint32 average_bitrate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.average_bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 channels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sample_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InputAudioState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.InputAudioState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mime_type().data(), static_cast<int>(this->_internal_mime_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.InputAudioState.mime_type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mime_type(), target);
  }

  // uint32 average_bitrate = 2;
  if (this->_internal_average_bitrate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_average_bitrate(), target);
  }

  // uint32 channels = 3;
  if (this->_internal_channels() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_channels(), target);
  }

  // uint32 sample_rate = 4;
  if (this->_internal_sample_rate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sample_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.InputAudioState)
  return target;
}

size_t InputAudioState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.InputAudioState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mime_type = 1;
  if (!this->_internal_mime_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mime_type());
  }

  // uint32 average_bitrate = 2;
  if (this->_internal_average_bitrate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_average_bitrate());
  }

  // uint32 channels = 3;
  if (this->_internal_channels() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channels());
  }

  // uint32 sample_rate = 4;
  if (this->_internal_sample_rate() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InputAudioState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InputAudioState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InputAudioState::GetClassData() const { return &_class_data_; }


void InputAudioState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InputAudioState*>(&to_msg);
  auto& from = static_cast<const InputAudioState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.InputAudioState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mime_type().empty()) {
    _this->_internal_set_mime_type(from._internal_mime_type());
  }
  if (from._internal_average_bitrate() != 0) {
    _this->_internal_set_average_bitrate(from._internal_average_bitrate());
  }
  if (from._internal_channels() != 0) {
    _this->_internal_set_channels(from._internal_channels());
  }
  if (from._internal_sample_rate() != 0) {
    _this->_internal_set_sample_rate(from._internal_sample_rate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InputAudioState::CopyFrom(const InputAudioState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.InputAudioState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputAudioState::IsInitialized() const {
  return true;
}

void InputAudioState::InternalSwap(InputAudioState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mime_type_, lhs_arena,
      &other->_impl_.mime_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InputAudioState, _impl_.sample_rate_)
      + sizeof(InputAudioState::_impl_.sample_rate_)
      - PROTOBUF_FIELD_OFFSET(InputAudioState, _impl_.average_bitrate_)>(
          reinterpret_cast<char*>(&_impl_.average_bitrate_),
          reinterpret_cast<char*>(&other->_impl_.average_bitrate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InputAudioState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[8]);
}

// ===================================================================

class UpdateIngressRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateIngressRequest>()._impl_._has_bits_);
  static void set_has_bypass_transcoding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_transcoding(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::livekit::IngressAudioOptions& audio(const UpdateIngressRequest* msg);
  static const ::livekit::IngressVideoOptions& video(const UpdateIngressRequest* msg);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::livekit::IngressAudioOptions&
UpdateIngressRequest::_Internal::audio(const UpdateIngressRequest* msg) {
  return *msg->_impl_.audio_;
}
const ::livekit::IngressVideoOptions&
UpdateIngressRequest::_Internal::video(const UpdateIngressRequest* msg) {
  return *msg->_impl_.video_;
}
UpdateIngressRequest::UpdateIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.UpdateIngressRequest)
}
UpdateIngressRequest::UpdateIngressRequest(const UpdateIngressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateIngressRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ingress_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.bypass_transcoding_){}
    , decltype(_impl_.enable_transcoding_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ingress_id().empty()) {
    _this->_impl_.ingress_id_.Set(from._internal_ingress_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room_name().empty()) {
    _this->_impl_.room_name_.Set(from._internal_room_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_identity().empty()) {
    _this->_impl_.participant_identity_.Set(from._internal_participant_identity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_name().empty()) {
    _this->_impl_.participant_name_.Set(from._internal_participant_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_participant_metadata().empty()) {
    _this->_impl_.participant_metadata_.Set(from._internal_participant_metadata(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::livekit::IngressAudioOptions(*from._impl_.audio_);
  }
  if (from._internal_has_video()) {
    _this->_impl_.video_ = new ::livekit::IngressVideoOptions(*from._impl_.video_);
  }
  ::memcpy(&_impl_.bypass_transcoding_, &from._impl_.bypass_transcoding_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.bypass_transcoding_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:livekit.UpdateIngressRequest)
}

inline void UpdateIngressRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ingress_id_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.room_name_){}
    , decltype(_impl_.participant_identity_){}
    , decltype(_impl_.participant_name_){}
    , decltype(_impl_.participant_metadata_){}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.video_){nullptr}
    , decltype(_impl_.bypass_transcoding_){false}
    , decltype(_impl_.enable_transcoding_){false}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_identity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.participant_metadata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UpdateIngressRequest::~UpdateIngressRequest() {
  // @@protoc_insertion_point(destructor:livekit.UpdateIngressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateIngressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ingress_id_.Destroy();
  _impl_.name_.Destroy();
  _impl_.room_name_.Destroy();
  _impl_.participant_identity_.Destroy();
  _impl_.participant_name_.Destroy();
  _impl_.participant_metadata_.Destroy();
  if (this != internal_default_instance()) delete _impl_.audio_;
  if (this != internal_default_instance()) delete _impl_.video_;
}

void UpdateIngressRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateIngressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.UpdateIngressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ingress_id_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.room_name_.ClearToEmpty();
  _impl_.participant_identity_.ClearToEmpty();
  _impl_.participant_name_.ClearToEmpty();
  _impl_.participant_metadata_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
  ::memset(&_impl_.bypass_transcoding_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enabled_) -
      reinterpret_cast<char*>(&_impl_.bypass_transcoding_)) + sizeof(_impl_.enabled_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateIngressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ingress_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ingress_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.ingress_id"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // string room_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_room_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.room_name"));
        } else
          goto handle_unusual;
        continue;
      // string participant_identity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_participant_identity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.participant_identity"));
        } else
          goto handle_unusual;
        continue;
      // string participant_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_participant_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.participant_name"));
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressAudioOptions audio = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .livekit.IngressVideoOptions video = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_video(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bypass_transcoding = 8 [deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bypass_transcoding(&has_bits);
          _impl_.bypass_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string participant_metadata = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_participant_metadata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.UpdateIngressRequest.participant_metadata"));
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_transcoding = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_enable_transcoding(&has_bits);
          _impl_.enable_transcoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateIngressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.UpdateIngressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ingress_id().data(), static_cast<int>(this->_internal_ingress_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.ingress_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ingress_id(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string room_name = 3;
  if (!this->_internal_room_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room_name().data(), static_cast<int>(this->_internal_room_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.room_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_room_name(), target);
  }

  // string participant_identity = 4;
  if (!this->_internal_participant_identity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_identity().data(), static_cast<int>(this->_internal_participant_identity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.participant_identity");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_participant_identity(), target);
  }

  // string participant_name = 5;
  if (!this->_internal_participant_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_name().data(), static_cast<int>(this->_internal_participant_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.participant_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_participant_name(), target);
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::video(this),
        _Internal::video(this).GetCachedSize(), target, stream);
  }

  // optional bool bypass_transcoding = 8 [deprecated = true];
  if (_internal_has_bypass_transcoding()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_bypass_transcoding(), target);
  }

  // string participant_metadata = 9;
  if (!this->_internal_participant_metadata().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_participant_metadata().data(), static_cast<int>(this->_internal_participant_metadata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.UpdateIngressRequest.participant_metadata");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_participant_metadata(), target);
  }

  // optional bool enable_transcoding = 10;
  if (_internal_has_enable_transcoding()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_enable_transcoding(), target);
  }

  // optional bool enabled = 11;
  if (_internal_has_enabled()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.UpdateIngressRequest)
  return target;
}

size_t UpdateIngressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.UpdateIngressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ingress_id());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string room_name = 3;
  if (!this->_internal_room_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room_name());
  }

  // string participant_identity = 4;
  if (!this->_internal_participant_identity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_identity());
  }

  // string participant_name = 5;
  if (!this->_internal_participant_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_name());
  }

  // string participant_metadata = 9;
  if (!this->_internal_participant_metadata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_participant_metadata());
  }

  // .livekit.IngressAudioOptions audio = 6;
  if (this->_internal_has_audio()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.audio_);
  }

  // .livekit.IngressVideoOptions video = 7;
  if (this->_internal_has_video()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.video_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool bypass_transcoding = 8 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool enable_transcoding = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool enabled = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateIngressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateIngressRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateIngressRequest::GetClassData() const { return &_class_data_; }


void UpdateIngressRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateIngressRequest*>(&to_msg);
  auto& from = static_cast<const UpdateIngressRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.UpdateIngressRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ingress_id().empty()) {
    _this->_internal_set_ingress_id(from._internal_ingress_id());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_room_name().empty()) {
    _this->_internal_set_room_name(from._internal_room_name());
  }
  if (!from._internal_participant_identity().empty()) {
    _this->_internal_set_participant_identity(from._internal_participant_identity());
  }
  if (!from._internal_participant_name().empty()) {
    _this->_internal_set_participant_name(from._internal_participant_name());
  }
  if (!from._internal_participant_metadata().empty()) {
    _this->_internal_set_participant_metadata(from._internal_participant_metadata());
  }
  if (from._internal_has_audio()) {
    _this->_internal_mutable_audio()->::livekit::IngressAudioOptions::MergeFrom(
        from._internal_audio());
  }
  if (from._internal_has_video()) {
    _this->_internal_mutable_video()->::livekit::IngressVideoOptions::MergeFrom(
        from._internal_video());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bypass_transcoding_ = from._impl_.bypass_transcoding_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enable_transcoding_ = from._impl_.enable_transcoding_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateIngressRequest::CopyFrom(const UpdateIngressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.UpdateIngressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateIngressRequest::IsInitialized() const {
  return true;
}

void UpdateIngressRequest::InternalSwap(UpdateIngressRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ingress_id_, lhs_arena,
      &other->_impl_.ingress_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_name_, lhs_arena,
      &other->_impl_.room_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_identity_, lhs_arena,
      &other->_impl_.participant_identity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_name_, lhs_arena,
      &other->_impl_.participant_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.participant_metadata_, lhs_arena,
      &other->_impl_.participant_metadata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateIngressRequest, _impl_.enabled_)
      + sizeof(UpdateIngressRequest::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(UpdateIngressRequest, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateIngressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[9]);
}

// ===================================================================

class ListIngressRequest::_Internal {
 public:
};

ListIngressRequest::ListIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.ListIngressRequest)
}
ListIngressRequest::ListIngressRequest(const ListIngressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListIngressRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.room_name_){}
    , decltype(_impl_.ingress_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room_name().empty()) {
    _this->_impl_.room_name_.Set(from._internal_room_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ingress_id().empty()) {
    _this->_impl_.ingress_id_.Set(from._internal_ingress_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.ListIngressRequest)
}

inline void ListIngressRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.room_name_){}
    , decltype(_impl_.ingress_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.room_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListIngressRequest::~ListIngressRequest() {
  // @@protoc_insertion_point(destructor:livekit.ListIngressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListIngressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.room_name_.Destroy();
  _impl_.ingress_id_.Destroy();
}

void ListIngressRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListIngressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.ListIngressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.room_name_.ClearToEmpty();
  _impl_.ingress_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListIngressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string room_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_room_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.ListIngressRequest.room_name"));
        } else
          goto handle_unusual;
        continue;
      // string ingress_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ingress_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.ListIngressRequest.ingress_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListIngressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.ListIngressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string room_name = 1;
  if (!this->_internal_room_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room_name().data(), static_cast<int>(this->_internal_room_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.ListIngressRequest.room_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_room_name(), target);
  }

  // string ingress_id = 2;
  if (!this->_internal_ingress_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ingress_id().data(), static_cast<int>(this->_internal_ingress_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.ListIngressRequest.ingress_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ingress_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.ListIngressRequest)
  return target;
}

size_t ListIngressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.ListIngressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string room_name = 1;
  if (!this->_internal_room_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room_name());
  }

  // string ingress_id = 2;
  if (!this->_internal_ingress_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ingress_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListIngressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListIngressRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListIngressRequest::GetClassData() const { return &_class_data_; }


void ListIngressRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListIngressRequest*>(&to_msg);
  auto& from = static_cast<const ListIngressRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.ListIngressRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_room_name().empty()) {
    _this->_internal_set_room_name(from._internal_room_name());
  }
  if (!from._internal_ingress_id().empty()) {
    _this->_internal_set_ingress_id(from._internal_ingress_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListIngressRequest::CopyFrom(const ListIngressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.ListIngressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListIngressRequest::IsInitialized() const {
  return true;
}

void ListIngressRequest::InternalSwap(ListIngressRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_name_, lhs_arena,
      &other->_impl_.room_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ingress_id_, lhs_arena,
      &other->_impl_.ingress_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListIngressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[10]);
}

// ===================================================================

class ListIngressResponse::_Internal {
 public:
};

ListIngressResponse::ListIngressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.ListIngressResponse)
}
ListIngressResponse::ListIngressResponse(const ListIngressResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListIngressResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){from._impl_.items_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:livekit.ListIngressResponse)
}

inline void ListIngressResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.items_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ListIngressResponse::~ListIngressResponse() {
  // @@protoc_insertion_point(destructor:livekit.ListIngressResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListIngressResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.items_.~RepeatedPtrField();
}

void ListIngressResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListIngressResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.ListIngressResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListIngressResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .livekit.IngressInfo items = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListIngressResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.ListIngressResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .livekit.IngressInfo items = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.ListIngressResponse)
  return target;
}

size_t ListIngressResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.ListIngressResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .livekit.IngressInfo items = 1;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_impl_.items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListIngressResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListIngressResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListIngressResponse::GetClassData() const { return &_class_data_; }


void ListIngressResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListIngressResponse*>(&to_msg);
  auto& from = static_cast<const ListIngressResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.ListIngressResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.items_.MergeFrom(from._impl_.items_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListIngressResponse::CopyFrom(const ListIngressResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.ListIngressResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListIngressResponse::IsInitialized() const {
  return true;
}

void ListIngressResponse::InternalSwap(ListIngressResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListIngressResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[11]);
}

// ===================================================================

class DeleteIngressRequest::_Internal {
 public:
};

DeleteIngressRequest::DeleteIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:livekit.DeleteIngressRequest)
}
DeleteIngressRequest::DeleteIngressRequest(const DeleteIngressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteIngressRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ingress_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ingress_id().empty()) {
    _this->_impl_.ingress_id_.Set(from._internal_ingress_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:livekit.DeleteIngressRequest)
}

inline void DeleteIngressRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ingress_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ingress_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteIngressRequest::~DeleteIngressRequest() {
  // @@protoc_insertion_point(destructor:livekit.DeleteIngressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteIngressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ingress_id_.Destroy();
}

void DeleteIngressRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteIngressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:livekit.DeleteIngressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ingress_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteIngressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ingress_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ingress_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "livekit.DeleteIngressRequest.ingress_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteIngressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:livekit.DeleteIngressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ingress_id().data(), static_cast<int>(this->_internal_ingress_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "livekit.DeleteIngressRequest.ingress_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ingress_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:livekit.DeleteIngressRequest)
  return target;
}

size_t DeleteIngressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:livekit.DeleteIngressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ingress_id = 1;
  if (!this->_internal_ingress_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ingress_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteIngressRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteIngressRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteIngressRequest::GetClassData() const { return &_class_data_; }


void DeleteIngressRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteIngressRequest*>(&to_msg);
  auto& from = static_cast<const DeleteIngressRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:livekit.DeleteIngressRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ingress_id().empty()) {
    _this->_internal_set_ingress_id(from._internal_ingress_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteIngressRequest::CopyFrom(const DeleteIngressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:livekit.DeleteIngressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteIngressRequest::IsInitialized() const {
  return true;
}

void DeleteIngressRequest::InternalSwap(DeleteIngressRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ingress_id_, lhs_arena,
      &other->_impl_.ingress_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteIngressRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_livekit_5fingress_2eproto_getter, &descriptor_table_livekit_5fingress_2eproto_once,
      file_level_metadata_livekit_5fingress_2eproto[12]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::livekit::CreateIngressRequest*
Arena::CreateMaybeMessage< ::livekit::CreateIngressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::CreateIngressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressAudioOptions*
Arena::CreateMaybeMessage< ::livekit::IngressAudioOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressAudioOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressVideoOptions*
Arena::CreateMaybeMessage< ::livekit::IngressVideoOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressVideoOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressAudioEncodingOptions*
Arena::CreateMaybeMessage< ::livekit::IngressAudioEncodingOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressAudioEncodingOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressVideoEncodingOptions*
Arena::CreateMaybeMessage< ::livekit::IngressVideoEncodingOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressVideoEncodingOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressInfo*
Arena::CreateMaybeMessage< ::livekit::IngressInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::IngressState*
Arena::CreateMaybeMessage< ::livekit::IngressState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::IngressState >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::InputVideoState*
Arena::CreateMaybeMessage< ::livekit::InputVideoState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::InputVideoState >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::InputAudioState*
Arena::CreateMaybeMessage< ::livekit::InputAudioState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::InputAudioState >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::UpdateIngressRequest*
Arena::CreateMaybeMessage< ::livekit::UpdateIngressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::UpdateIngressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::ListIngressRequest*
Arena::CreateMaybeMessage< ::livekit::ListIngressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::ListIngressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::ListIngressResponse*
Arena::CreateMaybeMessage< ::livekit::ListIngressResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::ListIngressResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::livekit::DeleteIngressRequest*
Arena::CreateMaybeMessage< ::livekit::DeleteIngressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::livekit::DeleteIngressRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
