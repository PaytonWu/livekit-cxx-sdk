// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_egress.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5fegress_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5fegress_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5fegress_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fegress_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5fegress_2eproto;
namespace livekit {
class AliOSSUpload;
struct AliOSSUploadDefaultTypeInternal;
extern AliOSSUploadDefaultTypeInternal _AliOSSUpload_default_instance_;
class AutoParticipantEgress;
struct AutoParticipantEgressDefaultTypeInternal;
extern AutoParticipantEgressDefaultTypeInternal _AutoParticipantEgress_default_instance_;
class AutoTrackEgress;
struct AutoTrackEgressDefaultTypeInternal;
extern AutoTrackEgressDefaultTypeInternal _AutoTrackEgress_default_instance_;
class AzureBlobUpload;
struct AzureBlobUploadDefaultTypeInternal;
extern AzureBlobUploadDefaultTypeInternal _AzureBlobUpload_default_instance_;
class DirectFileOutput;
struct DirectFileOutputDefaultTypeInternal;
extern DirectFileOutputDefaultTypeInternal _DirectFileOutput_default_instance_;
class EgressInfo;
struct EgressInfoDefaultTypeInternal;
extern EgressInfoDefaultTypeInternal _EgressInfo_default_instance_;
class EncodedFileOutput;
struct EncodedFileOutputDefaultTypeInternal;
extern EncodedFileOutputDefaultTypeInternal _EncodedFileOutput_default_instance_;
class EncodingOptions;
struct EncodingOptionsDefaultTypeInternal;
extern EncodingOptionsDefaultTypeInternal _EncodingOptions_default_instance_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class GCPUpload;
struct GCPUploadDefaultTypeInternal;
extern GCPUploadDefaultTypeInternal _GCPUpload_default_instance_;
class ImageOutput;
struct ImageOutputDefaultTypeInternal;
extern ImageOutputDefaultTypeInternal _ImageOutput_default_instance_;
class ImagesInfo;
struct ImagesInfoDefaultTypeInternal;
extern ImagesInfoDefaultTypeInternal _ImagesInfo_default_instance_;
class ListEgressRequest;
struct ListEgressRequestDefaultTypeInternal;
extern ListEgressRequestDefaultTypeInternal _ListEgressRequest_default_instance_;
class ListEgressResponse;
struct ListEgressResponseDefaultTypeInternal;
extern ListEgressResponseDefaultTypeInternal _ListEgressResponse_default_instance_;
class ParticipantEgressRequest;
struct ParticipantEgressRequestDefaultTypeInternal;
extern ParticipantEgressRequestDefaultTypeInternal _ParticipantEgressRequest_default_instance_;
class ProxyConfig;
struct ProxyConfigDefaultTypeInternal;
extern ProxyConfigDefaultTypeInternal _ProxyConfig_default_instance_;
class RoomCompositeEgressRequest;
struct RoomCompositeEgressRequestDefaultTypeInternal;
extern RoomCompositeEgressRequestDefaultTypeInternal _RoomCompositeEgressRequest_default_instance_;
class S3Upload;
struct S3UploadDefaultTypeInternal;
extern S3UploadDefaultTypeInternal _S3Upload_default_instance_;
class S3Upload_MetadataEntry_DoNotUse;
struct S3Upload_MetadataEntry_DoNotUseDefaultTypeInternal;
extern S3Upload_MetadataEntry_DoNotUseDefaultTypeInternal _S3Upload_MetadataEntry_DoNotUse_default_instance_;
class SegmentedFileOutput;
struct SegmentedFileOutputDefaultTypeInternal;
extern SegmentedFileOutputDefaultTypeInternal _SegmentedFileOutput_default_instance_;
class SegmentsInfo;
struct SegmentsInfoDefaultTypeInternal;
extern SegmentsInfoDefaultTypeInternal _SegmentsInfo_default_instance_;
class StopEgressRequest;
struct StopEgressRequestDefaultTypeInternal;
extern StopEgressRequestDefaultTypeInternal _StopEgressRequest_default_instance_;
class StreamInfo;
struct StreamInfoDefaultTypeInternal;
extern StreamInfoDefaultTypeInternal _StreamInfo_default_instance_;
class StreamInfoList;
struct StreamInfoListDefaultTypeInternal;
extern StreamInfoListDefaultTypeInternal _StreamInfoList_default_instance_;
class StreamOutput;
struct StreamOutputDefaultTypeInternal;
extern StreamOutputDefaultTypeInternal _StreamOutput_default_instance_;
class TrackCompositeEgressRequest;
struct TrackCompositeEgressRequestDefaultTypeInternal;
extern TrackCompositeEgressRequestDefaultTypeInternal _TrackCompositeEgressRequest_default_instance_;
class TrackEgressRequest;
struct TrackEgressRequestDefaultTypeInternal;
extern TrackEgressRequestDefaultTypeInternal _TrackEgressRequest_default_instance_;
class UpdateLayoutRequest;
struct UpdateLayoutRequestDefaultTypeInternal;
extern UpdateLayoutRequestDefaultTypeInternal _UpdateLayoutRequest_default_instance_;
class UpdateStreamRequest;
struct UpdateStreamRequestDefaultTypeInternal;
extern UpdateStreamRequestDefaultTypeInternal _UpdateStreamRequest_default_instance_;
class WebEgressRequest;
struct WebEgressRequestDefaultTypeInternal;
extern WebEgressRequestDefaultTypeInternal _WebEgressRequest_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::AliOSSUpload* Arena::CreateMaybeMessage<::livekit::AliOSSUpload>(Arena*);
template<> ::livekit::AutoParticipantEgress* Arena::CreateMaybeMessage<::livekit::AutoParticipantEgress>(Arena*);
template<> ::livekit::AutoTrackEgress* Arena::CreateMaybeMessage<::livekit::AutoTrackEgress>(Arena*);
template<> ::livekit::AzureBlobUpload* Arena::CreateMaybeMessage<::livekit::AzureBlobUpload>(Arena*);
template<> ::livekit::DirectFileOutput* Arena::CreateMaybeMessage<::livekit::DirectFileOutput>(Arena*);
template<> ::livekit::EgressInfo* Arena::CreateMaybeMessage<::livekit::EgressInfo>(Arena*);
template<> ::livekit::EncodedFileOutput* Arena::CreateMaybeMessage<::livekit::EncodedFileOutput>(Arena*);
template<> ::livekit::EncodingOptions* Arena::CreateMaybeMessage<::livekit::EncodingOptions>(Arena*);
template<> ::livekit::FileInfo* Arena::CreateMaybeMessage<::livekit::FileInfo>(Arena*);
template<> ::livekit::GCPUpload* Arena::CreateMaybeMessage<::livekit::GCPUpload>(Arena*);
template<> ::livekit::ImageOutput* Arena::CreateMaybeMessage<::livekit::ImageOutput>(Arena*);
template<> ::livekit::ImagesInfo* Arena::CreateMaybeMessage<::livekit::ImagesInfo>(Arena*);
template<> ::livekit::ListEgressRequest* Arena::CreateMaybeMessage<::livekit::ListEgressRequest>(Arena*);
template<> ::livekit::ListEgressResponse* Arena::CreateMaybeMessage<::livekit::ListEgressResponse>(Arena*);
template<> ::livekit::ParticipantEgressRequest* Arena::CreateMaybeMessage<::livekit::ParticipantEgressRequest>(Arena*);
template<> ::livekit::ProxyConfig* Arena::CreateMaybeMessage<::livekit::ProxyConfig>(Arena*);
template<> ::livekit::RoomCompositeEgressRequest* Arena::CreateMaybeMessage<::livekit::RoomCompositeEgressRequest>(Arena*);
template<> ::livekit::S3Upload* Arena::CreateMaybeMessage<::livekit::S3Upload>(Arena*);
template<> ::livekit::S3Upload_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::S3Upload_MetadataEntry_DoNotUse>(Arena*);
template<> ::livekit::SegmentedFileOutput* Arena::CreateMaybeMessage<::livekit::SegmentedFileOutput>(Arena*);
template<> ::livekit::SegmentsInfo* Arena::CreateMaybeMessage<::livekit::SegmentsInfo>(Arena*);
template<> ::livekit::StopEgressRequest* Arena::CreateMaybeMessage<::livekit::StopEgressRequest>(Arena*);
template<> ::livekit::StreamInfo* Arena::CreateMaybeMessage<::livekit::StreamInfo>(Arena*);
template<> ::livekit::StreamInfoList* Arena::CreateMaybeMessage<::livekit::StreamInfoList>(Arena*);
template<> ::livekit::StreamOutput* Arena::CreateMaybeMessage<::livekit::StreamOutput>(Arena*);
template<> ::livekit::TrackCompositeEgressRequest* Arena::CreateMaybeMessage<::livekit::TrackCompositeEgressRequest>(Arena*);
template<> ::livekit::TrackEgressRequest* Arena::CreateMaybeMessage<::livekit::TrackEgressRequest>(Arena*);
template<> ::livekit::UpdateLayoutRequest* Arena::CreateMaybeMessage<::livekit::UpdateLayoutRequest>(Arena*);
template<> ::livekit::UpdateStreamRequest* Arena::CreateMaybeMessage<::livekit::UpdateStreamRequest>(Arena*);
template<> ::livekit::WebEgressRequest* Arena::CreateMaybeMessage<::livekit::WebEgressRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum StreamInfo_Status : int {
  StreamInfo_Status_ACTIVE = 0,
  StreamInfo_Status_FINISHED = 1,
  StreamInfo_Status_FAILED = 2,
  StreamInfo_Status_StreamInfo_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamInfo_Status_StreamInfo_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamInfo_Status_IsValid(int value);
constexpr StreamInfo_Status StreamInfo_Status_Status_MIN = StreamInfo_Status_ACTIVE;
constexpr StreamInfo_Status StreamInfo_Status_Status_MAX = StreamInfo_Status_FAILED;
constexpr int StreamInfo_Status_Status_ARRAYSIZE = StreamInfo_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamInfo_Status_descriptor();
template<typename T>
inline const std::string& StreamInfo_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamInfo_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamInfo_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamInfo_Status_descriptor(), enum_t_value);
}
inline bool StreamInfo_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamInfo_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamInfo_Status>(
    StreamInfo_Status_descriptor(), name, value);
}
enum EncodedFileType : int {
  DEFAULT_FILETYPE = 0,
  MP4 = 1,
  OGG = 2,
  EncodedFileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncodedFileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncodedFileType_IsValid(int value);
constexpr EncodedFileType EncodedFileType_MIN = DEFAULT_FILETYPE;
constexpr EncodedFileType EncodedFileType_MAX = OGG;
constexpr int EncodedFileType_ARRAYSIZE = EncodedFileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncodedFileType_descriptor();
template<typename T>
inline const std::string& EncodedFileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncodedFileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncodedFileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncodedFileType_descriptor(), enum_t_value);
}
inline bool EncodedFileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncodedFileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncodedFileType>(
    EncodedFileType_descriptor(), name, value);
}
enum SegmentedFileProtocol : int {
  DEFAULT_SEGMENTED_FILE_PROTOCOL = 0,
  HLS_PROTOCOL = 1,
  SegmentedFileProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SegmentedFileProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SegmentedFileProtocol_IsValid(int value);
constexpr SegmentedFileProtocol SegmentedFileProtocol_MIN = DEFAULT_SEGMENTED_FILE_PROTOCOL;
constexpr SegmentedFileProtocol SegmentedFileProtocol_MAX = HLS_PROTOCOL;
constexpr int SegmentedFileProtocol_ARRAYSIZE = SegmentedFileProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SegmentedFileProtocol_descriptor();
template<typename T>
inline const std::string& SegmentedFileProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SegmentedFileProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SegmentedFileProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SegmentedFileProtocol_descriptor(), enum_t_value);
}
inline bool SegmentedFileProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentedFileProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SegmentedFileProtocol>(
    SegmentedFileProtocol_descriptor(), name, value);
}
enum SegmentedFileSuffix : int {
  INDEX = 0,
  TIMESTAMP = 1,
  SegmentedFileSuffix_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SegmentedFileSuffix_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SegmentedFileSuffix_IsValid(int value);
constexpr SegmentedFileSuffix SegmentedFileSuffix_MIN = INDEX;
constexpr SegmentedFileSuffix SegmentedFileSuffix_MAX = TIMESTAMP;
constexpr int SegmentedFileSuffix_ARRAYSIZE = SegmentedFileSuffix_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SegmentedFileSuffix_descriptor();
template<typename T>
inline const std::string& SegmentedFileSuffix_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SegmentedFileSuffix>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SegmentedFileSuffix_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SegmentedFileSuffix_descriptor(), enum_t_value);
}
inline bool SegmentedFileSuffix_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentedFileSuffix* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SegmentedFileSuffix>(
    SegmentedFileSuffix_descriptor(), name, value);
}
enum ImageFileSuffix : int {
  IMAGE_SUFFIX_INDEX = 0,
  IMAGE_SUFFIX_TIMESTAMP = 1,
  ImageFileSuffix_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageFileSuffix_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageFileSuffix_IsValid(int value);
constexpr ImageFileSuffix ImageFileSuffix_MIN = IMAGE_SUFFIX_INDEX;
constexpr ImageFileSuffix ImageFileSuffix_MAX = IMAGE_SUFFIX_TIMESTAMP;
constexpr int ImageFileSuffix_ARRAYSIZE = ImageFileSuffix_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFileSuffix_descriptor();
template<typename T>
inline const std::string& ImageFileSuffix_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFileSuffix>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFileSuffix_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFileSuffix_descriptor(), enum_t_value);
}
inline bool ImageFileSuffix_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFileSuffix* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFileSuffix>(
    ImageFileSuffix_descriptor(), name, value);
}
enum StreamProtocol : int {
  DEFAULT_PROTOCOL = 0,
  RTMP = 1,
  SRT = 2,
  StreamProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamProtocol_IsValid(int value);
constexpr StreamProtocol StreamProtocol_MIN = DEFAULT_PROTOCOL;
constexpr StreamProtocol StreamProtocol_MAX = SRT;
constexpr int StreamProtocol_ARRAYSIZE = StreamProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamProtocol_descriptor();
template<typename T>
inline const std::string& StreamProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamProtocol_descriptor(), enum_t_value);
}
inline bool StreamProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamProtocol>(
    StreamProtocol_descriptor(), name, value);
}
enum AudioMixing : int {
  DEFAULT_MIXING = 0,
  DUAL_CHANNEL_AGENT = 1,
  DUAL_CHANNEL_ALTERNATE = 2,
  AudioMixing_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioMixing_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioMixing_IsValid(int value);
constexpr AudioMixing AudioMixing_MIN = DEFAULT_MIXING;
constexpr AudioMixing AudioMixing_MAX = DUAL_CHANNEL_ALTERNATE;
constexpr int AudioMixing_ARRAYSIZE = AudioMixing_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioMixing_descriptor();
template<typename T>
inline const std::string& AudioMixing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioMixing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioMixing_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioMixing_descriptor(), enum_t_value);
}
inline bool AudioMixing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioMixing* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioMixing>(
    AudioMixing_descriptor(), name, value);
}
enum EncodingOptionsPreset : int {
  H264_720P_30 = 0,
  H264_720P_60 = 1,
  H264_1080P_30 = 2,
  H264_1080P_60 = 3,
  PORTRAIT_H264_720P_30 = 4,
  PORTRAIT_H264_720P_60 = 5,
  PORTRAIT_H264_1080P_30 = 6,
  PORTRAIT_H264_1080P_60 = 7,
  EncodingOptionsPreset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncodingOptionsPreset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncodingOptionsPreset_IsValid(int value);
constexpr EncodingOptionsPreset EncodingOptionsPreset_MIN = H264_720P_30;
constexpr EncodingOptionsPreset EncodingOptionsPreset_MAX = PORTRAIT_H264_1080P_60;
constexpr int EncodingOptionsPreset_ARRAYSIZE = EncodingOptionsPreset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncodingOptionsPreset_descriptor();
template<typename T>
inline const std::string& EncodingOptionsPreset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncodingOptionsPreset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncodingOptionsPreset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncodingOptionsPreset_descriptor(), enum_t_value);
}
inline bool EncodingOptionsPreset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncodingOptionsPreset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncodingOptionsPreset>(
    EncodingOptionsPreset_descriptor(), name, value);
}
enum EgressStatus : int {
  EGRESS_STARTING = 0,
  EGRESS_ACTIVE = 1,
  EGRESS_ENDING = 2,
  EGRESS_COMPLETE = 3,
  EGRESS_FAILED = 4,
  EGRESS_ABORTED = 5,
  EGRESS_LIMIT_REACHED = 6,
  EgressStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EgressStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EgressStatus_IsValid(int value);
constexpr EgressStatus EgressStatus_MIN = EGRESS_STARTING;
constexpr EgressStatus EgressStatus_MAX = EGRESS_LIMIT_REACHED;
constexpr int EgressStatus_ARRAYSIZE = EgressStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgressStatus_descriptor();
template<typename T>
inline const std::string& EgressStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgressStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgressStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgressStatus_descriptor(), enum_t_value);
}
inline bool EgressStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgressStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgressStatus>(
    EgressStatus_descriptor(), name, value);
}
enum EgressSourceType : int {
  EGRESS_SOURCE_TYPE_WEB = 0,
  EGRESS_SOURCE_TYPE_SDK = 1,
  EgressSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EgressSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EgressSourceType_IsValid(int value);
constexpr EgressSourceType EgressSourceType_MIN = EGRESS_SOURCE_TYPE_WEB;
constexpr EgressSourceType EgressSourceType_MAX = EGRESS_SOURCE_TYPE_SDK;
constexpr int EgressSourceType_ARRAYSIZE = EgressSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EgressSourceType_descriptor();
template<typename T>
inline const std::string& EgressSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EgressSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EgressSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EgressSourceType_descriptor(), enum_t_value);
}
inline bool EgressSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EgressSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EgressSourceType>(
    EgressSourceType_descriptor(), name, value);
}
// ===================================================================

class RoomCompositeEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomCompositeEgressRequest) */ {
 public:
  inline RoomCompositeEgressRequest() : RoomCompositeEgressRequest(nullptr) {}
  ~RoomCompositeEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR RoomCompositeEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomCompositeEgressRequest(const RoomCompositeEgressRequest& from);
  RoomCompositeEgressRequest(RoomCompositeEgressRequest&& from) noexcept
    : RoomCompositeEgressRequest() {
    *this = ::std::move(from);
  }

  inline RoomCompositeEgressRequest& operator=(const RoomCompositeEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomCompositeEgressRequest& operator=(RoomCompositeEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomCompositeEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kFile = 6,
    kStream = 7,
    kSegments = 10,
    OUTPUT_NOT_SET = 0,
  };

  enum OptionsCase {
    kPreset = 8,
    kAdvanced = 9,
    OPTIONS_NOT_SET = 0,
  };

  static inline const RoomCompositeEgressRequest* internal_default_instance() {
    return reinterpret_cast<const RoomCompositeEgressRequest*>(
               &_RoomCompositeEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoomCompositeEgressRequest& a, RoomCompositeEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomCompositeEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomCompositeEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomCompositeEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomCompositeEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomCompositeEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomCompositeEgressRequest& from) {
    RoomCompositeEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomCompositeEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomCompositeEgressRequest";
  }
  protected:
  explicit RoomCompositeEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileOutputsFieldNumber = 11,
    kStreamOutputsFieldNumber = 12,
    kSegmentOutputsFieldNumber = 13,
    kImageOutputsFieldNumber = 14,
    kRoomNameFieldNumber = 1,
    kLayoutFieldNumber = 2,
    kCustomBaseUrlFieldNumber = 5,
    kAudioOnlyFieldNumber = 3,
    kVideoOnlyFieldNumber = 4,
    kAudioMixingFieldNumber = 15,
    kFileFieldNumber = 6,
    kStreamFieldNumber = 7,
    kSegmentsFieldNumber = 10,
    kPresetFieldNumber = 8,
    kAdvancedFieldNumber = 9,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 11;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;
  public:
  void clear_file_outputs();
  ::livekit::EncodedFileOutput* mutable_file_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
      mutable_file_outputs();
  private:
  const ::livekit::EncodedFileOutput& _internal_file_outputs(int index) const;
  ::livekit::EncodedFileOutput* _internal_add_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* add_file_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
      file_outputs() const;

  // repeated .livekit.StreamOutput stream_outputs = 12;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;
  public:
  void clear_stream_outputs();
  ::livekit::StreamOutput* mutable_stream_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
      mutable_stream_outputs();
  private:
  const ::livekit::StreamOutput& _internal_stream_outputs(int index) const;
  ::livekit::StreamOutput* _internal_add_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* add_stream_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
      stream_outputs() const;

  // repeated .livekit.SegmentedFileOutput segment_outputs = 13;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;
  public:
  void clear_segment_outputs();
  ::livekit::SegmentedFileOutput* mutable_segment_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
      mutable_segment_outputs();
  private:
  const ::livekit::SegmentedFileOutput& _internal_segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* _internal_add_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* add_segment_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
      segment_outputs() const;

  // repeated .livekit.ImageOutput image_outputs = 14;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;
  public:
  void clear_image_outputs();
  ::livekit::ImageOutput* mutable_image_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
      mutable_image_outputs();
  private:
  const ::livekit::ImageOutput& _internal_image_outputs(int index) const;
  ::livekit::ImageOutput* _internal_add_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* add_image_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
      image_outputs() const;

  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string layout = 2;
  void clear_layout();
  const std::string& layout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layout();
  PROTOBUF_NODISCARD std::string* release_layout();
  void set_allocated_layout(std::string* layout);
  private:
  const std::string& _internal_layout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* _internal_mutable_layout();
  public:

  // string custom_base_url = 5;
  void clear_custom_base_url();
  const std::string& custom_base_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_base_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_base_url();
  PROTOBUF_NODISCARD std::string* release_custom_base_url();
  void set_allocated_custom_base_url(std::string* custom_base_url);
  private:
  const std::string& _internal_custom_base_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_base_url(const std::string& value);
  std::string* _internal_mutable_custom_base_url();
  public:

  // bool audio_only = 3;
  void clear_audio_only();
  bool audio_only() const;
  void set_audio_only(bool value);
  private:
  bool _internal_audio_only() const;
  void _internal_set_audio_only(bool value);
  public:

  // bool video_only = 4;
  void clear_video_only();
  bool video_only() const;
  void set_video_only(bool value);
  private:
  bool _internal_video_only() const;
  void _internal_set_video_only(bool value);
  public:

  // .livekit.AudioMixing audio_mixing = 15;
  void clear_audio_mixing();
  ::livekit::AudioMixing audio_mixing() const;
  void set_audio_mixing(::livekit::AudioMixing value);
  private:
  ::livekit::AudioMixing _internal_audio_mixing() const;
  void _internal_set_audio_mixing(::livekit::AudioMixing value);
  public:

  // .livekit.EncodedFileOutput file = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  PROTOBUF_DEPRECATED void clear_file();
  PROTOBUF_DEPRECATED const ::livekit::EncodedFileOutput& file() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* release_file();
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* mutable_file();
  PROTOBUF_DEPRECATED void set_allocated_file(::livekit::EncodedFileOutput* file);
  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* _internal_mutable_file();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_file(
      ::livekit::EncodedFileOutput* file);
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* unsafe_arena_release_file();

  // .livekit.StreamOutput stream = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  PROTOBUF_DEPRECATED void clear_stream();
  PROTOBUF_DEPRECATED const ::livekit::StreamOutput& stream() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::StreamOutput* release_stream();
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* mutable_stream();
  PROTOBUF_DEPRECATED void set_allocated_stream(::livekit::StreamOutput* stream);
  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* _internal_mutable_stream();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_stream(
      ::livekit::StreamOutput* stream);
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* unsafe_arena_release_stream();

  // .livekit.SegmentedFileOutput segments = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_segments() const;
  private:
  bool _internal_has_segments() const;
  public:
  PROTOBUF_DEPRECATED void clear_segments();
  PROTOBUF_DEPRECATED const ::livekit::SegmentedFileOutput& segments() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* release_segments();
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* mutable_segments();
  PROTOBUF_DEPRECATED void set_allocated_segments(::livekit::SegmentedFileOutput* segments);
  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* _internal_mutable_segments();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_segments(
      ::livekit::SegmentedFileOutput* segments);
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* unsafe_arena_release_segments();

  // .livekit.EncodingOptionsPreset preset = 8;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);
  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);
  public:

  // .livekit.EncodingOptions advanced = 9;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;
  public:
  void clear_advanced();
  const ::livekit::EncodingOptions& advanced() const;
  PROTOBUF_NODISCARD ::livekit::EncodingOptions* release_advanced();
  ::livekit::EncodingOptions* mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* advanced);
  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* _internal_mutable_advanced();
  public:
  void unsafe_arena_set_allocated_advanced(
      ::livekit::EncodingOptions* advanced);
  ::livekit::EncodingOptions* unsafe_arena_release_advanced();

  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.RoomCompositeEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();

  inline bool has_output() const;
  inline void clear_has_output();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_base_url_;
    bool audio_only_;
    bool video_only_;
    int audio_mixing_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::EncodedFileOutput* file_;
      ::livekit::StreamOutput* stream_;
      ::livekit::SegmentedFileOutput* segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* advanced_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class WebEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.WebEgressRequest) */ {
 public:
  inline WebEgressRequest() : WebEgressRequest(nullptr) {}
  ~WebEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR WebEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebEgressRequest(const WebEgressRequest& from);
  WebEgressRequest(WebEgressRequest&& from) noexcept
    : WebEgressRequest() {
    *this = ::std::move(from);
  }

  inline WebEgressRequest& operator=(const WebEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebEgressRequest& operator=(WebEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kFile = 4,
    kStream = 5,
    kSegments = 6,
    OUTPUT_NOT_SET = 0,
  };

  enum OptionsCase {
    kPreset = 7,
    kAdvanced = 8,
    OPTIONS_NOT_SET = 0,
  };

  static inline const WebEgressRequest* internal_default_instance() {
    return reinterpret_cast<const WebEgressRequest*>(
               &_WebEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WebEgressRequest& a, WebEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WebEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebEgressRequest& from) {
    WebEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.WebEgressRequest";
  }
  protected:
  explicit WebEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileOutputsFieldNumber = 9,
    kStreamOutputsFieldNumber = 10,
    kSegmentOutputsFieldNumber = 11,
    kImageOutputsFieldNumber = 13,
    kUrlFieldNumber = 1,
    kAudioOnlyFieldNumber = 2,
    kVideoOnlyFieldNumber = 3,
    kAwaitStartSignalFieldNumber = 12,
    kFileFieldNumber = 4,
    kStreamFieldNumber = 5,
    kSegmentsFieldNumber = 6,
    kPresetFieldNumber = 7,
    kAdvancedFieldNumber = 8,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 9;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;
  public:
  void clear_file_outputs();
  ::livekit::EncodedFileOutput* mutable_file_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
      mutable_file_outputs();
  private:
  const ::livekit::EncodedFileOutput& _internal_file_outputs(int index) const;
  ::livekit::EncodedFileOutput* _internal_add_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* add_file_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
      file_outputs() const;

  // repeated .livekit.StreamOutput stream_outputs = 10;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;
  public:
  void clear_stream_outputs();
  ::livekit::StreamOutput* mutable_stream_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
      mutable_stream_outputs();
  private:
  const ::livekit::StreamOutput& _internal_stream_outputs(int index) const;
  ::livekit::StreamOutput* _internal_add_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* add_stream_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
      stream_outputs() const;

  // repeated .livekit.SegmentedFileOutput segment_outputs = 11;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;
  public:
  void clear_segment_outputs();
  ::livekit::SegmentedFileOutput* mutable_segment_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
      mutable_segment_outputs();
  private:
  const ::livekit::SegmentedFileOutput& _internal_segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* _internal_add_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* add_segment_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
      segment_outputs() const;

  // repeated .livekit.ImageOutput image_outputs = 13;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;
  public:
  void clear_image_outputs();
  ::livekit::ImageOutput* mutable_image_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
      mutable_image_outputs();
  private:
  const ::livekit::ImageOutput& _internal_image_outputs(int index) const;
  ::livekit::ImageOutput* _internal_add_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* add_image_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
      image_outputs() const;

  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bool audio_only = 2;
  void clear_audio_only();
  bool audio_only() const;
  void set_audio_only(bool value);
  private:
  bool _internal_audio_only() const;
  void _internal_set_audio_only(bool value);
  public:

  // bool video_only = 3;
  void clear_video_only();
  bool video_only() const;
  void set_video_only(bool value);
  private:
  bool _internal_video_only() const;
  void _internal_set_video_only(bool value);
  public:

  // bool await_start_signal = 12;
  void clear_await_start_signal();
  bool await_start_signal() const;
  void set_await_start_signal(bool value);
  private:
  bool _internal_await_start_signal() const;
  void _internal_set_await_start_signal(bool value);
  public:

  // .livekit.EncodedFileOutput file = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  PROTOBUF_DEPRECATED void clear_file();
  PROTOBUF_DEPRECATED const ::livekit::EncodedFileOutput& file() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* release_file();
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* mutable_file();
  PROTOBUF_DEPRECATED void set_allocated_file(::livekit::EncodedFileOutput* file);
  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* _internal_mutable_file();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_file(
      ::livekit::EncodedFileOutput* file);
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* unsafe_arena_release_file();

  // .livekit.StreamOutput stream = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  PROTOBUF_DEPRECATED void clear_stream();
  PROTOBUF_DEPRECATED const ::livekit::StreamOutput& stream() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::StreamOutput* release_stream();
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* mutable_stream();
  PROTOBUF_DEPRECATED void set_allocated_stream(::livekit::StreamOutput* stream);
  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* _internal_mutable_stream();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_stream(
      ::livekit::StreamOutput* stream);
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* unsafe_arena_release_stream();

  // .livekit.SegmentedFileOutput segments = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_segments() const;
  private:
  bool _internal_has_segments() const;
  public:
  PROTOBUF_DEPRECATED void clear_segments();
  PROTOBUF_DEPRECATED const ::livekit::SegmentedFileOutput& segments() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* release_segments();
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* mutable_segments();
  PROTOBUF_DEPRECATED void set_allocated_segments(::livekit::SegmentedFileOutput* segments);
  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* _internal_mutable_segments();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_segments(
      ::livekit::SegmentedFileOutput* segments);
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* unsafe_arena_release_segments();

  // .livekit.EncodingOptionsPreset preset = 7;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);
  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);
  public:

  // .livekit.EncodingOptions advanced = 8;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;
  public:
  void clear_advanced();
  const ::livekit::EncodingOptions& advanced() const;
  PROTOBUF_NODISCARD ::livekit::EncodingOptions* release_advanced();
  ::livekit::EncodingOptions* mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* advanced);
  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* _internal_mutable_advanced();
  public:
  void unsafe_arena_set_allocated_advanced(
      ::livekit::EncodingOptions* advanced);
  ::livekit::EncodingOptions* unsafe_arena_release_advanced();

  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.WebEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();

  inline bool has_output() const;
  inline void clear_has_output();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    bool audio_only_;
    bool video_only_;
    bool await_start_signal_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::EncodedFileOutput* file_;
      ::livekit::StreamOutput* stream_;
      ::livekit::SegmentedFileOutput* segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* advanced_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ParticipantEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantEgressRequest) */ {
 public:
  inline ParticipantEgressRequest() : ParticipantEgressRequest(nullptr) {}
  ~ParticipantEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR ParticipantEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantEgressRequest(const ParticipantEgressRequest& from);
  ParticipantEgressRequest(ParticipantEgressRequest&& from) noexcept
    : ParticipantEgressRequest() {
    *this = ::std::move(from);
  }

  inline ParticipantEgressRequest& operator=(const ParticipantEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantEgressRequest& operator=(ParticipantEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kPreset = 4,
    kAdvanced = 5,
    OPTIONS_NOT_SET = 0,
  };

  static inline const ParticipantEgressRequest* internal_default_instance() {
    return reinterpret_cast<const ParticipantEgressRequest*>(
               &_ParticipantEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ParticipantEgressRequest& a, ParticipantEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantEgressRequest& from) {
    ParticipantEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantEgressRequest";
  }
  protected:
  explicit ParticipantEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileOutputsFieldNumber = 6,
    kStreamOutputsFieldNumber = 7,
    kSegmentOutputsFieldNumber = 8,
    kImageOutputsFieldNumber = 9,
    kRoomNameFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kScreenShareFieldNumber = 3,
    kPresetFieldNumber = 4,
    kAdvancedFieldNumber = 5,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 6;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;
  public:
  void clear_file_outputs();
  ::livekit::EncodedFileOutput* mutable_file_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
      mutable_file_outputs();
  private:
  const ::livekit::EncodedFileOutput& _internal_file_outputs(int index) const;
  ::livekit::EncodedFileOutput* _internal_add_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* add_file_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
      file_outputs() const;

  // repeated .livekit.StreamOutput stream_outputs = 7;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;
  public:
  void clear_stream_outputs();
  ::livekit::StreamOutput* mutable_stream_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
      mutable_stream_outputs();
  private:
  const ::livekit::StreamOutput& _internal_stream_outputs(int index) const;
  ::livekit::StreamOutput* _internal_add_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* add_stream_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
      stream_outputs() const;

  // repeated .livekit.SegmentedFileOutput segment_outputs = 8;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;
  public:
  void clear_segment_outputs();
  ::livekit::SegmentedFileOutput* mutable_segment_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
      mutable_segment_outputs();
  private:
  const ::livekit::SegmentedFileOutput& _internal_segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* _internal_add_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* add_segment_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
      segment_outputs() const;

  // repeated .livekit.ImageOutput image_outputs = 9;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;
  public:
  void clear_image_outputs();
  ::livekit::ImageOutput* mutable_image_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
      mutable_image_outputs();
  private:
  const ::livekit::ImageOutput& _internal_image_outputs(int index) const;
  ::livekit::ImageOutput* _internal_add_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* add_image_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
      image_outputs() const;

  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // bool screen_share = 3;
  void clear_screen_share();
  bool screen_share() const;
  void set_screen_share(bool value);
  private:
  bool _internal_screen_share() const;
  void _internal_set_screen_share(bool value);
  public:

  // .livekit.EncodingOptionsPreset preset = 4;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);
  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);
  public:

  // .livekit.EncodingOptions advanced = 5;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;
  public:
  void clear_advanced();
  const ::livekit::EncodingOptions& advanced() const;
  PROTOBUF_NODISCARD ::livekit::EncodingOptions* release_advanced();
  ::livekit::EncodingOptions* mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* advanced);
  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* _internal_mutable_advanced();
  public:
  void unsafe_arena_set_allocated_advanced(
      ::livekit::EncodingOptions* advanced);
  ::livekit::EncodingOptions* unsafe_arena_release_advanced();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ParticipantEgressRequest)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_advanced();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    bool screen_share_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* advanced_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class TrackCompositeEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackCompositeEgressRequest) */ {
 public:
  inline TrackCompositeEgressRequest() : TrackCompositeEgressRequest(nullptr) {}
  ~TrackCompositeEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR TrackCompositeEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackCompositeEgressRequest(const TrackCompositeEgressRequest& from);
  TrackCompositeEgressRequest(TrackCompositeEgressRequest&& from) noexcept
    : TrackCompositeEgressRequest() {
    *this = ::std::move(from);
  }

  inline TrackCompositeEgressRequest& operator=(const TrackCompositeEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackCompositeEgressRequest& operator=(TrackCompositeEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackCompositeEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kFile = 4,
    kStream = 5,
    kSegments = 8,
    OUTPUT_NOT_SET = 0,
  };

  enum OptionsCase {
    kPreset = 6,
    kAdvanced = 7,
    OPTIONS_NOT_SET = 0,
  };

  static inline const TrackCompositeEgressRequest* internal_default_instance() {
    return reinterpret_cast<const TrackCompositeEgressRequest*>(
               &_TrackCompositeEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrackCompositeEgressRequest& a, TrackCompositeEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackCompositeEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackCompositeEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackCompositeEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackCompositeEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackCompositeEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackCompositeEgressRequest& from) {
    TrackCompositeEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackCompositeEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackCompositeEgressRequest";
  }
  protected:
  explicit TrackCompositeEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileOutputsFieldNumber = 11,
    kStreamOutputsFieldNumber = 12,
    kSegmentOutputsFieldNumber = 13,
    kImageOutputsFieldNumber = 14,
    kRoomNameFieldNumber = 1,
    kAudioTrackIdFieldNumber = 2,
    kVideoTrackIdFieldNumber = 3,
    kFileFieldNumber = 4,
    kStreamFieldNumber = 5,
    kSegmentsFieldNumber = 8,
    kPresetFieldNumber = 6,
    kAdvancedFieldNumber = 7,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 11;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;
  public:
  void clear_file_outputs();
  ::livekit::EncodedFileOutput* mutable_file_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
      mutable_file_outputs();
  private:
  const ::livekit::EncodedFileOutput& _internal_file_outputs(int index) const;
  ::livekit::EncodedFileOutput* _internal_add_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* add_file_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
      file_outputs() const;

  // repeated .livekit.StreamOutput stream_outputs = 12;
  int stream_outputs_size() const;
  private:
  int _internal_stream_outputs_size() const;
  public:
  void clear_stream_outputs();
  ::livekit::StreamOutput* mutable_stream_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
      mutable_stream_outputs();
  private:
  const ::livekit::StreamOutput& _internal_stream_outputs(int index) const;
  ::livekit::StreamOutput* _internal_add_stream_outputs();
  public:
  const ::livekit::StreamOutput& stream_outputs(int index) const;
  ::livekit::StreamOutput* add_stream_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
      stream_outputs() const;

  // repeated .livekit.SegmentedFileOutput segment_outputs = 13;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;
  public:
  void clear_segment_outputs();
  ::livekit::SegmentedFileOutput* mutable_segment_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
      mutable_segment_outputs();
  private:
  const ::livekit::SegmentedFileOutput& _internal_segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* _internal_add_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* add_segment_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
      segment_outputs() const;

  // repeated .livekit.ImageOutput image_outputs = 14;
  int image_outputs_size() const;
  private:
  int _internal_image_outputs_size() const;
  public:
  void clear_image_outputs();
  ::livekit::ImageOutput* mutable_image_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
      mutable_image_outputs();
  private:
  const ::livekit::ImageOutput& _internal_image_outputs(int index) const;
  ::livekit::ImageOutput* _internal_add_image_outputs();
  public:
  const ::livekit::ImageOutput& image_outputs(int index) const;
  ::livekit::ImageOutput* add_image_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
      image_outputs() const;

  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string audio_track_id = 2;
  void clear_audio_track_id();
  const std::string& audio_track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_track_id();
  PROTOBUF_NODISCARD std::string* release_audio_track_id();
  void set_allocated_audio_track_id(std::string* audio_track_id);
  private:
  const std::string& _internal_audio_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_track_id(const std::string& value);
  std::string* _internal_mutable_audio_track_id();
  public:

  // string video_track_id = 3;
  void clear_video_track_id();
  const std::string& video_track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_video_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_video_track_id();
  PROTOBUF_NODISCARD std::string* release_video_track_id();
  void set_allocated_video_track_id(std::string* video_track_id);
  private:
  const std::string& _internal_video_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_track_id(const std::string& value);
  std::string* _internal_mutable_video_track_id();
  public:

  // .livekit.EncodedFileOutput file = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  PROTOBUF_DEPRECATED void clear_file();
  PROTOBUF_DEPRECATED const ::livekit::EncodedFileOutput& file() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* release_file();
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* mutable_file();
  PROTOBUF_DEPRECATED void set_allocated_file(::livekit::EncodedFileOutput* file);
  private:
  const ::livekit::EncodedFileOutput& _internal_file() const;
  ::livekit::EncodedFileOutput* _internal_mutable_file();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_file(
      ::livekit::EncodedFileOutput* file);
  PROTOBUF_DEPRECATED ::livekit::EncodedFileOutput* unsafe_arena_release_file();

  // .livekit.StreamOutput stream = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  PROTOBUF_DEPRECATED void clear_stream();
  PROTOBUF_DEPRECATED const ::livekit::StreamOutput& stream() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::StreamOutput* release_stream();
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* mutable_stream();
  PROTOBUF_DEPRECATED void set_allocated_stream(::livekit::StreamOutput* stream);
  private:
  const ::livekit::StreamOutput& _internal_stream() const;
  ::livekit::StreamOutput* _internal_mutable_stream();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_stream(
      ::livekit::StreamOutput* stream);
  PROTOBUF_DEPRECATED ::livekit::StreamOutput* unsafe_arena_release_stream();

  // .livekit.SegmentedFileOutput segments = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_segments() const;
  private:
  bool _internal_has_segments() const;
  public:
  PROTOBUF_DEPRECATED void clear_segments();
  PROTOBUF_DEPRECATED const ::livekit::SegmentedFileOutput& segments() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* release_segments();
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* mutable_segments();
  PROTOBUF_DEPRECATED void set_allocated_segments(::livekit::SegmentedFileOutput* segments);
  private:
  const ::livekit::SegmentedFileOutput& _internal_segments() const;
  ::livekit::SegmentedFileOutput* _internal_mutable_segments();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_segments(
      ::livekit::SegmentedFileOutput* segments);
  PROTOBUF_DEPRECATED ::livekit::SegmentedFileOutput* unsafe_arena_release_segments();

  // .livekit.EncodingOptionsPreset preset = 6;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);
  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);
  public:

  // .livekit.EncodingOptions advanced = 7;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;
  public:
  void clear_advanced();
  const ::livekit::EncodingOptions& advanced() const;
  PROTOBUF_NODISCARD ::livekit::EncodingOptions* release_advanced();
  ::livekit::EncodingOptions* mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* advanced);
  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* _internal_mutable_advanced();
  public:
  void unsafe_arena_set_allocated_advanced(
      ::livekit::EncodingOptions* advanced);
  ::livekit::EncodingOptions* unsafe_arena_release_advanced();

  void clear_output();
  OutputCase output_case() const;
  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.TrackCompositeEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_stream();
  void set_has_segments();
  void set_has_preset();
  void set_has_advanced();

  inline bool has_output() const;
  inline void clear_has_output();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput > stream_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput > image_outputs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_track_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr video_track_id_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::EncodedFileOutput* file_;
      ::livekit::StreamOutput* stream_;
      ::livekit::SegmentedFileOutput* segments_;
    } output_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* advanced_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class TrackEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackEgressRequest) */ {
 public:
  inline TrackEgressRequest() : TrackEgressRequest(nullptr) {}
  ~TrackEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR TrackEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackEgressRequest(const TrackEgressRequest& from);
  TrackEgressRequest(TrackEgressRequest&& from) noexcept
    : TrackEgressRequest() {
    *this = ::std::move(from);
  }

  inline TrackEgressRequest& operator=(const TrackEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackEgressRequest& operator=(TrackEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kFile = 3,
    kWebsocketUrl = 4,
    OUTPUT_NOT_SET = 0,
  };

  static inline const TrackEgressRequest* internal_default_instance() {
    return reinterpret_cast<const TrackEgressRequest*>(
               &_TrackEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrackEgressRequest& a, TrackEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackEgressRequest& from) {
    TrackEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackEgressRequest";
  }
  protected:
  explicit TrackEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kTrackIdFieldNumber = 2,
    kFileFieldNumber = 3,
    kWebsocketUrlFieldNumber = 4,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string track_id = 2;
  void clear_track_id();
  const std::string& track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_id();
  PROTOBUF_NODISCARD std::string* release_track_id();
  void set_allocated_track_id(std::string* track_id);
  private:
  const std::string& _internal_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(const std::string& value);
  std::string* _internal_mutable_track_id();
  public:

  // .livekit.DirectFileOutput file = 3;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::livekit::DirectFileOutput& file() const;
  PROTOBUF_NODISCARD ::livekit::DirectFileOutput* release_file();
  ::livekit::DirectFileOutput* mutable_file();
  void set_allocated_file(::livekit::DirectFileOutput* file);
  private:
  const ::livekit::DirectFileOutput& _internal_file() const;
  ::livekit::DirectFileOutput* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::livekit::DirectFileOutput* file);
  ::livekit::DirectFileOutput* unsafe_arena_release_file();

  // string websocket_url = 4;
  bool has_websocket_url() const;
  private:
  bool _internal_has_websocket_url() const;
  public:
  void clear_websocket_url();
  const std::string& websocket_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_websocket_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_websocket_url();
  PROTOBUF_NODISCARD std::string* release_websocket_url();
  void set_allocated_websocket_url(std::string* websocket_url);
  private:
  const std::string& _internal_websocket_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_websocket_url(const std::string& value);
  std::string* _internal_mutable_websocket_url();
  public:

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.TrackEgressRequest)
 private:
  class _Internal;
  void set_has_file();
  void set_has_websocket_url();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_id_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::DirectFileOutput* file_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr websocket_url_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class EncodedFileOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.EncodedFileOutput) */ {
 public:
  inline EncodedFileOutput() : EncodedFileOutput(nullptr) {}
  ~EncodedFileOutput() override;
  explicit PROTOBUF_CONSTEXPR EncodedFileOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncodedFileOutput(const EncodedFileOutput& from);
  EncodedFileOutput(EncodedFileOutput&& from) noexcept
    : EncodedFileOutput() {
    *this = ::std::move(from);
  }

  inline EncodedFileOutput& operator=(const EncodedFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodedFileOutput& operator=(EncodedFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodedFileOutput& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kS3 = 3,
    kGcp = 4,
    kAzure = 5,
    kAliOSS = 7,
    OUTPUT_NOT_SET = 0,
  };

  static inline const EncodedFileOutput* internal_default_instance() {
    return reinterpret_cast<const EncodedFileOutput*>(
               &_EncodedFileOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EncodedFileOutput& a, EncodedFileOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodedFileOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodedFileOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodedFileOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncodedFileOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncodedFileOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncodedFileOutput& from) {
    EncodedFileOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodedFileOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.EncodedFileOutput";
  }
  protected:
  explicit EncodedFileOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 2,
    kFileTypeFieldNumber = 1,
    kDisableManifestFieldNumber = 6,
    kS3FieldNumber = 3,
    kGcpFieldNumber = 4,
    kAzureFieldNumber = 5,
    kAliOSSFieldNumber = 7,
  };
  // string filepath = 2;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // .livekit.EncodedFileType file_type = 1;
  void clear_file_type();
  ::livekit::EncodedFileType file_type() const;
  void set_file_type(::livekit::EncodedFileType value);
  private:
  ::livekit::EncodedFileType _internal_file_type() const;
  void _internal_set_file_type(::livekit::EncodedFileType value);
  public:

  // bool disable_manifest = 6;
  void clear_disable_manifest();
  bool disable_manifest() const;
  void set_disable_manifest(bool value);
  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);
  public:

  // .livekit.S3Upload s3 = 3;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::livekit::S3Upload& s3() const;
  PROTOBUF_NODISCARD ::livekit::S3Upload* release_s3();
  ::livekit::S3Upload* mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* s3);
  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::livekit::S3Upload* s3);
  ::livekit::S3Upload* unsafe_arena_release_s3();

  // .livekit.GCPUpload gcp = 4;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;
  public:
  void clear_gcp();
  const ::livekit::GCPUpload& gcp() const;
  PROTOBUF_NODISCARD ::livekit::GCPUpload* release_gcp();
  ::livekit::GCPUpload* mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* gcp);
  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* _internal_mutable_gcp();
  public:
  void unsafe_arena_set_allocated_gcp(
      ::livekit::GCPUpload* gcp);
  ::livekit::GCPUpload* unsafe_arena_release_gcp();

  // .livekit.AzureBlobUpload azure = 5;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::livekit::AzureBlobUpload& azure() const;
  PROTOBUF_NODISCARD ::livekit::AzureBlobUpload* release_azure();
  ::livekit::AzureBlobUpload* mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* azure);
  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::livekit::AzureBlobUpload* azure);
  ::livekit::AzureBlobUpload* unsafe_arena_release_azure();

  // .livekit.AliOSSUpload aliOSS = 7;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;
  public:
  void clear_alioss();
  const ::livekit::AliOSSUpload& alioss() const;
  PROTOBUF_NODISCARD ::livekit::AliOSSUpload* release_alioss();
  ::livekit::AliOSSUpload* mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* alioss);
  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* _internal_mutable_alioss();
  public:
  void unsafe_arena_set_allocated_alioss(
      ::livekit::AliOSSUpload* alioss);
  ::livekit::AliOSSUpload* unsafe_arena_release_alioss();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.EncodedFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    int file_type_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::S3Upload* s3_;
      ::livekit::GCPUpload* gcp_;
      ::livekit::AzureBlobUpload* azure_;
      ::livekit::AliOSSUpload* alioss_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class SegmentedFileOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SegmentedFileOutput) */ {
 public:
  inline SegmentedFileOutput() : SegmentedFileOutput(nullptr) {}
  ~SegmentedFileOutput() override;
  explicit PROTOBUF_CONSTEXPR SegmentedFileOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentedFileOutput(const SegmentedFileOutput& from);
  SegmentedFileOutput(SegmentedFileOutput&& from) noexcept
    : SegmentedFileOutput() {
    *this = ::std::move(from);
  }

  inline SegmentedFileOutput& operator=(const SegmentedFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentedFileOutput& operator=(SegmentedFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentedFileOutput& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kS3 = 5,
    kGcp = 6,
    kAzure = 7,
    kAliOSS = 9,
    OUTPUT_NOT_SET = 0,
  };

  static inline const SegmentedFileOutput* internal_default_instance() {
    return reinterpret_cast<const SegmentedFileOutput*>(
               &_SegmentedFileOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SegmentedFileOutput& a, SegmentedFileOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentedFileOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentedFileOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentedFileOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentedFileOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SegmentedFileOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SegmentedFileOutput& from) {
    SegmentedFileOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentedFileOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SegmentedFileOutput";
  }
  protected:
  explicit SegmentedFileOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenamePrefixFieldNumber = 2,
    kPlaylistNameFieldNumber = 3,
    kLivePlaylistNameFieldNumber = 11,
    kProtocolFieldNumber = 1,
    kSegmentDurationFieldNumber = 4,
    kDisableManifestFieldNumber = 8,
    kFilenameSuffixFieldNumber = 10,
    kS3FieldNumber = 5,
    kGcpFieldNumber = 6,
    kAzureFieldNumber = 7,
    kAliOSSFieldNumber = 9,
  };
  // string filename_prefix = 2;
  void clear_filename_prefix();
  const std::string& filename_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename_prefix();
  PROTOBUF_NODISCARD std::string* release_filename_prefix();
  void set_allocated_filename_prefix(std::string* filename_prefix);
  private:
  const std::string& _internal_filename_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* _internal_mutable_filename_prefix();
  public:

  // string playlist_name = 3;
  void clear_playlist_name();
  const std::string& playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlist_name();
  PROTOBUF_NODISCARD std::string* release_playlist_name();
  void set_allocated_playlist_name(std::string* playlist_name);
  private:
  const std::string& _internal_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_name(const std::string& value);
  std::string* _internal_mutable_playlist_name();
  public:

  // string live_playlist_name = 11;
  void clear_live_playlist_name();
  const std::string& live_playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_live_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_live_playlist_name();
  PROTOBUF_NODISCARD std::string* release_live_playlist_name();
  void set_allocated_live_playlist_name(std::string* live_playlist_name);
  private:
  const std::string& _internal_live_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_name(const std::string& value);
  std::string* _internal_mutable_live_playlist_name();
  public:

  // .livekit.SegmentedFileProtocol protocol = 1;
  void clear_protocol();
  ::livekit::SegmentedFileProtocol protocol() const;
  void set_protocol(::livekit::SegmentedFileProtocol value);
  private:
  ::livekit::SegmentedFileProtocol _internal_protocol() const;
  void _internal_set_protocol(::livekit::SegmentedFileProtocol value);
  public:

  // uint32 segment_duration = 4;
  void clear_segment_duration();
  uint32_t segment_duration() const;
  void set_segment_duration(uint32_t value);
  private:
  uint32_t _internal_segment_duration() const;
  void _internal_set_segment_duration(uint32_t value);
  public:

  // bool disable_manifest = 8;
  void clear_disable_manifest();
  bool disable_manifest() const;
  void set_disable_manifest(bool value);
  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);
  public:

  // .livekit.SegmentedFileSuffix filename_suffix = 10;
  void clear_filename_suffix();
  ::livekit::SegmentedFileSuffix filename_suffix() const;
  void set_filename_suffix(::livekit::SegmentedFileSuffix value);
  private:
  ::livekit::SegmentedFileSuffix _internal_filename_suffix() const;
  void _internal_set_filename_suffix(::livekit::SegmentedFileSuffix value);
  public:

  // .livekit.S3Upload s3 = 5;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::livekit::S3Upload& s3() const;
  PROTOBUF_NODISCARD ::livekit::S3Upload* release_s3();
  ::livekit::S3Upload* mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* s3);
  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::livekit::S3Upload* s3);
  ::livekit::S3Upload* unsafe_arena_release_s3();

  // .livekit.GCPUpload gcp = 6;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;
  public:
  void clear_gcp();
  const ::livekit::GCPUpload& gcp() const;
  PROTOBUF_NODISCARD ::livekit::GCPUpload* release_gcp();
  ::livekit::GCPUpload* mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* gcp);
  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* _internal_mutable_gcp();
  public:
  void unsafe_arena_set_allocated_gcp(
      ::livekit::GCPUpload* gcp);
  ::livekit::GCPUpload* unsafe_arena_release_gcp();

  // .livekit.AzureBlobUpload azure = 7;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::livekit::AzureBlobUpload& azure() const;
  PROTOBUF_NODISCARD ::livekit::AzureBlobUpload* release_azure();
  ::livekit::AzureBlobUpload* mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* azure);
  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::livekit::AzureBlobUpload* azure);
  ::livekit::AzureBlobUpload* unsafe_arena_release_azure();

  // .livekit.AliOSSUpload aliOSS = 9;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;
  public:
  void clear_alioss();
  const ::livekit::AliOSSUpload& alioss() const;
  PROTOBUF_NODISCARD ::livekit::AliOSSUpload* release_alioss();
  ::livekit::AliOSSUpload* mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* alioss);
  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* _internal_mutable_alioss();
  public:
  void unsafe_arena_set_allocated_alioss(
      ::livekit::AliOSSUpload* alioss);
  ::livekit::AliOSSUpload* unsafe_arena_release_alioss();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SegmentedFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_prefix_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlist_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr live_playlist_name_;
    int protocol_;
    uint32_t segment_duration_;
    bool disable_manifest_;
    int filename_suffix_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::S3Upload* s3_;
      ::livekit::GCPUpload* gcp_;
      ::livekit::AzureBlobUpload* azure_;
      ::livekit::AliOSSUpload* alioss_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class DirectFileOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DirectFileOutput) */ {
 public:
  inline DirectFileOutput() : DirectFileOutput(nullptr) {}
  ~DirectFileOutput() override;
  explicit PROTOBUF_CONSTEXPR DirectFileOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectFileOutput(const DirectFileOutput& from);
  DirectFileOutput(DirectFileOutput&& from) noexcept
    : DirectFileOutput() {
    *this = ::std::move(from);
  }

  inline DirectFileOutput& operator=(const DirectFileOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectFileOutput& operator=(DirectFileOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectFileOutput& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kS3 = 2,
    kGcp = 3,
    kAzure = 4,
    kAliOSS = 6,
    OUTPUT_NOT_SET = 0,
  };

  static inline const DirectFileOutput* internal_default_instance() {
    return reinterpret_cast<const DirectFileOutput*>(
               &_DirectFileOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DirectFileOutput& a, DirectFileOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectFileOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectFileOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectFileOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectFileOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectFileOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectFileOutput& from) {
    DirectFileOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectFileOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DirectFileOutput";
  }
  protected:
  explicit DirectFileOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 1,
    kDisableManifestFieldNumber = 5,
    kS3FieldNumber = 2,
    kGcpFieldNumber = 3,
    kAzureFieldNumber = 4,
    kAliOSSFieldNumber = 6,
  };
  // string filepath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // bool disable_manifest = 5;
  void clear_disable_manifest();
  bool disable_manifest() const;
  void set_disable_manifest(bool value);
  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);
  public:

  // .livekit.S3Upload s3 = 2;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::livekit::S3Upload& s3() const;
  PROTOBUF_NODISCARD ::livekit::S3Upload* release_s3();
  ::livekit::S3Upload* mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* s3);
  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::livekit::S3Upload* s3);
  ::livekit::S3Upload* unsafe_arena_release_s3();

  // .livekit.GCPUpload gcp = 3;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;
  public:
  void clear_gcp();
  const ::livekit::GCPUpload& gcp() const;
  PROTOBUF_NODISCARD ::livekit::GCPUpload* release_gcp();
  ::livekit::GCPUpload* mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* gcp);
  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* _internal_mutable_gcp();
  public:
  void unsafe_arena_set_allocated_gcp(
      ::livekit::GCPUpload* gcp);
  ::livekit::GCPUpload* unsafe_arena_release_gcp();

  // .livekit.AzureBlobUpload azure = 4;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::livekit::AzureBlobUpload& azure() const;
  PROTOBUF_NODISCARD ::livekit::AzureBlobUpload* release_azure();
  ::livekit::AzureBlobUpload* mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* azure);
  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::livekit::AzureBlobUpload* azure);
  ::livekit::AzureBlobUpload* unsafe_arena_release_azure();

  // .livekit.AliOSSUpload aliOSS = 6;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;
  public:
  void clear_alioss();
  const ::livekit::AliOSSUpload& alioss() const;
  PROTOBUF_NODISCARD ::livekit::AliOSSUpload* release_alioss();
  ::livekit::AliOSSUpload* mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* alioss);
  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* _internal_mutable_alioss();
  public:
  void unsafe_arena_set_allocated_alioss(
      ::livekit::AliOSSUpload* alioss);
  ::livekit::AliOSSUpload* unsafe_arena_release_alioss();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.DirectFileOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::S3Upload* s3_;
      ::livekit::GCPUpload* gcp_;
      ::livekit::AzureBlobUpload* azure_;
      ::livekit::AliOSSUpload* alioss_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ImageOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ImageOutput) */ {
 public:
  inline ImageOutput() : ImageOutput(nullptr) {}
  ~ImageOutput() override;
  explicit PROTOBUF_CONSTEXPR ImageOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageOutput(const ImageOutput& from);
  ImageOutput(ImageOutput&& from) noexcept
    : ImageOutput() {
    *this = ::std::move(from);
  }

  inline ImageOutput& operator=(const ImageOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageOutput& operator=(ImageOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageOutput& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kS3 = 8,
    kGcp = 9,
    kAzure = 10,
    kAliOSS = 11,
    OUTPUT_NOT_SET = 0,
  };

  static inline const ImageOutput* internal_default_instance() {
    return reinterpret_cast<const ImageOutput*>(
               &_ImageOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ImageOutput& a, ImageOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageOutput& from) {
    ImageOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ImageOutput";
  }
  protected:
  explicit ImageOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenamePrefixFieldNumber = 4,
    kCaptureIntervalFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kFilenameSuffixFieldNumber = 5,
    kImageCodecFieldNumber = 6,
    kDisableManifestFieldNumber = 7,
    kS3FieldNumber = 8,
    kGcpFieldNumber = 9,
    kAzureFieldNumber = 10,
    kAliOSSFieldNumber = 11,
  };
  // string filename_prefix = 4;
  void clear_filename_prefix();
  const std::string& filename_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename_prefix();
  PROTOBUF_NODISCARD std::string* release_filename_prefix();
  void set_allocated_filename_prefix(std::string* filename_prefix);
  private:
  const std::string& _internal_filename_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* _internal_mutable_filename_prefix();
  public:

  // uint32 capture_interval = 1;
  void clear_capture_interval();
  uint32_t capture_interval() const;
  void set_capture_interval(uint32_t value);
  private:
  uint32_t _internal_capture_interval() const;
  void _internal_set_capture_interval(uint32_t value);
  public:

  // int32 width = 2;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // .livekit.ImageFileSuffix filename_suffix = 5;
  void clear_filename_suffix();
  ::livekit::ImageFileSuffix filename_suffix() const;
  void set_filename_suffix(::livekit::ImageFileSuffix value);
  private:
  ::livekit::ImageFileSuffix _internal_filename_suffix() const;
  void _internal_set_filename_suffix(::livekit::ImageFileSuffix value);
  public:

  // .livekit.ImageCodec image_codec = 6;
  void clear_image_codec();
  ::livekit::ImageCodec image_codec() const;
  void set_image_codec(::livekit::ImageCodec value);
  private:
  ::livekit::ImageCodec _internal_image_codec() const;
  void _internal_set_image_codec(::livekit::ImageCodec value);
  public:

  // bool disable_manifest = 7;
  void clear_disable_manifest();
  bool disable_manifest() const;
  void set_disable_manifest(bool value);
  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);
  public:

  // .livekit.S3Upload s3 = 8;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::livekit::S3Upload& s3() const;
  PROTOBUF_NODISCARD ::livekit::S3Upload* release_s3();
  ::livekit::S3Upload* mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* s3);
  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::livekit::S3Upload* s3);
  ::livekit::S3Upload* unsafe_arena_release_s3();

  // .livekit.GCPUpload gcp = 9;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;
  public:
  void clear_gcp();
  const ::livekit::GCPUpload& gcp() const;
  PROTOBUF_NODISCARD ::livekit::GCPUpload* release_gcp();
  ::livekit::GCPUpload* mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* gcp);
  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* _internal_mutable_gcp();
  public:
  void unsafe_arena_set_allocated_gcp(
      ::livekit::GCPUpload* gcp);
  ::livekit::GCPUpload* unsafe_arena_release_gcp();

  // .livekit.AzureBlobUpload azure = 10;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::livekit::AzureBlobUpload& azure() const;
  PROTOBUF_NODISCARD ::livekit::AzureBlobUpload* release_azure();
  ::livekit::AzureBlobUpload* mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* azure);
  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::livekit::AzureBlobUpload* azure);
  ::livekit::AzureBlobUpload* unsafe_arena_release_azure();

  // .livekit.AliOSSUpload aliOSS = 11;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;
  public:
  void clear_alioss();
  const ::livekit::AliOSSUpload& alioss() const;
  PROTOBUF_NODISCARD ::livekit::AliOSSUpload* release_alioss();
  ::livekit::AliOSSUpload* mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* alioss);
  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* _internal_mutable_alioss();
  public:
  void unsafe_arena_set_allocated_alioss(
      ::livekit::AliOSSUpload* alioss);
  ::livekit::AliOSSUpload* unsafe_arena_release_alioss();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ImageOutput)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_prefix_;
    uint32_t capture_interval_;
    int32_t width_;
    int32_t height_;
    int filename_suffix_;
    int image_codec_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::S3Upload* s3_;
      ::livekit::GCPUpload* gcp_;
      ::livekit::AzureBlobUpload* azure_;
      ::livekit::AliOSSUpload* alioss_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class S3Upload_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<S3Upload_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<S3Upload_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  S3Upload_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR S3Upload_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit S3Upload_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const S3Upload_MetadataEntry_DoNotUse& other);
  static const S3Upload_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const S3Upload_MetadataEntry_DoNotUse*>(&_S3Upload_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.S3Upload.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.S3Upload.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};

// -------------------------------------------------------------------

class S3Upload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.S3Upload) */ {
 public:
  inline S3Upload() : S3Upload(nullptr) {}
  ~S3Upload() override;
  explicit PROTOBUF_CONSTEXPR S3Upload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S3Upload(const S3Upload& from);
  S3Upload(S3Upload&& from) noexcept
    : S3Upload() {
    *this = ::std::move(from);
  }

  inline S3Upload& operator=(const S3Upload& from) {
    CopyFrom(from);
    return *this;
  }
  inline S3Upload& operator=(S3Upload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S3Upload& default_instance() {
    return *internal_default_instance();
  }
  static inline const S3Upload* internal_default_instance() {
    return reinterpret_cast<const S3Upload*>(
               &_S3Upload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S3Upload& a, S3Upload& b) {
    a.Swap(&b);
  }
  inline void Swap(S3Upload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S3Upload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S3Upload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S3Upload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S3Upload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S3Upload& from) {
    S3Upload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S3Upload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.S3Upload";
  }
  protected:
  explicit S3Upload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 7,
    kAccessKeyFieldNumber = 1,
    kSecretFieldNumber = 2,
    kRegionFieldNumber = 3,
    kEndpointFieldNumber = 4,
    kBucketFieldNumber = 5,
    kTaggingFieldNumber = 8,
    kContentDispositionFieldNumber = 9,
    kSessionTokenFieldNumber = 11,
    kProxyFieldNumber = 10,
    kForcePathStyleFieldNumber = 6,
  };
  // map<string, string> metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string access_key = 1;
  void clear_access_key();
  const std::string& access_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_key();
  PROTOBUF_NODISCARD std::string* release_access_key();
  void set_allocated_access_key(std::string* access_key);
  private:
  const std::string& _internal_access_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_key(const std::string& value);
  std::string* _internal_mutable_access_key();
  public:

  // string secret = 2;
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string endpoint = 4;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // string bucket = 5;
  void clear_bucket();
  const std::string& bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // string tagging = 8;
  void clear_tagging();
  const std::string& tagging() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tagging(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tagging();
  PROTOBUF_NODISCARD std::string* release_tagging();
  void set_allocated_tagging(std::string* tagging);
  private:
  const std::string& _internal_tagging() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tagging(const std::string& value);
  std::string* _internal_mutable_tagging();
  public:

  // string content_disposition = 9;
  void clear_content_disposition();
  const std::string& content_disposition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_disposition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_disposition();
  PROTOBUF_NODISCARD std::string* release_content_disposition();
  void set_allocated_content_disposition(std::string* content_disposition);
  private:
  const std::string& _internal_content_disposition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_disposition(const std::string& value);
  std::string* _internal_mutable_content_disposition();
  public:

  // string session_token = 11;
  void clear_session_token();
  const std::string& session_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_token();
  PROTOBUF_NODISCARD std::string* release_session_token();
  void set_allocated_session_token(std::string* session_token);
  private:
  const std::string& _internal_session_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_token(const std::string& value);
  std::string* _internal_mutable_session_token();
  public:

  // .livekit.ProxyConfig proxy = 10;
  bool has_proxy() const;
  private:
  bool _internal_has_proxy() const;
  public:
  void clear_proxy();
  const ::livekit::ProxyConfig& proxy() const;
  PROTOBUF_NODISCARD ::livekit::ProxyConfig* release_proxy();
  ::livekit::ProxyConfig* mutable_proxy();
  void set_allocated_proxy(::livekit::ProxyConfig* proxy);
  private:
  const ::livekit::ProxyConfig& _internal_proxy() const;
  ::livekit::ProxyConfig* _internal_mutable_proxy();
  public:
  void unsafe_arena_set_allocated_proxy(
      ::livekit::ProxyConfig* proxy);
  ::livekit::ProxyConfig* unsafe_arena_release_proxy();

  // bool force_path_style = 6;
  void clear_force_path_style();
  bool force_path_style() const;
  void set_force_path_style(bool value);
  private:
  bool _internal_force_path_style() const;
  void _internal_set_force_path_style(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.S3Upload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        S3Upload_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tagging_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_disposition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_token_;
    ::livekit::ProxyConfig* proxy_;
    bool force_path_style_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class GCPUpload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.GCPUpload) */ {
 public:
  inline GCPUpload() : GCPUpload(nullptr) {}
  ~GCPUpload() override;
  explicit PROTOBUF_CONSTEXPR GCPUpload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GCPUpload(const GCPUpload& from);
  GCPUpload(GCPUpload&& from) noexcept
    : GCPUpload() {
    *this = ::std::move(from);
  }

  inline GCPUpload& operator=(const GCPUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline GCPUpload& operator=(GCPUpload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GCPUpload& default_instance() {
    return *internal_default_instance();
  }
  static inline const GCPUpload* internal_default_instance() {
    return reinterpret_cast<const GCPUpload*>(
               &_GCPUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GCPUpload& a, GCPUpload& b) {
    a.Swap(&b);
  }
  inline void Swap(GCPUpload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GCPUpload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GCPUpload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GCPUpload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GCPUpload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GCPUpload& from) {
    GCPUpload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GCPUpload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.GCPUpload";
  }
  protected:
  explicit GCPUpload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialsFieldNumber = 1,
    kBucketFieldNumber = 2,
    kProxyFieldNumber = 3,
  };
  // string credentials = 1;
  void clear_credentials();
  const std::string& credentials() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credentials(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credentials();
  PROTOBUF_NODISCARD std::string* release_credentials();
  void set_allocated_credentials(std::string* credentials);
  private:
  const std::string& _internal_credentials() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credentials(const std::string& value);
  std::string* _internal_mutable_credentials();
  public:

  // string bucket = 2;
  void clear_bucket();
  const std::string& bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // .livekit.ProxyConfig proxy = 3;
  bool has_proxy() const;
  private:
  bool _internal_has_proxy() const;
  public:
  void clear_proxy();
  const ::livekit::ProxyConfig& proxy() const;
  PROTOBUF_NODISCARD ::livekit::ProxyConfig* release_proxy();
  ::livekit::ProxyConfig* mutable_proxy();
  void set_allocated_proxy(::livekit::ProxyConfig* proxy);
  private:
  const ::livekit::ProxyConfig& _internal_proxy() const;
  ::livekit::ProxyConfig* _internal_mutable_proxy();
  public:
  void unsafe_arena_set_allocated_proxy(
      ::livekit::ProxyConfig* proxy);
  ::livekit::ProxyConfig* unsafe_arena_release_proxy();

  // @@protoc_insertion_point(class_scope:livekit.GCPUpload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credentials_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
    ::livekit::ProxyConfig* proxy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class AzureBlobUpload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AzureBlobUpload) */ {
 public:
  inline AzureBlobUpload() : AzureBlobUpload(nullptr) {}
  ~AzureBlobUpload() override;
  explicit PROTOBUF_CONSTEXPR AzureBlobUpload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AzureBlobUpload(const AzureBlobUpload& from);
  AzureBlobUpload(AzureBlobUpload&& from) noexcept
    : AzureBlobUpload() {
    *this = ::std::move(from);
  }

  inline AzureBlobUpload& operator=(const AzureBlobUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AzureBlobUpload& operator=(AzureBlobUpload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AzureBlobUpload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AzureBlobUpload* internal_default_instance() {
    return reinterpret_cast<const AzureBlobUpload*>(
               &_AzureBlobUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AzureBlobUpload& a, AzureBlobUpload& b) {
    a.Swap(&b);
  }
  inline void Swap(AzureBlobUpload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AzureBlobUpload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AzureBlobUpload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AzureBlobUpload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AzureBlobUpload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AzureBlobUpload& from) {
    AzureBlobUpload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AzureBlobUpload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AzureBlobUpload";
  }
  protected:
  explicit AzureBlobUpload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
    kAccountKeyFieldNumber = 2,
    kContainerNameFieldNumber = 3,
  };
  // string account_name = 1;
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // string account_key = 2;
  void clear_account_key();
  const std::string& account_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_key();
  PROTOBUF_NODISCARD std::string* release_account_key();
  void set_allocated_account_key(std::string* account_key);
  private:
  const std::string& _internal_account_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_key(const std::string& value);
  std::string* _internal_mutable_account_key();
  public:

  // string container_name = 3;
  void clear_container_name();
  const std::string& container_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_name();
  PROTOBUF_NODISCARD std::string* release_container_name();
  void set_allocated_container_name(std::string* container_name);
  private:
  const std::string& _internal_container_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_name(const std::string& value);
  std::string* _internal_mutable_container_name();
  public:

  // @@protoc_insertion_point(class_scope:livekit.AzureBlobUpload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class AliOSSUpload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AliOSSUpload) */ {
 public:
  inline AliOSSUpload() : AliOSSUpload(nullptr) {}
  ~AliOSSUpload() override;
  explicit PROTOBUF_CONSTEXPR AliOSSUpload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AliOSSUpload(const AliOSSUpload& from);
  AliOSSUpload(AliOSSUpload&& from) noexcept
    : AliOSSUpload() {
    *this = ::std::move(from);
  }

  inline AliOSSUpload& operator=(const AliOSSUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliOSSUpload& operator=(AliOSSUpload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliOSSUpload& default_instance() {
    return *internal_default_instance();
  }
  static inline const AliOSSUpload* internal_default_instance() {
    return reinterpret_cast<const AliOSSUpload*>(
               &_AliOSSUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AliOSSUpload& a, AliOSSUpload& b) {
    a.Swap(&b);
  }
  inline void Swap(AliOSSUpload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliOSSUpload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliOSSUpload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AliOSSUpload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AliOSSUpload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AliOSSUpload& from) {
    AliOSSUpload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AliOSSUpload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AliOSSUpload";
  }
  protected:
  explicit AliOSSUpload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessKeyFieldNumber = 1,
    kSecretFieldNumber = 2,
    kRegionFieldNumber = 3,
    kEndpointFieldNumber = 4,
    kBucketFieldNumber = 5,
  };
  // string access_key = 1;
  void clear_access_key();
  const std::string& access_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_key();
  PROTOBUF_NODISCARD std::string* release_access_key();
  void set_allocated_access_key(std::string* access_key);
  private:
  const std::string& _internal_access_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_key(const std::string& value);
  std::string* _internal_mutable_access_key();
  public:

  // string secret = 2;
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string region = 3;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string endpoint = 4;
  void clear_endpoint();
  const std::string& endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint();
  PROTOBUF_NODISCARD std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // string bucket = 5;
  void clear_bucket();
  const std::string& bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // @@protoc_insertion_point(class_scope:livekit.AliOSSUpload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ProxyConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ProxyConfig) */ {
 public:
  inline ProxyConfig() : ProxyConfig(nullptr) {}
  ~ProxyConfig() override;
  explicit PROTOBUF_CONSTEXPR ProxyConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProxyConfig(const ProxyConfig& from);
  ProxyConfig(ProxyConfig&& from) noexcept
    : ProxyConfig() {
    *this = ::std::move(from);
  }

  inline ProxyConfig& operator=(const ProxyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProxyConfig& operator=(ProxyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProxyConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProxyConfig* internal_default_instance() {
    return reinterpret_cast<const ProxyConfig*>(
               &_ProxyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ProxyConfig& a, ProxyConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ProxyConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProxyConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProxyConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProxyConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProxyConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProxyConfig& from) {
    ProxyConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProxyConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ProxyConfig";
  }
  protected:
  explicit ProxyConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ProxyConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class StreamOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamOutput) */ {
 public:
  inline StreamOutput() : StreamOutput(nullptr) {}
  ~StreamOutput() override;
  explicit PROTOBUF_CONSTEXPR StreamOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamOutput(const StreamOutput& from);
  StreamOutput(StreamOutput&& from) noexcept
    : StreamOutput() {
    *this = ::std::move(from);
  }

  inline StreamOutput& operator=(const StreamOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamOutput& operator=(StreamOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamOutput* internal_default_instance() {
    return reinterpret_cast<const StreamOutput*>(
               &_StreamOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StreamOutput& a, StreamOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamOutput& from) {
    StreamOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamOutput";
  }
  protected:
  explicit StreamOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 2,
    kProtocolFieldNumber = 1,
  };
  // repeated string urls = 2;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // .livekit.StreamProtocol protocol = 1;
  void clear_protocol();
  ::livekit::StreamProtocol protocol() const;
  void set_protocol(::livekit::StreamProtocol value);
  private:
  ::livekit::StreamProtocol _internal_protocol() const;
  void _internal_set_protocol(::livekit::StreamProtocol value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.StreamOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    int protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class EncodingOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.EncodingOptions) */ {
 public:
  inline EncodingOptions() : EncodingOptions(nullptr) {}
  ~EncodingOptions() override;
  explicit PROTOBUF_CONSTEXPR EncodingOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncodingOptions(const EncodingOptions& from);
  EncodingOptions(EncodingOptions&& from) noexcept
    : EncodingOptions() {
    *this = ::std::move(from);
  }

  inline EncodingOptions& operator=(const EncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodingOptions& operator=(EncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodingOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncodingOptions* internal_default_instance() {
    return reinterpret_cast<const EncodingOptions*>(
               &_EncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EncodingOptions& a, EncodingOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodingOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodingOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodingOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncodingOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncodingOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncodingOptions& from) {
    EncodingOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodingOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.EncodingOptions";
  }
  protected:
  explicit EncodingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
    kFramerateFieldNumber = 4,
    kAudioCodecFieldNumber = 5,
    kAudioBitrateFieldNumber = 6,
    kAudioFrequencyFieldNumber = 7,
    kVideoCodecFieldNumber = 8,
    kKeyFrameIntervalFieldNumber = 10,
    kVideoBitrateFieldNumber = 9,
    kAudioQualityFieldNumber = 11,
    kVideoQualityFieldNumber = 12,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 depth = 3;
  void clear_depth();
  int32_t depth() const;
  void set_depth(int32_t value);
  private:
  int32_t _internal_depth() const;
  void _internal_set_depth(int32_t value);
  public:

  // int32 framerate = 4;
  void clear_framerate();
  int32_t framerate() const;
  void set_framerate(int32_t value);
  private:
  int32_t _internal_framerate() const;
  void _internal_set_framerate(int32_t value);
  public:

  // .livekit.AudioCodec audio_codec = 5;
  void clear_audio_codec();
  ::livekit::AudioCodec audio_codec() const;
  void set_audio_codec(::livekit::AudioCodec value);
  private:
  ::livekit::AudioCodec _internal_audio_codec() const;
  void _internal_set_audio_codec(::livekit::AudioCodec value);
  public:

  // int32 audio_bitrate = 6;
  void clear_audio_bitrate();
  int32_t audio_bitrate() const;
  void set_audio_bitrate(int32_t value);
  private:
  int32_t _internal_audio_bitrate() const;
  void _internal_set_audio_bitrate(int32_t value);
  public:

  // int32 audio_frequency = 7;
  void clear_audio_frequency();
  int32_t audio_frequency() const;
  void set_audio_frequency(int32_t value);
  private:
  int32_t _internal_audio_frequency() const;
  void _internal_set_audio_frequency(int32_t value);
  public:

  // .livekit.VideoCodec video_codec = 8;
  void clear_video_codec();
  ::livekit::VideoCodec video_codec() const;
  void set_video_codec(::livekit::VideoCodec value);
  private:
  ::livekit::VideoCodec _internal_video_codec() const;
  void _internal_set_video_codec(::livekit::VideoCodec value);
  public:

  // double key_frame_interval = 10;
  void clear_key_frame_interval();
  double key_frame_interval() const;
  void set_key_frame_interval(double value);
  private:
  double _internal_key_frame_interval() const;
  void _internal_set_key_frame_interval(double value);
  public:

  // int32 video_bitrate = 9;
  void clear_video_bitrate();
  int32_t video_bitrate() const;
  void set_video_bitrate(int32_t value);
  private:
  int32_t _internal_video_bitrate() const;
  void _internal_set_video_bitrate(int32_t value);
  public:

  // int32 audio_quality = 11;
  void clear_audio_quality();
  int32_t audio_quality() const;
  void set_audio_quality(int32_t value);
  private:
  int32_t _internal_audio_quality() const;
  void _internal_set_audio_quality(int32_t value);
  public:

  // int32 video_quality = 12;
  void clear_video_quality();
  int32_t video_quality() const;
  void set_video_quality(int32_t value);
  private:
  int32_t _internal_video_quality() const;
  void _internal_set_video_quality(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.EncodingOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    int32_t height_;
    int32_t depth_;
    int32_t framerate_;
    int audio_codec_;
    int32_t audio_bitrate_;
    int32_t audio_frequency_;
    int video_codec_;
    double key_frame_interval_;
    int32_t video_bitrate_;
    int32_t audio_quality_;
    int32_t video_quality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class UpdateLayoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateLayoutRequest) */ {
 public:
  inline UpdateLayoutRequest() : UpdateLayoutRequest(nullptr) {}
  ~UpdateLayoutRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateLayoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLayoutRequest(const UpdateLayoutRequest& from);
  UpdateLayoutRequest(UpdateLayoutRequest&& from) noexcept
    : UpdateLayoutRequest() {
    *this = ::std::move(from);
  }

  inline UpdateLayoutRequest& operator=(const UpdateLayoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLayoutRequest& operator=(UpdateLayoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLayoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLayoutRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateLayoutRequest*>(
               &_UpdateLayoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateLayoutRequest& a, UpdateLayoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLayoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLayoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLayoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLayoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLayoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLayoutRequest& from) {
    UpdateLayoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLayoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateLayoutRequest";
  }
  protected:
  explicit UpdateLayoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgressIdFieldNumber = 1,
    kLayoutFieldNumber = 2,
  };
  // string egress_id = 1;
  void clear_egress_id();
  const std::string& egress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_id();
  PROTOBUF_NODISCARD std::string* release_egress_id();
  void set_allocated_egress_id(std::string* egress_id);
  private:
  const std::string& _internal_egress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* _internal_mutable_egress_id();
  public:

  // string layout = 2;
  void clear_layout();
  const std::string& layout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layout();
  PROTOBUF_NODISCARD std::string* release_layout();
  void set_allocated_layout(std::string* layout);
  private:
  const std::string& _internal_layout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* _internal_mutable_layout();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateLayoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class UpdateStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateStreamRequest) */ {
 public:
  inline UpdateStreamRequest() : UpdateStreamRequest(nullptr) {}
  ~UpdateStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateStreamRequest(const UpdateStreamRequest& from);
  UpdateStreamRequest(UpdateStreamRequest&& from) noexcept
    : UpdateStreamRequest() {
    *this = ::std::move(from);
  }

  inline UpdateStreamRequest& operator=(const UpdateStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStreamRequest& operator=(UpdateStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStreamRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateStreamRequest*>(
               &_UpdateStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateStreamRequest& a, UpdateStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateStreamRequest& from) {
    UpdateStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateStreamRequest";
  }
  protected:
  explicit UpdateStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddOutputUrlsFieldNumber = 2,
    kRemoveOutputUrlsFieldNumber = 3,
    kEgressIdFieldNumber = 1,
  };
  // repeated string add_output_urls = 2;
  int add_output_urls_size() const;
  private:
  int _internal_add_output_urls_size() const;
  public:
  void clear_add_output_urls();
  const std::string& add_output_urls(int index) const;
  std::string* mutable_add_output_urls(int index);
  void set_add_output_urls(int index, const std::string& value);
  void set_add_output_urls(int index, std::string&& value);
  void set_add_output_urls(int index, const char* value);
  void set_add_output_urls(int index, const char* value, size_t size);
  std::string* add_add_output_urls();
  void add_add_output_urls(const std::string& value);
  void add_add_output_urls(std::string&& value);
  void add_add_output_urls(const char* value);
  void add_add_output_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_output_urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_output_urls();
  private:
  const std::string& _internal_add_output_urls(int index) const;
  std::string* _internal_add_add_output_urls();
  public:

  // repeated string remove_output_urls = 3;
  int remove_output_urls_size() const;
  private:
  int _internal_remove_output_urls_size() const;
  public:
  void clear_remove_output_urls();
  const std::string& remove_output_urls(int index) const;
  std::string* mutable_remove_output_urls(int index);
  void set_remove_output_urls(int index, const std::string& value);
  void set_remove_output_urls(int index, std::string&& value);
  void set_remove_output_urls(int index, const char* value);
  void set_remove_output_urls(int index, const char* value, size_t size);
  std::string* add_remove_output_urls();
  void add_remove_output_urls(const std::string& value);
  void add_remove_output_urls(std::string&& value);
  void add_remove_output_urls(const char* value);
  void add_remove_output_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& remove_output_urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_remove_output_urls();
  private:
  const std::string& _internal_remove_output_urls(int index) const;
  std::string* _internal_add_remove_output_urls();
  public:

  // string egress_id = 1;
  void clear_egress_id();
  const std::string& egress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_id();
  PROTOBUF_NODISCARD std::string* release_egress_id();
  void set_allocated_egress_id(std::string* egress_id);
  private:
  const std::string& _internal_egress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* _internal_mutable_egress_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateStreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_output_urls_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> remove_output_urls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ListEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListEgressRequest) */ {
 public:
  inline ListEgressRequest() : ListEgressRequest(nullptr) {}
  ~ListEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR ListEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEgressRequest(const ListEgressRequest& from);
  ListEgressRequest(ListEgressRequest&& from) noexcept
    : ListEgressRequest() {
    *this = ::std::move(from);
  }

  inline ListEgressRequest& operator=(const ListEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEgressRequest& operator=(ListEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEgressRequest* internal_default_instance() {
    return reinterpret_cast<const ListEgressRequest*>(
               &_ListEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListEgressRequest& a, ListEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEgressRequest& from) {
    ListEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListEgressRequest";
  }
  protected:
  explicit ListEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kEgressIdFieldNumber = 2,
    kActiveFieldNumber = 3,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string egress_id = 2;
  void clear_egress_id();
  const std::string& egress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_id();
  PROTOBUF_NODISCARD std::string* release_egress_id();
  void set_allocated_egress_id(std::string* egress_id);
  private:
  const std::string& _internal_egress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* _internal_mutable_egress_id();
  public:

  // bool active = 3;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ListEgressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_id_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ListEgressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListEgressResponse) */ {
 public:
  inline ListEgressResponse() : ListEgressResponse(nullptr) {}
  ~ListEgressResponse() override;
  explicit PROTOBUF_CONSTEXPR ListEgressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListEgressResponse(const ListEgressResponse& from);
  ListEgressResponse(ListEgressResponse&& from) noexcept
    : ListEgressResponse() {
    *this = ::std::move(from);
  }

  inline ListEgressResponse& operator=(const ListEgressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListEgressResponse& operator=(ListEgressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListEgressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListEgressResponse* internal_default_instance() {
    return reinterpret_cast<const ListEgressResponse*>(
               &_ListEgressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListEgressResponse& a, ListEgressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListEgressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListEgressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListEgressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListEgressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListEgressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListEgressResponse& from) {
    ListEgressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListEgressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListEgressResponse";
  }
  protected:
  explicit ListEgressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .livekit.EgressInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::livekit::EgressInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EgressInfo >*
      mutable_items();
  private:
  const ::livekit::EgressInfo& _internal_items(int index) const;
  ::livekit::EgressInfo* _internal_add_items();
  public:
  const ::livekit::EgressInfo& items(int index) const;
  ::livekit::EgressInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EgressInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:livekit.ListEgressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EgressInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class StopEgressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StopEgressRequest) */ {
 public:
  inline StopEgressRequest() : StopEgressRequest(nullptr) {}
  ~StopEgressRequest() override;
  explicit PROTOBUF_CONSTEXPR StopEgressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopEgressRequest(const StopEgressRequest& from);
  StopEgressRequest(StopEgressRequest&& from) noexcept
    : StopEgressRequest() {
    *this = ::std::move(from);
  }

  inline StopEgressRequest& operator=(const StopEgressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopEgressRequest& operator=(StopEgressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopEgressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopEgressRequest* internal_default_instance() {
    return reinterpret_cast<const StopEgressRequest*>(
               &_StopEgressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StopEgressRequest& a, StopEgressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopEgressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopEgressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopEgressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopEgressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopEgressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopEgressRequest& from) {
    StopEgressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopEgressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StopEgressRequest";
  }
  protected:
  explicit StopEgressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEgressIdFieldNumber = 1,
  };
  // string egress_id = 1;
  void clear_egress_id();
  const std::string& egress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_id();
  PROTOBUF_NODISCARD std::string* release_egress_id();
  void set_allocated_egress_id(std::string* egress_id);
  private:
  const std::string& _internal_egress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* _internal_mutable_egress_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.StopEgressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class EgressInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.EgressInfo) */ {
 public:
  inline EgressInfo() : EgressInfo(nullptr) {}
  ~EgressInfo() override;
  explicit PROTOBUF_CONSTEXPR EgressInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EgressInfo(const EgressInfo& from);
  EgressInfo(EgressInfo&& from) noexcept
    : EgressInfo() {
    *this = ::std::move(from);
  }

  inline EgressInfo& operator=(const EgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EgressInfo& operator=(EgressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EgressInfo& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kRoomComposite = 4,
    kWeb = 14,
    kParticipant = 19,
    kTrackComposite = 5,
    kTrack = 6,
    REQUEST_NOT_SET = 0,
  };

  enum ResultCase {
    kStream = 7,
    kFile = 8,
    kSegments = 12,
    RESULT_NOT_SET = 0,
  };

  static inline const EgressInfo* internal_default_instance() {
    return reinterpret_cast<const EgressInfo*>(
               &_EgressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EgressInfo& a, EgressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EgressInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EgressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EgressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EgressInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EgressInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EgressInfo& from) {
    EgressInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EgressInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.EgressInfo";
  }
  protected:
  explicit EgressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamResultsFieldNumber = 15,
    kFileResultsFieldNumber = 16,
    kSegmentResultsFieldNumber = 17,
    kImageResultsFieldNumber = 20,
    kEgressIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kErrorFieldNumber = 9,
    kRoomNameFieldNumber = 13,
    kDetailsFieldNumber = 21,
    kManifestLocationFieldNumber = 23,
    kStartedAtFieldNumber = 10,
    kEndedAtFieldNumber = 11,
    kStatusFieldNumber = 3,
    kErrorCodeFieldNumber = 22,
    kUpdatedAtFieldNumber = 18,
    kBackupStorageUsedFieldNumber = 25,
    kSourceTypeFieldNumber = 26,
    kRoomCompositeFieldNumber = 4,
    kWebFieldNumber = 14,
    kParticipantFieldNumber = 19,
    kTrackCompositeFieldNumber = 5,
    kTrackFieldNumber = 6,
    kStreamFieldNumber = 7,
    kFileFieldNumber = 8,
    kSegmentsFieldNumber = 12,
  };
  // repeated .livekit.StreamInfo stream_results = 15;
  int stream_results_size() const;
  private:
  int _internal_stream_results_size() const;
  public:
  void clear_stream_results();
  ::livekit::StreamInfo* mutable_stream_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >*
      mutable_stream_results();
  private:
  const ::livekit::StreamInfo& _internal_stream_results(int index) const;
  ::livekit::StreamInfo* _internal_add_stream_results();
  public:
  const ::livekit::StreamInfo& stream_results(int index) const;
  ::livekit::StreamInfo* add_stream_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >&
      stream_results() const;

  // repeated .livekit.FileInfo file_results = 16;
  int file_results_size() const;
  private:
  int _internal_file_results_size() const;
  public:
  void clear_file_results();
  ::livekit::FileInfo* mutable_file_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::FileInfo >*
      mutable_file_results();
  private:
  const ::livekit::FileInfo& _internal_file_results(int index) const;
  ::livekit::FileInfo* _internal_add_file_results();
  public:
  const ::livekit::FileInfo& file_results(int index) const;
  ::livekit::FileInfo* add_file_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::FileInfo >&
      file_results() const;

  // repeated .livekit.SegmentsInfo segment_results = 17;
  int segment_results_size() const;
  private:
  int _internal_segment_results_size() const;
  public:
  void clear_segment_results();
  ::livekit::SegmentsInfo* mutable_segment_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentsInfo >*
      mutable_segment_results();
  private:
  const ::livekit::SegmentsInfo& _internal_segment_results(int index) const;
  ::livekit::SegmentsInfo* _internal_add_segment_results();
  public:
  const ::livekit::SegmentsInfo& segment_results(int index) const;
  ::livekit::SegmentsInfo* add_segment_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentsInfo >&
      segment_results() const;

  // repeated .livekit.ImagesInfo image_results = 20;
  int image_results_size() const;
  private:
  int _internal_image_results_size() const;
  public:
  void clear_image_results();
  ::livekit::ImagesInfo* mutable_image_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImagesInfo >*
      mutable_image_results();
  private:
  const ::livekit::ImagesInfo& _internal_image_results(int index) const;
  ::livekit::ImagesInfo* _internal_add_image_results();
  public:
  const ::livekit::ImagesInfo& image_results(int index) const;
  ::livekit::ImagesInfo* add_image_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImagesInfo >&
      image_results() const;

  // string egress_id = 1;
  void clear_egress_id();
  const std::string& egress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_id();
  PROTOBUF_NODISCARD std::string* release_egress_id();
  void set_allocated_egress_id(std::string* egress_id);
  private:
  const std::string& _internal_egress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_id(const std::string& value);
  std::string* _internal_mutable_egress_id();
  public:

  // string room_id = 2;
  void clear_room_id();
  const std::string& room_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_id();
  PROTOBUF_NODISCARD std::string* release_room_id();
  void set_allocated_room_id(std::string* room_id);
  private:
  const std::string& _internal_room_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* _internal_mutable_room_id();
  public:

  // string error = 9;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string room_name = 13;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string details = 21;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_NODISCARD std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // string manifest_location = 23;
  void clear_manifest_location();
  const std::string& manifest_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manifest_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manifest_location();
  PROTOBUF_NODISCARD std::string* release_manifest_location();
  void set_allocated_manifest_location(std::string* manifest_location);
  private:
  const std::string& _internal_manifest_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manifest_location(const std::string& value);
  std::string* _internal_mutable_manifest_location();
  public:

  // int64 started_at = 10;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 11;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // .livekit.EgressStatus status = 3;
  void clear_status();
  ::livekit::EgressStatus status() const;
  void set_status(::livekit::EgressStatus value);
  private:
  ::livekit::EgressStatus _internal_status() const;
  void _internal_set_status(::livekit::EgressStatus value);
  public:

  // int32 error_code = 22;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int64 updated_at = 18;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // bool backup_storage_used = 25;
  void clear_backup_storage_used();
  bool backup_storage_used() const;
  void set_backup_storage_used(bool value);
  private:
  bool _internal_backup_storage_used() const;
  void _internal_set_backup_storage_used(bool value);
  public:

  // .livekit.EgressSourceType source_type = 26;
  void clear_source_type();
  ::livekit::EgressSourceType source_type() const;
  void set_source_type(::livekit::EgressSourceType value);
  private:
  ::livekit::EgressSourceType _internal_source_type() const;
  void _internal_set_source_type(::livekit::EgressSourceType value);
  public:

  // .livekit.RoomCompositeEgressRequest room_composite = 4;
  bool has_room_composite() const;
  private:
  bool _internal_has_room_composite() const;
  public:
  void clear_room_composite();
  const ::livekit::RoomCompositeEgressRequest& room_composite() const;
  PROTOBUF_NODISCARD ::livekit::RoomCompositeEgressRequest* release_room_composite();
  ::livekit::RoomCompositeEgressRequest* mutable_room_composite();
  void set_allocated_room_composite(::livekit::RoomCompositeEgressRequest* room_composite);
  private:
  const ::livekit::RoomCompositeEgressRequest& _internal_room_composite() const;
  ::livekit::RoomCompositeEgressRequest* _internal_mutable_room_composite();
  public:
  void unsafe_arena_set_allocated_room_composite(
      ::livekit::RoomCompositeEgressRequest* room_composite);
  ::livekit::RoomCompositeEgressRequest* unsafe_arena_release_room_composite();

  // .livekit.WebEgressRequest web = 14;
  bool has_web() const;
  private:
  bool _internal_has_web() const;
  public:
  void clear_web();
  const ::livekit::WebEgressRequest& web() const;
  PROTOBUF_NODISCARD ::livekit::WebEgressRequest* release_web();
  ::livekit::WebEgressRequest* mutable_web();
  void set_allocated_web(::livekit::WebEgressRequest* web);
  private:
  const ::livekit::WebEgressRequest& _internal_web() const;
  ::livekit::WebEgressRequest* _internal_mutable_web();
  public:
  void unsafe_arena_set_allocated_web(
      ::livekit::WebEgressRequest* web);
  ::livekit::WebEgressRequest* unsafe_arena_release_web();

  // .livekit.ParticipantEgressRequest participant = 19;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::ParticipantEgressRequest& participant() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantEgressRequest* release_participant();
  ::livekit::ParticipantEgressRequest* mutable_participant();
  void set_allocated_participant(::livekit::ParticipantEgressRequest* participant);
  private:
  const ::livekit::ParticipantEgressRequest& _internal_participant() const;
  ::livekit::ParticipantEgressRequest* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::ParticipantEgressRequest* participant);
  ::livekit::ParticipantEgressRequest* unsafe_arena_release_participant();

  // .livekit.TrackCompositeEgressRequest track_composite = 5;
  bool has_track_composite() const;
  private:
  bool _internal_has_track_composite() const;
  public:
  void clear_track_composite();
  const ::livekit::TrackCompositeEgressRequest& track_composite() const;
  PROTOBUF_NODISCARD ::livekit::TrackCompositeEgressRequest* release_track_composite();
  ::livekit::TrackCompositeEgressRequest* mutable_track_composite();
  void set_allocated_track_composite(::livekit::TrackCompositeEgressRequest* track_composite);
  private:
  const ::livekit::TrackCompositeEgressRequest& _internal_track_composite() const;
  ::livekit::TrackCompositeEgressRequest* _internal_mutable_track_composite();
  public:
  void unsafe_arena_set_allocated_track_composite(
      ::livekit::TrackCompositeEgressRequest* track_composite);
  ::livekit::TrackCompositeEgressRequest* unsafe_arena_release_track_composite();

  // .livekit.TrackEgressRequest track = 6;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::TrackEgressRequest& track() const;
  PROTOBUF_NODISCARD ::livekit::TrackEgressRequest* release_track();
  ::livekit::TrackEgressRequest* mutable_track();
  void set_allocated_track(::livekit::TrackEgressRequest* track);
  private:
  const ::livekit::TrackEgressRequest& _internal_track() const;
  ::livekit::TrackEgressRequest* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::TrackEgressRequest* track);
  ::livekit::TrackEgressRequest* unsafe_arena_release_track();

  // .livekit.StreamInfoList stream = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  PROTOBUF_DEPRECATED void clear_stream();
  PROTOBUF_DEPRECATED const ::livekit::StreamInfoList& stream() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::StreamInfoList* release_stream();
  PROTOBUF_DEPRECATED ::livekit::StreamInfoList* mutable_stream();
  PROTOBUF_DEPRECATED void set_allocated_stream(::livekit::StreamInfoList* stream);
  private:
  const ::livekit::StreamInfoList& _internal_stream() const;
  ::livekit::StreamInfoList* _internal_mutable_stream();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_stream(
      ::livekit::StreamInfoList* stream);
  PROTOBUF_DEPRECATED ::livekit::StreamInfoList* unsafe_arena_release_stream();

  // .livekit.FileInfo file = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  PROTOBUF_DEPRECATED void clear_file();
  PROTOBUF_DEPRECATED const ::livekit::FileInfo& file() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::FileInfo* release_file();
  PROTOBUF_DEPRECATED ::livekit::FileInfo* mutable_file();
  PROTOBUF_DEPRECATED void set_allocated_file(::livekit::FileInfo* file);
  private:
  const ::livekit::FileInfo& _internal_file() const;
  ::livekit::FileInfo* _internal_mutable_file();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_file(
      ::livekit::FileInfo* file);
  PROTOBUF_DEPRECATED ::livekit::FileInfo* unsafe_arena_release_file();

  // .livekit.SegmentsInfo segments = 12 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_segments() const;
  private:
  bool _internal_has_segments() const;
  public:
  PROTOBUF_DEPRECATED void clear_segments();
  PROTOBUF_DEPRECATED const ::livekit::SegmentsInfo& segments() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::SegmentsInfo* release_segments();
  PROTOBUF_DEPRECATED ::livekit::SegmentsInfo* mutable_segments();
  PROTOBUF_DEPRECATED void set_allocated_segments(::livekit::SegmentsInfo* segments);
  private:
  const ::livekit::SegmentsInfo& _internal_segments() const;
  ::livekit::SegmentsInfo* _internal_mutable_segments();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_segments(
      ::livekit::SegmentsInfo* segments);
  PROTOBUF_DEPRECATED ::livekit::SegmentsInfo* unsafe_arena_release_segments();

  void clear_request();
  RequestCase request_case() const;
  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:livekit.EgressInfo)
 private:
  class _Internal;
  void set_has_room_composite();
  void set_has_web();
  void set_has_participant();
  void set_has_track_composite();
  void set_has_track();
  void set_has_stream();
  void set_has_file();
  void set_has_segments();

  inline bool has_request() const;
  inline void clear_has_request();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo > stream_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::FileInfo > file_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentsInfo > segment_results_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImagesInfo > image_results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manifest_location_;
    int64_t started_at_;
    int64_t ended_at_;
    int status_;
    int32_t error_code_;
    int64_t updated_at_;
    bool backup_storage_used_;
    int source_type_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::RoomCompositeEgressRequest* room_composite_;
      ::livekit::WebEgressRequest* web_;
      ::livekit::ParticipantEgressRequest* participant_;
      ::livekit::TrackCompositeEgressRequest* track_composite_;
      ::livekit::TrackEgressRequest* track_;
    } request_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::StreamInfoList* stream_;
      ::livekit::FileInfo* file_;
      ::livekit::SegmentsInfo* segments_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class StreamInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamInfoList) */ {
 public:
  inline StreamInfoList() : StreamInfoList(nullptr) {}
  ~StreamInfoList() override;
  explicit PROTOBUF_CONSTEXPR StreamInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInfoList(const StreamInfoList& from);
  StreamInfoList(StreamInfoList&& from) noexcept
    : StreamInfoList() {
    *this = ::std::move(from);
  }

  inline StreamInfoList& operator=(const StreamInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfoList& operator=(StreamInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInfoList* internal_default_instance() {
    return reinterpret_cast<const StreamInfoList*>(
               &_StreamInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StreamInfoList& a, StreamInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamInfoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInfoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamInfoList& from) {
    StreamInfoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamInfoList";
  }
  protected:
  explicit StreamInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .livekit.StreamInfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::livekit::StreamInfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >*
      mutable_info();
  private:
  const ::livekit::StreamInfo& _internal_info(int index) const;
  ::livekit::StreamInfo* _internal_add_info();
  public:
  const ::livekit::StreamInfo& info(int index) const;
  ::livekit::StreamInfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:livekit.StreamInfoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class StreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamInfo) */ {
 public:
  inline StreamInfo() : StreamInfo(nullptr) {}
  ~StreamInfo() override;
  explicit PROTOBUF_CONSTEXPR StreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamInfo(const StreamInfo& from);
  StreamInfo(StreamInfo&& from) noexcept
    : StreamInfo() {
    *this = ::std::move(from);
  }

  inline StreamInfo& operator=(const StreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamInfo& operator=(StreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamInfo* internal_default_instance() {
    return reinterpret_cast<const StreamInfo*>(
               &_StreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StreamInfo& a, StreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamInfo& from) {
    StreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamInfo";
  }
  protected:
  explicit StreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StreamInfo_Status Status;
  static constexpr Status ACTIVE =
    StreamInfo_Status_ACTIVE;
  static constexpr Status FINISHED =
    StreamInfo_Status_FINISHED;
  static constexpr Status FAILED =
    StreamInfo_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return StreamInfo_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StreamInfo_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StreamInfo_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StreamInfo_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StreamInfo_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StreamInfo_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StreamInfo_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kErrorFieldNumber = 6,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
    kDurationFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string error = 6;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int64 started_at = 2;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 3;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // int64 duration = 4;
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // .livekit.StreamInfo.Status status = 5;
  void clear_status();
  ::livekit::StreamInfo_Status status() const;
  void set_status(::livekit::StreamInfo_Status value);
  private:
  ::livekit::StreamInfo_Status _internal_status() const;
  void _internal_set_status(::livekit::StreamInfo_Status value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.StreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int64_t started_at_;
    int64_t ended_at_;
    int64_t duration_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class FileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() override;
  explicit PROTOBUF_CONSTEXPR FileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileInfo(const FileInfo& from);
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileInfo& from) {
    FileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.FileInfo";
  }
  protected:
  explicit FileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kLocationFieldNumber = 5,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
    kSizeFieldNumber = 4,
    kDurationFieldNumber = 6,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string location = 5;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // int64 started_at = 2;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 3;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 duration = 6;
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.FileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    int64_t started_at_;
    int64_t ended_at_;
    int64_t size_;
    int64_t duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class SegmentsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SegmentsInfo) */ {
 public:
  inline SegmentsInfo() : SegmentsInfo(nullptr) {}
  ~SegmentsInfo() override;
  explicit PROTOBUF_CONSTEXPR SegmentsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentsInfo(const SegmentsInfo& from);
  SegmentsInfo(SegmentsInfo&& from) noexcept
    : SegmentsInfo() {
    *this = ::std::move(from);
  }

  inline SegmentsInfo& operator=(const SegmentsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentsInfo& operator=(SegmentsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SegmentsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentsInfo* internal_default_instance() {
    return reinterpret_cast<const SegmentsInfo*>(
               &_SegmentsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SegmentsInfo& a, SegmentsInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SegmentsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SegmentsInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SegmentsInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SegmentsInfo& from) {
    SegmentsInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SegmentsInfo";
  }
  protected:
  explicit SegmentsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaylistNameFieldNumber = 1,
    kPlaylistLocationFieldNumber = 4,
    kLivePlaylistNameFieldNumber = 8,
    kLivePlaylistLocationFieldNumber = 9,
    kDurationFieldNumber = 2,
    kSizeFieldNumber = 3,
    kSegmentCountFieldNumber = 5,
    kStartedAtFieldNumber = 6,
    kEndedAtFieldNumber = 7,
  };
  // string playlist_name = 1;
  void clear_playlist_name();
  const std::string& playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlist_name();
  PROTOBUF_NODISCARD std::string* release_playlist_name();
  void set_allocated_playlist_name(std::string* playlist_name);
  private:
  const std::string& _internal_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_name(const std::string& value);
  std::string* _internal_mutable_playlist_name();
  public:

  // string playlist_location = 4;
  void clear_playlist_location();
  const std::string& playlist_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playlist_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playlist_location();
  PROTOBUF_NODISCARD std::string* release_playlist_location();
  void set_allocated_playlist_location(std::string* playlist_location);
  private:
  const std::string& _internal_playlist_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playlist_location(const std::string& value);
  std::string* _internal_mutable_playlist_location();
  public:

  // string live_playlist_name = 8;
  void clear_live_playlist_name();
  const std::string& live_playlist_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_live_playlist_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_live_playlist_name();
  PROTOBUF_NODISCARD std::string* release_live_playlist_name();
  void set_allocated_live_playlist_name(std::string* live_playlist_name);
  private:
  const std::string& _internal_live_playlist_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_name(const std::string& value);
  std::string* _internal_mutable_live_playlist_name();
  public:

  // string live_playlist_location = 9;
  void clear_live_playlist_location();
  const std::string& live_playlist_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_live_playlist_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_live_playlist_location();
  PROTOBUF_NODISCARD std::string* release_live_playlist_location();
  void set_allocated_live_playlist_location(std::string* live_playlist_location);
  private:
  const std::string& _internal_live_playlist_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_live_playlist_location(const std::string& value);
  std::string* _internal_mutable_live_playlist_location();
  public:

  // int64 duration = 2;
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 segment_count = 5;
  void clear_segment_count();
  int64_t segment_count() const;
  void set_segment_count(int64_t value);
  private:
  int64_t _internal_segment_count() const;
  void _internal_set_segment_count(int64_t value);
  public:

  // int64 started_at = 6;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 7;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SegmentsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlist_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playlist_location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr live_playlist_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr live_playlist_location_;
    int64_t duration_;
    int64_t size_;
    int64_t segment_count_;
    int64_t started_at_;
    int64_t ended_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class ImagesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ImagesInfo) */ {
 public:
  inline ImagesInfo() : ImagesInfo(nullptr) {}
  ~ImagesInfo() override;
  explicit PROTOBUF_CONSTEXPR ImagesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesInfo(const ImagesInfo& from);
  ImagesInfo(ImagesInfo&& from) noexcept
    : ImagesInfo() {
    *this = ::std::move(from);
  }

  inline ImagesInfo& operator=(const ImagesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesInfo& operator=(ImagesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesInfo* internal_default_instance() {
    return reinterpret_cast<const ImagesInfo*>(
               &_ImagesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ImagesInfo& a, ImagesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesInfo& from) {
    ImagesInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ImagesInfo";
  }
  protected:
  explicit ImagesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenamePrefixFieldNumber = 4,
    kImageCountFieldNumber = 1,
    kStartedAtFieldNumber = 2,
    kEndedAtFieldNumber = 3,
  };
  // string filename_prefix = 4;
  void clear_filename_prefix();
  const std::string& filename_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename_prefix();
  PROTOBUF_NODISCARD std::string* release_filename_prefix();
  void set_allocated_filename_prefix(std::string* filename_prefix);
  private:
  const std::string& _internal_filename_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename_prefix(const std::string& value);
  std::string* _internal_mutable_filename_prefix();
  public:

  // int64 image_count = 1;
  void clear_image_count();
  int64_t image_count() const;
  void set_image_count(int64_t value);
  private:
  int64_t _internal_image_count() const;
  void _internal_set_image_count(int64_t value);
  public:

  // int64 started_at = 2;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 3;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ImagesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_prefix_;
    int64_t image_count_;
    int64_t started_at_;
    int64_t ended_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class AutoParticipantEgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AutoParticipantEgress) */ {
 public:
  inline AutoParticipantEgress() : AutoParticipantEgress(nullptr) {}
  ~AutoParticipantEgress() override;
  explicit PROTOBUF_CONSTEXPR AutoParticipantEgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoParticipantEgress(const AutoParticipantEgress& from);
  AutoParticipantEgress(AutoParticipantEgress&& from) noexcept
    : AutoParticipantEgress() {
    *this = ::std::move(from);
  }

  inline AutoParticipantEgress& operator=(const AutoParticipantEgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoParticipantEgress& operator=(AutoParticipantEgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoParticipantEgress& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kPreset = 1,
    kAdvanced = 2,
    OPTIONS_NOT_SET = 0,
  };

  static inline const AutoParticipantEgress* internal_default_instance() {
    return reinterpret_cast<const AutoParticipantEgress*>(
               &_AutoParticipantEgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AutoParticipantEgress& a, AutoParticipantEgress& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoParticipantEgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoParticipantEgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoParticipantEgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoParticipantEgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoParticipantEgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AutoParticipantEgress& from) {
    AutoParticipantEgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoParticipantEgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AutoParticipantEgress";
  }
  protected:
  explicit AutoParticipantEgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileOutputsFieldNumber = 3,
    kSegmentOutputsFieldNumber = 4,
    kPresetFieldNumber = 1,
    kAdvancedFieldNumber = 2,
  };
  // repeated .livekit.EncodedFileOutput file_outputs = 3;
  int file_outputs_size() const;
  private:
  int _internal_file_outputs_size() const;
  public:
  void clear_file_outputs();
  ::livekit::EncodedFileOutput* mutable_file_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
      mutable_file_outputs();
  private:
  const ::livekit::EncodedFileOutput& _internal_file_outputs(int index) const;
  ::livekit::EncodedFileOutput* _internal_add_file_outputs();
  public:
  const ::livekit::EncodedFileOutput& file_outputs(int index) const;
  ::livekit::EncodedFileOutput* add_file_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
      file_outputs() const;

  // repeated .livekit.SegmentedFileOutput segment_outputs = 4;
  int segment_outputs_size() const;
  private:
  int _internal_segment_outputs_size() const;
  public:
  void clear_segment_outputs();
  ::livekit::SegmentedFileOutput* mutable_segment_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
      mutable_segment_outputs();
  private:
  const ::livekit::SegmentedFileOutput& _internal_segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* _internal_add_segment_outputs();
  public:
  const ::livekit::SegmentedFileOutput& segment_outputs(int index) const;
  ::livekit::SegmentedFileOutput* add_segment_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
      segment_outputs() const;

  // .livekit.EncodingOptionsPreset preset = 1;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::EncodingOptionsPreset preset() const;
  void set_preset(::livekit::EncodingOptionsPreset value);
  private:
  ::livekit::EncodingOptionsPreset _internal_preset() const;
  void _internal_set_preset(::livekit::EncodingOptionsPreset value);
  public:

  // .livekit.EncodingOptions advanced = 2;
  bool has_advanced() const;
  private:
  bool _internal_has_advanced() const;
  public:
  void clear_advanced();
  const ::livekit::EncodingOptions& advanced() const;
  PROTOBUF_NODISCARD ::livekit::EncodingOptions* release_advanced();
  ::livekit::EncodingOptions* mutable_advanced();
  void set_allocated_advanced(::livekit::EncodingOptions* advanced);
  private:
  const ::livekit::EncodingOptions& _internal_advanced() const;
  ::livekit::EncodingOptions* _internal_mutable_advanced();
  public:
  void unsafe_arena_set_allocated_advanced(
      ::livekit::EncodingOptions* advanced);
  ::livekit::EncodingOptions* unsafe_arena_release_advanced();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.AutoParticipantEgress)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_advanced();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput > file_outputs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput > segment_outputs_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::EncodingOptions* advanced_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// -------------------------------------------------------------------

class AutoTrackEgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AutoTrackEgress) */ {
 public:
  inline AutoTrackEgress() : AutoTrackEgress(nullptr) {}
  ~AutoTrackEgress() override;
  explicit PROTOBUF_CONSTEXPR AutoTrackEgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoTrackEgress(const AutoTrackEgress& from);
  AutoTrackEgress(AutoTrackEgress&& from) noexcept
    : AutoTrackEgress() {
    *this = ::std::move(from);
  }

  inline AutoTrackEgress& operator=(const AutoTrackEgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoTrackEgress& operator=(AutoTrackEgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoTrackEgress& default_instance() {
    return *internal_default_instance();
  }
  enum OutputCase {
    kS3 = 2,
    kGcp = 3,
    kAzure = 4,
    kAliOSS = 6,
    OUTPUT_NOT_SET = 0,
  };

  static inline const AutoTrackEgress* internal_default_instance() {
    return reinterpret_cast<const AutoTrackEgress*>(
               &_AutoTrackEgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AutoTrackEgress& a, AutoTrackEgress& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoTrackEgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoTrackEgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoTrackEgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoTrackEgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoTrackEgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AutoTrackEgress& from) {
    AutoTrackEgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoTrackEgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AutoTrackEgress";
  }
  protected:
  explicit AutoTrackEgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 1,
    kDisableManifestFieldNumber = 5,
    kS3FieldNumber = 2,
    kGcpFieldNumber = 3,
    kAzureFieldNumber = 4,
    kAliOSSFieldNumber = 6,
  };
  // string filepath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // bool disable_manifest = 5;
  void clear_disable_manifest();
  bool disable_manifest() const;
  void set_disable_manifest(bool value);
  private:
  bool _internal_disable_manifest() const;
  void _internal_set_disable_manifest(bool value);
  public:

  // .livekit.S3Upload s3 = 2;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;
  public:
  void clear_s3();
  const ::livekit::S3Upload& s3() const;
  PROTOBUF_NODISCARD ::livekit::S3Upload* release_s3();
  ::livekit::S3Upload* mutable_s3();
  void set_allocated_s3(::livekit::S3Upload* s3);
  private:
  const ::livekit::S3Upload& _internal_s3() const;
  ::livekit::S3Upload* _internal_mutable_s3();
  public:
  void unsafe_arena_set_allocated_s3(
      ::livekit::S3Upload* s3);
  ::livekit::S3Upload* unsafe_arena_release_s3();

  // .livekit.GCPUpload gcp = 3;
  bool has_gcp() const;
  private:
  bool _internal_has_gcp() const;
  public:
  void clear_gcp();
  const ::livekit::GCPUpload& gcp() const;
  PROTOBUF_NODISCARD ::livekit::GCPUpload* release_gcp();
  ::livekit::GCPUpload* mutable_gcp();
  void set_allocated_gcp(::livekit::GCPUpload* gcp);
  private:
  const ::livekit::GCPUpload& _internal_gcp() const;
  ::livekit::GCPUpload* _internal_mutable_gcp();
  public:
  void unsafe_arena_set_allocated_gcp(
      ::livekit::GCPUpload* gcp);
  ::livekit::GCPUpload* unsafe_arena_release_gcp();

  // .livekit.AzureBlobUpload azure = 4;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;
  public:
  void clear_azure();
  const ::livekit::AzureBlobUpload& azure() const;
  PROTOBUF_NODISCARD ::livekit::AzureBlobUpload* release_azure();
  ::livekit::AzureBlobUpload* mutable_azure();
  void set_allocated_azure(::livekit::AzureBlobUpload* azure);
  private:
  const ::livekit::AzureBlobUpload& _internal_azure() const;
  ::livekit::AzureBlobUpload* _internal_mutable_azure();
  public:
  void unsafe_arena_set_allocated_azure(
      ::livekit::AzureBlobUpload* azure);
  ::livekit::AzureBlobUpload* unsafe_arena_release_azure();

  // .livekit.AliOSSUpload aliOSS = 6;
  bool has_alioss() const;
  private:
  bool _internal_has_alioss() const;
  public:
  void clear_alioss();
  const ::livekit::AliOSSUpload& alioss() const;
  PROTOBUF_NODISCARD ::livekit::AliOSSUpload* release_alioss();
  ::livekit::AliOSSUpload* mutable_alioss();
  void set_allocated_alioss(::livekit::AliOSSUpload* alioss);
  private:
  const ::livekit::AliOSSUpload& _internal_alioss() const;
  ::livekit::AliOSSUpload* _internal_mutable_alioss();
  public:
  void unsafe_arena_set_allocated_alioss(
      ::livekit::AliOSSUpload* alioss);
  ::livekit::AliOSSUpload* unsafe_arena_release_alioss();

  void clear_output();
  OutputCase output_case() const;
  // @@protoc_insertion_point(class_scope:livekit.AutoTrackEgress)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_gcp();
  void set_has_azure();
  void set_has_alioss();

  inline bool has_output() const;
  inline void clear_has_output();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    bool disable_manifest_;
    union OutputUnion {
      constexpr OutputUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::S3Upload* s3_;
      ::livekit::GCPUpload* gcp_;
      ::livekit::AzureBlobUpload* azure_;
      ::livekit::AliOSSUpload* alioss_;
    } output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fegress_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoomCompositeEgressRequest

// string room_name = 1;
inline void RoomCompositeEgressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& RoomCompositeEgressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomCompositeEgressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.room_name)
}
inline std::string* RoomCompositeEgressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.room_name)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void RoomCompositeEgressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.room_name)
}

// string layout = 2;
inline void RoomCompositeEgressRequest::clear_layout() {
  _impl_.layout_.ClearToEmpty();
}
inline const std::string& RoomCompositeEgressRequest::layout() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.layout)
  return _internal_layout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomCompositeEgressRequest::set_layout(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layout_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.layout)
}
inline std::string* RoomCompositeEgressRequest::mutable_layout() {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.layout)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_layout() const {
  return _impl_.layout_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_layout(const std::string& value) {
  
  _impl_.layout_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::_internal_mutable_layout() {
  
  return _impl_.layout_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::release_layout() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.layout)
  return _impl_.layout_.Release();
}
inline void RoomCompositeEgressRequest::set_allocated_layout(std::string* layout) {
  if (layout != nullptr) {
    
  } else {
    
  }
  _impl_.layout_.SetAllocated(layout, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layout_.IsDefault()) {
    _impl_.layout_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.layout)
}

// bool audio_only = 3;
inline void RoomCompositeEgressRequest::clear_audio_only() {
  _impl_.audio_only_ = false;
}
inline bool RoomCompositeEgressRequest::_internal_audio_only() const {
  return _impl_.audio_only_;
}
inline bool RoomCompositeEgressRequest::audio_only() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.audio_only)
  return _internal_audio_only();
}
inline void RoomCompositeEgressRequest::_internal_set_audio_only(bool value) {
  
  _impl_.audio_only_ = value;
}
inline void RoomCompositeEgressRequest::set_audio_only(bool value) {
  _internal_set_audio_only(value);
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.audio_only)
}

// .livekit.AudioMixing audio_mixing = 15;
inline void RoomCompositeEgressRequest::clear_audio_mixing() {
  _impl_.audio_mixing_ = 0;
}
inline ::livekit::AudioMixing RoomCompositeEgressRequest::_internal_audio_mixing() const {
  return static_cast< ::livekit::AudioMixing >(_impl_.audio_mixing_);
}
inline ::livekit::AudioMixing RoomCompositeEgressRequest::audio_mixing() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.audio_mixing)
  return _internal_audio_mixing();
}
inline void RoomCompositeEgressRequest::_internal_set_audio_mixing(::livekit::AudioMixing value) {
  
  _impl_.audio_mixing_ = value;
}
inline void RoomCompositeEgressRequest::set_audio_mixing(::livekit::AudioMixing value) {
  _internal_set_audio_mixing(value);
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.audio_mixing)
}

// bool video_only = 4;
inline void RoomCompositeEgressRequest::clear_video_only() {
  _impl_.video_only_ = false;
}
inline bool RoomCompositeEgressRequest::_internal_video_only() const {
  return _impl_.video_only_;
}
inline bool RoomCompositeEgressRequest::video_only() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.video_only)
  return _internal_video_only();
}
inline void RoomCompositeEgressRequest::_internal_set_video_only(bool value) {
  
  _impl_.video_only_ = value;
}
inline void RoomCompositeEgressRequest::set_video_only(bool value) {
  _internal_set_video_only(value);
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.video_only)
}

// string custom_base_url = 5;
inline void RoomCompositeEgressRequest::clear_custom_base_url() {
  _impl_.custom_base_url_.ClearToEmpty();
}
inline const std::string& RoomCompositeEgressRequest::custom_base_url() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.custom_base_url)
  return _internal_custom_base_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomCompositeEgressRequest::set_custom_base_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.custom_base_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.custom_base_url)
}
inline std::string* RoomCompositeEgressRequest::mutable_custom_base_url() {
  std::string* _s = _internal_mutable_custom_base_url();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.custom_base_url)
  return _s;
}
inline const std::string& RoomCompositeEgressRequest::_internal_custom_base_url() const {
  return _impl_.custom_base_url_.Get();
}
inline void RoomCompositeEgressRequest::_internal_set_custom_base_url(const std::string& value) {
  
  _impl_.custom_base_url_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::_internal_mutable_custom_base_url() {
  
  return _impl_.custom_base_url_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomCompositeEgressRequest::release_custom_base_url() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.custom_base_url)
  return _impl_.custom_base_url_.Release();
}
inline void RoomCompositeEgressRequest::set_allocated_custom_base_url(std::string* custom_base_url) {
  if (custom_base_url != nullptr) {
    
  } else {
    
  }
  _impl_.custom_base_url_.SetAllocated(custom_base_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_base_url_.IsDefault()) {
    _impl_.custom_base_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomCompositeEgressRequest.custom_base_url)
}

// .livekit.EncodedFileOutput file = 6 [deprecated = true];
inline bool RoomCompositeEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline bool RoomCompositeEgressRequest::has_file() const {
  return _internal_has_file();
}
inline void RoomCompositeEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void RoomCompositeEgressRequest::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.file_;
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.output_.file_
      : reinterpret_cast< ::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::file() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* file) {
  clear_output();
  if (file) {
    set_has_file();
    _impl_.output_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = CreateMaybeMessage< ::livekit::EncodedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.file_;
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::mutable_file() {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 7 [deprecated = true];
inline bool RoomCompositeEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline bool RoomCompositeEgressRequest::has_stream() const {
  return _internal_has_stream();
}
inline void RoomCompositeEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void RoomCompositeEgressRequest::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.stream_;
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.output_.stream_
      : reinterpret_cast< ::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::stream() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_stream(::livekit::StreamOutput* stream) {
  clear_output();
  if (stream) {
    set_has_stream();
    _impl_.output_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.stream)
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = CreateMaybeMessage< ::livekit::StreamOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.stream_;
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::mutable_stream() {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 10 [deprecated = true];
inline bool RoomCompositeEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline bool RoomCompositeEgressRequest::has_segments() const {
  return _internal_has_segments();
}
inline void RoomCompositeEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void RoomCompositeEgressRequest::clear_segments() {
  if (_internal_has_segments()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.segments_;
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::_internal_segments() const {
  return _internal_has_segments()
      ? *_impl_.output_.segments_
      : reinterpret_cast< ::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::segments() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* segments) {
  clear_output();
  if (segments) {
    set_has_segments();
    _impl_.output_.segments_ = segments;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::_internal_mutable_segments() {
  if (!_internal_has_segments()) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = CreateMaybeMessage< ::livekit::SegmentedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.segments_;
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::mutable_segments() {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 8;
inline bool RoomCompositeEgressRequest::_internal_has_preset() const {
  return options_case() == kPreset;
}
inline bool RoomCompositeEgressRequest::has_preset() const {
  return _internal_has_preset();
}
inline void RoomCompositeEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void RoomCompositeEgressRequest::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset RoomCompositeEgressRequest::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::EncodingOptionsPreset >(_impl_.options_.preset_);
  }
  return static_cast< ::livekit::EncodingOptionsPreset >(0);
}
inline ::livekit::EncodingOptionsPreset RoomCompositeEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.preset)
  return _internal_preset();
}
inline void RoomCompositeEgressRequest::_internal_set_preset(::livekit::EncodingOptionsPreset value) {
  if (!_internal_has_preset()) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
}
inline void RoomCompositeEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.RoomCompositeEgressRequest.preset)
}

// .livekit.EncodingOptions advanced = 9;
inline bool RoomCompositeEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool RoomCompositeEgressRequest::has_advanced() const {
  return _internal_has_advanced();
}
inline void RoomCompositeEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void RoomCompositeEgressRequest::clear_advanced() {
  if (_internal_has_advanced()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.advanced_;
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* RoomCompositeEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.RoomCompositeEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& RoomCompositeEgressRequest::_internal_advanced() const {
  return _internal_has_advanced()
      ? *_impl_.options_.advanced_
      : reinterpret_cast< ::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& RoomCompositeEgressRequest::advanced() const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* RoomCompositeEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RoomCompositeEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomCompositeEgressRequest::unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* advanced) {
  clear_options();
  if (advanced) {
    set_has_advanced();
    _impl_.options_.advanced_ = advanced;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomCompositeEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* RoomCompositeEgressRequest::_internal_mutable_advanced() {
  if (!_internal_has_advanced()) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = CreateMaybeMessage< ::livekit::EncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* RoomCompositeEgressRequest::mutable_advanced() {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 11;
inline int RoomCompositeEgressRequest::_internal_file_outputs_size() const {
  return _impl_.file_outputs_.size();
}
inline int RoomCompositeEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_file_outputs() {
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::mutable_file_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.file_outputs)
  return _impl_.file_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
RoomCompositeEgressRequest::mutable_file_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.file_outputs)
  return &_impl_.file_outputs_;
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::_internal_file_outputs(int index) const {
  return _impl_.file_outputs_.Get(index);
}
inline const ::livekit::EncodedFileOutput& RoomCompositeEgressRequest::file_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.file_outputs)
  return _internal_file_outputs(index);
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::_internal_add_file_outputs() {
  return _impl_.file_outputs_.Add();
}
inline ::livekit::EncodedFileOutput* RoomCompositeEgressRequest::add_file_outputs() {
  ::livekit::EncodedFileOutput* _add = _internal_add_file_outputs();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.file_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
RoomCompositeEgressRequest::file_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.file_outputs)
  return _impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 12;
inline int RoomCompositeEgressRequest::_internal_stream_outputs_size() const {
  return _impl_.stream_outputs_.size();
}
inline int RoomCompositeEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_stream_outputs() {
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::mutable_stream_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _impl_.stream_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
RoomCompositeEgressRequest::mutable_stream_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.stream_outputs)
  return &_impl_.stream_outputs_;
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::_internal_stream_outputs(int index) const {
  return _impl_.stream_outputs_.Get(index);
}
inline const ::livekit::StreamOutput& RoomCompositeEgressRequest::stream_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs(index);
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::_internal_add_stream_outputs() {
  return _impl_.stream_outputs_.Add();
}
inline ::livekit::StreamOutput* RoomCompositeEgressRequest::add_stream_outputs() {
  ::livekit::StreamOutput* _add = _internal_add_stream_outputs();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
RoomCompositeEgressRequest::stream_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.stream_outputs)
  return _impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 13;
inline int RoomCompositeEgressRequest::_internal_segment_outputs_size() const {
  return _impl_.segment_outputs_.size();
}
inline int RoomCompositeEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_segment_outputs() {
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::mutable_segment_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _impl_.segment_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
RoomCompositeEgressRequest::mutable_segment_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.segment_outputs)
  return &_impl_.segment_outputs_;
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::_internal_segment_outputs(int index) const {
  return _impl_.segment_outputs_.Get(index);
}
inline const ::livekit::SegmentedFileOutput& RoomCompositeEgressRequest::segment_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs(index);
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::_internal_add_segment_outputs() {
  return _impl_.segment_outputs_.Add();
}
inline ::livekit::SegmentedFileOutput* RoomCompositeEgressRequest::add_segment_outputs() {
  ::livekit::SegmentedFileOutput* _add = _internal_add_segment_outputs();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
RoomCompositeEgressRequest::segment_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.segment_outputs)
  return _impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 14;
inline int RoomCompositeEgressRequest::_internal_image_outputs_size() const {
  return _impl_.image_outputs_.size();
}
inline int RoomCompositeEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void RoomCompositeEgressRequest::clear_image_outputs() {
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* RoomCompositeEgressRequest::mutable_image_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomCompositeEgressRequest.image_outputs)
  return _impl_.image_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
RoomCompositeEgressRequest::mutable_image_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomCompositeEgressRequest.image_outputs)
  return &_impl_.image_outputs_;
}
inline const ::livekit::ImageOutput& RoomCompositeEgressRequest::_internal_image_outputs(int index) const {
  return _impl_.image_outputs_.Get(index);
}
inline const ::livekit::ImageOutput& RoomCompositeEgressRequest::image_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomCompositeEgressRequest.image_outputs)
  return _internal_image_outputs(index);
}
inline ::livekit::ImageOutput* RoomCompositeEgressRequest::_internal_add_image_outputs() {
  return _impl_.image_outputs_.Add();
}
inline ::livekit::ImageOutput* RoomCompositeEgressRequest::add_image_outputs() {
  ::livekit::ImageOutput* _add = _internal_add_image_outputs();
  // @@protoc_insertion_point(field_add:livekit.RoomCompositeEgressRequest.image_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
RoomCompositeEgressRequest::image_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.RoomCompositeEgressRequest.image_outputs)
  return _impl_.image_outputs_;
}

inline bool RoomCompositeEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void RoomCompositeEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool RoomCompositeEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void RoomCompositeEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline RoomCompositeEgressRequest::OutputCase RoomCompositeEgressRequest::output_case() const {
  return RoomCompositeEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline RoomCompositeEgressRequest::OptionsCase RoomCompositeEgressRequest::options_case() const {
  return RoomCompositeEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// WebEgressRequest

// string url = 1;
inline void WebEgressRequest::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& WebEgressRequest::url() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebEgressRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.url)
}
inline std::string* WebEgressRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.url)
  return _s;
}
inline const std::string& WebEgressRequest::_internal_url() const {
  return _impl_.url_.Get();
}
inline void WebEgressRequest::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebEgressRequest::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebEgressRequest::release_url() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.url)
  return _impl_.url_.Release();
}
inline void WebEgressRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.WebEgressRequest.url)
}

// bool audio_only = 2;
inline void WebEgressRequest::clear_audio_only() {
  _impl_.audio_only_ = false;
}
inline bool WebEgressRequest::_internal_audio_only() const {
  return _impl_.audio_only_;
}
inline bool WebEgressRequest::audio_only() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.audio_only)
  return _internal_audio_only();
}
inline void WebEgressRequest::_internal_set_audio_only(bool value) {
  
  _impl_.audio_only_ = value;
}
inline void WebEgressRequest::set_audio_only(bool value) {
  _internal_set_audio_only(value);
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.audio_only)
}

// bool video_only = 3;
inline void WebEgressRequest::clear_video_only() {
  _impl_.video_only_ = false;
}
inline bool WebEgressRequest::_internal_video_only() const {
  return _impl_.video_only_;
}
inline bool WebEgressRequest::video_only() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.video_only)
  return _internal_video_only();
}
inline void WebEgressRequest::_internal_set_video_only(bool value) {
  
  _impl_.video_only_ = value;
}
inline void WebEgressRequest::set_video_only(bool value) {
  _internal_set_video_only(value);
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.video_only)
}

// bool await_start_signal = 12;
inline void WebEgressRequest::clear_await_start_signal() {
  _impl_.await_start_signal_ = false;
}
inline bool WebEgressRequest::_internal_await_start_signal() const {
  return _impl_.await_start_signal_;
}
inline bool WebEgressRequest::await_start_signal() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.await_start_signal)
  return _internal_await_start_signal();
}
inline void WebEgressRequest::_internal_set_await_start_signal(bool value) {
  
  _impl_.await_start_signal_ = value;
}
inline void WebEgressRequest::set_await_start_signal(bool value) {
  _internal_set_await_start_signal(value);
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.await_start_signal)
}

// .livekit.EncodedFileOutput file = 4 [deprecated = true];
inline bool WebEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline bool WebEgressRequest::has_file() const {
  return _internal_has_file();
}
inline void WebEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void WebEgressRequest::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.file_;
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.output_.file_
      : reinterpret_cast< ::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::file() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* file) {
  clear_output();
  if (file) {
    set_has_file();
    _impl_.output_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = CreateMaybeMessage< ::livekit::EncodedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.file_;
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::mutable_file() {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 5 [deprecated = true];
inline bool WebEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline bool WebEgressRequest::has_stream() const {
  return _internal_has_stream();
}
inline void WebEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void WebEgressRequest::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.stream_;
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* WebEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& WebEgressRequest::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.output_.stream_
      : reinterpret_cast< ::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& WebEgressRequest::stream() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* WebEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_stream(::livekit::StreamOutput* stream) {
  clear_output();
  if (stream) {
    set_has_stream();
    _impl_.output_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.stream)
}
inline ::livekit::StreamOutput* WebEgressRequest::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = CreateMaybeMessage< ::livekit::StreamOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.stream_;
}
inline ::livekit::StreamOutput* WebEgressRequest::mutable_stream() {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 6 [deprecated = true];
inline bool WebEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline bool WebEgressRequest::has_segments() const {
  return _internal_has_segments();
}
inline void WebEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void WebEgressRequest::clear_segments() {
  if (_internal_has_segments()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.segments_;
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::_internal_segments() const {
  return _internal_has_segments()
      ? *_impl_.output_.segments_
      : reinterpret_cast< ::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::segments() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* segments) {
  clear_output();
  if (segments) {
    set_has_segments();
    _impl_.output_.segments_ = segments;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::_internal_mutable_segments() {
  if (!_internal_has_segments()) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = CreateMaybeMessage< ::livekit::SegmentedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.segments_;
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::mutable_segments() {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 7;
inline bool WebEgressRequest::_internal_has_preset() const {
  return options_case() == kPreset;
}
inline bool WebEgressRequest::has_preset() const {
  return _internal_has_preset();
}
inline void WebEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void WebEgressRequest::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset WebEgressRequest::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::EncodingOptionsPreset >(_impl_.options_.preset_);
  }
  return static_cast< ::livekit::EncodingOptionsPreset >(0);
}
inline ::livekit::EncodingOptionsPreset WebEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.preset)
  return _internal_preset();
}
inline void WebEgressRequest::_internal_set_preset(::livekit::EncodingOptionsPreset value) {
  if (!_internal_has_preset()) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
}
inline void WebEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.WebEgressRequest.preset)
}

// .livekit.EncodingOptions advanced = 8;
inline bool WebEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool WebEgressRequest::has_advanced() const {
  return _internal_has_advanced();
}
inline void WebEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void WebEgressRequest::clear_advanced() {
  if (_internal_has_advanced()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.advanced_;
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* WebEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.WebEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& WebEgressRequest::_internal_advanced() const {
  return _internal_has_advanced()
      ? *_impl_.options_.advanced_
      : reinterpret_cast< ::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& WebEgressRequest::advanced() const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* WebEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WebEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WebEgressRequest::unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* advanced) {
  clear_options();
  if (advanced) {
    set_has_advanced();
    _impl_.options_.advanced_ = advanced;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WebEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* WebEgressRequest::_internal_mutable_advanced() {
  if (!_internal_has_advanced()) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = CreateMaybeMessage< ::livekit::EncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* WebEgressRequest::mutable_advanced() {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 9;
inline int WebEgressRequest::_internal_file_outputs_size() const {
  return _impl_.file_outputs_.size();
}
inline int WebEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void WebEgressRequest::clear_file_outputs() {
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::mutable_file_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.file_outputs)
  return _impl_.file_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
WebEgressRequest::mutable_file_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.file_outputs)
  return &_impl_.file_outputs_;
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::_internal_file_outputs(int index) const {
  return _impl_.file_outputs_.Get(index);
}
inline const ::livekit::EncodedFileOutput& WebEgressRequest::file_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.file_outputs)
  return _internal_file_outputs(index);
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::_internal_add_file_outputs() {
  return _impl_.file_outputs_.Add();
}
inline ::livekit::EncodedFileOutput* WebEgressRequest::add_file_outputs() {
  ::livekit::EncodedFileOutput* _add = _internal_add_file_outputs();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.file_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
WebEgressRequest::file_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.file_outputs)
  return _impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 10;
inline int WebEgressRequest::_internal_stream_outputs_size() const {
  return _impl_.stream_outputs_.size();
}
inline int WebEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void WebEgressRequest::clear_stream_outputs() {
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* WebEgressRequest::mutable_stream_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.stream_outputs)
  return _impl_.stream_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
WebEgressRequest::mutable_stream_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.stream_outputs)
  return &_impl_.stream_outputs_;
}
inline const ::livekit::StreamOutput& WebEgressRequest::_internal_stream_outputs(int index) const {
  return _impl_.stream_outputs_.Get(index);
}
inline const ::livekit::StreamOutput& WebEgressRequest::stream_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.stream_outputs)
  return _internal_stream_outputs(index);
}
inline ::livekit::StreamOutput* WebEgressRequest::_internal_add_stream_outputs() {
  return _impl_.stream_outputs_.Add();
}
inline ::livekit::StreamOutput* WebEgressRequest::add_stream_outputs() {
  ::livekit::StreamOutput* _add = _internal_add_stream_outputs();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.stream_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
WebEgressRequest::stream_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.stream_outputs)
  return _impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 11;
inline int WebEgressRequest::_internal_segment_outputs_size() const {
  return _impl_.segment_outputs_.size();
}
inline int WebEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void WebEgressRequest::clear_segment_outputs() {
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::mutable_segment_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.segment_outputs)
  return _impl_.segment_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
WebEgressRequest::mutable_segment_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.segment_outputs)
  return &_impl_.segment_outputs_;
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::_internal_segment_outputs(int index) const {
  return _impl_.segment_outputs_.Get(index);
}
inline const ::livekit::SegmentedFileOutput& WebEgressRequest::segment_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.segment_outputs)
  return _internal_segment_outputs(index);
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::_internal_add_segment_outputs() {
  return _impl_.segment_outputs_.Add();
}
inline ::livekit::SegmentedFileOutput* WebEgressRequest::add_segment_outputs() {
  ::livekit::SegmentedFileOutput* _add = _internal_add_segment_outputs();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.segment_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
WebEgressRequest::segment_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.segment_outputs)
  return _impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 13;
inline int WebEgressRequest::_internal_image_outputs_size() const {
  return _impl_.image_outputs_.size();
}
inline int WebEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void WebEgressRequest::clear_image_outputs() {
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* WebEgressRequest::mutable_image_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.WebEgressRequest.image_outputs)
  return _impl_.image_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
WebEgressRequest::mutable_image_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.WebEgressRequest.image_outputs)
  return &_impl_.image_outputs_;
}
inline const ::livekit::ImageOutput& WebEgressRequest::_internal_image_outputs(int index) const {
  return _impl_.image_outputs_.Get(index);
}
inline const ::livekit::ImageOutput& WebEgressRequest::image_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.WebEgressRequest.image_outputs)
  return _internal_image_outputs(index);
}
inline ::livekit::ImageOutput* WebEgressRequest::_internal_add_image_outputs() {
  return _impl_.image_outputs_.Add();
}
inline ::livekit::ImageOutput* WebEgressRequest::add_image_outputs() {
  ::livekit::ImageOutput* _add = _internal_add_image_outputs();
  // @@protoc_insertion_point(field_add:livekit.WebEgressRequest.image_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
WebEgressRequest::image_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.WebEgressRequest.image_outputs)
  return _impl_.image_outputs_;
}

inline bool WebEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void WebEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool WebEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void WebEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline WebEgressRequest::OutputCase WebEgressRequest::output_case() const {
  return WebEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline WebEgressRequest::OptionsCase WebEgressRequest::options_case() const {
  return WebEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// ParticipantEgressRequest

// string room_name = 1;
inline void ParticipantEgressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& ParticipantEgressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantEgressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.room_name)
}
inline std::string* ParticipantEgressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.room_name)
  return _s;
}
inline const std::string& ParticipantEgressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void ParticipantEgressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantEgressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantEgressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void ParticipantEgressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantEgressRequest.room_name)
}

// string identity = 2;
inline void ParticipantEgressRequest::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& ParticipantEgressRequest::identity() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantEgressRequest::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.identity)
}
inline std::string* ParticipantEgressRequest::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.identity)
  return _s;
}
inline const std::string& ParticipantEgressRequest::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void ParticipantEgressRequest::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantEgressRequest::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantEgressRequest::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.identity)
  return _impl_.identity_.Release();
}
inline void ParticipantEgressRequest::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantEgressRequest.identity)
}

// bool screen_share = 3;
inline void ParticipantEgressRequest::clear_screen_share() {
  _impl_.screen_share_ = false;
}
inline bool ParticipantEgressRequest::_internal_screen_share() const {
  return _impl_.screen_share_;
}
inline bool ParticipantEgressRequest::screen_share() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.screen_share)
  return _internal_screen_share();
}
inline void ParticipantEgressRequest::_internal_set_screen_share(bool value) {
  
  _impl_.screen_share_ = value;
}
inline void ParticipantEgressRequest::set_screen_share(bool value) {
  _internal_set_screen_share(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.screen_share)
}

// .livekit.EncodingOptionsPreset preset = 4;
inline bool ParticipantEgressRequest::_internal_has_preset() const {
  return options_case() == kPreset;
}
inline bool ParticipantEgressRequest::has_preset() const {
  return _internal_has_preset();
}
inline void ParticipantEgressRequest::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void ParticipantEgressRequest::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset ParticipantEgressRequest::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::EncodingOptionsPreset >(_impl_.options_.preset_);
  }
  return static_cast< ::livekit::EncodingOptionsPreset >(0);
}
inline ::livekit::EncodingOptionsPreset ParticipantEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.preset)
  return _internal_preset();
}
inline void ParticipantEgressRequest::_internal_set_preset(::livekit::EncodingOptionsPreset value) {
  if (!_internal_has_preset()) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
}
inline void ParticipantEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantEgressRequest.preset)
}

// .livekit.EncodingOptions advanced = 5;
inline bool ParticipantEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool ParticipantEgressRequest::has_advanced() const {
  return _internal_has_advanced();
}
inline void ParticipantEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[0] = kAdvanced;
}
inline void ParticipantEgressRequest::clear_advanced() {
  if (_internal_has_advanced()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.advanced_;
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* ParticipantEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& ParticipantEgressRequest::_internal_advanced() const {
  return _internal_has_advanced()
      ? *_impl_.options_.advanced_
      : reinterpret_cast< ::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& ParticipantEgressRequest::advanced() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* ParticipantEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ParticipantEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParticipantEgressRequest::unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* advanced) {
  clear_options();
  if (advanced) {
    set_has_advanced();
    _impl_.options_.advanced_ = advanced;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ParticipantEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* ParticipantEgressRequest::_internal_mutable_advanced() {
  if (!_internal_has_advanced()) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = CreateMaybeMessage< ::livekit::EncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* ParticipantEgressRequest::mutable_advanced() {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 6;
inline int ParticipantEgressRequest::_internal_file_outputs_size() const {
  return _impl_.file_outputs_.size();
}
inline int ParticipantEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void ParticipantEgressRequest::clear_file_outputs() {
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* ParticipantEgressRequest::mutable_file_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.file_outputs)
  return _impl_.file_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
ParticipantEgressRequest::mutable_file_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.file_outputs)
  return &_impl_.file_outputs_;
}
inline const ::livekit::EncodedFileOutput& ParticipantEgressRequest::_internal_file_outputs(int index) const {
  return _impl_.file_outputs_.Get(index);
}
inline const ::livekit::EncodedFileOutput& ParticipantEgressRequest::file_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.file_outputs)
  return _internal_file_outputs(index);
}
inline ::livekit::EncodedFileOutput* ParticipantEgressRequest::_internal_add_file_outputs() {
  return _impl_.file_outputs_.Add();
}
inline ::livekit::EncodedFileOutput* ParticipantEgressRequest::add_file_outputs() {
  ::livekit::EncodedFileOutput* _add = _internal_add_file_outputs();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.file_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
ParticipantEgressRequest::file_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.file_outputs)
  return _impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 7;
inline int ParticipantEgressRequest::_internal_stream_outputs_size() const {
  return _impl_.stream_outputs_.size();
}
inline int ParticipantEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void ParticipantEgressRequest::clear_stream_outputs() {
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* ParticipantEgressRequest::mutable_stream_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.stream_outputs)
  return _impl_.stream_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
ParticipantEgressRequest::mutable_stream_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.stream_outputs)
  return &_impl_.stream_outputs_;
}
inline const ::livekit::StreamOutput& ParticipantEgressRequest::_internal_stream_outputs(int index) const {
  return _impl_.stream_outputs_.Get(index);
}
inline const ::livekit::StreamOutput& ParticipantEgressRequest::stream_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.stream_outputs)
  return _internal_stream_outputs(index);
}
inline ::livekit::StreamOutput* ParticipantEgressRequest::_internal_add_stream_outputs() {
  return _impl_.stream_outputs_.Add();
}
inline ::livekit::StreamOutput* ParticipantEgressRequest::add_stream_outputs() {
  ::livekit::StreamOutput* _add = _internal_add_stream_outputs();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.stream_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
ParticipantEgressRequest::stream_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.stream_outputs)
  return _impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 8;
inline int ParticipantEgressRequest::_internal_segment_outputs_size() const {
  return _impl_.segment_outputs_.size();
}
inline int ParticipantEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void ParticipantEgressRequest::clear_segment_outputs() {
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* ParticipantEgressRequest::mutable_segment_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.segment_outputs)
  return _impl_.segment_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
ParticipantEgressRequest::mutable_segment_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.segment_outputs)
  return &_impl_.segment_outputs_;
}
inline const ::livekit::SegmentedFileOutput& ParticipantEgressRequest::_internal_segment_outputs(int index) const {
  return _impl_.segment_outputs_.Get(index);
}
inline const ::livekit::SegmentedFileOutput& ParticipantEgressRequest::segment_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.segment_outputs)
  return _internal_segment_outputs(index);
}
inline ::livekit::SegmentedFileOutput* ParticipantEgressRequest::_internal_add_segment_outputs() {
  return _impl_.segment_outputs_.Add();
}
inline ::livekit::SegmentedFileOutput* ParticipantEgressRequest::add_segment_outputs() {
  ::livekit::SegmentedFileOutput* _add = _internal_add_segment_outputs();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.segment_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
ParticipantEgressRequest::segment_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.segment_outputs)
  return _impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 9;
inline int ParticipantEgressRequest::_internal_image_outputs_size() const {
  return _impl_.image_outputs_.size();
}
inline int ParticipantEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void ParticipantEgressRequest::clear_image_outputs() {
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* ParticipantEgressRequest::mutable_image_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantEgressRequest.image_outputs)
  return _impl_.image_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
ParticipantEgressRequest::mutable_image_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantEgressRequest.image_outputs)
  return &_impl_.image_outputs_;
}
inline const ::livekit::ImageOutput& ParticipantEgressRequest::_internal_image_outputs(int index) const {
  return _impl_.image_outputs_.Get(index);
}
inline const ::livekit::ImageOutput& ParticipantEgressRequest::image_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantEgressRequest.image_outputs)
  return _internal_image_outputs(index);
}
inline ::livekit::ImageOutput* ParticipantEgressRequest::_internal_add_image_outputs() {
  return _impl_.image_outputs_.Add();
}
inline ::livekit::ImageOutput* ParticipantEgressRequest::add_image_outputs() {
  ::livekit::ImageOutput* _add = _internal_add_image_outputs();
  // @@protoc_insertion_point(field_add:livekit.ParticipantEgressRequest.image_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
ParticipantEgressRequest::image_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantEgressRequest.image_outputs)
  return _impl_.image_outputs_;
}

inline bool ParticipantEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void ParticipantEgressRequest::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline ParticipantEgressRequest::OptionsCase ParticipantEgressRequest::options_case() const {
  return ParticipantEgressRequest::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrackCompositeEgressRequest

// string room_name = 1;
inline void TrackCompositeEgressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& TrackCompositeEgressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackCompositeEgressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.room_name)
}
inline std::string* TrackCompositeEgressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.room_name)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void TrackCompositeEgressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.room_name)
}

// string audio_track_id = 2;
inline void TrackCompositeEgressRequest::clear_audio_track_id() {
  _impl_.audio_track_id_.ClearToEmpty();
}
inline const std::string& TrackCompositeEgressRequest::audio_track_id() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.audio_track_id)
  return _internal_audio_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackCompositeEgressRequest::set_audio_track_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audio_track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.audio_track_id)
}
inline std::string* TrackCompositeEgressRequest::mutable_audio_track_id() {
  std::string* _s = _internal_mutable_audio_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.audio_track_id)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_audio_track_id() const {
  return _impl_.audio_track_id_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_audio_track_id(const std::string& value) {
  
  _impl_.audio_track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::_internal_mutable_audio_track_id() {
  
  return _impl_.audio_track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::release_audio_track_id() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.audio_track_id)
  return _impl_.audio_track_id_.Release();
}
inline void TrackCompositeEgressRequest::set_allocated_audio_track_id(std::string* audio_track_id) {
  if (audio_track_id != nullptr) {
    
  } else {
    
  }
  _impl_.audio_track_id_.SetAllocated(audio_track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_track_id_.IsDefault()) {
    _impl_.audio_track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.audio_track_id)
}

// string video_track_id = 3;
inline void TrackCompositeEgressRequest::clear_video_track_id() {
  _impl_.video_track_id_.ClearToEmpty();
}
inline const std::string& TrackCompositeEgressRequest::video_track_id() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.video_track_id)
  return _internal_video_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackCompositeEgressRequest::set_video_track_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.video_track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.video_track_id)
}
inline std::string* TrackCompositeEgressRequest::mutable_video_track_id() {
  std::string* _s = _internal_mutable_video_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.video_track_id)
  return _s;
}
inline const std::string& TrackCompositeEgressRequest::_internal_video_track_id() const {
  return _impl_.video_track_id_.Get();
}
inline void TrackCompositeEgressRequest::_internal_set_video_track_id(const std::string& value) {
  
  _impl_.video_track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::_internal_mutable_video_track_id() {
  
  return _impl_.video_track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackCompositeEgressRequest::release_video_track_id() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.video_track_id)
  return _impl_.video_track_id_.Release();
}
inline void TrackCompositeEgressRequest::set_allocated_video_track_id(std::string* video_track_id) {
  if (video_track_id != nullptr) {
    
  } else {
    
  }
  _impl_.video_track_id_.SetAllocated(video_track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.video_track_id_.IsDefault()) {
    _impl_.video_track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackCompositeEgressRequest.video_track_id)
}

// .livekit.EncodedFileOutput file = 4 [deprecated = true];
inline bool TrackCompositeEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline bool TrackCompositeEgressRequest::has_file() const {
  return _internal_has_file();
}
inline void TrackCompositeEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void TrackCompositeEgressRequest::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.file_;
    }
    clear_has_output();
  }
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.output_.file_
      : reinterpret_cast< ::livekit::EncodedFileOutput&>(::livekit::_EncodedFileOutput_default_instance_);
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::file() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.file)
  return _internal_file();
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::EncodedFileOutput* temp = _impl_.output_.file_;
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_file(::livekit::EncodedFileOutput* file) {
  clear_output();
  if (file) {
    set_has_file();
    _impl_.output_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.file)
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = CreateMaybeMessage< ::livekit::EncodedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.file_;
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::mutable_file() {
  ::livekit::EncodedFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.file)
  return _msg;
}

// .livekit.StreamOutput stream = 5 [deprecated = true];
inline bool TrackCompositeEgressRequest::_internal_has_stream() const {
  return output_case() == kStream;
}
inline bool TrackCompositeEgressRequest::has_stream() const {
  return _internal_has_stream();
}
inline void TrackCompositeEgressRequest::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline void TrackCompositeEgressRequest::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.stream_;
    }
    clear_has_output();
  }
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.output_.stream_
      : reinterpret_cast< ::livekit::StreamOutput&>(::livekit::_StreamOutput_default_instance_);
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::stream() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.stream)
  return _internal_stream();
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.stream)
  if (_internal_has_stream()) {
    clear_has_output();
    ::livekit::StreamOutput* temp = _impl_.output_.stream_;
    _impl_.output_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_stream(::livekit::StreamOutput* stream) {
  clear_output();
  if (stream) {
    set_has_stream();
    _impl_.output_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.stream)
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_output();
    set_has_stream();
    _impl_.output_.stream_ = CreateMaybeMessage< ::livekit::StreamOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.stream_;
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::mutable_stream() {
  ::livekit::StreamOutput* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.stream)
  return _msg;
}

// .livekit.SegmentedFileOutput segments = 8 [deprecated = true];
inline bool TrackCompositeEgressRequest::_internal_has_segments() const {
  return output_case() == kSegments;
}
inline bool TrackCompositeEgressRequest::has_segments() const {
  return _internal_has_segments();
}
inline void TrackCompositeEgressRequest::set_has_segments() {
  _impl_._oneof_case_[0] = kSegments;
}
inline void TrackCompositeEgressRequest::clear_segments() {
  if (_internal_has_segments()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.segments_;
    }
    clear_has_output();
  }
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::_internal_segments() const {
  return _internal_has_segments()
      ? *_impl_.output_.segments_
      : reinterpret_cast< ::livekit::SegmentedFileOutput&>(::livekit::_SegmentedFileOutput_default_instance_);
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::segments() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.segments)
  return _internal_segments();
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.segments)
  if (_internal_has_segments()) {
    clear_has_output();
    ::livekit::SegmentedFileOutput* temp = _impl_.output_.segments_;
    _impl_.output_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_segments(::livekit::SegmentedFileOutput* segments) {
  clear_output();
  if (segments) {
    set_has_segments();
    _impl_.output_.segments_ = segments;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.segments)
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::_internal_mutable_segments() {
  if (!_internal_has_segments()) {
    clear_output();
    set_has_segments();
    _impl_.output_.segments_ = CreateMaybeMessage< ::livekit::SegmentedFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.segments_;
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::mutable_segments() {
  ::livekit::SegmentedFileOutput* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.segments)
  return _msg;
}

// .livekit.EncodingOptionsPreset preset = 6;
inline bool TrackCompositeEgressRequest::_internal_has_preset() const {
  return options_case() == kPreset;
}
inline bool TrackCompositeEgressRequest::has_preset() const {
  return _internal_has_preset();
}
inline void TrackCompositeEgressRequest::set_has_preset() {
  _impl_._oneof_case_[1] = kPreset;
}
inline void TrackCompositeEgressRequest::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset TrackCompositeEgressRequest::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::EncodingOptionsPreset >(_impl_.options_.preset_);
  }
  return static_cast< ::livekit::EncodingOptionsPreset >(0);
}
inline ::livekit::EncodingOptionsPreset TrackCompositeEgressRequest::preset() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.preset)
  return _internal_preset();
}
inline void TrackCompositeEgressRequest::_internal_set_preset(::livekit::EncodingOptionsPreset value) {
  if (!_internal_has_preset()) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
}
inline void TrackCompositeEgressRequest::set_preset(::livekit::EncodingOptionsPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.TrackCompositeEgressRequest.preset)
}

// .livekit.EncodingOptions advanced = 7;
inline bool TrackCompositeEgressRequest::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool TrackCompositeEgressRequest::has_advanced() const {
  return _internal_has_advanced();
}
inline void TrackCompositeEgressRequest::set_has_advanced() {
  _impl_._oneof_case_[1] = kAdvanced;
}
inline void TrackCompositeEgressRequest::clear_advanced() {
  if (_internal_has_advanced()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.advanced_;
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* TrackCompositeEgressRequest::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.TrackCompositeEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& TrackCompositeEgressRequest::_internal_advanced() const {
  return _internal_has_advanced()
      ? *_impl_.options_.advanced_
      : reinterpret_cast< ::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& TrackCompositeEgressRequest::advanced() const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* TrackCompositeEgressRequest::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackCompositeEgressRequest.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackCompositeEgressRequest::unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* advanced) {
  clear_options();
  if (advanced) {
    set_has_advanced();
    _impl_.options_.advanced_ = advanced;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackCompositeEgressRequest.advanced)
}
inline ::livekit::EncodingOptions* TrackCompositeEgressRequest::_internal_mutable_advanced() {
  if (!_internal_has_advanced()) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = CreateMaybeMessage< ::livekit::EncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* TrackCompositeEgressRequest::mutable_advanced() {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 11;
inline int TrackCompositeEgressRequest::_internal_file_outputs_size() const {
  return _impl_.file_outputs_.size();
}
inline int TrackCompositeEgressRequest::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_file_outputs() {
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::mutable_file_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.file_outputs)
  return _impl_.file_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
TrackCompositeEgressRequest::mutable_file_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.file_outputs)
  return &_impl_.file_outputs_;
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::_internal_file_outputs(int index) const {
  return _impl_.file_outputs_.Get(index);
}
inline const ::livekit::EncodedFileOutput& TrackCompositeEgressRequest::file_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.file_outputs)
  return _internal_file_outputs(index);
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::_internal_add_file_outputs() {
  return _impl_.file_outputs_.Add();
}
inline ::livekit::EncodedFileOutput* TrackCompositeEgressRequest::add_file_outputs() {
  ::livekit::EncodedFileOutput* _add = _internal_add_file_outputs();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.file_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
TrackCompositeEgressRequest::file_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.file_outputs)
  return _impl_.file_outputs_;
}

// repeated .livekit.StreamOutput stream_outputs = 12;
inline int TrackCompositeEgressRequest::_internal_stream_outputs_size() const {
  return _impl_.stream_outputs_.size();
}
inline int TrackCompositeEgressRequest::stream_outputs_size() const {
  return _internal_stream_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_stream_outputs() {
  _impl_.stream_outputs_.Clear();
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::mutable_stream_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _impl_.stream_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >*
TrackCompositeEgressRequest::mutable_stream_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.stream_outputs)
  return &_impl_.stream_outputs_;
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::_internal_stream_outputs(int index) const {
  return _impl_.stream_outputs_.Get(index);
}
inline const ::livekit::StreamOutput& TrackCompositeEgressRequest::stream_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _internal_stream_outputs(index);
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::_internal_add_stream_outputs() {
  return _impl_.stream_outputs_.Add();
}
inline ::livekit::StreamOutput* TrackCompositeEgressRequest::add_stream_outputs() {
  ::livekit::StreamOutput* _add = _internal_add_stream_outputs();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamOutput >&
TrackCompositeEgressRequest::stream_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.stream_outputs)
  return _impl_.stream_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 13;
inline int TrackCompositeEgressRequest::_internal_segment_outputs_size() const {
  return _impl_.segment_outputs_.size();
}
inline int TrackCompositeEgressRequest::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_segment_outputs() {
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::mutable_segment_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _impl_.segment_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
TrackCompositeEgressRequest::mutable_segment_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.segment_outputs)
  return &_impl_.segment_outputs_;
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::_internal_segment_outputs(int index) const {
  return _impl_.segment_outputs_.Get(index);
}
inline const ::livekit::SegmentedFileOutput& TrackCompositeEgressRequest::segment_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _internal_segment_outputs(index);
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::_internal_add_segment_outputs() {
  return _impl_.segment_outputs_.Add();
}
inline ::livekit::SegmentedFileOutput* TrackCompositeEgressRequest::add_segment_outputs() {
  ::livekit::SegmentedFileOutput* _add = _internal_add_segment_outputs();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
TrackCompositeEgressRequest::segment_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.segment_outputs)
  return _impl_.segment_outputs_;
}

// repeated .livekit.ImageOutput image_outputs = 14;
inline int TrackCompositeEgressRequest::_internal_image_outputs_size() const {
  return _impl_.image_outputs_.size();
}
inline int TrackCompositeEgressRequest::image_outputs_size() const {
  return _internal_image_outputs_size();
}
inline void TrackCompositeEgressRequest::clear_image_outputs() {
  _impl_.image_outputs_.Clear();
}
inline ::livekit::ImageOutput* TrackCompositeEgressRequest::mutable_image_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackCompositeEgressRequest.image_outputs)
  return _impl_.image_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >*
TrackCompositeEgressRequest::mutable_image_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackCompositeEgressRequest.image_outputs)
  return &_impl_.image_outputs_;
}
inline const ::livekit::ImageOutput& TrackCompositeEgressRequest::_internal_image_outputs(int index) const {
  return _impl_.image_outputs_.Get(index);
}
inline const ::livekit::ImageOutput& TrackCompositeEgressRequest::image_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackCompositeEgressRequest.image_outputs)
  return _internal_image_outputs(index);
}
inline ::livekit::ImageOutput* TrackCompositeEgressRequest::_internal_add_image_outputs() {
  return _impl_.image_outputs_.Add();
}
inline ::livekit::ImageOutput* TrackCompositeEgressRequest::add_image_outputs() {
  ::livekit::ImageOutput* _add = _internal_add_image_outputs();
  // @@protoc_insertion_point(field_add:livekit.TrackCompositeEgressRequest.image_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImageOutput >&
TrackCompositeEgressRequest::image_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.TrackCompositeEgressRequest.image_outputs)
  return _impl_.image_outputs_;
}

inline bool TrackCompositeEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void TrackCompositeEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline bool TrackCompositeEgressRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void TrackCompositeEgressRequest::clear_has_options() {
  _impl_._oneof_case_[1] = OPTIONS_NOT_SET;
}
inline TrackCompositeEgressRequest::OutputCase TrackCompositeEgressRequest::output_case() const {
  return TrackCompositeEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
inline TrackCompositeEgressRequest::OptionsCase TrackCompositeEgressRequest::options_case() const {
  return TrackCompositeEgressRequest::OptionsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TrackEgressRequest

// string room_name = 1;
inline void TrackEgressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& TrackEgressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackEgressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.room_name)
}
inline std::string* TrackEgressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.room_name)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void TrackEgressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void TrackEgressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.room_name)
}

// string track_id = 2;
inline void TrackEgressRequest::clear_track_id() {
  _impl_.track_id_.ClearToEmpty();
}
inline const std::string& TrackEgressRequest::track_id() const {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.track_id)
  return _internal_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackEgressRequest::set_track_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.track_id)
}
inline std::string* TrackEgressRequest::mutable_track_id() {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.track_id)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_track_id() const {
  return _impl_.track_id_.Get();
}
inline void TrackEgressRequest::_internal_set_track_id(const std::string& value) {
  
  _impl_.track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::_internal_mutable_track_id() {
  
  return _impl_.track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::release_track_id() {
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.track_id)
  return _impl_.track_id_.Release();
}
inline void TrackEgressRequest::set_allocated_track_id(std::string* track_id) {
  if (track_id != nullptr) {
    
  } else {
    
  }
  _impl_.track_id_.SetAllocated(track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.track_id)
}

// .livekit.DirectFileOutput file = 3;
inline bool TrackEgressRequest::_internal_has_file() const {
  return output_case() == kFile;
}
inline bool TrackEgressRequest::has_file() const {
  return _internal_has_file();
}
inline void TrackEgressRequest::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void TrackEgressRequest::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.file_;
    }
    clear_has_output();
  }
}
inline ::livekit::DirectFileOutput* TrackEgressRequest::release_file() {
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::DirectFileOutput* temp = _impl_.output_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DirectFileOutput& TrackEgressRequest::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.output_.file_
      : reinterpret_cast< ::livekit::DirectFileOutput&>(::livekit::_DirectFileOutput_default_instance_);
}
inline const ::livekit::DirectFileOutput& TrackEgressRequest::file() const {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.file)
  return _internal_file();
}
inline ::livekit::DirectFileOutput* TrackEgressRequest::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.TrackEgressRequest.file)
  if (_internal_has_file()) {
    clear_has_output();
    ::livekit::DirectFileOutput* temp = _impl_.output_.file_;
    _impl_.output_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrackEgressRequest::unsafe_arena_set_allocated_file(::livekit::DirectFileOutput* file) {
  clear_output();
  if (file) {
    set_has_file();
    _impl_.output_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackEgressRequest.file)
}
inline ::livekit::DirectFileOutput* TrackEgressRequest::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_output();
    set_has_file();
    _impl_.output_.file_ = CreateMaybeMessage< ::livekit::DirectFileOutput >(GetArenaForAllocation());
  }
  return _impl_.output_.file_;
}
inline ::livekit::DirectFileOutput* TrackEgressRequest::mutable_file() {
  ::livekit::DirectFileOutput* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.file)
  return _msg;
}

// string websocket_url = 4;
inline bool TrackEgressRequest::_internal_has_websocket_url() const {
  return output_case() == kWebsocketUrl;
}
inline bool TrackEgressRequest::has_websocket_url() const {
  return _internal_has_websocket_url();
}
inline void TrackEgressRequest::set_has_websocket_url() {
  _impl_._oneof_case_[0] = kWebsocketUrl;
}
inline void TrackEgressRequest::clear_websocket_url() {
  if (_internal_has_websocket_url()) {
    _impl_.output_.websocket_url_.Destroy();
    clear_has_output();
  }
}
inline const std::string& TrackEgressRequest::websocket_url() const {
  // @@protoc_insertion_point(field_get:livekit.TrackEgressRequest.websocket_url)
  return _internal_websocket_url();
}
template <typename ArgT0, typename... ArgT>
inline void TrackEgressRequest::set_websocket_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_websocket_url()) {
    clear_output();
    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  _impl_.output_.websocket_url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackEgressRequest.websocket_url)
}
inline std::string* TrackEgressRequest::mutable_websocket_url() {
  std::string* _s = _internal_mutable_websocket_url();
  // @@protoc_insertion_point(field_mutable:livekit.TrackEgressRequest.websocket_url)
  return _s;
}
inline const std::string& TrackEgressRequest::_internal_websocket_url() const {
  if (_internal_has_websocket_url()) {
    return _impl_.output_.websocket_url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TrackEgressRequest::_internal_set_websocket_url(const std::string& value) {
  if (!_internal_has_websocket_url()) {
    clear_output();
    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  _impl_.output_.websocket_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::_internal_mutable_websocket_url() {
  if (!_internal_has_websocket_url()) {
    clear_output();
    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitDefault();
  }
  return _impl_.output_.websocket_url_.Mutable(      GetArenaForAllocation());
}
inline std::string* TrackEgressRequest::release_websocket_url() {
  // @@protoc_insertion_point(field_release:livekit.TrackEgressRequest.websocket_url)
  if (_internal_has_websocket_url()) {
    clear_has_output();
    return _impl_.output_.websocket_url_.Release();
  } else {
    return nullptr;
  }
}
inline void TrackEgressRequest::set_allocated_websocket_url(std::string* websocket_url) {
  if (has_output()) {
    clear_output();
  }
  if (websocket_url != nullptr) {
    set_has_websocket_url();
    _impl_.output_.websocket_url_.InitAllocated(websocket_url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackEgressRequest.websocket_url)
}

inline bool TrackEgressRequest::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void TrackEgressRequest::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline TrackEgressRequest::OutputCase TrackEgressRequest::output_case() const {
  return TrackEgressRequest::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EncodedFileOutput

// .livekit.EncodedFileType file_type = 1;
inline void EncodedFileOutput::clear_file_type() {
  _impl_.file_type_ = 0;
}
inline ::livekit::EncodedFileType EncodedFileOutput::_internal_file_type() const {
  return static_cast< ::livekit::EncodedFileType >(_impl_.file_type_);
}
inline ::livekit::EncodedFileType EncodedFileOutput::file_type() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.file_type)
  return _internal_file_type();
}
inline void EncodedFileOutput::_internal_set_file_type(::livekit::EncodedFileType value) {
  
  _impl_.file_type_ = value;
}
inline void EncodedFileOutput::set_file_type(::livekit::EncodedFileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.file_type)
}

// string filepath = 2;
inline void EncodedFileOutput::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& EncodedFileOutput::filepath() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncodedFileOutput::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.filepath)
}
inline std::string* EncodedFileOutput::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.filepath)
  return _s;
}
inline const std::string& EncodedFileOutput::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void EncodedFileOutput::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* EncodedFileOutput::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* EncodedFileOutput::release_filepath() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.filepath)
  return _impl_.filepath_.Release();
}
inline void EncodedFileOutput::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EncodedFileOutput.filepath)
}

// bool disable_manifest = 6;
inline void EncodedFileOutput::clear_disable_manifest() {
  _impl_.disable_manifest_ = false;
}
inline bool EncodedFileOutput::_internal_disable_manifest() const {
  return _impl_.disable_manifest_;
}
inline bool EncodedFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void EncodedFileOutput::_internal_set_disable_manifest(bool value) {
  
  _impl_.disable_manifest_ = value;
}
inline void EncodedFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  // @@protoc_insertion_point(field_set:livekit.EncodedFileOutput.disable_manifest)
}

// .livekit.S3Upload s3 = 3;
inline bool EncodedFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline bool EncodedFileOutput::has_s3() const {
  return _internal_has_s3();
}
inline void EncodedFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void EncodedFileOutput::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.s3_;
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* EncodedFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& EncodedFileOutput::_internal_s3() const {
  return _internal_has_s3()
      ? *_impl_.output_.s3_
      : reinterpret_cast< ::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& EncodedFileOutput::s3() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* EncodedFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_s3(::livekit::S3Upload* s3) {
  clear_output();
  if (s3) {
    set_has_s3();
    _impl_.output_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.s3)
}
inline ::livekit::S3Upload* EncodedFileOutput::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = CreateMaybeMessage< ::livekit::S3Upload >(GetArenaForAllocation());
  }
  return _impl_.output_.s3_;
}
inline ::livekit::S3Upload* EncodedFileOutput::mutable_s3() {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 4;
inline bool EncodedFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline bool EncodedFileOutput::has_gcp() const {
  return _internal_has_gcp();
}
inline void EncodedFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void EncodedFileOutput::clear_gcp() {
  if (_internal_has_gcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.gcp_;
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* EncodedFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& EncodedFileOutput::_internal_gcp() const {
  return _internal_has_gcp()
      ? *_impl_.output_.gcp_
      : reinterpret_cast< ::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& EncodedFileOutput::gcp() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* EncodedFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* gcp) {
  clear_output();
  if (gcp) {
    set_has_gcp();
    _impl_.output_.gcp_ = gcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.gcp)
}
inline ::livekit::GCPUpload* EncodedFileOutput::_internal_mutable_gcp() {
  if (!_internal_has_gcp()) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = CreateMaybeMessage< ::livekit::GCPUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.gcp_;
}
inline ::livekit::GCPUpload* EncodedFileOutput::mutable_gcp() {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 5;
inline bool EncodedFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline bool EncodedFileOutput::has_azure() const {
  return _internal_has_azure();
}
inline void EncodedFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void EncodedFileOutput::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.azure_;
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* EncodedFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& EncodedFileOutput::_internal_azure() const {
  return _internal_has_azure()
      ? *_impl_.output_.azure_
      : reinterpret_cast< ::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& EncodedFileOutput::azure() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* EncodedFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* azure) {
  clear_output();
  if (azure) {
    set_has_azure();
    _impl_.output_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* EncodedFileOutput::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = CreateMaybeMessage< ::livekit::AzureBlobUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.azure_;
}
inline ::livekit::AzureBlobUpload* EncodedFileOutput::mutable_azure() {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 7;
inline bool EncodedFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool EncodedFileOutput::has_alioss() const {
  return _internal_has_alioss();
}
inline void EncodedFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void EncodedFileOutput::clear_alioss() {
  if (_internal_has_alioss()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.alioss_;
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* EncodedFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.EncodedFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& EncodedFileOutput::_internal_alioss() const {
  return _internal_has_alioss()
      ? *_impl_.output_.alioss_
      : reinterpret_cast< ::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& EncodedFileOutput::alioss() const {
  // @@protoc_insertion_point(field_get:livekit.EncodedFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* EncodedFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EncodedFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EncodedFileOutput::unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* alioss) {
  clear_output();
  if (alioss) {
    set_has_alioss();
    _impl_.output_.alioss_ = alioss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EncodedFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* EncodedFileOutput::_internal_mutable_alioss() {
  if (!_internal_has_alioss()) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = CreateMaybeMessage< ::livekit::AliOSSUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.alioss_;
}
inline ::livekit::AliOSSUpload* EncodedFileOutput::mutable_alioss() {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.EncodedFileOutput.aliOSS)
  return _msg;
}

inline bool EncodedFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void EncodedFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline EncodedFileOutput::OutputCase EncodedFileOutput::output_case() const {
  return EncodedFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SegmentedFileOutput

// .livekit.SegmentedFileProtocol protocol = 1;
inline void SegmentedFileOutput::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::livekit::SegmentedFileProtocol SegmentedFileOutput::_internal_protocol() const {
  return static_cast< ::livekit::SegmentedFileProtocol >(_impl_.protocol_);
}
inline ::livekit::SegmentedFileProtocol SegmentedFileOutput::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.protocol)
  return _internal_protocol();
}
inline void SegmentedFileOutput::_internal_set_protocol(::livekit::SegmentedFileProtocol value) {
  
  _impl_.protocol_ = value;
}
inline void SegmentedFileOutput::set_protocol(::livekit::SegmentedFileProtocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.protocol)
}

// string filename_prefix = 2;
inline void SegmentedFileOutput::clear_filename_prefix() {
  _impl_.filename_prefix_.ClearToEmpty();
}
inline const std::string& SegmentedFileOutput::filename_prefix() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.filename_prefix)
  return _internal_filename_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentedFileOutput::set_filename_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.filename_prefix)
}
inline std::string* SegmentedFileOutput::mutable_filename_prefix() {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.filename_prefix)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_filename_prefix() const {
  return _impl_.filename_prefix_.Get();
}
inline void SegmentedFileOutput::_internal_set_filename_prefix(const std::string& value) {
  
  _impl_.filename_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::_internal_mutable_filename_prefix() {
  
  return _impl_.filename_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::release_filename_prefix() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.filename_prefix)
  return _impl_.filename_prefix_.Release();
}
inline void SegmentedFileOutput::set_allocated_filename_prefix(std::string* filename_prefix) {
  if (filename_prefix != nullptr) {
    
  } else {
    
  }
  _impl_.filename_prefix_.SetAllocated(filename_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.filename_prefix)
}

// string playlist_name = 3;
inline void SegmentedFileOutput::clear_playlist_name() {
  _impl_.playlist_name_.ClearToEmpty();
}
inline const std::string& SegmentedFileOutput::playlist_name() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.playlist_name)
  return _internal_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentedFileOutput::set_playlist_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.playlist_name)
}
inline std::string* SegmentedFileOutput::mutable_playlist_name() {
  std::string* _s = _internal_mutable_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.playlist_name)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_playlist_name() const {
  return _impl_.playlist_name_.Get();
}
inline void SegmentedFileOutput::_internal_set_playlist_name(const std::string& value) {
  
  _impl_.playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::_internal_mutable_playlist_name() {
  
  return _impl_.playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::release_playlist_name() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.playlist_name)
  return _impl_.playlist_name_.Release();
}
inline void SegmentedFileOutput::set_allocated_playlist_name(std::string* playlist_name) {
  if (playlist_name != nullptr) {
    
  } else {
    
  }
  _impl_.playlist_name_.SetAllocated(playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlist_name_.IsDefault()) {
    _impl_.playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.playlist_name)
}

// string live_playlist_name = 11;
inline void SegmentedFileOutput::clear_live_playlist_name() {
  _impl_.live_playlist_name_.ClearToEmpty();
}
inline const std::string& SegmentedFileOutput::live_playlist_name() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.live_playlist_name)
  return _internal_live_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentedFileOutput::set_live_playlist_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.live_playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.live_playlist_name)
}
inline std::string* SegmentedFileOutput::mutable_live_playlist_name() {
  std::string* _s = _internal_mutable_live_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.live_playlist_name)
  return _s;
}
inline const std::string& SegmentedFileOutput::_internal_live_playlist_name() const {
  return _impl_.live_playlist_name_.Get();
}
inline void SegmentedFileOutput::_internal_set_live_playlist_name(const std::string& value) {
  
  _impl_.live_playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::_internal_mutable_live_playlist_name() {
  
  return _impl_.live_playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentedFileOutput::release_live_playlist_name() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.live_playlist_name)
  return _impl_.live_playlist_name_.Release();
}
inline void SegmentedFileOutput::set_allocated_live_playlist_name(std::string* live_playlist_name) {
  if (live_playlist_name != nullptr) {
    
  } else {
    
  }
  _impl_.live_playlist_name_.SetAllocated(live_playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.live_playlist_name_.IsDefault()) {
    _impl_.live_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentedFileOutput.live_playlist_name)
}

// uint32 segment_duration = 4;
inline void SegmentedFileOutput::clear_segment_duration() {
  _impl_.segment_duration_ = 0u;
}
inline uint32_t SegmentedFileOutput::_internal_segment_duration() const {
  return _impl_.segment_duration_;
}
inline uint32_t SegmentedFileOutput::segment_duration() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.segment_duration)
  return _internal_segment_duration();
}
inline void SegmentedFileOutput::_internal_set_segment_duration(uint32_t value) {
  
  _impl_.segment_duration_ = value;
}
inline void SegmentedFileOutput::set_segment_duration(uint32_t value) {
  _internal_set_segment_duration(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.segment_duration)
}

// .livekit.SegmentedFileSuffix filename_suffix = 10;
inline void SegmentedFileOutput::clear_filename_suffix() {
  _impl_.filename_suffix_ = 0;
}
inline ::livekit::SegmentedFileSuffix SegmentedFileOutput::_internal_filename_suffix() const {
  return static_cast< ::livekit::SegmentedFileSuffix >(_impl_.filename_suffix_);
}
inline ::livekit::SegmentedFileSuffix SegmentedFileOutput::filename_suffix() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.filename_suffix)
  return _internal_filename_suffix();
}
inline void SegmentedFileOutput::_internal_set_filename_suffix(::livekit::SegmentedFileSuffix value) {
  
  _impl_.filename_suffix_ = value;
}
inline void SegmentedFileOutput::set_filename_suffix(::livekit::SegmentedFileSuffix value) {
  _internal_set_filename_suffix(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.filename_suffix)
}

// bool disable_manifest = 8;
inline void SegmentedFileOutput::clear_disable_manifest() {
  _impl_.disable_manifest_ = false;
}
inline bool SegmentedFileOutput::_internal_disable_manifest() const {
  return _impl_.disable_manifest_;
}
inline bool SegmentedFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void SegmentedFileOutput::_internal_set_disable_manifest(bool value) {
  
  _impl_.disable_manifest_ = value;
}
inline void SegmentedFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentedFileOutput.disable_manifest)
}

// .livekit.S3Upload s3 = 5;
inline bool SegmentedFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline bool SegmentedFileOutput::has_s3() const {
  return _internal_has_s3();
}
inline void SegmentedFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void SegmentedFileOutput::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.s3_;
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* SegmentedFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& SegmentedFileOutput::_internal_s3() const {
  return _internal_has_s3()
      ? *_impl_.output_.s3_
      : reinterpret_cast< ::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& SegmentedFileOutput::s3() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* SegmentedFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_s3(::livekit::S3Upload* s3) {
  clear_output();
  if (s3) {
    set_has_s3();
    _impl_.output_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.s3)
}
inline ::livekit::S3Upload* SegmentedFileOutput::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = CreateMaybeMessage< ::livekit::S3Upload >(GetArenaForAllocation());
  }
  return _impl_.output_.s3_;
}
inline ::livekit::S3Upload* SegmentedFileOutput::mutable_s3() {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 6;
inline bool SegmentedFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline bool SegmentedFileOutput::has_gcp() const {
  return _internal_has_gcp();
}
inline void SegmentedFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void SegmentedFileOutput::clear_gcp() {
  if (_internal_has_gcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.gcp_;
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* SegmentedFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& SegmentedFileOutput::_internal_gcp() const {
  return _internal_has_gcp()
      ? *_impl_.output_.gcp_
      : reinterpret_cast< ::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& SegmentedFileOutput::gcp() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* SegmentedFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* gcp) {
  clear_output();
  if (gcp) {
    set_has_gcp();
    _impl_.output_.gcp_ = gcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.gcp)
}
inline ::livekit::GCPUpload* SegmentedFileOutput::_internal_mutable_gcp() {
  if (!_internal_has_gcp()) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = CreateMaybeMessage< ::livekit::GCPUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.gcp_;
}
inline ::livekit::GCPUpload* SegmentedFileOutput::mutable_gcp() {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 7;
inline bool SegmentedFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline bool SegmentedFileOutput::has_azure() const {
  return _internal_has_azure();
}
inline void SegmentedFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void SegmentedFileOutput::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.azure_;
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* SegmentedFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& SegmentedFileOutput::_internal_azure() const {
  return _internal_has_azure()
      ? *_impl_.output_.azure_
      : reinterpret_cast< ::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& SegmentedFileOutput::azure() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* SegmentedFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* azure) {
  clear_output();
  if (azure) {
    set_has_azure();
    _impl_.output_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* SegmentedFileOutput::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = CreateMaybeMessage< ::livekit::AzureBlobUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.azure_;
}
inline ::livekit::AzureBlobUpload* SegmentedFileOutput::mutable_azure() {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 9;
inline bool SegmentedFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool SegmentedFileOutput::has_alioss() const {
  return _internal_has_alioss();
}
inline void SegmentedFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void SegmentedFileOutput::clear_alioss() {
  if (_internal_has_alioss()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.alioss_;
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* SegmentedFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.SegmentedFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& SegmentedFileOutput::_internal_alioss() const {
  return _internal_has_alioss()
      ? *_impl_.output_.alioss_
      : reinterpret_cast< ::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& SegmentedFileOutput::alioss() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentedFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* SegmentedFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SegmentedFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SegmentedFileOutput::unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* alioss) {
  clear_output();
  if (alioss) {
    set_has_alioss();
    _impl_.output_.alioss_ = alioss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SegmentedFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* SegmentedFileOutput::_internal_mutable_alioss() {
  if (!_internal_has_alioss()) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = CreateMaybeMessage< ::livekit::AliOSSUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.alioss_;
}
inline ::livekit::AliOSSUpload* SegmentedFileOutput::mutable_alioss() {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentedFileOutput.aliOSS)
  return _msg;
}

inline bool SegmentedFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void SegmentedFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline SegmentedFileOutput::OutputCase SegmentedFileOutput::output_case() const {
  return SegmentedFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DirectFileOutput

// string filepath = 1;
inline void DirectFileOutput::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& DirectFileOutput::filepath() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectFileOutput::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DirectFileOutput.filepath)
}
inline std::string* DirectFileOutput::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.filepath)
  return _s;
}
inline const std::string& DirectFileOutput::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void DirectFileOutput::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectFileOutput::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectFileOutput::release_filepath() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.filepath)
  return _impl_.filepath_.Release();
}
inline void DirectFileOutput::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DirectFileOutput.filepath)
}

// bool disable_manifest = 5;
inline void DirectFileOutput::clear_disable_manifest() {
  _impl_.disable_manifest_ = false;
}
inline bool DirectFileOutput::_internal_disable_manifest() const {
  return _impl_.disable_manifest_;
}
inline bool DirectFileOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void DirectFileOutput::_internal_set_disable_manifest(bool value) {
  
  _impl_.disable_manifest_ = value;
}
inline void DirectFileOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  // @@protoc_insertion_point(field_set:livekit.DirectFileOutput.disable_manifest)
}

// .livekit.S3Upload s3 = 2;
inline bool DirectFileOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline bool DirectFileOutput::has_s3() const {
  return _internal_has_s3();
}
inline void DirectFileOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void DirectFileOutput::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.s3_;
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* DirectFileOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& DirectFileOutput::_internal_s3() const {
  return _internal_has_s3()
      ? *_impl_.output_.s3_
      : reinterpret_cast< ::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& DirectFileOutput::s3() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* DirectFileOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_s3(::livekit::S3Upload* s3) {
  clear_output();
  if (s3) {
    set_has_s3();
    _impl_.output_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.s3)
}
inline ::livekit::S3Upload* DirectFileOutput::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = CreateMaybeMessage< ::livekit::S3Upload >(GetArenaForAllocation());
  }
  return _impl_.output_.s3_;
}
inline ::livekit::S3Upload* DirectFileOutput::mutable_s3() {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 3;
inline bool DirectFileOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline bool DirectFileOutput::has_gcp() const {
  return _internal_has_gcp();
}
inline void DirectFileOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void DirectFileOutput::clear_gcp() {
  if (_internal_has_gcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.gcp_;
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* DirectFileOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& DirectFileOutput::_internal_gcp() const {
  return _internal_has_gcp()
      ? *_impl_.output_.gcp_
      : reinterpret_cast< ::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& DirectFileOutput::gcp() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* DirectFileOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* gcp) {
  clear_output();
  if (gcp) {
    set_has_gcp();
    _impl_.output_.gcp_ = gcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.gcp)
}
inline ::livekit::GCPUpload* DirectFileOutput::_internal_mutable_gcp() {
  if (!_internal_has_gcp()) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = CreateMaybeMessage< ::livekit::GCPUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.gcp_;
}
inline ::livekit::GCPUpload* DirectFileOutput::mutable_gcp() {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 4;
inline bool DirectFileOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline bool DirectFileOutput::has_azure() const {
  return _internal_has_azure();
}
inline void DirectFileOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void DirectFileOutput::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.azure_;
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* DirectFileOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& DirectFileOutput::_internal_azure() const {
  return _internal_has_azure()
      ? *_impl_.output_.azure_
      : reinterpret_cast< ::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& DirectFileOutput::azure() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* DirectFileOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* azure) {
  clear_output();
  if (azure) {
    set_has_azure();
    _impl_.output_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.azure)
}
inline ::livekit::AzureBlobUpload* DirectFileOutput::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = CreateMaybeMessage< ::livekit::AzureBlobUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.azure_;
}
inline ::livekit::AzureBlobUpload* DirectFileOutput::mutable_azure() {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 6;
inline bool DirectFileOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool DirectFileOutput::has_alioss() const {
  return _internal_has_alioss();
}
inline void DirectFileOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void DirectFileOutput::clear_alioss() {
  if (_internal_has_alioss()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.alioss_;
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* DirectFileOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.DirectFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& DirectFileOutput::_internal_alioss() const {
  return _internal_has_alioss()
      ? *_impl_.output_.alioss_
      : reinterpret_cast< ::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& DirectFileOutput::alioss() const {
  // @@protoc_insertion_point(field_get:livekit.DirectFileOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* DirectFileOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DirectFileOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DirectFileOutput::unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* alioss) {
  clear_output();
  if (alioss) {
    set_has_alioss();
    _impl_.output_.alioss_ = alioss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DirectFileOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* DirectFileOutput::_internal_mutable_alioss() {
  if (!_internal_has_alioss()) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = CreateMaybeMessage< ::livekit::AliOSSUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.alioss_;
}
inline ::livekit::AliOSSUpload* DirectFileOutput::mutable_alioss() {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.DirectFileOutput.aliOSS)
  return _msg;
}

inline bool DirectFileOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void DirectFileOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline DirectFileOutput::OutputCase DirectFileOutput::output_case() const {
  return DirectFileOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ImageOutput

// uint32 capture_interval = 1;
inline void ImageOutput::clear_capture_interval() {
  _impl_.capture_interval_ = 0u;
}
inline uint32_t ImageOutput::_internal_capture_interval() const {
  return _impl_.capture_interval_;
}
inline uint32_t ImageOutput::capture_interval() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.capture_interval)
  return _internal_capture_interval();
}
inline void ImageOutput::_internal_set_capture_interval(uint32_t value) {
  
  _impl_.capture_interval_ = value;
}
inline void ImageOutput::set_capture_interval(uint32_t value) {
  _internal_set_capture_interval(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.capture_interval)
}

// int32 width = 2;
inline void ImageOutput::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t ImageOutput::_internal_width() const {
  return _impl_.width_;
}
inline int32_t ImageOutput::width() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.width)
  return _internal_width();
}
inline void ImageOutput::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void ImageOutput::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.width)
}

// int32 height = 3;
inline void ImageOutput::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t ImageOutput::_internal_height() const {
  return _impl_.height_;
}
inline int32_t ImageOutput::height() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.height)
  return _internal_height();
}
inline void ImageOutput::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void ImageOutput::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.height)
}

// string filename_prefix = 4;
inline void ImageOutput::clear_filename_prefix() {
  _impl_.filename_prefix_.ClearToEmpty();
}
inline const std::string& ImageOutput::filename_prefix() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.filename_prefix)
  return _internal_filename_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageOutput::set_filename_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.filename_prefix)
}
inline std::string* ImageOutput::mutable_filename_prefix() {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.filename_prefix)
  return _s;
}
inline const std::string& ImageOutput::_internal_filename_prefix() const {
  return _impl_.filename_prefix_.Get();
}
inline void ImageOutput::_internal_set_filename_prefix(const std::string& value) {
  
  _impl_.filename_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageOutput::_internal_mutable_filename_prefix() {
  
  return _impl_.filename_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageOutput::release_filename_prefix() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.filename_prefix)
  return _impl_.filename_prefix_.Release();
}
inline void ImageOutput::set_allocated_filename_prefix(std::string* filename_prefix) {
  if (filename_prefix != nullptr) {
    
  } else {
    
  }
  _impl_.filename_prefix_.SetAllocated(filename_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ImageOutput.filename_prefix)
}

// .livekit.ImageFileSuffix filename_suffix = 5;
inline void ImageOutput::clear_filename_suffix() {
  _impl_.filename_suffix_ = 0;
}
inline ::livekit::ImageFileSuffix ImageOutput::_internal_filename_suffix() const {
  return static_cast< ::livekit::ImageFileSuffix >(_impl_.filename_suffix_);
}
inline ::livekit::ImageFileSuffix ImageOutput::filename_suffix() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.filename_suffix)
  return _internal_filename_suffix();
}
inline void ImageOutput::_internal_set_filename_suffix(::livekit::ImageFileSuffix value) {
  
  _impl_.filename_suffix_ = value;
}
inline void ImageOutput::set_filename_suffix(::livekit::ImageFileSuffix value) {
  _internal_set_filename_suffix(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.filename_suffix)
}

// .livekit.ImageCodec image_codec = 6;
inline void ImageOutput::clear_image_codec() {
  _impl_.image_codec_ = 0;
}
inline ::livekit::ImageCodec ImageOutput::_internal_image_codec() const {
  return static_cast< ::livekit::ImageCodec >(_impl_.image_codec_);
}
inline ::livekit::ImageCodec ImageOutput::image_codec() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.image_codec)
  return _internal_image_codec();
}
inline void ImageOutput::_internal_set_image_codec(::livekit::ImageCodec value) {
  
  _impl_.image_codec_ = value;
}
inline void ImageOutput::set_image_codec(::livekit::ImageCodec value) {
  _internal_set_image_codec(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.image_codec)
}

// bool disable_manifest = 7;
inline void ImageOutput::clear_disable_manifest() {
  _impl_.disable_manifest_ = false;
}
inline bool ImageOutput::_internal_disable_manifest() const {
  return _impl_.disable_manifest_;
}
inline bool ImageOutput::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.disable_manifest)
  return _internal_disable_manifest();
}
inline void ImageOutput::_internal_set_disable_manifest(bool value) {
  
  _impl_.disable_manifest_ = value;
}
inline void ImageOutput::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  // @@protoc_insertion_point(field_set:livekit.ImageOutput.disable_manifest)
}

// .livekit.S3Upload s3 = 8;
inline bool ImageOutput::_internal_has_s3() const {
  return output_case() == kS3;
}
inline bool ImageOutput::has_s3() const {
  return _internal_has_s3();
}
inline void ImageOutput::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void ImageOutput::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.s3_;
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* ImageOutput::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& ImageOutput::_internal_s3() const {
  return _internal_has_s3()
      ? *_impl_.output_.s3_
      : reinterpret_cast< ::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& ImageOutput::s3() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* ImageOutput::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_s3(::livekit::S3Upload* s3) {
  clear_output();
  if (s3) {
    set_has_s3();
    _impl_.output_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.s3)
}
inline ::livekit::S3Upload* ImageOutput::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = CreateMaybeMessage< ::livekit::S3Upload >(GetArenaForAllocation());
  }
  return _impl_.output_.s3_;
}
inline ::livekit::S3Upload* ImageOutput::mutable_s3() {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 9;
inline bool ImageOutput::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline bool ImageOutput::has_gcp() const {
  return _internal_has_gcp();
}
inline void ImageOutput::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void ImageOutput::clear_gcp() {
  if (_internal_has_gcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.gcp_;
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* ImageOutput::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& ImageOutput::_internal_gcp() const {
  return _internal_has_gcp()
      ? *_impl_.output_.gcp_
      : reinterpret_cast< ::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& ImageOutput::gcp() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* ImageOutput::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* gcp) {
  clear_output();
  if (gcp) {
    set_has_gcp();
    _impl_.output_.gcp_ = gcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.gcp)
}
inline ::livekit::GCPUpload* ImageOutput::_internal_mutable_gcp() {
  if (!_internal_has_gcp()) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = CreateMaybeMessage< ::livekit::GCPUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.gcp_;
}
inline ::livekit::GCPUpload* ImageOutput::mutable_gcp() {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 10;
inline bool ImageOutput::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline bool ImageOutput::has_azure() const {
  return _internal_has_azure();
}
inline void ImageOutput::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void ImageOutput::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.azure_;
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* ImageOutput::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& ImageOutput::_internal_azure() const {
  return _internal_has_azure()
      ? *_impl_.output_.azure_
      : reinterpret_cast< ::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& ImageOutput::azure() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* ImageOutput::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* azure) {
  clear_output();
  if (azure) {
    set_has_azure();
    _impl_.output_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.azure)
}
inline ::livekit::AzureBlobUpload* ImageOutput::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = CreateMaybeMessage< ::livekit::AzureBlobUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.azure_;
}
inline ::livekit::AzureBlobUpload* ImageOutput::mutable_azure() {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 11;
inline bool ImageOutput::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool ImageOutput::has_alioss() const {
  return _internal_has_alioss();
}
inline void ImageOutput::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void ImageOutput::clear_alioss() {
  if (_internal_has_alioss()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.alioss_;
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* ImageOutput::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.ImageOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& ImageOutput::_internal_alioss() const {
  return _internal_has_alioss()
      ? *_impl_.output_.alioss_
      : reinterpret_cast< ::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& ImageOutput::alioss() const {
  // @@protoc_insertion_point(field_get:livekit.ImageOutput.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* ImageOutput::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ImageOutput.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageOutput::unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* alioss) {
  clear_output();
  if (alioss) {
    set_has_alioss();
    _impl_.output_.alioss_ = alioss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ImageOutput.aliOSS)
}
inline ::livekit::AliOSSUpload* ImageOutput::_internal_mutable_alioss() {
  if (!_internal_has_alioss()) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = CreateMaybeMessage< ::livekit::AliOSSUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.alioss_;
}
inline ::livekit::AliOSSUpload* ImageOutput::mutable_alioss() {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.ImageOutput.aliOSS)
  return _msg;
}

inline bool ImageOutput::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void ImageOutput::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline ImageOutput::OutputCase ImageOutput::output_case() const {
  return ImageOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// S3Upload

// string access_key = 1;
inline void S3Upload::clear_access_key() {
  _impl_.access_key_.ClearToEmpty();
}
inline const std::string& S3Upload::access_key() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.access_key)
  return _internal_access_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_access_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.access_key)
}
inline std::string* S3Upload::mutable_access_key() {
  std::string* _s = _internal_mutable_access_key();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.access_key)
  return _s;
}
inline const std::string& S3Upload::_internal_access_key() const {
  return _impl_.access_key_.Get();
}
inline void S3Upload::_internal_set_access_key(const std::string& value) {
  
  _impl_.access_key_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_access_key() {
  
  return _impl_.access_key_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_access_key() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.access_key)
  return _impl_.access_key_.Release();
}
inline void S3Upload::set_allocated_access_key(std::string* access_key) {
  if (access_key != nullptr) {
    
  } else {
    
  }
  _impl_.access_key_.SetAllocated(access_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_key_.IsDefault()) {
    _impl_.access_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.access_key)
}

// string secret = 2;
inline void S3Upload::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& S3Upload::secret() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.secret)
}
inline std::string* S3Upload::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.secret)
  return _s;
}
inline const std::string& S3Upload::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void S3Upload::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_secret() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.secret)
  return _impl_.secret_.Release();
}
inline void S3Upload::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.secret)
}

// string session_token = 11;
inline void S3Upload::clear_session_token() {
  _impl_.session_token_.ClearToEmpty();
}
inline const std::string& S3Upload::session_token() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.session_token)
  return _internal_session_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_session_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.session_token)
}
inline std::string* S3Upload::mutable_session_token() {
  std::string* _s = _internal_mutable_session_token();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.session_token)
  return _s;
}
inline const std::string& S3Upload::_internal_session_token() const {
  return _impl_.session_token_.Get();
}
inline void S3Upload::_internal_set_session_token(const std::string& value) {
  
  _impl_.session_token_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_session_token() {
  
  return _impl_.session_token_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_session_token() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.session_token)
  return _impl_.session_token_.Release();
}
inline void S3Upload::set_allocated_session_token(std::string* session_token) {
  if (session_token != nullptr) {
    
  } else {
    
  }
  _impl_.session_token_.SetAllocated(session_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_token_.IsDefault()) {
    _impl_.session_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.session_token)
}

// string region = 3;
inline void S3Upload::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& S3Upload::region() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.region)
}
inline std::string* S3Upload::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.region)
  return _s;
}
inline const std::string& S3Upload::_internal_region() const {
  return _impl_.region_.Get();
}
inline void S3Upload::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_region() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.region)
  return _impl_.region_.Release();
}
inline void S3Upload::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.region)
}

// string endpoint = 4;
inline void S3Upload::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& S3Upload::endpoint() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.endpoint)
}
inline std::string* S3Upload::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.endpoint)
  return _s;
}
inline const std::string& S3Upload::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void S3Upload::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_endpoint() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.endpoint)
  return _impl_.endpoint_.Release();
}
inline void S3Upload::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.endpoint)
}

// string bucket = 5;
inline void S3Upload::clear_bucket() {
  _impl_.bucket_.ClearToEmpty();
}
inline const std::string& S3Upload::bucket() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.bucket)
  return _internal_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_bucket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.bucket)
}
inline std::string* S3Upload::mutable_bucket() {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.bucket)
  return _s;
}
inline const std::string& S3Upload::_internal_bucket() const {
  return _impl_.bucket_.Get();
}
inline void S3Upload::_internal_set_bucket(const std::string& value) {
  
  _impl_.bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_bucket() {
  
  return _impl_.bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_bucket() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.bucket)
  return _impl_.bucket_.Release();
}
inline void S3Upload::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  _impl_.bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.bucket)
}

// bool force_path_style = 6;
inline void S3Upload::clear_force_path_style() {
  _impl_.force_path_style_ = false;
}
inline bool S3Upload::_internal_force_path_style() const {
  return _impl_.force_path_style_;
}
inline bool S3Upload::force_path_style() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.force_path_style)
  return _internal_force_path_style();
}
inline void S3Upload::_internal_set_force_path_style(bool value) {
  
  _impl_.force_path_style_ = value;
}
inline void S3Upload::set_force_path_style(bool value) {
  _internal_set_force_path_style(value);
  // @@protoc_insertion_point(field_set:livekit.S3Upload.force_path_style)
}

// map<string, string> metadata = 7;
inline int S3Upload::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int S3Upload::metadata_size() const {
  return _internal_metadata_size();
}
inline void S3Upload::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
S3Upload::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
S3Upload::metadata() const {
  // @@protoc_insertion_point(field_map:livekit.S3Upload.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
S3Upload::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
S3Upload::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:livekit.S3Upload.metadata)
  return _internal_mutable_metadata();
}

// string tagging = 8;
inline void S3Upload::clear_tagging() {
  _impl_.tagging_.ClearToEmpty();
}
inline const std::string& S3Upload::tagging() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.tagging)
  return _internal_tagging();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_tagging(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tagging_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.tagging)
}
inline std::string* S3Upload::mutable_tagging() {
  std::string* _s = _internal_mutable_tagging();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.tagging)
  return _s;
}
inline const std::string& S3Upload::_internal_tagging() const {
  return _impl_.tagging_.Get();
}
inline void S3Upload::_internal_set_tagging(const std::string& value) {
  
  _impl_.tagging_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_tagging() {
  
  return _impl_.tagging_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_tagging() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.tagging)
  return _impl_.tagging_.Release();
}
inline void S3Upload::set_allocated_tagging(std::string* tagging) {
  if (tagging != nullptr) {
    
  } else {
    
  }
  _impl_.tagging_.SetAllocated(tagging, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tagging_.IsDefault()) {
    _impl_.tagging_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.tagging)
}

// string content_disposition = 9;
inline void S3Upload::clear_content_disposition() {
  _impl_.content_disposition_.ClearToEmpty();
}
inline const std::string& S3Upload::content_disposition() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.content_disposition)
  return _internal_content_disposition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S3Upload::set_content_disposition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_disposition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.S3Upload.content_disposition)
}
inline std::string* S3Upload::mutable_content_disposition() {
  std::string* _s = _internal_mutable_content_disposition();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.content_disposition)
  return _s;
}
inline const std::string& S3Upload::_internal_content_disposition() const {
  return _impl_.content_disposition_.Get();
}
inline void S3Upload::_internal_set_content_disposition(const std::string& value) {
  
  _impl_.content_disposition_.Set(value, GetArenaForAllocation());
}
inline std::string* S3Upload::_internal_mutable_content_disposition() {
  
  return _impl_.content_disposition_.Mutable(GetArenaForAllocation());
}
inline std::string* S3Upload::release_content_disposition() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.content_disposition)
  return _impl_.content_disposition_.Release();
}
inline void S3Upload::set_allocated_content_disposition(std::string* content_disposition) {
  if (content_disposition != nullptr) {
    
  } else {
    
  }
  _impl_.content_disposition_.SetAllocated(content_disposition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_disposition_.IsDefault()) {
    _impl_.content_disposition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.content_disposition)
}

// .livekit.ProxyConfig proxy = 10;
inline bool S3Upload::_internal_has_proxy() const {
  return this != internal_default_instance() && _impl_.proxy_ != nullptr;
}
inline bool S3Upload::has_proxy() const {
  return _internal_has_proxy();
}
inline void S3Upload::clear_proxy() {
  if (GetArenaForAllocation() == nullptr && _impl_.proxy_ != nullptr) {
    delete _impl_.proxy_;
  }
  _impl_.proxy_ = nullptr;
}
inline const ::livekit::ProxyConfig& S3Upload::_internal_proxy() const {
  const ::livekit::ProxyConfig* p = _impl_.proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ProxyConfig&>(
      ::livekit::_ProxyConfig_default_instance_);
}
inline const ::livekit::ProxyConfig& S3Upload::proxy() const {
  // @@protoc_insertion_point(field_get:livekit.S3Upload.proxy)
  return _internal_proxy();
}
inline void S3Upload::unsafe_arena_set_allocated_proxy(
    ::livekit::ProxyConfig* proxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proxy_);
  }
  _impl_.proxy_ = proxy;
  if (proxy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.S3Upload.proxy)
}
inline ::livekit::ProxyConfig* S3Upload::release_proxy() {
  
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ProxyConfig* S3Upload::unsafe_arena_release_proxy() {
  // @@protoc_insertion_point(field_release:livekit.S3Upload.proxy)
  
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  return temp;
}
inline ::livekit::ProxyConfig* S3Upload::_internal_mutable_proxy() {
  
  if (_impl_.proxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ProxyConfig>(GetArenaForAllocation());
    _impl_.proxy_ = p;
  }
  return _impl_.proxy_;
}
inline ::livekit::ProxyConfig* S3Upload::mutable_proxy() {
  ::livekit::ProxyConfig* _msg = _internal_mutable_proxy();
  // @@protoc_insertion_point(field_mutable:livekit.S3Upload.proxy)
  return _msg;
}
inline void S3Upload::set_allocated_proxy(::livekit::ProxyConfig* proxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.proxy_;
  }
  if (proxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proxy);
    if (message_arena != submessage_arena) {
      proxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proxy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proxy_ = proxy;
  // @@protoc_insertion_point(field_set_allocated:livekit.S3Upload.proxy)
}

// -------------------------------------------------------------------

// GCPUpload

// string credentials = 1;
inline void GCPUpload::clear_credentials() {
  _impl_.credentials_.ClearToEmpty();
}
inline const std::string& GCPUpload::credentials() const {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.credentials)
  return _internal_credentials();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GCPUpload::set_credentials(ArgT0&& arg0, ArgT... args) {
 
 _impl_.credentials_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.GCPUpload.credentials)
}
inline std::string* GCPUpload::mutable_credentials() {
  std::string* _s = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.credentials)
  return _s;
}
inline const std::string& GCPUpload::_internal_credentials() const {
  return _impl_.credentials_.Get();
}
inline void GCPUpload::_internal_set_credentials(const std::string& value) {
  
  _impl_.credentials_.Set(value, GetArenaForAllocation());
}
inline std::string* GCPUpload::_internal_mutable_credentials() {
  
  return _impl_.credentials_.Mutable(GetArenaForAllocation());
}
inline std::string* GCPUpload::release_credentials() {
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.credentials)
  return _impl_.credentials_.Release();
}
inline void GCPUpload::set_allocated_credentials(std::string* credentials) {
  if (credentials != nullptr) {
    
  } else {
    
  }
  _impl_.credentials_.SetAllocated(credentials, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credentials_.IsDefault()) {
    _impl_.credentials_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.credentials)
}

// string bucket = 2;
inline void GCPUpload::clear_bucket() {
  _impl_.bucket_.ClearToEmpty();
}
inline const std::string& GCPUpload::bucket() const {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.bucket)
  return _internal_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GCPUpload::set_bucket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.GCPUpload.bucket)
}
inline std::string* GCPUpload::mutable_bucket() {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.bucket)
  return _s;
}
inline const std::string& GCPUpload::_internal_bucket() const {
  return _impl_.bucket_.Get();
}
inline void GCPUpload::_internal_set_bucket(const std::string& value) {
  
  _impl_.bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* GCPUpload::_internal_mutable_bucket() {
  
  return _impl_.bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* GCPUpload::release_bucket() {
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.bucket)
  return _impl_.bucket_.Release();
}
inline void GCPUpload::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  _impl_.bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.bucket)
}

// .livekit.ProxyConfig proxy = 3;
inline bool GCPUpload::_internal_has_proxy() const {
  return this != internal_default_instance() && _impl_.proxy_ != nullptr;
}
inline bool GCPUpload::has_proxy() const {
  return _internal_has_proxy();
}
inline void GCPUpload::clear_proxy() {
  if (GetArenaForAllocation() == nullptr && _impl_.proxy_ != nullptr) {
    delete _impl_.proxy_;
  }
  _impl_.proxy_ = nullptr;
}
inline const ::livekit::ProxyConfig& GCPUpload::_internal_proxy() const {
  const ::livekit::ProxyConfig* p = _impl_.proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ProxyConfig&>(
      ::livekit::_ProxyConfig_default_instance_);
}
inline const ::livekit::ProxyConfig& GCPUpload::proxy() const {
  // @@protoc_insertion_point(field_get:livekit.GCPUpload.proxy)
  return _internal_proxy();
}
inline void GCPUpload::unsafe_arena_set_allocated_proxy(
    ::livekit::ProxyConfig* proxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proxy_);
  }
  _impl_.proxy_ = proxy;
  if (proxy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.GCPUpload.proxy)
}
inline ::livekit::ProxyConfig* GCPUpload::release_proxy() {
  
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ProxyConfig* GCPUpload::unsafe_arena_release_proxy() {
  // @@protoc_insertion_point(field_release:livekit.GCPUpload.proxy)
  
  ::livekit::ProxyConfig* temp = _impl_.proxy_;
  _impl_.proxy_ = nullptr;
  return temp;
}
inline ::livekit::ProxyConfig* GCPUpload::_internal_mutable_proxy() {
  
  if (_impl_.proxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ProxyConfig>(GetArenaForAllocation());
    _impl_.proxy_ = p;
  }
  return _impl_.proxy_;
}
inline ::livekit::ProxyConfig* GCPUpload::mutable_proxy() {
  ::livekit::ProxyConfig* _msg = _internal_mutable_proxy();
  // @@protoc_insertion_point(field_mutable:livekit.GCPUpload.proxy)
  return _msg;
}
inline void GCPUpload::set_allocated_proxy(::livekit::ProxyConfig* proxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.proxy_;
  }
  if (proxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(proxy);
    if (message_arena != submessage_arena) {
      proxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proxy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proxy_ = proxy;
  // @@protoc_insertion_point(field_set_allocated:livekit.GCPUpload.proxy)
}

// -------------------------------------------------------------------

// AzureBlobUpload

// string account_name = 1;
inline void AzureBlobUpload::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& AzureBlobUpload::account_name() const {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AzureBlobUpload::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.account_name)
}
inline std::string* AzureBlobUpload::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.account_name)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_account_name() const {
  return _impl_.account_name_.Get();
}
inline void AzureBlobUpload::_internal_set_account_name(const std::string& value) {
  
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::_internal_mutable_account_name() {
  
  return _impl_.account_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::release_account_name() {
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.account_name)
  return _impl_.account_name_.Release();
}
inline void AzureBlobUpload::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  _impl_.account_name_.SetAllocated(account_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.account_name)
}

// string account_key = 2;
inline void AzureBlobUpload::clear_account_key() {
  _impl_.account_key_.ClearToEmpty();
}
inline const std::string& AzureBlobUpload::account_key() const {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.account_key)
  return _internal_account_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AzureBlobUpload::set_account_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.account_key)
}
inline std::string* AzureBlobUpload::mutable_account_key() {
  std::string* _s = _internal_mutable_account_key();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.account_key)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_account_key() const {
  return _impl_.account_key_.Get();
}
inline void AzureBlobUpload::_internal_set_account_key(const std::string& value) {
  
  _impl_.account_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::_internal_mutable_account_key() {
  
  return _impl_.account_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::release_account_key() {
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.account_key)
  return _impl_.account_key_.Release();
}
inline void AzureBlobUpload::set_allocated_account_key(std::string* account_key) {
  if (account_key != nullptr) {
    
  } else {
    
  }
  _impl_.account_key_.SetAllocated(account_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_key_.IsDefault()) {
    _impl_.account_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.account_key)
}

// string container_name = 3;
inline void AzureBlobUpload::clear_container_name() {
  _impl_.container_name_.ClearToEmpty();
}
inline const std::string& AzureBlobUpload::container_name() const {
  // @@protoc_insertion_point(field_get:livekit.AzureBlobUpload.container_name)
  return _internal_container_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AzureBlobUpload::set_container_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.container_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AzureBlobUpload.container_name)
}
inline std::string* AzureBlobUpload::mutable_container_name() {
  std::string* _s = _internal_mutable_container_name();
  // @@protoc_insertion_point(field_mutable:livekit.AzureBlobUpload.container_name)
  return _s;
}
inline const std::string& AzureBlobUpload::_internal_container_name() const {
  return _impl_.container_name_.Get();
}
inline void AzureBlobUpload::_internal_set_container_name(const std::string& value) {
  
  _impl_.container_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::_internal_mutable_container_name() {
  
  return _impl_.container_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AzureBlobUpload::release_container_name() {
  // @@protoc_insertion_point(field_release:livekit.AzureBlobUpload.container_name)
  return _impl_.container_name_.Release();
}
inline void AzureBlobUpload::set_allocated_container_name(std::string* container_name) {
  if (container_name != nullptr) {
    
  } else {
    
  }
  _impl_.container_name_.SetAllocated(container_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.container_name_.IsDefault()) {
    _impl_.container_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AzureBlobUpload.container_name)
}

// -------------------------------------------------------------------

// AliOSSUpload

// string access_key = 1;
inline void AliOSSUpload::clear_access_key() {
  _impl_.access_key_.ClearToEmpty();
}
inline const std::string& AliOSSUpload::access_key() const {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.access_key)
  return _internal_access_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliOSSUpload::set_access_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.access_key)
}
inline std::string* AliOSSUpload::mutable_access_key() {
  std::string* _s = _internal_mutable_access_key();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.access_key)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_access_key() const {
  return _impl_.access_key_.Get();
}
inline void AliOSSUpload::_internal_set_access_key(const std::string& value) {
  
  _impl_.access_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AliOSSUpload::_internal_mutable_access_key() {
  
  return _impl_.access_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AliOSSUpload::release_access_key() {
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.access_key)
  return _impl_.access_key_.Release();
}
inline void AliOSSUpload::set_allocated_access_key(std::string* access_key) {
  if (access_key != nullptr) {
    
  } else {
    
  }
  _impl_.access_key_.SetAllocated(access_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_key_.IsDefault()) {
    _impl_.access_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.access_key)
}

// string secret = 2;
inline void AliOSSUpload::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& AliOSSUpload::secret() const {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliOSSUpload::set_secret(ArgT0&& arg0, ArgT... args) {
 
 _impl_.secret_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.secret)
}
inline std::string* AliOSSUpload::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.secret)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_secret() const {
  return _impl_.secret_.Get();
}
inline void AliOSSUpload::_internal_set_secret(const std::string& value) {
  
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* AliOSSUpload::_internal_mutable_secret() {
  
  return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* AliOSSUpload::release_secret() {
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.secret)
  return _impl_.secret_.Release();
}
inline void AliOSSUpload::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.secret)
}

// string region = 3;
inline void AliOSSUpload::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& AliOSSUpload::region() const {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliOSSUpload::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.region)
}
inline std::string* AliOSSUpload::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.region)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_region() const {
  return _impl_.region_.Get();
}
inline void AliOSSUpload::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* AliOSSUpload::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* AliOSSUpload::release_region() {
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.region)
  return _impl_.region_.Release();
}
inline void AliOSSUpload::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.region)
}

// string endpoint = 4;
inline void AliOSSUpload::clear_endpoint() {
  _impl_.endpoint_.ClearToEmpty();
}
inline const std::string& AliOSSUpload::endpoint() const {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.endpoint)
  return _internal_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliOSSUpload::set_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.endpoint)
}
inline std::string* AliOSSUpload::mutable_endpoint() {
  std::string* _s = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.endpoint)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_endpoint() const {
  return _impl_.endpoint_.Get();
}
inline void AliOSSUpload::_internal_set_endpoint(const std::string& value) {
  
  _impl_.endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* AliOSSUpload::_internal_mutable_endpoint() {
  
  return _impl_.endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* AliOSSUpload::release_endpoint() {
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.endpoint)
  return _impl_.endpoint_.Release();
}
inline void AliOSSUpload::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.endpoint_.SetAllocated(endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.endpoint_.IsDefault()) {
    _impl_.endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.endpoint)
}

// string bucket = 5;
inline void AliOSSUpload::clear_bucket() {
  _impl_.bucket_.ClearToEmpty();
}
inline const std::string& AliOSSUpload::bucket() const {
  // @@protoc_insertion_point(field_get:livekit.AliOSSUpload.bucket)
  return _internal_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliOSSUpload::set_bucket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bucket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AliOSSUpload.bucket)
}
inline std::string* AliOSSUpload::mutable_bucket() {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:livekit.AliOSSUpload.bucket)
  return _s;
}
inline const std::string& AliOSSUpload::_internal_bucket() const {
  return _impl_.bucket_.Get();
}
inline void AliOSSUpload::_internal_set_bucket(const std::string& value) {
  
  _impl_.bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* AliOSSUpload::_internal_mutable_bucket() {
  
  return _impl_.bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* AliOSSUpload::release_bucket() {
  // @@protoc_insertion_point(field_release:livekit.AliOSSUpload.bucket)
  return _impl_.bucket_.Release();
}
inline void AliOSSUpload::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    
  } else {
    
  }
  _impl_.bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AliOSSUpload.bucket)
}

// -------------------------------------------------------------------

// ProxyConfig

// string url = 1;
inline void ProxyConfig::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& ProxyConfig::url() const {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProxyConfig::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.url)
}
inline std::string* ProxyConfig::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.url)
  return _s;
}
inline const std::string& ProxyConfig::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ProxyConfig::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ProxyConfig::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ProxyConfig::release_url() {
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.url)
  return _impl_.url_.Release();
}
inline void ProxyConfig::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.url)
}

// string username = 2;
inline void ProxyConfig::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ProxyConfig::username() const {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProxyConfig::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.username)
}
inline std::string* ProxyConfig::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.username)
  return _s;
}
inline const std::string& ProxyConfig::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ProxyConfig::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ProxyConfig::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ProxyConfig::release_username() {
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.username)
  return _impl_.username_.Release();
}
inline void ProxyConfig::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.username)
}

// string password = 3;
inline void ProxyConfig::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ProxyConfig::password() const {
  // @@protoc_insertion_point(field_get:livekit.ProxyConfig.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProxyConfig::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ProxyConfig.password)
}
inline std::string* ProxyConfig::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:livekit.ProxyConfig.password)
  return _s;
}
inline const std::string& ProxyConfig::_internal_password() const {
  return _impl_.password_.Get();
}
inline void ProxyConfig::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* ProxyConfig::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* ProxyConfig::release_password() {
  // @@protoc_insertion_point(field_release:livekit.ProxyConfig.password)
  return _impl_.password_.Release();
}
inline void ProxyConfig::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ProxyConfig.password)
}

// -------------------------------------------------------------------

// StreamOutput

// .livekit.StreamProtocol protocol = 1;
inline void StreamOutput::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::livekit::StreamProtocol StreamOutput::_internal_protocol() const {
  return static_cast< ::livekit::StreamProtocol >(_impl_.protocol_);
}
inline ::livekit::StreamProtocol StreamOutput::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.StreamOutput.protocol)
  return _internal_protocol();
}
inline void StreamOutput::_internal_set_protocol(::livekit::StreamProtocol value) {
  
  _impl_.protocol_ = value;
}
inline void StreamOutput::set_protocol(::livekit::StreamProtocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.StreamOutput.protocol)
}

// repeated string urls = 2;
inline int StreamOutput::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int StreamOutput::urls_size() const {
  return _internal_urls_size();
}
inline void StreamOutput::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* StreamOutput::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.StreamOutput.urls)
  return _s;
}
inline const std::string& StreamOutput::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& StreamOutput::urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.StreamOutput.urls)
  return _internal_urls(index);
}
inline std::string* StreamOutput::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.StreamOutput.urls)
  return _impl_.urls_.Mutable(index);
}
inline void StreamOutput::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.StreamOutput.urls)
}
inline void StreamOutput::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.StreamOutput.urls)
}
inline void StreamOutput::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.StreamOutput.urls)
}
inline void StreamOutput::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.StreamOutput.urls)
}
inline std::string* StreamOutput::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void StreamOutput::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.StreamOutput.urls)
}
inline void StreamOutput::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.StreamOutput.urls)
}
inline void StreamOutput::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.StreamOutput.urls)
}
inline void StreamOutput::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.StreamOutput.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StreamOutput::urls() const {
  // @@protoc_insertion_point(field_list:livekit.StreamOutput.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StreamOutput::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamOutput.urls)
  return &_impl_.urls_;
}

// -------------------------------------------------------------------

// EncodingOptions

// int32 width = 1;
inline void EncodingOptions::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t EncodingOptions::_internal_width() const {
  return _impl_.width_;
}
inline int32_t EncodingOptions::width() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.width)
  return _internal_width();
}
inline void EncodingOptions::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void EncodingOptions::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.width)
}

// int32 height = 2;
inline void EncodingOptions::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t EncodingOptions::_internal_height() const {
  return _impl_.height_;
}
inline int32_t EncodingOptions::height() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.height)
  return _internal_height();
}
inline void EncodingOptions::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void EncodingOptions::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.height)
}

// int32 depth = 3;
inline void EncodingOptions::clear_depth() {
  _impl_.depth_ = 0;
}
inline int32_t EncodingOptions::_internal_depth() const {
  return _impl_.depth_;
}
inline int32_t EncodingOptions::depth() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.depth)
  return _internal_depth();
}
inline void EncodingOptions::_internal_set_depth(int32_t value) {
  
  _impl_.depth_ = value;
}
inline void EncodingOptions::set_depth(int32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.depth)
}

// int32 framerate = 4;
inline void EncodingOptions::clear_framerate() {
  _impl_.framerate_ = 0;
}
inline int32_t EncodingOptions::_internal_framerate() const {
  return _impl_.framerate_;
}
inline int32_t EncodingOptions::framerate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.framerate)
  return _internal_framerate();
}
inline void EncodingOptions::_internal_set_framerate(int32_t value) {
  
  _impl_.framerate_ = value;
}
inline void EncodingOptions::set_framerate(int32_t value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.framerate)
}

// .livekit.AudioCodec audio_codec = 5;
inline void EncodingOptions::clear_audio_codec() {
  _impl_.audio_codec_ = 0;
}
inline ::livekit::AudioCodec EncodingOptions::_internal_audio_codec() const {
  return static_cast< ::livekit::AudioCodec >(_impl_.audio_codec_);
}
inline ::livekit::AudioCodec EncodingOptions::audio_codec() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_codec)
  return _internal_audio_codec();
}
inline void EncodingOptions::_internal_set_audio_codec(::livekit::AudioCodec value) {
  
  _impl_.audio_codec_ = value;
}
inline void EncodingOptions::set_audio_codec(::livekit::AudioCodec value) {
  _internal_set_audio_codec(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_codec)
}

// int32 audio_bitrate = 6;
inline void EncodingOptions::clear_audio_bitrate() {
  _impl_.audio_bitrate_ = 0;
}
inline int32_t EncodingOptions::_internal_audio_bitrate() const {
  return _impl_.audio_bitrate_;
}
inline int32_t EncodingOptions::audio_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_bitrate)
  return _internal_audio_bitrate();
}
inline void EncodingOptions::_internal_set_audio_bitrate(int32_t value) {
  
  _impl_.audio_bitrate_ = value;
}
inline void EncodingOptions::set_audio_bitrate(int32_t value) {
  _internal_set_audio_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_bitrate)
}

// int32 audio_quality = 11;
inline void EncodingOptions::clear_audio_quality() {
  _impl_.audio_quality_ = 0;
}
inline int32_t EncodingOptions::_internal_audio_quality() const {
  return _impl_.audio_quality_;
}
inline int32_t EncodingOptions::audio_quality() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_quality)
  return _internal_audio_quality();
}
inline void EncodingOptions::_internal_set_audio_quality(int32_t value) {
  
  _impl_.audio_quality_ = value;
}
inline void EncodingOptions::set_audio_quality(int32_t value) {
  _internal_set_audio_quality(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_quality)
}

// int32 audio_frequency = 7;
inline void EncodingOptions::clear_audio_frequency() {
  _impl_.audio_frequency_ = 0;
}
inline int32_t EncodingOptions::_internal_audio_frequency() const {
  return _impl_.audio_frequency_;
}
inline int32_t EncodingOptions::audio_frequency() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.audio_frequency)
  return _internal_audio_frequency();
}
inline void EncodingOptions::_internal_set_audio_frequency(int32_t value) {
  
  _impl_.audio_frequency_ = value;
}
inline void EncodingOptions::set_audio_frequency(int32_t value) {
  _internal_set_audio_frequency(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.audio_frequency)
}

// .livekit.VideoCodec video_codec = 8;
inline void EncodingOptions::clear_video_codec() {
  _impl_.video_codec_ = 0;
}
inline ::livekit::VideoCodec EncodingOptions::_internal_video_codec() const {
  return static_cast< ::livekit::VideoCodec >(_impl_.video_codec_);
}
inline ::livekit::VideoCodec EncodingOptions::video_codec() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_codec)
  return _internal_video_codec();
}
inline void EncodingOptions::_internal_set_video_codec(::livekit::VideoCodec value) {
  
  _impl_.video_codec_ = value;
}
inline void EncodingOptions::set_video_codec(::livekit::VideoCodec value) {
  _internal_set_video_codec(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_codec)
}

// int32 video_bitrate = 9;
inline void EncodingOptions::clear_video_bitrate() {
  _impl_.video_bitrate_ = 0;
}
inline int32_t EncodingOptions::_internal_video_bitrate() const {
  return _impl_.video_bitrate_;
}
inline int32_t EncodingOptions::video_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_bitrate)
  return _internal_video_bitrate();
}
inline void EncodingOptions::_internal_set_video_bitrate(int32_t value) {
  
  _impl_.video_bitrate_ = value;
}
inline void EncodingOptions::set_video_bitrate(int32_t value) {
  _internal_set_video_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_bitrate)
}

// int32 video_quality = 12;
inline void EncodingOptions::clear_video_quality() {
  _impl_.video_quality_ = 0;
}
inline int32_t EncodingOptions::_internal_video_quality() const {
  return _impl_.video_quality_;
}
inline int32_t EncodingOptions::video_quality() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.video_quality)
  return _internal_video_quality();
}
inline void EncodingOptions::_internal_set_video_quality(int32_t value) {
  
  _impl_.video_quality_ = value;
}
inline void EncodingOptions::set_video_quality(int32_t value) {
  _internal_set_video_quality(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.video_quality)
}

// double key_frame_interval = 10;
inline void EncodingOptions::clear_key_frame_interval() {
  _impl_.key_frame_interval_ = 0;
}
inline double EncodingOptions::_internal_key_frame_interval() const {
  return _impl_.key_frame_interval_;
}
inline double EncodingOptions::key_frame_interval() const {
  // @@protoc_insertion_point(field_get:livekit.EncodingOptions.key_frame_interval)
  return _internal_key_frame_interval();
}
inline void EncodingOptions::_internal_set_key_frame_interval(double value) {
  
  _impl_.key_frame_interval_ = value;
}
inline void EncodingOptions::set_key_frame_interval(double value) {
  _internal_set_key_frame_interval(value);
  // @@protoc_insertion_point(field_set:livekit.EncodingOptions.key_frame_interval)
}

// -------------------------------------------------------------------

// UpdateLayoutRequest

// string egress_id = 1;
inline void UpdateLayoutRequest::clear_egress_id() {
  _impl_.egress_id_.ClearToEmpty();
}
inline const std::string& UpdateLayoutRequest::egress_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLayoutRequest.egress_id)
  return _internal_egress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLayoutRequest::set_egress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.egress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateLayoutRequest.egress_id)
}
inline std::string* UpdateLayoutRequest::mutable_egress_id() {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLayoutRequest.egress_id)
  return _s;
}
inline const std::string& UpdateLayoutRequest::_internal_egress_id() const {
  return _impl_.egress_id_.Get();
}
inline void UpdateLayoutRequest::_internal_set_egress_id(const std::string& value) {
  
  _impl_.egress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLayoutRequest::_internal_mutable_egress_id() {
  
  return _impl_.egress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLayoutRequest::release_egress_id() {
  // @@protoc_insertion_point(field_release:livekit.UpdateLayoutRequest.egress_id)
  return _impl_.egress_id_.Release();
}
inline void UpdateLayoutRequest::set_allocated_egress_id(std::string* egress_id) {
  if (egress_id != nullptr) {
    
  } else {
    
  }
  _impl_.egress_id_.SetAllocated(egress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLayoutRequest.egress_id)
}

// string layout = 2;
inline void UpdateLayoutRequest::clear_layout() {
  _impl_.layout_.ClearToEmpty();
}
inline const std::string& UpdateLayoutRequest::layout() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLayoutRequest.layout)
  return _internal_layout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLayoutRequest::set_layout(ArgT0&& arg0, ArgT... args) {
 
 _impl_.layout_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateLayoutRequest.layout)
}
inline std::string* UpdateLayoutRequest::mutable_layout() {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLayoutRequest.layout)
  return _s;
}
inline const std::string& UpdateLayoutRequest::_internal_layout() const {
  return _impl_.layout_.Get();
}
inline void UpdateLayoutRequest::_internal_set_layout(const std::string& value) {
  
  _impl_.layout_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLayoutRequest::_internal_mutable_layout() {
  
  return _impl_.layout_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLayoutRequest::release_layout() {
  // @@protoc_insertion_point(field_release:livekit.UpdateLayoutRequest.layout)
  return _impl_.layout_.Release();
}
inline void UpdateLayoutRequest::set_allocated_layout(std::string* layout) {
  if (layout != nullptr) {
    
  } else {
    
  }
  _impl_.layout_.SetAllocated(layout, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.layout_.IsDefault()) {
    _impl_.layout_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLayoutRequest.layout)
}

// -------------------------------------------------------------------

// UpdateStreamRequest

// string egress_id = 1;
inline void UpdateStreamRequest::clear_egress_id() {
  _impl_.egress_id_.ClearToEmpty();
}
inline const std::string& UpdateStreamRequest::egress_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.egress_id)
  return _internal_egress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateStreamRequest::set_egress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.egress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.egress_id)
}
inline std::string* UpdateStreamRequest::mutable_egress_id() {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.egress_id)
  return _s;
}
inline const std::string& UpdateStreamRequest::_internal_egress_id() const {
  return _impl_.egress_id_.Get();
}
inline void UpdateStreamRequest::_internal_set_egress_id(const std::string& value) {
  
  _impl_.egress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateStreamRequest::_internal_mutable_egress_id() {
  
  return _impl_.egress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateStreamRequest::release_egress_id() {
  // @@protoc_insertion_point(field_release:livekit.UpdateStreamRequest.egress_id)
  return _impl_.egress_id_.Release();
}
inline void UpdateStreamRequest::set_allocated_egress_id(std::string* egress_id) {
  if (egress_id != nullptr) {
    
  } else {
    
  }
  _impl_.egress_id_.SetAllocated(egress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateStreamRequest.egress_id)
}

// repeated string add_output_urls = 2;
inline int UpdateStreamRequest::_internal_add_output_urls_size() const {
  return _impl_.add_output_urls_.size();
}
inline int UpdateStreamRequest::add_output_urls_size() const {
  return _internal_add_output_urls_size();
}
inline void UpdateStreamRequest::clear_add_output_urls() {
  _impl_.add_output_urls_.Clear();
}
inline std::string* UpdateStreamRequest::add_add_output_urls() {
  std::string* _s = _internal_add_add_output_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateStreamRequest.add_output_urls)
  return _s;
}
inline const std::string& UpdateStreamRequest::_internal_add_output_urls(int index) const {
  return _impl_.add_output_urls_.Get(index);
}
inline const std::string& UpdateStreamRequest::add_output_urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.add_output_urls)
  return _internal_add_output_urls(index);
}
inline std::string* UpdateStreamRequest::mutable_add_output_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.add_output_urls)
  return _impl_.add_output_urls_.Mutable(index);
}
inline void UpdateStreamRequest::set_add_output_urls(int index, const std::string& value) {
  _impl_.add_output_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::set_add_output_urls(int index, std::string&& value) {
  _impl_.add_output_urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::set_add_output_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_output_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::set_add_output_urls(int index, const char* value, size_t size) {
  _impl_.add_output_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateStreamRequest.add_output_urls)
}
inline std::string* UpdateStreamRequest::_internal_add_add_output_urls() {
  return _impl_.add_output_urls_.Add();
}
inline void UpdateStreamRequest::add_add_output_urls(const std::string& value) {
  _impl_.add_output_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::add_add_output_urls(std::string&& value) {
  _impl_.add_output_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::add_add_output_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.add_output_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateStreamRequest.add_output_urls)
}
inline void UpdateStreamRequest::add_add_output_urls(const char* value, size_t size) {
  _impl_.add_output_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateStreamRequest.add_output_urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateStreamRequest::add_output_urls() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateStreamRequest.add_output_urls)
  return _impl_.add_output_urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateStreamRequest::mutable_add_output_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateStreamRequest.add_output_urls)
  return &_impl_.add_output_urls_;
}

// repeated string remove_output_urls = 3;
inline int UpdateStreamRequest::_internal_remove_output_urls_size() const {
  return _impl_.remove_output_urls_.size();
}
inline int UpdateStreamRequest::remove_output_urls_size() const {
  return _internal_remove_output_urls_size();
}
inline void UpdateStreamRequest::clear_remove_output_urls() {
  _impl_.remove_output_urls_.Clear();
}
inline std::string* UpdateStreamRequest::add_remove_output_urls() {
  std::string* _s = _internal_add_remove_output_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateStreamRequest.remove_output_urls)
  return _s;
}
inline const std::string& UpdateStreamRequest::_internal_remove_output_urls(int index) const {
  return _impl_.remove_output_urls_.Get(index);
}
inline const std::string& UpdateStreamRequest::remove_output_urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateStreamRequest.remove_output_urls)
  return _internal_remove_output_urls(index);
}
inline std::string* UpdateStreamRequest::mutable_remove_output_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateStreamRequest.remove_output_urls)
  return _impl_.remove_output_urls_.Mutable(index);
}
inline void UpdateStreamRequest::set_remove_output_urls(int index, const std::string& value) {
  _impl_.remove_output_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::set_remove_output_urls(int index, std::string&& value) {
  _impl_.remove_output_urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::set_remove_output_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remove_output_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::set_remove_output_urls(int index, const char* value, size_t size) {
  _impl_.remove_output_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateStreamRequest.remove_output_urls)
}
inline std::string* UpdateStreamRequest::_internal_add_remove_output_urls() {
  return _impl_.remove_output_urls_.Add();
}
inline void UpdateStreamRequest::add_remove_output_urls(const std::string& value) {
  _impl_.remove_output_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::add_remove_output_urls(std::string&& value) {
  _impl_.remove_output_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::add_remove_output_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.remove_output_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateStreamRequest.remove_output_urls)
}
inline void UpdateStreamRequest::add_remove_output_urls(const char* value, size_t size) {
  _impl_.remove_output_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateStreamRequest.remove_output_urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateStreamRequest::remove_output_urls() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateStreamRequest.remove_output_urls)
  return _impl_.remove_output_urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateStreamRequest::mutable_remove_output_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateStreamRequest.remove_output_urls)
  return &_impl_.remove_output_urls_;
}

// -------------------------------------------------------------------

// ListEgressRequest

// string room_name = 1;
inline void ListEgressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& ListEgressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListEgressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.room_name)
}
inline std::string* ListEgressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressRequest.room_name)
  return _s;
}
inline const std::string& ListEgressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void ListEgressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListEgressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListEgressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.ListEgressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void ListEgressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ListEgressRequest.room_name)
}

// string egress_id = 2;
inline void ListEgressRequest::clear_egress_id() {
  _impl_.egress_id_.ClearToEmpty();
}
inline const std::string& ListEgressRequest::egress_id() const {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.egress_id)
  return _internal_egress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListEgressRequest::set_egress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.egress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.egress_id)
}
inline std::string* ListEgressRequest::mutable_egress_id() {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressRequest.egress_id)
  return _s;
}
inline const std::string& ListEgressRequest::_internal_egress_id() const {
  return _impl_.egress_id_.Get();
}
inline void ListEgressRequest::_internal_set_egress_id(const std::string& value) {
  
  _impl_.egress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListEgressRequest::_internal_mutable_egress_id() {
  
  return _impl_.egress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListEgressRequest::release_egress_id() {
  // @@protoc_insertion_point(field_release:livekit.ListEgressRequest.egress_id)
  return _impl_.egress_id_.Release();
}
inline void ListEgressRequest::set_allocated_egress_id(std::string* egress_id) {
  if (egress_id != nullptr) {
    
  } else {
    
  }
  _impl_.egress_id_.SetAllocated(egress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ListEgressRequest.egress_id)
}

// bool active = 3;
inline void ListEgressRequest::clear_active() {
  _impl_.active_ = false;
}
inline bool ListEgressRequest::_internal_active() const {
  return _impl_.active_;
}
inline bool ListEgressRequest::active() const {
  // @@protoc_insertion_point(field_get:livekit.ListEgressRequest.active)
  return _internal_active();
}
inline void ListEgressRequest::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void ListEgressRequest::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:livekit.ListEgressRequest.active)
}

// -------------------------------------------------------------------

// ListEgressResponse

// repeated .livekit.EgressInfo items = 1;
inline int ListEgressResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ListEgressResponse::items_size() const {
  return _internal_items_size();
}
inline void ListEgressResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::livekit::EgressInfo* ListEgressResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ListEgressResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EgressInfo >*
ListEgressResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListEgressResponse.items)
  return &_impl_.items_;
}
inline const ::livekit::EgressInfo& ListEgressResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::livekit::EgressInfo& ListEgressResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ListEgressResponse.items)
  return _internal_items(index);
}
inline ::livekit::EgressInfo* ListEgressResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::livekit::EgressInfo* ListEgressResponse::add_items() {
  ::livekit::EgressInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:livekit.ListEgressResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EgressInfo >&
ListEgressResponse::items() const {
  // @@protoc_insertion_point(field_list:livekit.ListEgressResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// StopEgressRequest

// string egress_id = 1;
inline void StopEgressRequest::clear_egress_id() {
  _impl_.egress_id_.ClearToEmpty();
}
inline const std::string& StopEgressRequest::egress_id() const {
  // @@protoc_insertion_point(field_get:livekit.StopEgressRequest.egress_id)
  return _internal_egress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopEgressRequest::set_egress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.egress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StopEgressRequest.egress_id)
}
inline std::string* StopEgressRequest::mutable_egress_id() {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.StopEgressRequest.egress_id)
  return _s;
}
inline const std::string& StopEgressRequest::_internal_egress_id() const {
  return _impl_.egress_id_.Get();
}
inline void StopEgressRequest::_internal_set_egress_id(const std::string& value) {
  
  _impl_.egress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopEgressRequest::_internal_mutable_egress_id() {
  
  return _impl_.egress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopEgressRequest::release_egress_id() {
  // @@protoc_insertion_point(field_release:livekit.StopEgressRequest.egress_id)
  return _impl_.egress_id_.Release();
}
inline void StopEgressRequest::set_allocated_egress_id(std::string* egress_id) {
  if (egress_id != nullptr) {
    
  } else {
    
  }
  _impl_.egress_id_.SetAllocated(egress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StopEgressRequest.egress_id)
}

// -------------------------------------------------------------------

// EgressInfo

// string egress_id = 1;
inline void EgressInfo::clear_egress_id() {
  _impl_.egress_id_.ClearToEmpty();
}
inline const std::string& EgressInfo::egress_id() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.egress_id)
  return _internal_egress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_egress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.egress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.egress_id)
}
inline std::string* EgressInfo::mutable_egress_id() {
  std::string* _s = _internal_mutable_egress_id();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.egress_id)
  return _s;
}
inline const std::string& EgressInfo::_internal_egress_id() const {
  return _impl_.egress_id_.Get();
}
inline void EgressInfo::_internal_set_egress_id(const std::string& value) {
  
  _impl_.egress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_egress_id() {
  
  return _impl_.egress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_egress_id() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.egress_id)
  return _impl_.egress_id_.Release();
}
inline void EgressInfo::set_allocated_egress_id(std::string* egress_id) {
  if (egress_id != nullptr) {
    
  } else {
    
  }
  _impl_.egress_id_.SetAllocated(egress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.egress_id_.IsDefault()) {
    _impl_.egress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.egress_id)
}

// string room_id = 2;
inline void EgressInfo::clear_room_id() {
  _impl_.room_id_.ClearToEmpty();
}
inline const std::string& EgressInfo::room_id() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_id)
  return _internal_room_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_room_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.room_id)
}
inline std::string* EgressInfo::mutable_room_id() {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_id)
  return _s;
}
inline const std::string& EgressInfo::_internal_room_id() const {
  return _impl_.room_id_.Get();
}
inline void EgressInfo::_internal_set_room_id(const std::string& value) {
  
  _impl_.room_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_room_id() {
  
  return _impl_.room_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_room_id() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_id)
  return _impl_.room_id_.Release();
}
inline void EgressInfo::set_allocated_room_id(std::string* room_id) {
  if (room_id != nullptr) {
    
  } else {
    
  }
  _impl_.room_id_.SetAllocated(room_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.room_id)
}

// string room_name = 13;
inline void EgressInfo::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& EgressInfo::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.room_name)
}
inline std::string* EgressInfo::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_name)
  return _s;
}
inline const std::string& EgressInfo::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void EgressInfo::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_name)
  return _impl_.room_name_.Release();
}
inline void EgressInfo::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.room_name)
}

// .livekit.EgressSourceType source_type = 26;
inline void EgressInfo::clear_source_type() {
  _impl_.source_type_ = 0;
}
inline ::livekit::EgressSourceType EgressInfo::_internal_source_type() const {
  return static_cast< ::livekit::EgressSourceType >(_impl_.source_type_);
}
inline ::livekit::EgressSourceType EgressInfo::source_type() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.source_type)
  return _internal_source_type();
}
inline void EgressInfo::_internal_set_source_type(::livekit::EgressSourceType value) {
  
  _impl_.source_type_ = value;
}
inline void EgressInfo::set_source_type(::livekit::EgressSourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.source_type)
}

// .livekit.EgressStatus status = 3;
inline void EgressInfo::clear_status() {
  _impl_.status_ = 0;
}
inline ::livekit::EgressStatus EgressInfo::_internal_status() const {
  return static_cast< ::livekit::EgressStatus >(_impl_.status_);
}
inline ::livekit::EgressStatus EgressInfo::status() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.status)
  return _internal_status();
}
inline void EgressInfo::_internal_set_status(::livekit::EgressStatus value) {
  
  _impl_.status_ = value;
}
inline void EgressInfo::set_status(::livekit::EgressStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.status)
}

// int64 started_at = 10;
inline void EgressInfo::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t EgressInfo::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t EgressInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.started_at)
  return _internal_started_at();
}
inline void EgressInfo::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void EgressInfo::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.started_at)
}

// int64 ended_at = 11;
inline void EgressInfo::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t EgressInfo::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t EgressInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.ended_at)
  return _internal_ended_at();
}
inline void EgressInfo::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void EgressInfo::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.ended_at)
}

// int64 updated_at = 18;
inline void EgressInfo::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t EgressInfo::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t EgressInfo::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.updated_at)
  return _internal_updated_at();
}
inline void EgressInfo::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void EgressInfo::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.updated_at)
}

// string details = 21;
inline void EgressInfo::clear_details() {
  _impl_.details_.ClearToEmpty();
}
inline const std::string& EgressInfo::details() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_details(ArgT0&& arg0, ArgT... args) {
 
 _impl_.details_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.details)
}
inline std::string* EgressInfo::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.details)
  return _s;
}
inline const std::string& EgressInfo::_internal_details() const {
  return _impl_.details_.Get();
}
inline void EgressInfo::_internal_set_details(const std::string& value) {
  
  _impl_.details_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_details() {
  
  return _impl_.details_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_details() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.details)
  return _impl_.details_.Release();
}
inline void EgressInfo::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  _impl_.details_.SetAllocated(details, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.details_.IsDefault()) {
    _impl_.details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.details)
}

// string error = 9;
inline void EgressInfo::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& EgressInfo::error() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.error)
}
inline std::string* EgressInfo::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.error)
  return _s;
}
inline const std::string& EgressInfo::_internal_error() const {
  return _impl_.error_.Get();
}
inline void EgressInfo::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_error() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.error)
  return _impl_.error_.Release();
}
inline void EgressInfo::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.error)
}

// int32 error_code = 22;
inline void EgressInfo::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t EgressInfo::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t EgressInfo::error_code() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.error_code)
  return _internal_error_code();
}
inline void EgressInfo::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void EgressInfo::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.error_code)
}

// .livekit.RoomCompositeEgressRequest room_composite = 4;
inline bool EgressInfo::_internal_has_room_composite() const {
  return request_case() == kRoomComposite;
}
inline bool EgressInfo::has_room_composite() const {
  return _internal_has_room_composite();
}
inline void EgressInfo::set_has_room_composite() {
  _impl_._oneof_case_[0] = kRoomComposite;
}
inline void EgressInfo::clear_room_composite() {
  if (_internal_has_room_composite()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.room_composite_;
    }
    clear_has_request();
  }
}
inline ::livekit::RoomCompositeEgressRequest* EgressInfo::release_room_composite() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.room_composite)
  if (_internal_has_room_composite()) {
    clear_has_request();
    ::livekit::RoomCompositeEgressRequest* temp = _impl_.request_.room_composite_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.room_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RoomCompositeEgressRequest& EgressInfo::_internal_room_composite() const {
  return _internal_has_room_composite()
      ? *_impl_.request_.room_composite_
      : reinterpret_cast< ::livekit::RoomCompositeEgressRequest&>(::livekit::_RoomCompositeEgressRequest_default_instance_);
}
inline const ::livekit::RoomCompositeEgressRequest& EgressInfo::room_composite() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.room_composite)
  return _internal_room_composite();
}
inline ::livekit::RoomCompositeEgressRequest* EgressInfo::unsafe_arena_release_room_composite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.room_composite)
  if (_internal_has_room_composite()) {
    clear_has_request();
    ::livekit::RoomCompositeEgressRequest* temp = _impl_.request_.room_composite_;
    _impl_.request_.room_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_room_composite(::livekit::RoomCompositeEgressRequest* room_composite) {
  clear_request();
  if (room_composite) {
    set_has_room_composite();
    _impl_.request_.room_composite_ = room_composite;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.room_composite)
}
inline ::livekit::RoomCompositeEgressRequest* EgressInfo::_internal_mutable_room_composite() {
  if (!_internal_has_room_composite()) {
    clear_request();
    set_has_room_composite();
    _impl_.request_.room_composite_ = CreateMaybeMessage< ::livekit::RoomCompositeEgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.room_composite_;
}
inline ::livekit::RoomCompositeEgressRequest* EgressInfo::mutable_room_composite() {
  ::livekit::RoomCompositeEgressRequest* _msg = _internal_mutable_room_composite();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.room_composite)
  return _msg;
}

// .livekit.WebEgressRequest web = 14;
inline bool EgressInfo::_internal_has_web() const {
  return request_case() == kWeb;
}
inline bool EgressInfo::has_web() const {
  return _internal_has_web();
}
inline void EgressInfo::set_has_web() {
  _impl_._oneof_case_[0] = kWeb;
}
inline void EgressInfo::clear_web() {
  if (_internal_has_web()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.web_;
    }
    clear_has_request();
  }
}
inline ::livekit::WebEgressRequest* EgressInfo::release_web() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.web)
  if (_internal_has_web()) {
    clear_has_request();
    ::livekit::WebEgressRequest* temp = _impl_.request_.web_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.web_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WebEgressRequest& EgressInfo::_internal_web() const {
  return _internal_has_web()
      ? *_impl_.request_.web_
      : reinterpret_cast< ::livekit::WebEgressRequest&>(::livekit::_WebEgressRequest_default_instance_);
}
inline const ::livekit::WebEgressRequest& EgressInfo::web() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.web)
  return _internal_web();
}
inline ::livekit::WebEgressRequest* EgressInfo::unsafe_arena_release_web() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.web)
  if (_internal_has_web()) {
    clear_has_request();
    ::livekit::WebEgressRequest* temp = _impl_.request_.web_;
    _impl_.request_.web_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_web(::livekit::WebEgressRequest* web) {
  clear_request();
  if (web) {
    set_has_web();
    _impl_.request_.web_ = web;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.web)
}
inline ::livekit::WebEgressRequest* EgressInfo::_internal_mutable_web() {
  if (!_internal_has_web()) {
    clear_request();
    set_has_web();
    _impl_.request_.web_ = CreateMaybeMessage< ::livekit::WebEgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.web_;
}
inline ::livekit::WebEgressRequest* EgressInfo::mutable_web() {
  ::livekit::WebEgressRequest* _msg = _internal_mutable_web();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.web)
  return _msg;
}

// .livekit.ParticipantEgressRequest participant = 19;
inline bool EgressInfo::_internal_has_participant() const {
  return request_case() == kParticipant;
}
inline bool EgressInfo::has_participant() const {
  return _internal_has_participant();
}
inline void EgressInfo::set_has_participant() {
  _impl_._oneof_case_[0] = kParticipant;
}
inline void EgressInfo::clear_participant() {
  if (_internal_has_participant()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.participant_;
    }
    clear_has_request();
  }
}
inline ::livekit::ParticipantEgressRequest* EgressInfo::release_participant() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.participant)
  if (_internal_has_participant()) {
    clear_has_request();
    ::livekit::ParticipantEgressRequest* temp = _impl_.request_.participant_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.participant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ParticipantEgressRequest& EgressInfo::_internal_participant() const {
  return _internal_has_participant()
      ? *_impl_.request_.participant_
      : reinterpret_cast< ::livekit::ParticipantEgressRequest&>(::livekit::_ParticipantEgressRequest_default_instance_);
}
inline const ::livekit::ParticipantEgressRequest& EgressInfo::participant() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.participant)
  return _internal_participant();
}
inline ::livekit::ParticipantEgressRequest* EgressInfo::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.participant)
  if (_internal_has_participant()) {
    clear_has_request();
    ::livekit::ParticipantEgressRequest* temp = _impl_.request_.participant_;
    _impl_.request_.participant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_participant(::livekit::ParticipantEgressRequest* participant) {
  clear_request();
  if (participant) {
    set_has_participant();
    _impl_.request_.participant_ = participant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.participant)
}
inline ::livekit::ParticipantEgressRequest* EgressInfo::_internal_mutable_participant() {
  if (!_internal_has_participant()) {
    clear_request();
    set_has_participant();
    _impl_.request_.participant_ = CreateMaybeMessage< ::livekit::ParticipantEgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.participant_;
}
inline ::livekit::ParticipantEgressRequest* EgressInfo::mutable_participant() {
  ::livekit::ParticipantEgressRequest* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.participant)
  return _msg;
}

// .livekit.TrackCompositeEgressRequest track_composite = 5;
inline bool EgressInfo::_internal_has_track_composite() const {
  return request_case() == kTrackComposite;
}
inline bool EgressInfo::has_track_composite() const {
  return _internal_has_track_composite();
}
inline void EgressInfo::set_has_track_composite() {
  _impl_._oneof_case_[0] = kTrackComposite;
}
inline void EgressInfo::clear_track_composite() {
  if (_internal_has_track_composite()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.track_composite_;
    }
    clear_has_request();
  }
}
inline ::livekit::TrackCompositeEgressRequest* EgressInfo::release_track_composite() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.track_composite)
  if (_internal_has_track_composite()) {
    clear_has_request();
    ::livekit::TrackCompositeEgressRequest* temp = _impl_.request_.track_composite_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.track_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackCompositeEgressRequest& EgressInfo::_internal_track_composite() const {
  return _internal_has_track_composite()
      ? *_impl_.request_.track_composite_
      : reinterpret_cast< ::livekit::TrackCompositeEgressRequest&>(::livekit::_TrackCompositeEgressRequest_default_instance_);
}
inline const ::livekit::TrackCompositeEgressRequest& EgressInfo::track_composite() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.track_composite)
  return _internal_track_composite();
}
inline ::livekit::TrackCompositeEgressRequest* EgressInfo::unsafe_arena_release_track_composite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.track_composite)
  if (_internal_has_track_composite()) {
    clear_has_request();
    ::livekit::TrackCompositeEgressRequest* temp = _impl_.request_.track_composite_;
    _impl_.request_.track_composite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_track_composite(::livekit::TrackCompositeEgressRequest* track_composite) {
  clear_request();
  if (track_composite) {
    set_has_track_composite();
    _impl_.request_.track_composite_ = track_composite;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.track_composite)
}
inline ::livekit::TrackCompositeEgressRequest* EgressInfo::_internal_mutable_track_composite() {
  if (!_internal_has_track_composite()) {
    clear_request();
    set_has_track_composite();
    _impl_.request_.track_composite_ = CreateMaybeMessage< ::livekit::TrackCompositeEgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.track_composite_;
}
inline ::livekit::TrackCompositeEgressRequest* EgressInfo::mutable_track_composite() {
  ::livekit::TrackCompositeEgressRequest* _msg = _internal_mutable_track_composite();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.track_composite)
  return _msg;
}

// .livekit.TrackEgressRequest track = 6;
inline bool EgressInfo::_internal_has_track() const {
  return request_case() == kTrack;
}
inline bool EgressInfo::has_track() const {
  return _internal_has_track();
}
inline void EgressInfo::set_has_track() {
  _impl_._oneof_case_[0] = kTrack;
}
inline void EgressInfo::clear_track() {
  if (_internal_has_track()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.track_;
    }
    clear_has_request();
  }
}
inline ::livekit::TrackEgressRequest* EgressInfo::release_track() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.track)
  if (_internal_has_track()) {
    clear_has_request();
    ::livekit::TrackEgressRequest* temp = _impl_.request_.track_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackEgressRequest& EgressInfo::_internal_track() const {
  return _internal_has_track()
      ? *_impl_.request_.track_
      : reinterpret_cast< ::livekit::TrackEgressRequest&>(::livekit::_TrackEgressRequest_default_instance_);
}
inline const ::livekit::TrackEgressRequest& EgressInfo::track() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.track)
  return _internal_track();
}
inline ::livekit::TrackEgressRequest* EgressInfo::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.track)
  if (_internal_has_track()) {
    clear_has_request();
    ::livekit::TrackEgressRequest* temp = _impl_.request_.track_;
    _impl_.request_.track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_track(::livekit::TrackEgressRequest* track) {
  clear_request();
  if (track) {
    set_has_track();
    _impl_.request_.track_ = track;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.track)
}
inline ::livekit::TrackEgressRequest* EgressInfo::_internal_mutable_track() {
  if (!_internal_has_track()) {
    clear_request();
    set_has_track();
    _impl_.request_.track_ = CreateMaybeMessage< ::livekit::TrackEgressRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.track_;
}
inline ::livekit::TrackEgressRequest* EgressInfo::mutable_track() {
  ::livekit::TrackEgressRequest* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.track)
  return _msg;
}

// .livekit.StreamInfoList stream = 7 [deprecated = true];
inline bool EgressInfo::_internal_has_stream() const {
  return result_case() == kStream;
}
inline bool EgressInfo::has_stream() const {
  return _internal_has_stream();
}
inline void EgressInfo::set_has_stream() {
  _impl_._oneof_case_[1] = kStream;
}
inline void EgressInfo::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.stream_;
    }
    clear_has_result();
  }
}
inline ::livekit::StreamInfoList* EgressInfo::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.stream)
  if (_internal_has_stream()) {
    clear_has_result();
    ::livekit::StreamInfoList* temp = _impl_.result_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamInfoList& EgressInfo::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.result_.stream_
      : reinterpret_cast< ::livekit::StreamInfoList&>(::livekit::_StreamInfoList_default_instance_);
}
inline const ::livekit::StreamInfoList& EgressInfo::stream() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.stream)
  return _internal_stream();
}
inline ::livekit::StreamInfoList* EgressInfo::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.stream)
  if (_internal_has_stream()) {
    clear_has_result();
    ::livekit::StreamInfoList* temp = _impl_.result_.stream_;
    _impl_.result_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_stream(::livekit::StreamInfoList* stream) {
  clear_result();
  if (stream) {
    set_has_stream();
    _impl_.result_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.stream)
}
inline ::livekit::StreamInfoList* EgressInfo::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_result();
    set_has_stream();
    _impl_.result_.stream_ = CreateMaybeMessage< ::livekit::StreamInfoList >(GetArenaForAllocation());
  }
  return _impl_.result_.stream_;
}
inline ::livekit::StreamInfoList* EgressInfo::mutable_stream() {
  ::livekit::StreamInfoList* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.stream)
  return _msg;
}

// .livekit.FileInfo file = 8 [deprecated = true];
inline bool EgressInfo::_internal_has_file() const {
  return result_case() == kFile;
}
inline bool EgressInfo::has_file() const {
  return _internal_has_file();
}
inline void EgressInfo::set_has_file() {
  _impl_._oneof_case_[1] = kFile;
}
inline void EgressInfo::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.file_;
    }
    clear_has_result();
  }
}
inline ::livekit::FileInfo* EgressInfo::release_file() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.file)
  if (_internal_has_file()) {
    clear_has_result();
    ::livekit::FileInfo* temp = _impl_.result_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::FileInfo& EgressInfo::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.result_.file_
      : reinterpret_cast< ::livekit::FileInfo&>(::livekit::_FileInfo_default_instance_);
}
inline const ::livekit::FileInfo& EgressInfo::file() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.file)
  return _internal_file();
}
inline ::livekit::FileInfo* EgressInfo::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.file)
  if (_internal_has_file()) {
    clear_has_result();
    ::livekit::FileInfo* temp = _impl_.result_.file_;
    _impl_.result_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_file(::livekit::FileInfo* file) {
  clear_result();
  if (file) {
    set_has_file();
    _impl_.result_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.file)
}
inline ::livekit::FileInfo* EgressInfo::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_result();
    set_has_file();
    _impl_.result_.file_ = CreateMaybeMessage< ::livekit::FileInfo >(GetArenaForAllocation());
  }
  return _impl_.result_.file_;
}
inline ::livekit::FileInfo* EgressInfo::mutable_file() {
  ::livekit::FileInfo* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.file)
  return _msg;
}

// .livekit.SegmentsInfo segments = 12 [deprecated = true];
inline bool EgressInfo::_internal_has_segments() const {
  return result_case() == kSegments;
}
inline bool EgressInfo::has_segments() const {
  return _internal_has_segments();
}
inline void EgressInfo::set_has_segments() {
  _impl_._oneof_case_[1] = kSegments;
}
inline void EgressInfo::clear_segments() {
  if (_internal_has_segments()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.segments_;
    }
    clear_has_result();
  }
}
inline ::livekit::SegmentsInfo* EgressInfo::release_segments() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.segments)
  if (_internal_has_segments()) {
    clear_has_result();
    ::livekit::SegmentsInfo* temp = _impl_.result_.segments_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SegmentsInfo& EgressInfo::_internal_segments() const {
  return _internal_has_segments()
      ? *_impl_.result_.segments_
      : reinterpret_cast< ::livekit::SegmentsInfo&>(::livekit::_SegmentsInfo_default_instance_);
}
inline const ::livekit::SegmentsInfo& EgressInfo::segments() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.segments)
  return _internal_segments();
}
inline ::livekit::SegmentsInfo* EgressInfo::unsafe_arena_release_segments() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.EgressInfo.segments)
  if (_internal_has_segments()) {
    clear_has_result();
    ::livekit::SegmentsInfo* temp = _impl_.result_.segments_;
    _impl_.result_.segments_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EgressInfo::unsafe_arena_set_allocated_segments(::livekit::SegmentsInfo* segments) {
  clear_result();
  if (segments) {
    set_has_segments();
    _impl_.result_.segments_ = segments;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.EgressInfo.segments)
}
inline ::livekit::SegmentsInfo* EgressInfo::_internal_mutable_segments() {
  if (!_internal_has_segments()) {
    clear_result();
    set_has_segments();
    _impl_.result_.segments_ = CreateMaybeMessage< ::livekit::SegmentsInfo >(GetArenaForAllocation());
  }
  return _impl_.result_.segments_;
}
inline ::livekit::SegmentsInfo* EgressInfo::mutable_segments() {
  ::livekit::SegmentsInfo* _msg = _internal_mutable_segments();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.segments)
  return _msg;
}

// repeated .livekit.StreamInfo stream_results = 15;
inline int EgressInfo::_internal_stream_results_size() const {
  return _impl_.stream_results_.size();
}
inline int EgressInfo::stream_results_size() const {
  return _internal_stream_results_size();
}
inline void EgressInfo::clear_stream_results() {
  _impl_.stream_results_.Clear();
}
inline ::livekit::StreamInfo* EgressInfo::mutable_stream_results(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.stream_results)
  return _impl_.stream_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >*
EgressInfo::mutable_stream_results() {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.stream_results)
  return &_impl_.stream_results_;
}
inline const ::livekit::StreamInfo& EgressInfo::_internal_stream_results(int index) const {
  return _impl_.stream_results_.Get(index);
}
inline const ::livekit::StreamInfo& EgressInfo::stream_results(int index) const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.stream_results)
  return _internal_stream_results(index);
}
inline ::livekit::StreamInfo* EgressInfo::_internal_add_stream_results() {
  return _impl_.stream_results_.Add();
}
inline ::livekit::StreamInfo* EgressInfo::add_stream_results() {
  ::livekit::StreamInfo* _add = _internal_add_stream_results();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.stream_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >&
EgressInfo::stream_results() const {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.stream_results)
  return _impl_.stream_results_;
}

// repeated .livekit.FileInfo file_results = 16;
inline int EgressInfo::_internal_file_results_size() const {
  return _impl_.file_results_.size();
}
inline int EgressInfo::file_results_size() const {
  return _internal_file_results_size();
}
inline void EgressInfo::clear_file_results() {
  _impl_.file_results_.Clear();
}
inline ::livekit::FileInfo* EgressInfo::mutable_file_results(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.file_results)
  return _impl_.file_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::FileInfo >*
EgressInfo::mutable_file_results() {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.file_results)
  return &_impl_.file_results_;
}
inline const ::livekit::FileInfo& EgressInfo::_internal_file_results(int index) const {
  return _impl_.file_results_.Get(index);
}
inline const ::livekit::FileInfo& EgressInfo::file_results(int index) const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.file_results)
  return _internal_file_results(index);
}
inline ::livekit::FileInfo* EgressInfo::_internal_add_file_results() {
  return _impl_.file_results_.Add();
}
inline ::livekit::FileInfo* EgressInfo::add_file_results() {
  ::livekit::FileInfo* _add = _internal_add_file_results();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.file_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::FileInfo >&
EgressInfo::file_results() const {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.file_results)
  return _impl_.file_results_;
}

// repeated .livekit.SegmentsInfo segment_results = 17;
inline int EgressInfo::_internal_segment_results_size() const {
  return _impl_.segment_results_.size();
}
inline int EgressInfo::segment_results_size() const {
  return _internal_segment_results_size();
}
inline void EgressInfo::clear_segment_results() {
  _impl_.segment_results_.Clear();
}
inline ::livekit::SegmentsInfo* EgressInfo::mutable_segment_results(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.segment_results)
  return _impl_.segment_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentsInfo >*
EgressInfo::mutable_segment_results() {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.segment_results)
  return &_impl_.segment_results_;
}
inline const ::livekit::SegmentsInfo& EgressInfo::_internal_segment_results(int index) const {
  return _impl_.segment_results_.Get(index);
}
inline const ::livekit::SegmentsInfo& EgressInfo::segment_results(int index) const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.segment_results)
  return _internal_segment_results(index);
}
inline ::livekit::SegmentsInfo* EgressInfo::_internal_add_segment_results() {
  return _impl_.segment_results_.Add();
}
inline ::livekit::SegmentsInfo* EgressInfo::add_segment_results() {
  ::livekit::SegmentsInfo* _add = _internal_add_segment_results();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.segment_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentsInfo >&
EgressInfo::segment_results() const {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.segment_results)
  return _impl_.segment_results_;
}

// repeated .livekit.ImagesInfo image_results = 20;
inline int EgressInfo::_internal_image_results_size() const {
  return _impl_.image_results_.size();
}
inline int EgressInfo::image_results_size() const {
  return _internal_image_results_size();
}
inline void EgressInfo::clear_image_results() {
  _impl_.image_results_.Clear();
}
inline ::livekit::ImagesInfo* EgressInfo::mutable_image_results(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.image_results)
  return _impl_.image_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImagesInfo >*
EgressInfo::mutable_image_results() {
  // @@protoc_insertion_point(field_mutable_list:livekit.EgressInfo.image_results)
  return &_impl_.image_results_;
}
inline const ::livekit::ImagesInfo& EgressInfo::_internal_image_results(int index) const {
  return _impl_.image_results_.Get(index);
}
inline const ::livekit::ImagesInfo& EgressInfo::image_results(int index) const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.image_results)
  return _internal_image_results(index);
}
inline ::livekit::ImagesInfo* EgressInfo::_internal_add_image_results() {
  return _impl_.image_results_.Add();
}
inline ::livekit::ImagesInfo* EgressInfo::add_image_results() {
  ::livekit::ImagesInfo* _add = _internal_add_image_results();
  // @@protoc_insertion_point(field_add:livekit.EgressInfo.image_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ImagesInfo >&
EgressInfo::image_results() const {
  // @@protoc_insertion_point(field_list:livekit.EgressInfo.image_results)
  return _impl_.image_results_;
}

// string manifest_location = 23;
inline void EgressInfo::clear_manifest_location() {
  _impl_.manifest_location_.ClearToEmpty();
}
inline const std::string& EgressInfo::manifest_location() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.manifest_location)
  return _internal_manifest_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EgressInfo::set_manifest_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.manifest_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.manifest_location)
}
inline std::string* EgressInfo::mutable_manifest_location() {
  std::string* _s = _internal_mutable_manifest_location();
  // @@protoc_insertion_point(field_mutable:livekit.EgressInfo.manifest_location)
  return _s;
}
inline const std::string& EgressInfo::_internal_manifest_location() const {
  return _impl_.manifest_location_.Get();
}
inline void EgressInfo::_internal_set_manifest_location(const std::string& value) {
  
  _impl_.manifest_location_.Set(value, GetArenaForAllocation());
}
inline std::string* EgressInfo::_internal_mutable_manifest_location() {
  
  return _impl_.manifest_location_.Mutable(GetArenaForAllocation());
}
inline std::string* EgressInfo::release_manifest_location() {
  // @@protoc_insertion_point(field_release:livekit.EgressInfo.manifest_location)
  return _impl_.manifest_location_.Release();
}
inline void EgressInfo::set_allocated_manifest_location(std::string* manifest_location) {
  if (manifest_location != nullptr) {
    
  } else {
    
  }
  _impl_.manifest_location_.SetAllocated(manifest_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.manifest_location_.IsDefault()) {
    _impl_.manifest_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.EgressInfo.manifest_location)
}

// bool backup_storage_used = 25;
inline void EgressInfo::clear_backup_storage_used() {
  _impl_.backup_storage_used_ = false;
}
inline bool EgressInfo::_internal_backup_storage_used() const {
  return _impl_.backup_storage_used_;
}
inline bool EgressInfo::backup_storage_used() const {
  // @@protoc_insertion_point(field_get:livekit.EgressInfo.backup_storage_used)
  return _internal_backup_storage_used();
}
inline void EgressInfo::_internal_set_backup_storage_used(bool value) {
  
  _impl_.backup_storage_used_ = value;
}
inline void EgressInfo::set_backup_storage_used(bool value) {
  _internal_set_backup_storage_used(value);
  // @@protoc_insertion_point(field_set:livekit.EgressInfo.backup_storage_used)
}

inline bool EgressInfo::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void EgressInfo::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline bool EgressInfo::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void EgressInfo::clear_has_result() {
  _impl_._oneof_case_[1] = RESULT_NOT_SET;
}
inline EgressInfo::RequestCase EgressInfo::request_case() const {
  return EgressInfo::RequestCase(_impl_._oneof_case_[0]);
}
inline EgressInfo::ResultCase EgressInfo::result_case() const {
  return EgressInfo::ResultCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// StreamInfoList

// repeated .livekit.StreamInfo info = 1;
inline int StreamInfoList::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int StreamInfoList::info_size() const {
  return _internal_info_size();
}
inline void StreamInfoList::clear_info() {
  _impl_.info_.Clear();
}
inline ::livekit::StreamInfo* StreamInfoList::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfoList.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >*
StreamInfoList::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamInfoList.info)
  return &_impl_.info_;
}
inline const ::livekit::StreamInfo& StreamInfoList::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::livekit::StreamInfo& StreamInfoList::info(int index) const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfoList.info)
  return _internal_info(index);
}
inline ::livekit::StreamInfo* StreamInfoList::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::livekit::StreamInfo* StreamInfoList::add_info() {
  ::livekit::StreamInfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:livekit.StreamInfoList.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamInfo >&
StreamInfoList::info() const {
  // @@protoc_insertion_point(field_list:livekit.StreamInfoList.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// StreamInfo

// string url = 1;
inline void StreamInfo::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& StreamInfo::url() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.url)
}
inline std::string* StreamInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfo.url)
  return _s;
}
inline const std::string& StreamInfo::_internal_url() const {
  return _impl_.url_.Get();
}
inline void StreamInfo::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamInfo::release_url() {
  // @@protoc_insertion_point(field_release:livekit.StreamInfo.url)
  return _impl_.url_.Release();
}
inline void StreamInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamInfo.url)
}

// int64 started_at = 2;
inline void StreamInfo::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t StreamInfo::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t StreamInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.started_at)
  return _internal_started_at();
}
inline void StreamInfo::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void StreamInfo::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.started_at)
}

// int64 ended_at = 3;
inline void StreamInfo::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t StreamInfo::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t StreamInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.ended_at)
  return _internal_ended_at();
}
inline void StreamInfo::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void StreamInfo::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.ended_at)
}

// int64 duration = 4;
inline void StreamInfo::clear_duration() {
  _impl_.duration_ = int64_t{0};
}
inline int64_t StreamInfo::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t StreamInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.duration)
  return _internal_duration();
}
inline void StreamInfo::_internal_set_duration(int64_t value) {
  
  _impl_.duration_ = value;
}
inline void StreamInfo::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.duration)
}

// .livekit.StreamInfo.Status status = 5;
inline void StreamInfo::clear_status() {
  _impl_.status_ = 0;
}
inline ::livekit::StreamInfo_Status StreamInfo::_internal_status() const {
  return static_cast< ::livekit::StreamInfo_Status >(_impl_.status_);
}
inline ::livekit::StreamInfo_Status StreamInfo::status() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.status)
  return _internal_status();
}
inline void StreamInfo::_internal_set_status(::livekit::StreamInfo_Status value) {
  
  _impl_.status_ = value;
}
inline void StreamInfo::set_status(::livekit::StreamInfo_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.status)
}

// string error = 6;
inline void StreamInfo::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& StreamInfo::error() const {
  // @@protoc_insertion_point(field_get:livekit.StreamInfo.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamInfo::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamInfo.error)
}
inline std::string* StreamInfo::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.StreamInfo.error)
  return _s;
}
inline const std::string& StreamInfo::_internal_error() const {
  return _impl_.error_.Get();
}
inline void StreamInfo::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamInfo::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamInfo::release_error() {
  // @@protoc_insertion_point(field_release:livekit.StreamInfo.error)
  return _impl_.error_.Release();
}
inline void StreamInfo::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamInfo.error)
}

// -------------------------------------------------------------------

// FileInfo

// string filename = 1;
inline void FileInfo::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& FileInfo::filename() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.FileInfo.filename)
}
inline std::string* FileInfo::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:livekit.FileInfo.filename)
  return _s;
}
inline const std::string& FileInfo::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void FileInfo::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_filename() {
  // @@protoc_insertion_point(field_release:livekit.FileInfo.filename)
  return _impl_.filename_.Release();
}
inline void FileInfo::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.FileInfo.filename)
}

// int64 started_at = 2;
inline void FileInfo::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t FileInfo::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t FileInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.started_at)
  return _internal_started_at();
}
inline void FileInfo::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void FileInfo::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.FileInfo.started_at)
}

// int64 ended_at = 3;
inline void FileInfo::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t FileInfo::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t FileInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.ended_at)
  return _internal_ended_at();
}
inline void FileInfo::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void FileInfo::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.FileInfo.ended_at)
}

// int64 duration = 6;
inline void FileInfo::clear_duration() {
  _impl_.duration_ = int64_t{0};
}
inline int64_t FileInfo::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t FileInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.duration)
  return _internal_duration();
}
inline void FileInfo::_internal_set_duration(int64_t value) {
  
  _impl_.duration_ = value;
}
inline void FileInfo::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.FileInfo.duration)
}

// int64 size = 4;
inline void FileInfo::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t FileInfo::_internal_size() const {
  return _impl_.size_;
}
inline int64_t FileInfo::size() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.size)
  return _internal_size();
}
inline void FileInfo::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void FileInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.FileInfo.size)
}

// string location = 5;
inline void FileInfo::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& FileInfo::location() const {
  // @@protoc_insertion_point(field_get:livekit.FileInfo.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileInfo::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.FileInfo.location)
}
inline std::string* FileInfo::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:livekit.FileInfo.location)
  return _s;
}
inline const std::string& FileInfo::_internal_location() const {
  return _impl_.location_.Get();
}
inline void FileInfo::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* FileInfo::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* FileInfo::release_location() {
  // @@protoc_insertion_point(field_release:livekit.FileInfo.location)
  return _impl_.location_.Release();
}
inline void FileInfo::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.FileInfo.location)
}

// -------------------------------------------------------------------

// SegmentsInfo

// string playlist_name = 1;
inline void SegmentsInfo::clear_playlist_name() {
  _impl_.playlist_name_.ClearToEmpty();
}
inline const std::string& SegmentsInfo::playlist_name() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.playlist_name)
  return _internal_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentsInfo::set_playlist_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.playlist_name)
}
inline std::string* SegmentsInfo::mutable_playlist_name() {
  std::string* _s = _internal_mutable_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.playlist_name)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_playlist_name() const {
  return _impl_.playlist_name_.Get();
}
inline void SegmentsInfo::_internal_set_playlist_name(const std::string& value) {
  
  _impl_.playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentsInfo::_internal_mutable_playlist_name() {
  
  return _impl_.playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentsInfo::release_playlist_name() {
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.playlist_name)
  return _impl_.playlist_name_.Release();
}
inline void SegmentsInfo::set_allocated_playlist_name(std::string* playlist_name) {
  if (playlist_name != nullptr) {
    
  } else {
    
  }
  _impl_.playlist_name_.SetAllocated(playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlist_name_.IsDefault()) {
    _impl_.playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.playlist_name)
}

// string live_playlist_name = 8;
inline void SegmentsInfo::clear_live_playlist_name() {
  _impl_.live_playlist_name_.ClearToEmpty();
}
inline const std::string& SegmentsInfo::live_playlist_name() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.live_playlist_name)
  return _internal_live_playlist_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentsInfo::set_live_playlist_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.live_playlist_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.live_playlist_name)
}
inline std::string* SegmentsInfo::mutable_live_playlist_name() {
  std::string* _s = _internal_mutable_live_playlist_name();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.live_playlist_name)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_live_playlist_name() const {
  return _impl_.live_playlist_name_.Get();
}
inline void SegmentsInfo::_internal_set_live_playlist_name(const std::string& value) {
  
  _impl_.live_playlist_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentsInfo::_internal_mutable_live_playlist_name() {
  
  return _impl_.live_playlist_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentsInfo::release_live_playlist_name() {
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.live_playlist_name)
  return _impl_.live_playlist_name_.Release();
}
inline void SegmentsInfo::set_allocated_live_playlist_name(std::string* live_playlist_name) {
  if (live_playlist_name != nullptr) {
    
  } else {
    
  }
  _impl_.live_playlist_name_.SetAllocated(live_playlist_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.live_playlist_name_.IsDefault()) {
    _impl_.live_playlist_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.live_playlist_name)
}

// int64 duration = 2;
inline void SegmentsInfo::clear_duration() {
  _impl_.duration_ = int64_t{0};
}
inline int64_t SegmentsInfo::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t SegmentsInfo::duration() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.duration)
  return _internal_duration();
}
inline void SegmentsInfo::_internal_set_duration(int64_t value) {
  
  _impl_.duration_ = value;
}
inline void SegmentsInfo::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.duration)
}

// int64 size = 3;
inline void SegmentsInfo::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t SegmentsInfo::_internal_size() const {
  return _impl_.size_;
}
inline int64_t SegmentsInfo::size() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.size)
  return _internal_size();
}
inline void SegmentsInfo::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void SegmentsInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.size)
}

// string playlist_location = 4;
inline void SegmentsInfo::clear_playlist_location() {
  _impl_.playlist_location_.ClearToEmpty();
}
inline const std::string& SegmentsInfo::playlist_location() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.playlist_location)
  return _internal_playlist_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentsInfo::set_playlist_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playlist_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.playlist_location)
}
inline std::string* SegmentsInfo::mutable_playlist_location() {
  std::string* _s = _internal_mutable_playlist_location();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.playlist_location)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_playlist_location() const {
  return _impl_.playlist_location_.Get();
}
inline void SegmentsInfo::_internal_set_playlist_location(const std::string& value) {
  
  _impl_.playlist_location_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentsInfo::_internal_mutable_playlist_location() {
  
  return _impl_.playlist_location_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentsInfo::release_playlist_location() {
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.playlist_location)
  return _impl_.playlist_location_.Release();
}
inline void SegmentsInfo::set_allocated_playlist_location(std::string* playlist_location) {
  if (playlist_location != nullptr) {
    
  } else {
    
  }
  _impl_.playlist_location_.SetAllocated(playlist_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playlist_location_.IsDefault()) {
    _impl_.playlist_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.playlist_location)
}

// string live_playlist_location = 9;
inline void SegmentsInfo::clear_live_playlist_location() {
  _impl_.live_playlist_location_.ClearToEmpty();
}
inline const std::string& SegmentsInfo::live_playlist_location() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.live_playlist_location)
  return _internal_live_playlist_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SegmentsInfo::set_live_playlist_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.live_playlist_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.live_playlist_location)
}
inline std::string* SegmentsInfo::mutable_live_playlist_location() {
  std::string* _s = _internal_mutable_live_playlist_location();
  // @@protoc_insertion_point(field_mutable:livekit.SegmentsInfo.live_playlist_location)
  return _s;
}
inline const std::string& SegmentsInfo::_internal_live_playlist_location() const {
  return _impl_.live_playlist_location_.Get();
}
inline void SegmentsInfo::_internal_set_live_playlist_location(const std::string& value) {
  
  _impl_.live_playlist_location_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentsInfo::_internal_mutable_live_playlist_location() {
  
  return _impl_.live_playlist_location_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentsInfo::release_live_playlist_location() {
  // @@protoc_insertion_point(field_release:livekit.SegmentsInfo.live_playlist_location)
  return _impl_.live_playlist_location_.Release();
}
inline void SegmentsInfo::set_allocated_live_playlist_location(std::string* live_playlist_location) {
  if (live_playlist_location != nullptr) {
    
  } else {
    
  }
  _impl_.live_playlist_location_.SetAllocated(live_playlist_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.live_playlist_location_.IsDefault()) {
    _impl_.live_playlist_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SegmentsInfo.live_playlist_location)
}

// int64 segment_count = 5;
inline void SegmentsInfo::clear_segment_count() {
  _impl_.segment_count_ = int64_t{0};
}
inline int64_t SegmentsInfo::_internal_segment_count() const {
  return _impl_.segment_count_;
}
inline int64_t SegmentsInfo::segment_count() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.segment_count)
  return _internal_segment_count();
}
inline void SegmentsInfo::_internal_set_segment_count(int64_t value) {
  
  _impl_.segment_count_ = value;
}
inline void SegmentsInfo::set_segment_count(int64_t value) {
  _internal_set_segment_count(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.segment_count)
}

// int64 started_at = 6;
inline void SegmentsInfo::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t SegmentsInfo::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t SegmentsInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.started_at)
  return _internal_started_at();
}
inline void SegmentsInfo::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void SegmentsInfo::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.started_at)
}

// int64 ended_at = 7;
inline void SegmentsInfo::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t SegmentsInfo::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t SegmentsInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.SegmentsInfo.ended_at)
  return _internal_ended_at();
}
inline void SegmentsInfo::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void SegmentsInfo::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.SegmentsInfo.ended_at)
}

// -------------------------------------------------------------------

// ImagesInfo

// string filename_prefix = 4;
inline void ImagesInfo::clear_filename_prefix() {
  _impl_.filename_prefix_.ClearToEmpty();
}
inline const std::string& ImagesInfo::filename_prefix() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.filename_prefix)
  return _internal_filename_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagesInfo::set_filename_prefix(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_prefix_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.filename_prefix)
}
inline std::string* ImagesInfo::mutable_filename_prefix() {
  std::string* _s = _internal_mutable_filename_prefix();
  // @@protoc_insertion_point(field_mutable:livekit.ImagesInfo.filename_prefix)
  return _s;
}
inline const std::string& ImagesInfo::_internal_filename_prefix() const {
  return _impl_.filename_prefix_.Get();
}
inline void ImagesInfo::_internal_set_filename_prefix(const std::string& value) {
  
  _impl_.filename_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagesInfo::_internal_mutable_filename_prefix() {
  
  return _impl_.filename_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagesInfo::release_filename_prefix() {
  // @@protoc_insertion_point(field_release:livekit.ImagesInfo.filename_prefix)
  return _impl_.filename_prefix_.Release();
}
inline void ImagesInfo::set_allocated_filename_prefix(std::string* filename_prefix) {
  if (filename_prefix != nullptr) {
    
  } else {
    
  }
  _impl_.filename_prefix_.SetAllocated(filename_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_prefix_.IsDefault()) {
    _impl_.filename_prefix_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ImagesInfo.filename_prefix)
}

// int64 image_count = 1;
inline void ImagesInfo::clear_image_count() {
  _impl_.image_count_ = int64_t{0};
}
inline int64_t ImagesInfo::_internal_image_count() const {
  return _impl_.image_count_;
}
inline int64_t ImagesInfo::image_count() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.image_count)
  return _internal_image_count();
}
inline void ImagesInfo::_internal_set_image_count(int64_t value) {
  
  _impl_.image_count_ = value;
}
inline void ImagesInfo::set_image_count(int64_t value) {
  _internal_set_image_count(value);
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.image_count)
}

// int64 started_at = 2;
inline void ImagesInfo::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t ImagesInfo::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t ImagesInfo::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.started_at)
  return _internal_started_at();
}
inline void ImagesInfo::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void ImagesInfo::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.started_at)
}

// int64 ended_at = 3;
inline void ImagesInfo::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t ImagesInfo::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t ImagesInfo::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.ImagesInfo.ended_at)
  return _internal_ended_at();
}
inline void ImagesInfo::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void ImagesInfo::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.ImagesInfo.ended_at)
}

// -------------------------------------------------------------------

// AutoParticipantEgress

// .livekit.EncodingOptionsPreset preset = 1;
inline bool AutoParticipantEgress::_internal_has_preset() const {
  return options_case() == kPreset;
}
inline bool AutoParticipantEgress::has_preset() const {
  return _internal_has_preset();
}
inline void AutoParticipantEgress::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void AutoParticipantEgress::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.options_.preset_ = 0;
    clear_has_options();
  }
}
inline ::livekit::EncodingOptionsPreset AutoParticipantEgress::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::EncodingOptionsPreset >(_impl_.options_.preset_);
  }
  return static_cast< ::livekit::EncodingOptionsPreset >(0);
}
inline ::livekit::EncodingOptionsPreset AutoParticipantEgress::preset() const {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.preset)
  return _internal_preset();
}
inline void AutoParticipantEgress::_internal_set_preset(::livekit::EncodingOptionsPreset value) {
  if (!_internal_has_preset()) {
    clear_options();
    set_has_preset();
  }
  _impl_.options_.preset_ = value;
}
inline void AutoParticipantEgress::set_preset(::livekit::EncodingOptionsPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.AutoParticipantEgress.preset)
}

// .livekit.EncodingOptions advanced = 2;
inline bool AutoParticipantEgress::_internal_has_advanced() const {
  return options_case() == kAdvanced;
}
inline bool AutoParticipantEgress::has_advanced() const {
  return _internal_has_advanced();
}
inline void AutoParticipantEgress::set_has_advanced() {
  _impl_._oneof_case_[0] = kAdvanced;
}
inline void AutoParticipantEgress::clear_advanced() {
  if (_internal_has_advanced()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.advanced_;
    }
    clear_has_options();
  }
}
inline ::livekit::EncodingOptions* AutoParticipantEgress::release_advanced() {
  // @@protoc_insertion_point(field_release:livekit.AutoParticipantEgress.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::EncodingOptions& AutoParticipantEgress::_internal_advanced() const {
  return _internal_has_advanced()
      ? *_impl_.options_.advanced_
      : reinterpret_cast< ::livekit::EncodingOptions&>(::livekit::_EncodingOptions_default_instance_);
}
inline const ::livekit::EncodingOptions& AutoParticipantEgress::advanced() const {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.advanced)
  return _internal_advanced();
}
inline ::livekit::EncodingOptions* AutoParticipantEgress::unsafe_arena_release_advanced() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoParticipantEgress.advanced)
  if (_internal_has_advanced()) {
    clear_has_options();
    ::livekit::EncodingOptions* temp = _impl_.options_.advanced_;
    _impl_.options_.advanced_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoParticipantEgress::unsafe_arena_set_allocated_advanced(::livekit::EncodingOptions* advanced) {
  clear_options();
  if (advanced) {
    set_has_advanced();
    _impl_.options_.advanced_ = advanced;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoParticipantEgress.advanced)
}
inline ::livekit::EncodingOptions* AutoParticipantEgress::_internal_mutable_advanced() {
  if (!_internal_has_advanced()) {
    clear_options();
    set_has_advanced();
    _impl_.options_.advanced_ = CreateMaybeMessage< ::livekit::EncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.options_.advanced_;
}
inline ::livekit::EncodingOptions* AutoParticipantEgress::mutable_advanced() {
  ::livekit::EncodingOptions* _msg = _internal_mutable_advanced();
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.advanced)
  return _msg;
}

// repeated .livekit.EncodedFileOutput file_outputs = 3;
inline int AutoParticipantEgress::_internal_file_outputs_size() const {
  return _impl_.file_outputs_.size();
}
inline int AutoParticipantEgress::file_outputs_size() const {
  return _internal_file_outputs_size();
}
inline void AutoParticipantEgress::clear_file_outputs() {
  _impl_.file_outputs_.Clear();
}
inline ::livekit::EncodedFileOutput* AutoParticipantEgress::mutable_file_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.file_outputs)
  return _impl_.file_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >*
AutoParticipantEgress::mutable_file_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.AutoParticipantEgress.file_outputs)
  return &_impl_.file_outputs_;
}
inline const ::livekit::EncodedFileOutput& AutoParticipantEgress::_internal_file_outputs(int index) const {
  return _impl_.file_outputs_.Get(index);
}
inline const ::livekit::EncodedFileOutput& AutoParticipantEgress::file_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.file_outputs)
  return _internal_file_outputs(index);
}
inline ::livekit::EncodedFileOutput* AutoParticipantEgress::_internal_add_file_outputs() {
  return _impl_.file_outputs_.Add();
}
inline ::livekit::EncodedFileOutput* AutoParticipantEgress::add_file_outputs() {
  ::livekit::EncodedFileOutput* _add = _internal_add_file_outputs();
  // @@protoc_insertion_point(field_add:livekit.AutoParticipantEgress.file_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::EncodedFileOutput >&
AutoParticipantEgress::file_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.AutoParticipantEgress.file_outputs)
  return _impl_.file_outputs_;
}

// repeated .livekit.SegmentedFileOutput segment_outputs = 4;
inline int AutoParticipantEgress::_internal_segment_outputs_size() const {
  return _impl_.segment_outputs_.size();
}
inline int AutoParticipantEgress::segment_outputs_size() const {
  return _internal_segment_outputs_size();
}
inline void AutoParticipantEgress::clear_segment_outputs() {
  _impl_.segment_outputs_.Clear();
}
inline ::livekit::SegmentedFileOutput* AutoParticipantEgress::mutable_segment_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.AutoParticipantEgress.segment_outputs)
  return _impl_.segment_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >*
AutoParticipantEgress::mutable_segment_outputs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.AutoParticipantEgress.segment_outputs)
  return &_impl_.segment_outputs_;
}
inline const ::livekit::SegmentedFileOutput& AutoParticipantEgress::_internal_segment_outputs(int index) const {
  return _impl_.segment_outputs_.Get(index);
}
inline const ::livekit::SegmentedFileOutput& AutoParticipantEgress::segment_outputs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.AutoParticipantEgress.segment_outputs)
  return _internal_segment_outputs(index);
}
inline ::livekit::SegmentedFileOutput* AutoParticipantEgress::_internal_add_segment_outputs() {
  return _impl_.segment_outputs_.Add();
}
inline ::livekit::SegmentedFileOutput* AutoParticipantEgress::add_segment_outputs() {
  ::livekit::SegmentedFileOutput* _add = _internal_add_segment_outputs();
  // @@protoc_insertion_point(field_add:livekit.AutoParticipantEgress.segment_outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SegmentedFileOutput >&
AutoParticipantEgress::segment_outputs() const {
  // @@protoc_insertion_point(field_list:livekit.AutoParticipantEgress.segment_outputs)
  return _impl_.segment_outputs_;
}

inline bool AutoParticipantEgress::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void AutoParticipantEgress::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline AutoParticipantEgress::OptionsCase AutoParticipantEgress::options_case() const {
  return AutoParticipantEgress::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AutoTrackEgress

// string filepath = 1;
inline void AutoTrackEgress::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& AutoTrackEgress::filepath() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutoTrackEgress::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AutoTrackEgress.filepath)
}
inline std::string* AutoTrackEgress::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.filepath)
  return _s;
}
inline const std::string& AutoTrackEgress::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void AutoTrackEgress::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* AutoTrackEgress::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* AutoTrackEgress::release_filepath() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.filepath)
  return _impl_.filepath_.Release();
}
inline void AutoTrackEgress::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AutoTrackEgress.filepath)
}

// bool disable_manifest = 5;
inline void AutoTrackEgress::clear_disable_manifest() {
  _impl_.disable_manifest_ = false;
}
inline bool AutoTrackEgress::_internal_disable_manifest() const {
  return _impl_.disable_manifest_;
}
inline bool AutoTrackEgress::disable_manifest() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.disable_manifest)
  return _internal_disable_manifest();
}
inline void AutoTrackEgress::_internal_set_disable_manifest(bool value) {
  
  _impl_.disable_manifest_ = value;
}
inline void AutoTrackEgress::set_disable_manifest(bool value) {
  _internal_set_disable_manifest(value);
  // @@protoc_insertion_point(field_set:livekit.AutoTrackEgress.disable_manifest)
}

// .livekit.S3Upload s3 = 2;
inline bool AutoTrackEgress::_internal_has_s3() const {
  return output_case() == kS3;
}
inline bool AutoTrackEgress::has_s3() const {
  return _internal_has_s3();
}
inline void AutoTrackEgress::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void AutoTrackEgress::clear_s3() {
  if (_internal_has_s3()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.s3_;
    }
    clear_has_output();
  }
}
inline ::livekit::S3Upload* AutoTrackEgress::release_s3() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::S3Upload& AutoTrackEgress::_internal_s3() const {
  return _internal_has_s3()
      ? *_impl_.output_.s3_
      : reinterpret_cast< ::livekit::S3Upload&>(::livekit::_S3Upload_default_instance_);
}
inline const ::livekit::S3Upload& AutoTrackEgress::s3() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.s3)
  return _internal_s3();
}
inline ::livekit::S3Upload* AutoTrackEgress::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.s3)
  if (_internal_has_s3()) {
    clear_has_output();
    ::livekit::S3Upload* temp = _impl_.output_.s3_;
    _impl_.output_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_s3(::livekit::S3Upload* s3) {
  clear_output();
  if (s3) {
    set_has_s3();
    _impl_.output_.s3_ = s3;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.s3)
}
inline ::livekit::S3Upload* AutoTrackEgress::_internal_mutable_s3() {
  if (!_internal_has_s3()) {
    clear_output();
    set_has_s3();
    _impl_.output_.s3_ = CreateMaybeMessage< ::livekit::S3Upload >(GetArenaForAllocation());
  }
  return _impl_.output_.s3_;
}
inline ::livekit::S3Upload* AutoTrackEgress::mutable_s3() {
  ::livekit::S3Upload* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.s3)
  return _msg;
}

// .livekit.GCPUpload gcp = 3;
inline bool AutoTrackEgress::_internal_has_gcp() const {
  return output_case() == kGcp;
}
inline bool AutoTrackEgress::has_gcp() const {
  return _internal_has_gcp();
}
inline void AutoTrackEgress::set_has_gcp() {
  _impl_._oneof_case_[0] = kGcp;
}
inline void AutoTrackEgress::clear_gcp() {
  if (_internal_has_gcp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.gcp_;
    }
    clear_has_output();
  }
}
inline ::livekit::GCPUpload* AutoTrackEgress::release_gcp() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::GCPUpload& AutoTrackEgress::_internal_gcp() const {
  return _internal_has_gcp()
      ? *_impl_.output_.gcp_
      : reinterpret_cast< ::livekit::GCPUpload&>(::livekit::_GCPUpload_default_instance_);
}
inline const ::livekit::GCPUpload& AutoTrackEgress::gcp() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.gcp)
  return _internal_gcp();
}
inline ::livekit::GCPUpload* AutoTrackEgress::unsafe_arena_release_gcp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.gcp)
  if (_internal_has_gcp()) {
    clear_has_output();
    ::livekit::GCPUpload* temp = _impl_.output_.gcp_;
    _impl_.output_.gcp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_gcp(::livekit::GCPUpload* gcp) {
  clear_output();
  if (gcp) {
    set_has_gcp();
    _impl_.output_.gcp_ = gcp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.gcp)
}
inline ::livekit::GCPUpload* AutoTrackEgress::_internal_mutable_gcp() {
  if (!_internal_has_gcp()) {
    clear_output();
    set_has_gcp();
    _impl_.output_.gcp_ = CreateMaybeMessage< ::livekit::GCPUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.gcp_;
}
inline ::livekit::GCPUpload* AutoTrackEgress::mutable_gcp() {
  ::livekit::GCPUpload* _msg = _internal_mutable_gcp();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.gcp)
  return _msg;
}

// .livekit.AzureBlobUpload azure = 4;
inline bool AutoTrackEgress::_internal_has_azure() const {
  return output_case() == kAzure;
}
inline bool AutoTrackEgress::has_azure() const {
  return _internal_has_azure();
}
inline void AutoTrackEgress::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void AutoTrackEgress::clear_azure() {
  if (_internal_has_azure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.azure_;
    }
    clear_has_output();
  }
}
inline ::livekit::AzureBlobUpload* AutoTrackEgress::release_azure() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AzureBlobUpload& AutoTrackEgress::_internal_azure() const {
  return _internal_has_azure()
      ? *_impl_.output_.azure_
      : reinterpret_cast< ::livekit::AzureBlobUpload&>(::livekit::_AzureBlobUpload_default_instance_);
}
inline const ::livekit::AzureBlobUpload& AutoTrackEgress::azure() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.azure)
  return _internal_azure();
}
inline ::livekit::AzureBlobUpload* AutoTrackEgress::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.azure)
  if (_internal_has_azure()) {
    clear_has_output();
    ::livekit::AzureBlobUpload* temp = _impl_.output_.azure_;
    _impl_.output_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_azure(::livekit::AzureBlobUpload* azure) {
  clear_output();
  if (azure) {
    set_has_azure();
    _impl_.output_.azure_ = azure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.azure)
}
inline ::livekit::AzureBlobUpload* AutoTrackEgress::_internal_mutable_azure() {
  if (!_internal_has_azure()) {
    clear_output();
    set_has_azure();
    _impl_.output_.azure_ = CreateMaybeMessage< ::livekit::AzureBlobUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.azure_;
}
inline ::livekit::AzureBlobUpload* AutoTrackEgress::mutable_azure() {
  ::livekit::AzureBlobUpload* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.azure)
  return _msg;
}

// .livekit.AliOSSUpload aliOSS = 6;
inline bool AutoTrackEgress::_internal_has_alioss() const {
  return output_case() == kAliOSS;
}
inline bool AutoTrackEgress::has_alioss() const {
  return _internal_has_alioss();
}
inline void AutoTrackEgress::set_has_alioss() {
  _impl_._oneof_case_[0] = kAliOSS;
}
inline void AutoTrackEgress::clear_alioss() {
  if (_internal_has_alioss()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.output_.alioss_;
    }
    clear_has_output();
  }
}
inline ::livekit::AliOSSUpload* AutoTrackEgress::release_alioss() {
  // @@protoc_insertion_point(field_release:livekit.AutoTrackEgress.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AliOSSUpload& AutoTrackEgress::_internal_alioss() const {
  return _internal_has_alioss()
      ? *_impl_.output_.alioss_
      : reinterpret_cast< ::livekit::AliOSSUpload&>(::livekit::_AliOSSUpload_default_instance_);
}
inline const ::livekit::AliOSSUpload& AutoTrackEgress::alioss() const {
  // @@protoc_insertion_point(field_get:livekit.AutoTrackEgress.aliOSS)
  return _internal_alioss();
}
inline ::livekit::AliOSSUpload* AutoTrackEgress::unsafe_arena_release_alioss() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.AutoTrackEgress.aliOSS)
  if (_internal_has_alioss()) {
    clear_has_output();
    ::livekit::AliOSSUpload* temp = _impl_.output_.alioss_;
    _impl_.output_.alioss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoTrackEgress::unsafe_arena_set_allocated_alioss(::livekit::AliOSSUpload* alioss) {
  clear_output();
  if (alioss) {
    set_has_alioss();
    _impl_.output_.alioss_ = alioss;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AutoTrackEgress.aliOSS)
}
inline ::livekit::AliOSSUpload* AutoTrackEgress::_internal_mutable_alioss() {
  if (!_internal_has_alioss()) {
    clear_output();
    set_has_alioss();
    _impl_.output_.alioss_ = CreateMaybeMessage< ::livekit::AliOSSUpload >(GetArenaForAllocation());
  }
  return _impl_.output_.alioss_;
}
inline ::livekit::AliOSSUpload* AutoTrackEgress::mutable_alioss() {
  ::livekit::AliOSSUpload* _msg = _internal_mutable_alioss();
  // @@protoc_insertion_point(field_mutable:livekit.AutoTrackEgress.aliOSS)
  return _msg;
}

inline bool AutoTrackEgress::has_output() const {
  return output_case() != OUTPUT_NOT_SET;
}
inline void AutoTrackEgress::clear_has_output() {
  _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline AutoTrackEgress::OutputCase AutoTrackEgress::output_case() const {
  return AutoTrackEgress::OutputCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::StreamInfo_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::StreamInfo_Status>() {
  return ::livekit::StreamInfo_Status_descriptor();
}
template <> struct is_proto_enum< ::livekit::EncodedFileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::EncodedFileType>() {
  return ::livekit::EncodedFileType_descriptor();
}
template <> struct is_proto_enum< ::livekit::SegmentedFileProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::SegmentedFileProtocol>() {
  return ::livekit::SegmentedFileProtocol_descriptor();
}
template <> struct is_proto_enum< ::livekit::SegmentedFileSuffix> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::SegmentedFileSuffix>() {
  return ::livekit::SegmentedFileSuffix_descriptor();
}
template <> struct is_proto_enum< ::livekit::ImageFileSuffix> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ImageFileSuffix>() {
  return ::livekit::ImageFileSuffix_descriptor();
}
template <> struct is_proto_enum< ::livekit::StreamProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::StreamProtocol>() {
  return ::livekit::StreamProtocol_descriptor();
}
template <> struct is_proto_enum< ::livekit::AudioMixing> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::AudioMixing>() {
  return ::livekit::AudioMixing_descriptor();
}
template <> struct is_proto_enum< ::livekit::EncodingOptionsPreset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::EncodingOptionsPreset>() {
  return ::livekit::EncodingOptionsPreset_descriptor();
}
template <> struct is_proto_enum< ::livekit::EgressStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::EgressStatus>() {
  return ::livekit::EgressStatus_descriptor();
}
template <> struct is_proto_enum< ::livekit::EgressSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::EgressSourceType>() {
  return ::livekit::EgressSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5fegress_2eproto
