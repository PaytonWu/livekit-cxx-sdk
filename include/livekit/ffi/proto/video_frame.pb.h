// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video_frame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_video_5fframe_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_video_5fframe_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "handle.pb.h"
#include "track.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_video_5fframe_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_video_5fframe_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_video_5fframe_2eproto;
namespace livekit {
namespace proto {
class CaptureVideoFrameRequest;
struct CaptureVideoFrameRequestDefaultTypeInternal;
extern CaptureVideoFrameRequestDefaultTypeInternal _CaptureVideoFrameRequest_default_instance_;
class CaptureVideoFrameResponse;
struct CaptureVideoFrameResponseDefaultTypeInternal;
extern CaptureVideoFrameResponseDefaultTypeInternal _CaptureVideoFrameResponse_default_instance_;
class NewVideoSourceRequest;
struct NewVideoSourceRequestDefaultTypeInternal;
extern NewVideoSourceRequestDefaultTypeInternal _NewVideoSourceRequest_default_instance_;
class NewVideoSourceResponse;
struct NewVideoSourceResponseDefaultTypeInternal;
extern NewVideoSourceResponseDefaultTypeInternal _NewVideoSourceResponse_default_instance_;
class NewVideoStreamRequest;
struct NewVideoStreamRequestDefaultTypeInternal;
extern NewVideoStreamRequestDefaultTypeInternal _NewVideoStreamRequest_default_instance_;
class NewVideoStreamResponse;
struct NewVideoStreamResponseDefaultTypeInternal;
extern NewVideoStreamResponseDefaultTypeInternal _NewVideoStreamResponse_default_instance_;
class OwnedVideoBuffer;
struct OwnedVideoBufferDefaultTypeInternal;
extern OwnedVideoBufferDefaultTypeInternal _OwnedVideoBuffer_default_instance_;
class OwnedVideoSource;
struct OwnedVideoSourceDefaultTypeInternal;
extern OwnedVideoSourceDefaultTypeInternal _OwnedVideoSource_default_instance_;
class OwnedVideoStream;
struct OwnedVideoStreamDefaultTypeInternal;
extern OwnedVideoStreamDefaultTypeInternal _OwnedVideoStream_default_instance_;
class VideoBufferInfo;
struct VideoBufferInfoDefaultTypeInternal;
extern VideoBufferInfoDefaultTypeInternal _VideoBufferInfo_default_instance_;
class VideoBufferInfo_ComponentInfo;
struct VideoBufferInfo_ComponentInfoDefaultTypeInternal;
extern VideoBufferInfo_ComponentInfoDefaultTypeInternal _VideoBufferInfo_ComponentInfo_default_instance_;
class VideoConvertRequest;
struct VideoConvertRequestDefaultTypeInternal;
extern VideoConvertRequestDefaultTypeInternal _VideoConvertRequest_default_instance_;
class VideoConvertResponse;
struct VideoConvertResponseDefaultTypeInternal;
extern VideoConvertResponseDefaultTypeInternal _VideoConvertResponse_default_instance_;
class VideoFrameReceived;
struct VideoFrameReceivedDefaultTypeInternal;
extern VideoFrameReceivedDefaultTypeInternal _VideoFrameReceived_default_instance_;
class VideoResolution;
struct VideoResolutionDefaultTypeInternal;
extern VideoResolutionDefaultTypeInternal _VideoResolution_default_instance_;
class VideoSourceInfo;
struct VideoSourceInfoDefaultTypeInternal;
extern VideoSourceInfoDefaultTypeInternal _VideoSourceInfo_default_instance_;
class VideoSourceResolution;
struct VideoSourceResolutionDefaultTypeInternal;
extern VideoSourceResolutionDefaultTypeInternal _VideoSourceResolution_default_instance_;
class VideoStreamEOS;
struct VideoStreamEOSDefaultTypeInternal;
extern VideoStreamEOSDefaultTypeInternal _VideoStreamEOS_default_instance_;
class VideoStreamEvent;
struct VideoStreamEventDefaultTypeInternal;
extern VideoStreamEventDefaultTypeInternal _VideoStreamEvent_default_instance_;
class VideoStreamFromParticipantRequest;
struct VideoStreamFromParticipantRequestDefaultTypeInternal;
extern VideoStreamFromParticipantRequestDefaultTypeInternal _VideoStreamFromParticipantRequest_default_instance_;
class VideoStreamFromParticipantResponse;
struct VideoStreamFromParticipantResponseDefaultTypeInternal;
extern VideoStreamFromParticipantResponseDefaultTypeInternal _VideoStreamFromParticipantResponse_default_instance_;
class VideoStreamInfo;
struct VideoStreamInfoDefaultTypeInternal;
extern VideoStreamInfoDefaultTypeInternal _VideoStreamInfo_default_instance_;
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::proto::CaptureVideoFrameRequest* Arena::CreateMaybeMessage<::livekit::proto::CaptureVideoFrameRequest>(Arena*);
template<> ::livekit::proto::CaptureVideoFrameResponse* Arena::CreateMaybeMessage<::livekit::proto::CaptureVideoFrameResponse>(Arena*);
template<> ::livekit::proto::NewVideoSourceRequest* Arena::CreateMaybeMessage<::livekit::proto::NewVideoSourceRequest>(Arena*);
template<> ::livekit::proto::NewVideoSourceResponse* Arena::CreateMaybeMessage<::livekit::proto::NewVideoSourceResponse>(Arena*);
template<> ::livekit::proto::NewVideoStreamRequest* Arena::CreateMaybeMessage<::livekit::proto::NewVideoStreamRequest>(Arena*);
template<> ::livekit::proto::NewVideoStreamResponse* Arena::CreateMaybeMessage<::livekit::proto::NewVideoStreamResponse>(Arena*);
template<> ::livekit::proto::OwnedVideoBuffer* Arena::CreateMaybeMessage<::livekit::proto::OwnedVideoBuffer>(Arena*);
template<> ::livekit::proto::OwnedVideoSource* Arena::CreateMaybeMessage<::livekit::proto::OwnedVideoSource>(Arena*);
template<> ::livekit::proto::OwnedVideoStream* Arena::CreateMaybeMessage<::livekit::proto::OwnedVideoStream>(Arena*);
template<> ::livekit::proto::VideoBufferInfo* Arena::CreateMaybeMessage<::livekit::proto::VideoBufferInfo>(Arena*);
template<> ::livekit::proto::VideoBufferInfo_ComponentInfo* Arena::CreateMaybeMessage<::livekit::proto::VideoBufferInfo_ComponentInfo>(Arena*);
template<> ::livekit::proto::VideoConvertRequest* Arena::CreateMaybeMessage<::livekit::proto::VideoConvertRequest>(Arena*);
template<> ::livekit::proto::VideoConvertResponse* Arena::CreateMaybeMessage<::livekit::proto::VideoConvertResponse>(Arena*);
template<> ::livekit::proto::VideoFrameReceived* Arena::CreateMaybeMessage<::livekit::proto::VideoFrameReceived>(Arena*);
template<> ::livekit::proto::VideoResolution* Arena::CreateMaybeMessage<::livekit::proto::VideoResolution>(Arena*);
template<> ::livekit::proto::VideoSourceInfo* Arena::CreateMaybeMessage<::livekit::proto::VideoSourceInfo>(Arena*);
template<> ::livekit::proto::VideoSourceResolution* Arena::CreateMaybeMessage<::livekit::proto::VideoSourceResolution>(Arena*);
template<> ::livekit::proto::VideoStreamEOS* Arena::CreateMaybeMessage<::livekit::proto::VideoStreamEOS>(Arena*);
template<> ::livekit::proto::VideoStreamEvent* Arena::CreateMaybeMessage<::livekit::proto::VideoStreamEvent>(Arena*);
template<> ::livekit::proto::VideoStreamFromParticipantRequest* Arena::CreateMaybeMessage<::livekit::proto::VideoStreamFromParticipantRequest>(Arena*);
template<> ::livekit::proto::VideoStreamFromParticipantResponse* Arena::CreateMaybeMessage<::livekit::proto::VideoStreamFromParticipantResponse>(Arena*);
template<> ::livekit::proto::VideoStreamInfo* Arena::CreateMaybeMessage<::livekit::proto::VideoStreamInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {
namespace proto {

enum VideoCodec : int {
  VP8 = 0,
  H264 = 1,
  AV1 = 2,
  VP9 = 3
};
bool VideoCodec_IsValid(int value);
constexpr VideoCodec VideoCodec_MIN = VP8;
constexpr VideoCodec VideoCodec_MAX = VP9;
constexpr int VideoCodec_ARRAYSIZE = VideoCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoCodec_descriptor();
template<typename T>
inline const std::string& VideoCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoCodec_descriptor(), enum_t_value);
}
inline bool VideoCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoCodec>(
    VideoCodec_descriptor(), name, value);
}
enum VideoRotation : int {
  VIDEO_ROTATION_0 = 0,
  VIDEO_ROTATION_90 = 1,
  VIDEO_ROTATION_180 = 2,
  VIDEO_ROTATION_270 = 3
};
bool VideoRotation_IsValid(int value);
constexpr VideoRotation VideoRotation_MIN = VIDEO_ROTATION_0;
constexpr VideoRotation VideoRotation_MAX = VIDEO_ROTATION_270;
constexpr int VideoRotation_ARRAYSIZE = VideoRotation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoRotation_descriptor();
template<typename T>
inline const std::string& VideoRotation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoRotation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoRotation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoRotation_descriptor(), enum_t_value);
}
inline bool VideoRotation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoRotation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoRotation>(
    VideoRotation_descriptor(), name, value);
}
enum VideoBufferType : int {
  RGBA = 0,
  ABGR = 1,
  ARGB = 2,
  BGRA = 3,
  RGB24 = 4,
  I420 = 5,
  I420A = 6,
  I422 = 7,
  I444 = 8,
  I010 = 9,
  NV12 = 10
};
bool VideoBufferType_IsValid(int value);
constexpr VideoBufferType VideoBufferType_MIN = RGBA;
constexpr VideoBufferType VideoBufferType_MAX = NV12;
constexpr int VideoBufferType_ARRAYSIZE = VideoBufferType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoBufferType_descriptor();
template<typename T>
inline const std::string& VideoBufferType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoBufferType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoBufferType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoBufferType_descriptor(), enum_t_value);
}
inline bool VideoBufferType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoBufferType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoBufferType>(
    VideoBufferType_descriptor(), name, value);
}
enum VideoStreamType : int {
  VIDEO_STREAM_NATIVE = 0,
  VIDEO_STREAM_WEBGL = 1,
  VIDEO_STREAM_HTML = 2
};
bool VideoStreamType_IsValid(int value);
constexpr VideoStreamType VideoStreamType_MIN = VIDEO_STREAM_NATIVE;
constexpr VideoStreamType VideoStreamType_MAX = VIDEO_STREAM_HTML;
constexpr int VideoStreamType_ARRAYSIZE = VideoStreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoStreamType_descriptor();
template<typename T>
inline const std::string& VideoStreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoStreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoStreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoStreamType_descriptor(), enum_t_value);
}
inline bool VideoStreamType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoStreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoStreamType>(
    VideoStreamType_descriptor(), name, value);
}
enum VideoSourceType : int {
  VIDEO_SOURCE_NATIVE = 0
};
bool VideoSourceType_IsValid(int value);
constexpr VideoSourceType VideoSourceType_MIN = VIDEO_SOURCE_NATIVE;
constexpr VideoSourceType VideoSourceType_MAX = VIDEO_SOURCE_NATIVE;
constexpr int VideoSourceType_ARRAYSIZE = VideoSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoSourceType_descriptor();
template<typename T>
inline const std::string& VideoSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoSourceType_descriptor(), enum_t_value);
}
inline bool VideoSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoSourceType>(
    VideoSourceType_descriptor(), name, value);
}
// ===================================================================

class NewVideoStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewVideoStreamRequest) */ {
 public:
  inline NewVideoStreamRequest() : NewVideoStreamRequest(nullptr) {}
  ~NewVideoStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR NewVideoStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewVideoStreamRequest(const NewVideoStreamRequest& from);
  NewVideoStreamRequest(NewVideoStreamRequest&& from) noexcept
    : NewVideoStreamRequest() {
    *this = ::std::move(from);
  }

  inline NewVideoStreamRequest& operator=(const NewVideoStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewVideoStreamRequest& operator=(NewVideoStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewVideoStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewVideoStreamRequest* internal_default_instance() {
    return reinterpret_cast<const NewVideoStreamRequest*>(
               &_NewVideoStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NewVideoStreamRequest& a, NewVideoStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewVideoStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewVideoStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewVideoStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewVideoStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewVideoStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewVideoStreamRequest& from) {
    NewVideoStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewVideoStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewVideoStreamRequest";
  }
  protected:
  explicit NewVideoStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackHandleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kFormatFieldNumber = 3,
    kNormalizeStrideFieldNumber = 4,
  };
  // required uint64 track_handle = 1;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // required .livekit.proto.VideoStreamType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoStreamType type() const;
  void set_type(::livekit::proto::VideoStreamType value);
  private:
  ::livekit::proto::VideoStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoStreamType value);
  public:

  // optional .livekit.proto.VideoBufferType format = 3;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::livekit::proto::VideoBufferType format() const;
  void set_format(::livekit::proto::VideoBufferType value);
  private:
  ::livekit::proto::VideoBufferType _internal_format() const;
  void _internal_set_format(::livekit::proto::VideoBufferType value);
  public:

  // optional bool normalize_stride = 4;
  bool has_normalize_stride() const;
  private:
  bool _internal_has_normalize_stride() const;
  public:
  void clear_normalize_stride();
  bool normalize_stride() const;
  void set_normalize_stride(bool value);
  private:
  bool _internal_normalize_stride() const;
  void _internal_set_normalize_stride(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewVideoStreamRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t track_handle_;
    int type_;
    int format_;
    bool normalize_stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewVideoStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewVideoStreamResponse) */ {
 public:
  inline NewVideoStreamResponse() : NewVideoStreamResponse(nullptr) {}
  ~NewVideoStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR NewVideoStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewVideoStreamResponse(const NewVideoStreamResponse& from);
  NewVideoStreamResponse(NewVideoStreamResponse&& from) noexcept
    : NewVideoStreamResponse() {
    *this = ::std::move(from);
  }

  inline NewVideoStreamResponse& operator=(const NewVideoStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewVideoStreamResponse& operator=(NewVideoStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewVideoStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewVideoStreamResponse* internal_default_instance() {
    return reinterpret_cast<const NewVideoStreamResponse*>(
               &_NewVideoStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NewVideoStreamResponse& a, NewVideoStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewVideoStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewVideoStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewVideoStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewVideoStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewVideoStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewVideoStreamResponse& from) {
    NewVideoStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewVideoStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewVideoStreamResponse";
  }
  protected:
  explicit NewVideoStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
  };
  // required .livekit.proto.OwnedVideoStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::livekit::proto::OwnedVideoStream& stream() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedVideoStream* release_stream();
  ::livekit::proto::OwnedVideoStream* mutable_stream();
  void set_allocated_stream(::livekit::proto::OwnedVideoStream* stream);
  private:
  const ::livekit::proto::OwnedVideoStream& _internal_stream() const;
  ::livekit::proto::OwnedVideoStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::livekit::proto::OwnedVideoStream* stream);
  ::livekit::proto::OwnedVideoStream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewVideoStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedVideoStream* stream_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoStreamFromParticipantRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoStreamFromParticipantRequest) */ {
 public:
  inline VideoStreamFromParticipantRequest() : VideoStreamFromParticipantRequest(nullptr) {}
  ~VideoStreamFromParticipantRequest() override;
  explicit PROTOBUF_CONSTEXPR VideoStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamFromParticipantRequest(const VideoStreamFromParticipantRequest& from);
  VideoStreamFromParticipantRequest(VideoStreamFromParticipantRequest&& from) noexcept
    : VideoStreamFromParticipantRequest() {
    *this = ::std::move(from);
  }

  inline VideoStreamFromParticipantRequest& operator=(const VideoStreamFromParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamFromParticipantRequest& operator=(VideoStreamFromParticipantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamFromParticipantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamFromParticipantRequest* internal_default_instance() {
    return reinterpret_cast<const VideoStreamFromParticipantRequest*>(
               &_VideoStreamFromParticipantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VideoStreamFromParticipantRequest& a, VideoStreamFromParticipantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamFromParticipantRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamFromParticipantRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamFromParticipantRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamFromParticipantRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamFromParticipantRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamFromParticipantRequest& from) {
    VideoStreamFromParticipantRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamFromParticipantRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoStreamFromParticipantRequest";
  }
  protected:
  explicit VideoStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantHandleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kTrackSourceFieldNumber = 3,
    kFormatFieldNumber = 4,
    kNormalizeStrideFieldNumber = 5,
  };
  // required uint64 participant_handle = 1;
  bool has_participant_handle() const;
  private:
  bool _internal_has_participant_handle() const;
  public:
  void clear_participant_handle();
  uint64_t participant_handle() const;
  void set_participant_handle(uint64_t value);
  private:
  uint64_t _internal_participant_handle() const;
  void _internal_set_participant_handle(uint64_t value);
  public:

  // required .livekit.proto.VideoStreamType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoStreamType type() const;
  void set_type(::livekit::proto::VideoStreamType value);
  private:
  ::livekit::proto::VideoStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoStreamType value);
  public:

  // required .livekit.proto.TrackSource track_source = 3;
  bool has_track_source() const;
  private:
  bool _internal_has_track_source() const;
  public:
  void clear_track_source();
  ::livekit::proto::TrackSource track_source() const;
  void set_track_source(::livekit::proto::TrackSource value);
  private:
  ::livekit::proto::TrackSource _internal_track_source() const;
  void _internal_set_track_source(::livekit::proto::TrackSource value);
  public:

  // optional .livekit.proto.VideoBufferType format = 4;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::livekit::proto::VideoBufferType format() const;
  void set_format(::livekit::proto::VideoBufferType value);
  private:
  ::livekit::proto::VideoBufferType _internal_format() const;
  void _internal_set_format(::livekit::proto::VideoBufferType value);
  public:

  // optional bool normalize_stride = 5;
  bool has_normalize_stride() const;
  private:
  bool _internal_has_normalize_stride() const;
  public:
  void clear_normalize_stride();
  bool normalize_stride() const;
  void set_normalize_stride(bool value);
  private:
  bool _internal_normalize_stride() const;
  void _internal_set_normalize_stride(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoStreamFromParticipantRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t participant_handle_;
    int type_;
    int track_source_;
    int format_;
    bool normalize_stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoStreamFromParticipantResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoStreamFromParticipantResponse) */ {
 public:
  inline VideoStreamFromParticipantResponse() : VideoStreamFromParticipantResponse(nullptr) {}
  ~VideoStreamFromParticipantResponse() override;
  explicit PROTOBUF_CONSTEXPR VideoStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamFromParticipantResponse(const VideoStreamFromParticipantResponse& from);
  VideoStreamFromParticipantResponse(VideoStreamFromParticipantResponse&& from) noexcept
    : VideoStreamFromParticipantResponse() {
    *this = ::std::move(from);
  }

  inline VideoStreamFromParticipantResponse& operator=(const VideoStreamFromParticipantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamFromParticipantResponse& operator=(VideoStreamFromParticipantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamFromParticipantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamFromParticipantResponse* internal_default_instance() {
    return reinterpret_cast<const VideoStreamFromParticipantResponse*>(
               &_VideoStreamFromParticipantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VideoStreamFromParticipantResponse& a, VideoStreamFromParticipantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamFromParticipantResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamFromParticipantResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamFromParticipantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamFromParticipantResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamFromParticipantResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamFromParticipantResponse& from) {
    VideoStreamFromParticipantResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamFromParticipantResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoStreamFromParticipantResponse";
  }
  protected:
  explicit VideoStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
  };
  // required .livekit.proto.OwnedVideoStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::livekit::proto::OwnedVideoStream& stream() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedVideoStream* release_stream();
  ::livekit::proto::OwnedVideoStream* mutable_stream();
  void set_allocated_stream(::livekit::proto::OwnedVideoStream* stream);
  private:
  const ::livekit::proto::OwnedVideoStream& _internal_stream() const;
  ::livekit::proto::OwnedVideoStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::livekit::proto::OwnedVideoStream* stream);
  ::livekit::proto::OwnedVideoStream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoStreamFromParticipantResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedVideoStream* stream_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewVideoSourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewVideoSourceRequest) */ {
 public:
  inline NewVideoSourceRequest() : NewVideoSourceRequest(nullptr) {}
  ~NewVideoSourceRequest() override;
  explicit PROTOBUF_CONSTEXPR NewVideoSourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewVideoSourceRequest(const NewVideoSourceRequest& from);
  NewVideoSourceRequest(NewVideoSourceRequest&& from) noexcept
    : NewVideoSourceRequest() {
    *this = ::std::move(from);
  }

  inline NewVideoSourceRequest& operator=(const NewVideoSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewVideoSourceRequest& operator=(NewVideoSourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewVideoSourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewVideoSourceRequest* internal_default_instance() {
    return reinterpret_cast<const NewVideoSourceRequest*>(
               &_NewVideoSourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewVideoSourceRequest& a, NewVideoSourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewVideoSourceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewVideoSourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewVideoSourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewVideoSourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewVideoSourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewVideoSourceRequest& from) {
    NewVideoSourceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewVideoSourceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewVideoSourceRequest";
  }
  protected:
  explicit NewVideoSourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResolutionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required .livekit.proto.VideoSourceResolution resolution = 2;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::livekit::proto::VideoSourceResolution& resolution() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoSourceResolution* release_resolution();
  ::livekit::proto::VideoSourceResolution* mutable_resolution();
  void set_allocated_resolution(::livekit::proto::VideoSourceResolution* resolution);
  private:
  const ::livekit::proto::VideoSourceResolution& _internal_resolution() const;
  ::livekit::proto::VideoSourceResolution* _internal_mutable_resolution();
  public:
  void unsafe_arena_set_allocated_resolution(
      ::livekit::proto::VideoSourceResolution* resolution);
  ::livekit::proto::VideoSourceResolution* unsafe_arena_release_resolution();

  // required .livekit.proto.VideoSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoSourceType type() const;
  void set_type(::livekit::proto::VideoSourceType value);
  private:
  ::livekit::proto::VideoSourceType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewVideoSourceRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::VideoSourceResolution* resolution_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewVideoSourceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewVideoSourceResponse) */ {
 public:
  inline NewVideoSourceResponse() : NewVideoSourceResponse(nullptr) {}
  ~NewVideoSourceResponse() override;
  explicit PROTOBUF_CONSTEXPR NewVideoSourceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewVideoSourceResponse(const NewVideoSourceResponse& from);
  NewVideoSourceResponse(NewVideoSourceResponse&& from) noexcept
    : NewVideoSourceResponse() {
    *this = ::std::move(from);
  }

  inline NewVideoSourceResponse& operator=(const NewVideoSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewVideoSourceResponse& operator=(NewVideoSourceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewVideoSourceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewVideoSourceResponse* internal_default_instance() {
    return reinterpret_cast<const NewVideoSourceResponse*>(
               &_NewVideoSourceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewVideoSourceResponse& a, NewVideoSourceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewVideoSourceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewVideoSourceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewVideoSourceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewVideoSourceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewVideoSourceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewVideoSourceResponse& from) {
    NewVideoSourceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewVideoSourceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewVideoSourceResponse";
  }
  protected:
  explicit NewVideoSourceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
  };
  // required .livekit.proto.OwnedVideoSource source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::livekit::proto::OwnedVideoSource& source() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedVideoSource* release_source();
  ::livekit::proto::OwnedVideoSource* mutable_source();
  void set_allocated_source(::livekit::proto::OwnedVideoSource* source);
  private:
  const ::livekit::proto::OwnedVideoSource& _internal_source() const;
  ::livekit::proto::OwnedVideoSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::livekit::proto::OwnedVideoSource* source);
  ::livekit::proto::OwnedVideoSource* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewVideoSourceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedVideoSource* source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class CaptureVideoFrameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CaptureVideoFrameRequest) */ {
 public:
  inline CaptureVideoFrameRequest() : CaptureVideoFrameRequest(nullptr) {}
  ~CaptureVideoFrameRequest() override;
  explicit PROTOBUF_CONSTEXPR CaptureVideoFrameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureVideoFrameRequest(const CaptureVideoFrameRequest& from);
  CaptureVideoFrameRequest(CaptureVideoFrameRequest&& from) noexcept
    : CaptureVideoFrameRequest() {
    *this = ::std::move(from);
  }

  inline CaptureVideoFrameRequest& operator=(const CaptureVideoFrameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureVideoFrameRequest& operator=(CaptureVideoFrameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureVideoFrameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureVideoFrameRequest* internal_default_instance() {
    return reinterpret_cast<const CaptureVideoFrameRequest*>(
               &_CaptureVideoFrameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CaptureVideoFrameRequest& a, CaptureVideoFrameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureVideoFrameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureVideoFrameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureVideoFrameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureVideoFrameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureVideoFrameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureVideoFrameRequest& from) {
    CaptureVideoFrameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureVideoFrameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CaptureVideoFrameRequest";
  }
  protected:
  explicit CaptureVideoFrameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kSourceHandleFieldNumber = 1,
    kTimestampUsFieldNumber = 3,
    kRotationFieldNumber = 4,
  };
  // required .livekit.proto.VideoBufferInfo buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::VideoBufferInfo& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoBufferInfo* release_buffer();
  ::livekit::proto::VideoBufferInfo* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::VideoBufferInfo* buffer);
  private:
  const ::livekit::proto::VideoBufferInfo& _internal_buffer() const;
  ::livekit::proto::VideoBufferInfo* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::VideoBufferInfo* buffer);
  ::livekit::proto::VideoBufferInfo* unsafe_arena_release_buffer();

  // required uint64 source_handle = 1;
  bool has_source_handle() const;
  private:
  bool _internal_has_source_handle() const;
  public:
  void clear_source_handle();
  uint64_t source_handle() const;
  void set_source_handle(uint64_t value);
  private:
  uint64_t _internal_source_handle() const;
  void _internal_set_source_handle(uint64_t value);
  public:

  // required int64 timestamp_us = 3;
  bool has_timestamp_us() const;
  private:
  bool _internal_has_timestamp_us() const;
  public:
  void clear_timestamp_us();
  int64_t timestamp_us() const;
  void set_timestamp_us(int64_t value);
  private:
  int64_t _internal_timestamp_us() const;
  void _internal_set_timestamp_us(int64_t value);
  public:

  // required .livekit.proto.VideoRotation rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  ::livekit::proto::VideoRotation rotation() const;
  void set_rotation(::livekit::proto::VideoRotation value);
  private:
  ::livekit::proto::VideoRotation _internal_rotation() const;
  void _internal_set_rotation(::livekit::proto::VideoRotation value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CaptureVideoFrameRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::VideoBufferInfo* buffer_;
    uint64_t source_handle_;
    int64_t timestamp_us_;
    int rotation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class CaptureVideoFrameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.CaptureVideoFrameResponse) */ {
 public:
  inline CaptureVideoFrameResponse() : CaptureVideoFrameResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CaptureVideoFrameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureVideoFrameResponse(const CaptureVideoFrameResponse& from);
  CaptureVideoFrameResponse(CaptureVideoFrameResponse&& from) noexcept
    : CaptureVideoFrameResponse() {
    *this = ::std::move(from);
  }

  inline CaptureVideoFrameResponse& operator=(const CaptureVideoFrameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureVideoFrameResponse& operator=(CaptureVideoFrameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureVideoFrameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureVideoFrameResponse* internal_default_instance() {
    return reinterpret_cast<const CaptureVideoFrameResponse*>(
               &_CaptureVideoFrameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CaptureVideoFrameResponse& a, CaptureVideoFrameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureVideoFrameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureVideoFrameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureVideoFrameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureVideoFrameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CaptureVideoFrameResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CaptureVideoFrameResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CaptureVideoFrameResponse";
  }
  protected:
  explicit CaptureVideoFrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.CaptureVideoFrameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoConvertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoConvertRequest) */ {
 public:
  inline VideoConvertRequest() : VideoConvertRequest(nullptr) {}
  ~VideoConvertRequest() override;
  explicit PROTOBUF_CONSTEXPR VideoConvertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoConvertRequest(const VideoConvertRequest& from);
  VideoConvertRequest(VideoConvertRequest&& from) noexcept
    : VideoConvertRequest() {
    *this = ::std::move(from);
  }

  inline VideoConvertRequest& operator=(const VideoConvertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoConvertRequest& operator=(VideoConvertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoConvertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoConvertRequest* internal_default_instance() {
    return reinterpret_cast<const VideoConvertRequest*>(
               &_VideoConvertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VideoConvertRequest& a, VideoConvertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoConvertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoConvertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoConvertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoConvertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoConvertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoConvertRequest& from) {
    VideoConvertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoConvertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoConvertRequest";
  }
  protected:
  explicit VideoConvertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kFlipYFieldNumber = 1,
    kDstTypeFieldNumber = 3,
  };
  // required .livekit.proto.VideoBufferInfo buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::VideoBufferInfo& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoBufferInfo* release_buffer();
  ::livekit::proto::VideoBufferInfo* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::VideoBufferInfo* buffer);
  private:
  const ::livekit::proto::VideoBufferInfo& _internal_buffer() const;
  ::livekit::proto::VideoBufferInfo* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::VideoBufferInfo* buffer);
  ::livekit::proto::VideoBufferInfo* unsafe_arena_release_buffer();

  // optional bool flip_y = 1;
  bool has_flip_y() const;
  private:
  bool _internal_has_flip_y() const;
  public:
  void clear_flip_y();
  bool flip_y() const;
  void set_flip_y(bool value);
  private:
  bool _internal_flip_y() const;
  void _internal_set_flip_y(bool value);
  public:

  // required .livekit.proto.VideoBufferType dst_type = 3;
  bool has_dst_type() const;
  private:
  bool _internal_has_dst_type() const;
  public:
  void clear_dst_type();
  ::livekit::proto::VideoBufferType dst_type() const;
  void set_dst_type(::livekit::proto::VideoBufferType value);
  private:
  ::livekit::proto::VideoBufferType _internal_dst_type() const;
  void _internal_set_dst_type(::livekit::proto::VideoBufferType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoConvertRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::VideoBufferInfo* buffer_;
    bool flip_y_;
    int dst_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoConvertResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoConvertResponse) */ {
 public:
  inline VideoConvertResponse() : VideoConvertResponse(nullptr) {}
  ~VideoConvertResponse() override;
  explicit PROTOBUF_CONSTEXPR VideoConvertResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoConvertResponse(const VideoConvertResponse& from);
  VideoConvertResponse(VideoConvertResponse&& from) noexcept
    : VideoConvertResponse() {
    *this = ::std::move(from);
  }

  inline VideoConvertResponse& operator=(const VideoConvertResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoConvertResponse& operator=(VideoConvertResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoConvertResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 1,
    kBuffer = 2,
    MESSAGE_NOT_SET = 0,
  };

  static inline const VideoConvertResponse* internal_default_instance() {
    return reinterpret_cast<const VideoConvertResponse*>(
               &_VideoConvertResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VideoConvertResponse& a, VideoConvertResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoConvertResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoConvertResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoConvertResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoConvertResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoConvertResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoConvertResponse& from) {
    VideoConvertResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoConvertResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoConvertResponse";
  }
  protected:
  explicit VideoConvertResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kBufferFieldNumber = 2,
  };
  // string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.proto.OwnedVideoBuffer buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::OwnedVideoBuffer& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedVideoBuffer* release_buffer();
  ::livekit::proto::OwnedVideoBuffer* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::OwnedVideoBuffer* buffer);
  private:
  const ::livekit::proto::OwnedVideoBuffer& _internal_buffer() const;
  ::livekit::proto::OwnedVideoBuffer* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::OwnedVideoBuffer* buffer);
  ::livekit::proto::OwnedVideoBuffer* unsafe_arena_release_buffer();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.VideoConvertResponse)
 private:
  class _Internal;
  void set_has_error();
  void set_has_buffer();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::livekit::proto::OwnedVideoBuffer* buffer_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoResolution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoResolution) */ {
 public:
  inline VideoResolution() : VideoResolution(nullptr) {}
  ~VideoResolution() override;
  explicit PROTOBUF_CONSTEXPR VideoResolution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoResolution(const VideoResolution& from);
  VideoResolution(VideoResolution&& from) noexcept
    : VideoResolution() {
    *this = ::std::move(from);
  }

  inline VideoResolution& operator=(const VideoResolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoResolution& operator=(VideoResolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoResolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoResolution* internal_default_instance() {
    return reinterpret_cast<const VideoResolution*>(
               &_VideoResolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VideoResolution& a, VideoResolution& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoResolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoResolution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoResolution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoResolution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoResolution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoResolution& from) {
    VideoResolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoResolution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoResolution";
  }
  protected:
  explicit VideoResolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFrameRateFieldNumber = 3,
  };
  // required uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // required uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // required double frame_rate = 3;
  bool has_frame_rate() const;
  private:
  bool _internal_has_frame_rate() const;
  public:
  void clear_frame_rate();
  double frame_rate() const;
  void set_frame_rate(double value);
  private:
  double _internal_frame_rate() const;
  void _internal_set_frame_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoResolution)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t width_;
    uint32_t height_;
    double frame_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoBufferInfo_ComponentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoBufferInfo.ComponentInfo) */ {
 public:
  inline VideoBufferInfo_ComponentInfo() : VideoBufferInfo_ComponentInfo(nullptr) {}
  ~VideoBufferInfo_ComponentInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoBufferInfo_ComponentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoBufferInfo_ComponentInfo(const VideoBufferInfo_ComponentInfo& from);
  VideoBufferInfo_ComponentInfo(VideoBufferInfo_ComponentInfo&& from) noexcept
    : VideoBufferInfo_ComponentInfo() {
    *this = ::std::move(from);
  }

  inline VideoBufferInfo_ComponentInfo& operator=(const VideoBufferInfo_ComponentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoBufferInfo_ComponentInfo& operator=(VideoBufferInfo_ComponentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoBufferInfo_ComponentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoBufferInfo_ComponentInfo* internal_default_instance() {
    return reinterpret_cast<const VideoBufferInfo_ComponentInfo*>(
               &_VideoBufferInfo_ComponentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VideoBufferInfo_ComponentInfo& a, VideoBufferInfo_ComponentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoBufferInfo_ComponentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoBufferInfo_ComponentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoBufferInfo_ComponentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoBufferInfo_ComponentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoBufferInfo_ComponentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoBufferInfo_ComponentInfo& from) {
    VideoBufferInfo_ComponentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoBufferInfo_ComponentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoBufferInfo.ComponentInfo";
  }
  protected:
  explicit VideoBufferInfo_ComponentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPtrFieldNumber = 1,
    kStrideFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // required uint64 data_ptr = 1;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 stride = 2;
  bool has_stride() const;
  private:
  bool _internal_has_stride() const;
  public:
  void clear_stride();
  uint32_t stride() const;
  void set_stride(uint32_t value);
  private:
  uint32_t _internal_stride() const;
  void _internal_set_stride(uint32_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoBufferInfo.ComponentInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t data_ptr_;
    uint32_t stride_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoBufferInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoBufferInfo) */ {
 public:
  inline VideoBufferInfo() : VideoBufferInfo(nullptr) {}
  ~VideoBufferInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoBufferInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoBufferInfo(const VideoBufferInfo& from);
  VideoBufferInfo(VideoBufferInfo&& from) noexcept
    : VideoBufferInfo() {
    *this = ::std::move(from);
  }

  inline VideoBufferInfo& operator=(const VideoBufferInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoBufferInfo& operator=(VideoBufferInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoBufferInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoBufferInfo* internal_default_instance() {
    return reinterpret_cast<const VideoBufferInfo*>(
               &_VideoBufferInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VideoBufferInfo& a, VideoBufferInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoBufferInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoBufferInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoBufferInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoBufferInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoBufferInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoBufferInfo& from) {
    VideoBufferInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoBufferInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoBufferInfo";
  }
  protected:
  explicit VideoBufferInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VideoBufferInfo_ComponentInfo ComponentInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kComponentsFieldNumber = 7,
    kTypeFieldNumber = 1,
    kWidthFieldNumber = 2,
    kDataPtrFieldNumber = 4,
    kHeightFieldNumber = 3,
    kStrideFieldNumber = 6,
  };
  // repeated .livekit.proto.VideoBufferInfo.ComponentInfo components = 7;
  int components_size() const;
  private:
  int _internal_components_size() const;
  public:
  void clear_components();
  ::livekit::proto::VideoBufferInfo_ComponentInfo* mutable_components(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::VideoBufferInfo_ComponentInfo >*
      mutable_components();
  private:
  const ::livekit::proto::VideoBufferInfo_ComponentInfo& _internal_components(int index) const;
  ::livekit::proto::VideoBufferInfo_ComponentInfo* _internal_add_components();
  public:
  const ::livekit::proto::VideoBufferInfo_ComponentInfo& components(int index) const;
  ::livekit::proto::VideoBufferInfo_ComponentInfo* add_components();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::VideoBufferInfo_ComponentInfo >&
      components() const;

  // required .livekit.proto.VideoBufferType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoBufferType type() const;
  void set_type(::livekit::proto::VideoBufferType value);
  private:
  ::livekit::proto::VideoBufferType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoBufferType value);
  public:

  // required uint32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // required uint64 data_ptr = 4;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 stride = 6;
  bool has_stride() const;
  private:
  bool _internal_has_stride() const;
  public:
  void clear_stride();
  uint32_t stride() const;
  void set_stride(uint32_t value);
  private:
  uint32_t _internal_stride() const;
  void _internal_set_stride(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoBufferInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::VideoBufferInfo_ComponentInfo > components_;
    int type_;
    uint32_t width_;
    uint64_t data_ptr_;
    uint32_t height_;
    uint32_t stride_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedVideoBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedVideoBuffer) */ {
 public:
  inline OwnedVideoBuffer() : OwnedVideoBuffer(nullptr) {}
  ~OwnedVideoBuffer() override;
  explicit PROTOBUF_CONSTEXPR OwnedVideoBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedVideoBuffer(const OwnedVideoBuffer& from);
  OwnedVideoBuffer(OwnedVideoBuffer&& from) noexcept
    : OwnedVideoBuffer() {
    *this = ::std::move(from);
  }

  inline OwnedVideoBuffer& operator=(const OwnedVideoBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedVideoBuffer& operator=(OwnedVideoBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedVideoBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedVideoBuffer* internal_default_instance() {
    return reinterpret_cast<const OwnedVideoBuffer*>(
               &_OwnedVideoBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(OwnedVideoBuffer& a, OwnedVideoBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedVideoBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedVideoBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedVideoBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedVideoBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedVideoBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedVideoBuffer& from) {
    OwnedVideoBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedVideoBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedVideoBuffer";
  }
  protected:
  explicit OwnedVideoBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.VideoBufferInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::VideoBufferInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoBufferInfo* release_info();
  ::livekit::proto::VideoBufferInfo* mutable_info();
  void set_allocated_info(::livekit::proto::VideoBufferInfo* info);
  private:
  const ::livekit::proto::VideoBufferInfo& _internal_info() const;
  ::livekit::proto::VideoBufferInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::VideoBufferInfo* info);
  ::livekit::proto::VideoBufferInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedVideoBuffer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::VideoBufferInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoStreamInfo) */ {
 public:
  inline VideoStreamInfo() : VideoStreamInfo(nullptr) {}
  ~VideoStreamInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamInfo(const VideoStreamInfo& from);
  VideoStreamInfo(VideoStreamInfo&& from) noexcept
    : VideoStreamInfo() {
    *this = ::std::move(from);
  }

  inline VideoStreamInfo& operator=(const VideoStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamInfo& operator=(VideoStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamInfo* internal_default_instance() {
    return reinterpret_cast<const VideoStreamInfo*>(
               &_VideoStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VideoStreamInfo& a, VideoStreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamInfo& from) {
    VideoStreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoStreamInfo";
  }
  protected:
  explicit VideoStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .livekit.proto.VideoStreamType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoStreamType type() const;
  void set_type(::livekit::proto::VideoStreamType value);
  private:
  ::livekit::proto::VideoStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoStreamType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedVideoStream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedVideoStream) */ {
 public:
  inline OwnedVideoStream() : OwnedVideoStream(nullptr) {}
  ~OwnedVideoStream() override;
  explicit PROTOBUF_CONSTEXPR OwnedVideoStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedVideoStream(const OwnedVideoStream& from);
  OwnedVideoStream(OwnedVideoStream&& from) noexcept
    : OwnedVideoStream() {
    *this = ::std::move(from);
  }

  inline OwnedVideoStream& operator=(const OwnedVideoStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedVideoStream& operator=(OwnedVideoStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedVideoStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedVideoStream* internal_default_instance() {
    return reinterpret_cast<const OwnedVideoStream*>(
               &_OwnedVideoStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(OwnedVideoStream& a, OwnedVideoStream& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedVideoStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedVideoStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedVideoStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedVideoStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedVideoStream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedVideoStream& from) {
    OwnedVideoStream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedVideoStream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedVideoStream";
  }
  protected:
  explicit OwnedVideoStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.VideoStreamInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::VideoStreamInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoStreamInfo* release_info();
  ::livekit::proto::VideoStreamInfo* mutable_info();
  void set_allocated_info(::livekit::proto::VideoStreamInfo* info);
  private:
  const ::livekit::proto::VideoStreamInfo& _internal_info() const;
  ::livekit::proto::VideoStreamInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::VideoStreamInfo* info);
  ::livekit::proto::VideoStreamInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedVideoStream)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::VideoStreamInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoStreamEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoStreamEvent) */ {
 public:
  inline VideoStreamEvent() : VideoStreamEvent(nullptr) {}
  ~VideoStreamEvent() override;
  explicit PROTOBUF_CONSTEXPR VideoStreamEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamEvent(const VideoStreamEvent& from);
  VideoStreamEvent(VideoStreamEvent&& from) noexcept
    : VideoStreamEvent() {
    *this = ::std::move(from);
  }

  inline VideoStreamEvent& operator=(const VideoStreamEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamEvent& operator=(VideoStreamEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamEvent& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kFrameReceived = 2,
    kEos = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const VideoStreamEvent* internal_default_instance() {
    return reinterpret_cast<const VideoStreamEvent*>(
               &_VideoStreamEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VideoStreamEvent& a, VideoStreamEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamEvent& from) {
    VideoStreamEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoStreamEvent";
  }
  protected:
  explicit VideoStreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamHandleFieldNumber = 1,
    kFrameReceivedFieldNumber = 2,
    kEosFieldNumber = 3,
  };
  // required uint64 stream_handle = 1;
  bool has_stream_handle() const;
  private:
  bool _internal_has_stream_handle() const;
  public:
  void clear_stream_handle();
  uint64_t stream_handle() const;
  void set_stream_handle(uint64_t value);
  private:
  uint64_t _internal_stream_handle() const;
  void _internal_set_stream_handle(uint64_t value);
  public:

  // .livekit.proto.VideoFrameReceived frame_received = 2;
  bool has_frame_received() const;
  private:
  bool _internal_has_frame_received() const;
  public:
  void clear_frame_received();
  const ::livekit::proto::VideoFrameReceived& frame_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoFrameReceived* release_frame_received();
  ::livekit::proto::VideoFrameReceived* mutable_frame_received();
  void set_allocated_frame_received(::livekit::proto::VideoFrameReceived* frame_received);
  private:
  const ::livekit::proto::VideoFrameReceived& _internal_frame_received() const;
  ::livekit::proto::VideoFrameReceived* _internal_mutable_frame_received();
  public:
  void unsafe_arena_set_allocated_frame_received(
      ::livekit::proto::VideoFrameReceived* frame_received);
  ::livekit::proto::VideoFrameReceived* unsafe_arena_release_frame_received();

  // .livekit.proto.VideoStreamEOS eos = 3;
  bool has_eos() const;
  private:
  bool _internal_has_eos() const;
  public:
  void clear_eos();
  const ::livekit::proto::VideoStreamEOS& eos() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoStreamEOS* release_eos();
  ::livekit::proto::VideoStreamEOS* mutable_eos();
  void set_allocated_eos(::livekit::proto::VideoStreamEOS* eos);
  private:
  const ::livekit::proto::VideoStreamEOS& _internal_eos() const;
  ::livekit::proto::VideoStreamEOS* _internal_mutable_eos();
  public:
  void unsafe_arena_set_allocated_eos(
      ::livekit::proto::VideoStreamEOS* eos);
  ::livekit::proto::VideoStreamEOS* unsafe_arena_release_eos();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.VideoStreamEvent)
 private:
  class _Internal;
  void set_has_frame_received();
  void set_has_eos();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t stream_handle_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::VideoFrameReceived* frame_received_;
      ::livekit::proto::VideoStreamEOS* eos_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoFrameReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoFrameReceived) */ {
 public:
  inline VideoFrameReceived() : VideoFrameReceived(nullptr) {}
  ~VideoFrameReceived() override;
  explicit PROTOBUF_CONSTEXPR VideoFrameReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoFrameReceived(const VideoFrameReceived& from);
  VideoFrameReceived(VideoFrameReceived&& from) noexcept
    : VideoFrameReceived() {
    *this = ::std::move(from);
  }

  inline VideoFrameReceived& operator=(const VideoFrameReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFrameReceived& operator=(VideoFrameReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoFrameReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoFrameReceived* internal_default_instance() {
    return reinterpret_cast<const VideoFrameReceived*>(
               &_VideoFrameReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VideoFrameReceived& a, VideoFrameReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFrameReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFrameReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoFrameReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoFrameReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoFrameReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoFrameReceived& from) {
    VideoFrameReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoFrameReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoFrameReceived";
  }
  protected:
  explicit VideoFrameReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
    kTimestampUsFieldNumber = 2,
    kRotationFieldNumber = 3,
  };
  // required .livekit.proto.OwnedVideoBuffer buffer = 1;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::OwnedVideoBuffer& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedVideoBuffer* release_buffer();
  ::livekit::proto::OwnedVideoBuffer* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::OwnedVideoBuffer* buffer);
  private:
  const ::livekit::proto::OwnedVideoBuffer& _internal_buffer() const;
  ::livekit::proto::OwnedVideoBuffer* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::OwnedVideoBuffer* buffer);
  ::livekit::proto::OwnedVideoBuffer* unsafe_arena_release_buffer();

  // required int64 timestamp_us = 2;
  bool has_timestamp_us() const;
  private:
  bool _internal_has_timestamp_us() const;
  public:
  void clear_timestamp_us();
  int64_t timestamp_us() const;
  void set_timestamp_us(int64_t value);
  private:
  int64_t _internal_timestamp_us() const;
  void _internal_set_timestamp_us(int64_t value);
  public:

  // required .livekit.proto.VideoRotation rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  ::livekit::proto::VideoRotation rotation() const;
  void set_rotation(::livekit::proto::VideoRotation value);
  private:
  ::livekit::proto::VideoRotation _internal_rotation() const;
  void _internal_set_rotation(::livekit::proto::VideoRotation value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoFrameReceived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedVideoBuffer* buffer_;
    int64_t timestamp_us_;
    int rotation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoStreamEOS final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.VideoStreamEOS) */ {
 public:
  inline VideoStreamEOS() : VideoStreamEOS(nullptr) {}
  explicit PROTOBUF_CONSTEXPR VideoStreamEOS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamEOS(const VideoStreamEOS& from);
  VideoStreamEOS(VideoStreamEOS&& from) noexcept
    : VideoStreamEOS() {
    *this = ::std::move(from);
  }

  inline VideoStreamEOS& operator=(const VideoStreamEOS& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamEOS& operator=(VideoStreamEOS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamEOS& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamEOS* internal_default_instance() {
    return reinterpret_cast<const VideoStreamEOS*>(
               &_VideoStreamEOS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VideoStreamEOS& a, VideoStreamEOS& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamEOS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamEOS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamEOS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamEOS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VideoStreamEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VideoStreamEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoStreamEOS";
  }
  protected:
  explicit VideoStreamEOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoStreamEOS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoSourceResolution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoSourceResolution) */ {
 public:
  inline VideoSourceResolution() : VideoSourceResolution(nullptr) {}
  ~VideoSourceResolution() override;
  explicit PROTOBUF_CONSTEXPR VideoSourceResolution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoSourceResolution(const VideoSourceResolution& from);
  VideoSourceResolution(VideoSourceResolution&& from) noexcept
    : VideoSourceResolution() {
    *this = ::std::move(from);
  }

  inline VideoSourceResolution& operator=(const VideoSourceResolution& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSourceResolution& operator=(VideoSourceResolution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoSourceResolution& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoSourceResolution* internal_default_instance() {
    return reinterpret_cast<const VideoSourceResolution*>(
               &_VideoSourceResolution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VideoSourceResolution& a, VideoSourceResolution& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSourceResolution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSourceResolution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoSourceResolution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoSourceResolution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoSourceResolution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoSourceResolution& from) {
    VideoSourceResolution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoSourceResolution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoSourceResolution";
  }
  protected:
  explicit VideoSourceResolution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // required uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // required uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoSourceResolution)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t width_;
    uint32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class VideoSourceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoSourceInfo) */ {
 public:
  inline VideoSourceInfo() : VideoSourceInfo(nullptr) {}
  ~VideoSourceInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoSourceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoSourceInfo(const VideoSourceInfo& from);
  VideoSourceInfo(VideoSourceInfo&& from) noexcept
    : VideoSourceInfo() {
    *this = ::std::move(from);
  }

  inline VideoSourceInfo& operator=(const VideoSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSourceInfo& operator=(VideoSourceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoSourceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoSourceInfo* internal_default_instance() {
    return reinterpret_cast<const VideoSourceInfo*>(
               &_VideoSourceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VideoSourceInfo& a, VideoSourceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSourceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSourceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoSourceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoSourceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoSourceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoSourceInfo& from) {
    VideoSourceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoSourceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoSourceInfo";
  }
  protected:
  explicit VideoSourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .livekit.proto.VideoSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::VideoSourceType type() const;
  void set_type(::livekit::proto::VideoSourceType value);
  private:
  ::livekit::proto::VideoSourceType _internal_type() const;
  void _internal_set_type(::livekit::proto::VideoSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoSourceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedVideoSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedVideoSource) */ {
 public:
  inline OwnedVideoSource() : OwnedVideoSource(nullptr) {}
  ~OwnedVideoSource() override;
  explicit PROTOBUF_CONSTEXPR OwnedVideoSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedVideoSource(const OwnedVideoSource& from);
  OwnedVideoSource(OwnedVideoSource&& from) noexcept
    : OwnedVideoSource() {
    *this = ::std::move(from);
  }

  inline OwnedVideoSource& operator=(const OwnedVideoSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedVideoSource& operator=(OwnedVideoSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedVideoSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedVideoSource* internal_default_instance() {
    return reinterpret_cast<const OwnedVideoSource*>(
               &_OwnedVideoSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(OwnedVideoSource& a, OwnedVideoSource& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedVideoSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedVideoSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedVideoSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedVideoSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedVideoSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedVideoSource& from) {
    OwnedVideoSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedVideoSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedVideoSource";
  }
  protected:
  explicit OwnedVideoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.VideoSourceInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::VideoSourceInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoSourceInfo* release_info();
  ::livekit::proto::VideoSourceInfo* mutable_info();
  void set_allocated_info(::livekit::proto::VideoSourceInfo* info);
  private:
  const ::livekit::proto::VideoSourceInfo& _internal_info() const;
  ::livekit::proto::VideoSourceInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::VideoSourceInfo* info);
  ::livekit::proto::VideoSourceInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedVideoSource)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::VideoSourceInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_video_5fframe_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NewVideoStreamRequest

// required uint64 track_handle = 1;
inline bool NewVideoStreamRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewVideoStreamRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void NewVideoStreamRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t NewVideoStreamRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t NewVideoStreamRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoStreamRequest.track_handle)
  return _internal_track_handle();
}
inline void NewVideoStreamRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_handle_ = value;
}
inline void NewVideoStreamRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewVideoStreamRequest.track_handle)
}

// required .livekit.proto.VideoStreamType type = 2;
inline bool NewVideoStreamRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewVideoStreamRequest::has_type() const {
  return _internal_has_type();
}
inline void NewVideoStreamRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::VideoStreamType NewVideoStreamRequest::_internal_type() const {
  return static_cast< ::livekit::proto::VideoStreamType >(_impl_.type_);
}
inline ::livekit::proto::VideoStreamType NewVideoStreamRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoStreamRequest.type)
  return _internal_type();
}
inline void NewVideoStreamRequest::_internal_set_type(::livekit::proto::VideoStreamType value) {
  assert(::livekit::proto::VideoStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void NewVideoStreamRequest::set_type(::livekit::proto::VideoStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewVideoStreamRequest.type)
}

// optional .livekit.proto.VideoBufferType format = 3;
inline bool NewVideoStreamRequest::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewVideoStreamRequest::has_format() const {
  return _internal_has_format();
}
inline void NewVideoStreamRequest::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::VideoBufferType NewVideoStreamRequest::_internal_format() const {
  return static_cast< ::livekit::proto::VideoBufferType >(_impl_.format_);
}
inline ::livekit::proto::VideoBufferType NewVideoStreamRequest::format() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoStreamRequest.format)
  return _internal_format();
}
inline void NewVideoStreamRequest::_internal_set_format(::livekit::proto::VideoBufferType value) {
  assert(::livekit::proto::VideoBufferType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.format_ = value;
}
inline void NewVideoStreamRequest::set_format(::livekit::proto::VideoBufferType value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewVideoStreamRequest.format)
}

// optional bool normalize_stride = 4;
inline bool NewVideoStreamRequest::_internal_has_normalize_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewVideoStreamRequest::has_normalize_stride() const {
  return _internal_has_normalize_stride();
}
inline void NewVideoStreamRequest::clear_normalize_stride() {
  _impl_.normalize_stride_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool NewVideoStreamRequest::_internal_normalize_stride() const {
  return _impl_.normalize_stride_;
}
inline bool NewVideoStreamRequest::normalize_stride() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoStreamRequest.normalize_stride)
  return _internal_normalize_stride();
}
inline void NewVideoStreamRequest::_internal_set_normalize_stride(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.normalize_stride_ = value;
}
inline void NewVideoStreamRequest::set_normalize_stride(bool value) {
  _internal_set_normalize_stride(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewVideoStreamRequest.normalize_stride)
}

// -------------------------------------------------------------------

// NewVideoStreamResponse

// required .livekit.proto.OwnedVideoStream stream = 1;
inline bool NewVideoStreamResponse::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool NewVideoStreamResponse::has_stream() const {
  return _internal_has_stream();
}
inline void NewVideoStreamResponse::clear_stream() {
  if (_impl_.stream_ != nullptr) _impl_.stream_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedVideoStream& NewVideoStreamResponse::_internal_stream() const {
  const ::livekit::proto::OwnedVideoStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedVideoStream&>(
      ::livekit::proto::_OwnedVideoStream_default_instance_);
}
inline const ::livekit::proto::OwnedVideoStream& NewVideoStreamResponse::stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoStreamResponse.stream)
  return _internal_stream();
}
inline void NewVideoStreamResponse::unsafe_arena_set_allocated_stream(
    ::livekit::proto::OwnedVideoStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewVideoStreamResponse.stream)
}
inline ::livekit::proto::OwnedVideoStream* NewVideoStreamResponse::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedVideoStream* NewVideoStreamResponse::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewVideoStreamResponse.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedVideoStream* NewVideoStreamResponse::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedVideoStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::livekit::proto::OwnedVideoStream* NewVideoStreamResponse::mutable_stream() {
  ::livekit::proto::OwnedVideoStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewVideoStreamResponse.stream)
  return _msg;
}
inline void NewVideoStreamResponse::set_allocated_stream(::livekit::proto::OwnedVideoStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewVideoStreamResponse.stream)
}

// -------------------------------------------------------------------

// VideoStreamFromParticipantRequest

// required uint64 participant_handle = 1;
inline bool VideoStreamFromParticipantRequest::_internal_has_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoStreamFromParticipantRequest::has_participant_handle() const {
  return _internal_has_participant_handle();
}
inline void VideoStreamFromParticipantRequest::clear_participant_handle() {
  _impl_.participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VideoStreamFromParticipantRequest::_internal_participant_handle() const {
  return _impl_.participant_handle_;
}
inline uint64_t VideoStreamFromParticipantRequest::participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantRequest.participant_handle)
  return _internal_participant_handle();
}
inline void VideoStreamFromParticipantRequest::_internal_set_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_handle_ = value;
}
inline void VideoStreamFromParticipantRequest::set_participant_handle(uint64_t value) {
  _internal_set_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamFromParticipantRequest.participant_handle)
}

// required .livekit.proto.VideoStreamType type = 2;
inline bool VideoStreamFromParticipantRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoStreamFromParticipantRequest::has_type() const {
  return _internal_has_type();
}
inline void VideoStreamFromParticipantRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::VideoStreamType VideoStreamFromParticipantRequest::_internal_type() const {
  return static_cast< ::livekit::proto::VideoStreamType >(_impl_.type_);
}
inline ::livekit::proto::VideoStreamType VideoStreamFromParticipantRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantRequest.type)
  return _internal_type();
}
inline void VideoStreamFromParticipantRequest::_internal_set_type(::livekit::proto::VideoStreamType value) {
  assert(::livekit::proto::VideoStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void VideoStreamFromParticipantRequest::set_type(::livekit::proto::VideoStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamFromParticipantRequest.type)
}

// required .livekit.proto.TrackSource track_source = 3;
inline bool VideoStreamFromParticipantRequest::_internal_has_track_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoStreamFromParticipantRequest::has_track_source() const {
  return _internal_has_track_source();
}
inline void VideoStreamFromParticipantRequest::clear_track_source() {
  _impl_.track_source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::TrackSource VideoStreamFromParticipantRequest::_internal_track_source() const {
  return static_cast< ::livekit::proto::TrackSource >(_impl_.track_source_);
}
inline ::livekit::proto::TrackSource VideoStreamFromParticipantRequest::track_source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantRequest.track_source)
  return _internal_track_source();
}
inline void VideoStreamFromParticipantRequest::_internal_set_track_source(::livekit::proto::TrackSource value) {
  assert(::livekit::proto::TrackSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.track_source_ = value;
}
inline void VideoStreamFromParticipantRequest::set_track_source(::livekit::proto::TrackSource value) {
  _internal_set_track_source(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamFromParticipantRequest.track_source)
}

// optional .livekit.proto.VideoBufferType format = 4;
inline bool VideoStreamFromParticipantRequest::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VideoStreamFromParticipantRequest::has_format() const {
  return _internal_has_format();
}
inline void VideoStreamFromParticipantRequest::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::VideoBufferType VideoStreamFromParticipantRequest::_internal_format() const {
  return static_cast< ::livekit::proto::VideoBufferType >(_impl_.format_);
}
inline ::livekit::proto::VideoBufferType VideoStreamFromParticipantRequest::format() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantRequest.format)
  return _internal_format();
}
inline void VideoStreamFromParticipantRequest::_internal_set_format(::livekit::proto::VideoBufferType value) {
  assert(::livekit::proto::VideoBufferType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.format_ = value;
}
inline void VideoStreamFromParticipantRequest::set_format(::livekit::proto::VideoBufferType value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamFromParticipantRequest.format)
}

// optional bool normalize_stride = 5;
inline bool VideoStreamFromParticipantRequest::_internal_has_normalize_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VideoStreamFromParticipantRequest::has_normalize_stride() const {
  return _internal_has_normalize_stride();
}
inline void VideoStreamFromParticipantRequest::clear_normalize_stride() {
  _impl_.normalize_stride_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool VideoStreamFromParticipantRequest::_internal_normalize_stride() const {
  return _impl_.normalize_stride_;
}
inline bool VideoStreamFromParticipantRequest::normalize_stride() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantRequest.normalize_stride)
  return _internal_normalize_stride();
}
inline void VideoStreamFromParticipantRequest::_internal_set_normalize_stride(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.normalize_stride_ = value;
}
inline void VideoStreamFromParticipantRequest::set_normalize_stride(bool value) {
  _internal_set_normalize_stride(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamFromParticipantRequest.normalize_stride)
}

// -------------------------------------------------------------------

// VideoStreamFromParticipantResponse

// required .livekit.proto.OwnedVideoStream stream = 1;
inline bool VideoStreamFromParticipantResponse::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool VideoStreamFromParticipantResponse::has_stream() const {
  return _internal_has_stream();
}
inline void VideoStreamFromParticipantResponse::clear_stream() {
  if (_impl_.stream_ != nullptr) _impl_.stream_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedVideoStream& VideoStreamFromParticipantResponse::_internal_stream() const {
  const ::livekit::proto::OwnedVideoStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedVideoStream&>(
      ::livekit::proto::_OwnedVideoStream_default_instance_);
}
inline const ::livekit::proto::OwnedVideoStream& VideoStreamFromParticipantResponse::stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamFromParticipantResponse.stream)
  return _internal_stream();
}
inline void VideoStreamFromParticipantResponse::unsafe_arena_set_allocated_stream(
    ::livekit::proto::OwnedVideoStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoStreamFromParticipantResponse.stream)
}
inline ::livekit::proto::OwnedVideoStream* VideoStreamFromParticipantResponse::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedVideoStream* VideoStreamFromParticipantResponse::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoStreamFromParticipantResponse.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedVideoStream* VideoStreamFromParticipantResponse::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedVideoStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::livekit::proto::OwnedVideoStream* VideoStreamFromParticipantResponse::mutable_stream() {
  ::livekit::proto::OwnedVideoStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoStreamFromParticipantResponse.stream)
  return _msg;
}
inline void VideoStreamFromParticipantResponse::set_allocated_stream(::livekit::proto::OwnedVideoStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoStreamFromParticipantResponse.stream)
}

// -------------------------------------------------------------------

// NewVideoSourceRequest

// required .livekit.proto.VideoSourceType type = 1;
inline bool NewVideoSourceRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewVideoSourceRequest::has_type() const {
  return _internal_has_type();
}
inline void NewVideoSourceRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::VideoSourceType NewVideoSourceRequest::_internal_type() const {
  return static_cast< ::livekit::proto::VideoSourceType >(_impl_.type_);
}
inline ::livekit::proto::VideoSourceType NewVideoSourceRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoSourceRequest.type)
  return _internal_type();
}
inline void NewVideoSourceRequest::_internal_set_type(::livekit::proto::VideoSourceType value) {
  assert(::livekit::proto::VideoSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void NewVideoSourceRequest::set_type(::livekit::proto::VideoSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewVideoSourceRequest.type)
}

// required .livekit.proto.VideoSourceResolution resolution = 2;
inline bool NewVideoSourceRequest::_internal_has_resolution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resolution_ != nullptr);
  return value;
}
inline bool NewVideoSourceRequest::has_resolution() const {
  return _internal_has_resolution();
}
inline void NewVideoSourceRequest::clear_resolution() {
  if (_impl_.resolution_ != nullptr) _impl_.resolution_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::VideoSourceResolution& NewVideoSourceRequest::_internal_resolution() const {
  const ::livekit::proto::VideoSourceResolution* p = _impl_.resolution_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoSourceResolution&>(
      ::livekit::proto::_VideoSourceResolution_default_instance_);
}
inline const ::livekit::proto::VideoSourceResolution& NewVideoSourceRequest::resolution() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoSourceRequest.resolution)
  return _internal_resolution();
}
inline void NewVideoSourceRequest::unsafe_arena_set_allocated_resolution(
    ::livekit::proto::VideoSourceResolution* resolution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolution_);
  }
  _impl_.resolution_ = resolution;
  if (resolution) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewVideoSourceRequest.resolution)
}
inline ::livekit::proto::VideoSourceResolution* NewVideoSourceRequest::release_resolution() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoSourceResolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoSourceResolution* NewVideoSourceRequest::unsafe_arena_release_resolution() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewVideoSourceRequest.resolution)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoSourceResolution* temp = _impl_.resolution_;
  _impl_.resolution_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoSourceResolution* NewVideoSourceRequest::_internal_mutable_resolution() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.resolution_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoSourceResolution>(GetArenaForAllocation());
    _impl_.resolution_ = p;
  }
  return _impl_.resolution_;
}
inline ::livekit::proto::VideoSourceResolution* NewVideoSourceRequest::mutable_resolution() {
  ::livekit::proto::VideoSourceResolution* _msg = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewVideoSourceRequest.resolution)
  return _msg;
}
inline void NewVideoSourceRequest::set_allocated_resolution(::livekit::proto::VideoSourceResolution* resolution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resolution_;
  }
  if (resolution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resolution);
    if (message_arena != submessage_arena) {
      resolution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewVideoSourceRequest.resolution)
}

// -------------------------------------------------------------------

// NewVideoSourceResponse

// required .livekit.proto.OwnedVideoSource source = 1;
inline bool NewVideoSourceResponse::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline bool NewVideoSourceResponse::has_source() const {
  return _internal_has_source();
}
inline void NewVideoSourceResponse::clear_source() {
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedVideoSource& NewVideoSourceResponse::_internal_source() const {
  const ::livekit::proto::OwnedVideoSource* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedVideoSource&>(
      ::livekit::proto::_OwnedVideoSource_default_instance_);
}
inline const ::livekit::proto::OwnedVideoSource& NewVideoSourceResponse::source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewVideoSourceResponse.source)
  return _internal_source();
}
inline void NewVideoSourceResponse::unsafe_arena_set_allocated_source(
    ::livekit::proto::OwnedVideoSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewVideoSourceResponse.source)
}
inline ::livekit::proto::OwnedVideoSource* NewVideoSourceResponse::release_source() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedVideoSource* NewVideoSourceResponse::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewVideoSourceResponse.source)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedVideoSource* NewVideoSourceResponse::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedVideoSource>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::livekit::proto::OwnedVideoSource* NewVideoSourceResponse::mutable_source() {
  ::livekit::proto::OwnedVideoSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewVideoSourceResponse.source)
  return _msg;
}
inline void NewVideoSourceResponse::set_allocated_source(::livekit::proto::OwnedVideoSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewVideoSourceResponse.source)
}

// -------------------------------------------------------------------

// CaptureVideoFrameRequest

// required uint64 source_handle = 1;
inline bool CaptureVideoFrameRequest::_internal_has_source_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CaptureVideoFrameRequest::has_source_handle() const {
  return _internal_has_source_handle();
}
inline void CaptureVideoFrameRequest::clear_source_handle() {
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CaptureVideoFrameRequest::_internal_source_handle() const {
  return _impl_.source_handle_;
}
inline uint64_t CaptureVideoFrameRequest::source_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureVideoFrameRequest.source_handle)
  return _internal_source_handle();
}
inline void CaptureVideoFrameRequest::_internal_set_source_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_handle_ = value;
}
inline void CaptureVideoFrameRequest::set_source_handle(uint64_t value) {
  _internal_set_source_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureVideoFrameRequest.source_handle)
}

// required .livekit.proto.VideoBufferInfo buffer = 2;
inline bool CaptureVideoFrameRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool CaptureVideoFrameRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void CaptureVideoFrameRequest::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::VideoBufferInfo& CaptureVideoFrameRequest::_internal_buffer() const {
  const ::livekit::proto::VideoBufferInfo* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoBufferInfo&>(
      ::livekit::proto::_VideoBufferInfo_default_instance_);
}
inline const ::livekit::proto::VideoBufferInfo& CaptureVideoFrameRequest::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureVideoFrameRequest.buffer)
  return _internal_buffer();
}
inline void CaptureVideoFrameRequest::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::VideoBufferInfo* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.CaptureVideoFrameRequest.buffer)
}
inline ::livekit::proto::VideoBufferInfo* CaptureVideoFrameRequest::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* CaptureVideoFrameRequest::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.CaptureVideoFrameRequest.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* CaptureVideoFrameRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoBufferInfo>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::VideoBufferInfo* CaptureVideoFrameRequest::mutable_buffer() {
  ::livekit::proto::VideoBufferInfo* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CaptureVideoFrameRequest.buffer)
  return _msg;
}
inline void CaptureVideoFrameRequest::set_allocated_buffer(::livekit::proto::VideoBufferInfo* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CaptureVideoFrameRequest.buffer)
}

// required int64 timestamp_us = 3;
inline bool CaptureVideoFrameRequest::_internal_has_timestamp_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CaptureVideoFrameRequest::has_timestamp_us() const {
  return _internal_has_timestamp_us();
}
inline void CaptureVideoFrameRequest::clear_timestamp_us() {
  _impl_.timestamp_us_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t CaptureVideoFrameRequest::_internal_timestamp_us() const {
  return _impl_.timestamp_us_;
}
inline int64_t CaptureVideoFrameRequest::timestamp_us() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureVideoFrameRequest.timestamp_us)
  return _internal_timestamp_us();
}
inline void CaptureVideoFrameRequest::_internal_set_timestamp_us(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_us_ = value;
}
inline void CaptureVideoFrameRequest::set_timestamp_us(int64_t value) {
  _internal_set_timestamp_us(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureVideoFrameRequest.timestamp_us)
}

// required .livekit.proto.VideoRotation rotation = 4;
inline bool CaptureVideoFrameRequest::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CaptureVideoFrameRequest::has_rotation() const {
  return _internal_has_rotation();
}
inline void CaptureVideoFrameRequest::clear_rotation() {
  _impl_.rotation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::VideoRotation CaptureVideoFrameRequest::_internal_rotation() const {
  return static_cast< ::livekit::proto::VideoRotation >(_impl_.rotation_);
}
inline ::livekit::proto::VideoRotation CaptureVideoFrameRequest::rotation() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureVideoFrameRequest.rotation)
  return _internal_rotation();
}
inline void CaptureVideoFrameRequest::_internal_set_rotation(::livekit::proto::VideoRotation value) {
  assert(::livekit::proto::VideoRotation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rotation_ = value;
}
inline void CaptureVideoFrameRequest::set_rotation(::livekit::proto::VideoRotation value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureVideoFrameRequest.rotation)
}

// -------------------------------------------------------------------

// CaptureVideoFrameResponse

// -------------------------------------------------------------------

// VideoConvertRequest

// optional bool flip_y = 1;
inline bool VideoConvertRequest::_internal_has_flip_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoConvertRequest::has_flip_y() const {
  return _internal_has_flip_y();
}
inline void VideoConvertRequest::clear_flip_y() {
  _impl_.flip_y_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool VideoConvertRequest::_internal_flip_y() const {
  return _impl_.flip_y_;
}
inline bool VideoConvertRequest::flip_y() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoConvertRequest.flip_y)
  return _internal_flip_y();
}
inline void VideoConvertRequest::_internal_set_flip_y(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.flip_y_ = value;
}
inline void VideoConvertRequest::set_flip_y(bool value) {
  _internal_set_flip_y(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoConvertRequest.flip_y)
}

// required .livekit.proto.VideoBufferInfo buffer = 2;
inline bool VideoConvertRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool VideoConvertRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void VideoConvertRequest::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::VideoBufferInfo& VideoConvertRequest::_internal_buffer() const {
  const ::livekit::proto::VideoBufferInfo* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoBufferInfo&>(
      ::livekit::proto::_VideoBufferInfo_default_instance_);
}
inline const ::livekit::proto::VideoBufferInfo& VideoConvertRequest::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoConvertRequest.buffer)
  return _internal_buffer();
}
inline void VideoConvertRequest::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::VideoBufferInfo* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoConvertRequest.buffer)
}
inline ::livekit::proto::VideoBufferInfo* VideoConvertRequest::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* VideoConvertRequest::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoConvertRequest.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* VideoConvertRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoBufferInfo>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::VideoBufferInfo* VideoConvertRequest::mutable_buffer() {
  ::livekit::proto::VideoBufferInfo* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoConvertRequest.buffer)
  return _msg;
}
inline void VideoConvertRequest::set_allocated_buffer(::livekit::proto::VideoBufferInfo* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoConvertRequest.buffer)
}

// required .livekit.proto.VideoBufferType dst_type = 3;
inline bool VideoConvertRequest::_internal_has_dst_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoConvertRequest::has_dst_type() const {
  return _internal_has_dst_type();
}
inline void VideoConvertRequest::clear_dst_type() {
  _impl_.dst_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::VideoBufferType VideoConvertRequest::_internal_dst_type() const {
  return static_cast< ::livekit::proto::VideoBufferType >(_impl_.dst_type_);
}
inline ::livekit::proto::VideoBufferType VideoConvertRequest::dst_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoConvertRequest.dst_type)
  return _internal_dst_type();
}
inline void VideoConvertRequest::_internal_set_dst_type(::livekit::proto::VideoBufferType value) {
  assert(::livekit::proto::VideoBufferType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dst_type_ = value;
}
inline void VideoConvertRequest::set_dst_type(::livekit::proto::VideoBufferType value) {
  _internal_set_dst_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoConvertRequest.dst_type)
}

// -------------------------------------------------------------------

// VideoConvertResponse

// string error = 1;
inline bool VideoConvertResponse::_internal_has_error() const {
  return message_case() == kError;
}
inline bool VideoConvertResponse::has_error() const {
  return _internal_has_error();
}
inline void VideoConvertResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void VideoConvertResponse::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& VideoConvertResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoConvertResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void VideoConvertResponse::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.VideoConvertResponse.error)
}
inline std::string* VideoConvertResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoConvertResponse.error)
  return _s;
}
inline const std::string& VideoConvertResponse::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void VideoConvertResponse::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoConvertResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* VideoConvertResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoConvertResponse.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void VideoConvertResponse::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoConvertResponse.error)
}

// .livekit.proto.OwnedVideoBuffer buffer = 2;
inline bool VideoConvertResponse::_internal_has_buffer() const {
  return message_case() == kBuffer;
}
inline bool VideoConvertResponse::has_buffer() const {
  return _internal_has_buffer();
}
inline void VideoConvertResponse::set_has_buffer() {
  _impl_._oneof_case_[0] = kBuffer;
}
inline void VideoConvertResponse::clear_buffer() {
  if (_internal_has_buffer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.buffer_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::OwnedVideoBuffer* VideoConvertResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoConvertResponse.buffer)
  if (_internal_has_buffer()) {
    clear_has_message();
    ::livekit::proto::OwnedVideoBuffer* temp = _impl_.message_.buffer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::OwnedVideoBuffer& VideoConvertResponse::_internal_buffer() const {
  return _internal_has_buffer()
      ? *_impl_.message_.buffer_
      : reinterpret_cast< ::livekit::proto::OwnedVideoBuffer&>(::livekit::proto::_OwnedVideoBuffer_default_instance_);
}
inline const ::livekit::proto::OwnedVideoBuffer& VideoConvertResponse::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoConvertResponse.buffer)
  return _internal_buffer();
}
inline ::livekit::proto::OwnedVideoBuffer* VideoConvertResponse::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.VideoConvertResponse.buffer)
  if (_internal_has_buffer()) {
    clear_has_message();
    ::livekit::proto::OwnedVideoBuffer* temp = _impl_.message_.buffer_;
    _impl_.message_.buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VideoConvertResponse::unsafe_arena_set_allocated_buffer(::livekit::proto::OwnedVideoBuffer* buffer) {
  clear_message();
  if (buffer) {
    set_has_buffer();
    _impl_.message_.buffer_ = buffer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoConvertResponse.buffer)
}
inline ::livekit::proto::OwnedVideoBuffer* VideoConvertResponse::_internal_mutable_buffer() {
  if (!_internal_has_buffer()) {
    clear_message();
    set_has_buffer();
    _impl_.message_.buffer_ = CreateMaybeMessage< ::livekit::proto::OwnedVideoBuffer >(GetArenaForAllocation());
  }
  return _impl_.message_.buffer_;
}
inline ::livekit::proto::OwnedVideoBuffer* VideoConvertResponse::mutable_buffer() {
  ::livekit::proto::OwnedVideoBuffer* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoConvertResponse.buffer)
  return _msg;
}

inline bool VideoConvertResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void VideoConvertResponse::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline VideoConvertResponse::MessageCase VideoConvertResponse::message_case() const {
  return VideoConvertResponse::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VideoResolution

// required uint32 width = 1;
inline bool VideoResolution::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoResolution::has_width() const {
  return _internal_has_width();
}
inline void VideoResolution::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t VideoResolution::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoResolution::width() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoResolution.width)
  return _internal_width();
}
inline void VideoResolution::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void VideoResolution::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoResolution.width)
}

// required uint32 height = 2;
inline bool VideoResolution::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoResolution::has_height() const {
  return _internal_has_height();
}
inline void VideoResolution::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VideoResolution::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoResolution::height() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoResolution.height)
  return _internal_height();
}
inline void VideoResolution::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void VideoResolution::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoResolution.height)
}

// required double frame_rate = 3;
inline bool VideoResolution::_internal_has_frame_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoResolution::has_frame_rate() const {
  return _internal_has_frame_rate();
}
inline void VideoResolution::clear_frame_rate() {
  _impl_.frame_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double VideoResolution::_internal_frame_rate() const {
  return _impl_.frame_rate_;
}
inline double VideoResolution::frame_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoResolution.frame_rate)
  return _internal_frame_rate();
}
inline void VideoResolution::_internal_set_frame_rate(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.frame_rate_ = value;
}
inline void VideoResolution::set_frame_rate(double value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoResolution.frame_rate)
}

// -------------------------------------------------------------------

// VideoBufferInfo_ComponentInfo

// required uint64 data_ptr = 1;
inline bool VideoBufferInfo_ComponentInfo::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoBufferInfo_ComponentInfo::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void VideoBufferInfo_ComponentInfo::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VideoBufferInfo_ComponentInfo::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t VideoBufferInfo_ComponentInfo::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.ComponentInfo.data_ptr)
  return _internal_data_ptr();
}
inline void VideoBufferInfo_ComponentInfo::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_ptr_ = value;
}
inline void VideoBufferInfo_ComponentInfo::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.ComponentInfo.data_ptr)
}

// required uint32 stride = 2;
inline bool VideoBufferInfo_ComponentInfo::_internal_has_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoBufferInfo_ComponentInfo::has_stride() const {
  return _internal_has_stride();
}
inline void VideoBufferInfo_ComponentInfo::clear_stride() {
  _impl_.stride_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VideoBufferInfo_ComponentInfo::_internal_stride() const {
  return _impl_.stride_;
}
inline uint32_t VideoBufferInfo_ComponentInfo::stride() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.ComponentInfo.stride)
  return _internal_stride();
}
inline void VideoBufferInfo_ComponentInfo::_internal_set_stride(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stride_ = value;
}
inline void VideoBufferInfo_ComponentInfo::set_stride(uint32_t value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.ComponentInfo.stride)
}

// required uint32 size = 3;
inline bool VideoBufferInfo_ComponentInfo::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoBufferInfo_ComponentInfo::has_size() const {
  return _internal_has_size();
}
inline void VideoBufferInfo_ComponentInfo::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t VideoBufferInfo_ComponentInfo::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t VideoBufferInfo_ComponentInfo::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.ComponentInfo.size)
  return _internal_size();
}
inline void VideoBufferInfo_ComponentInfo::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void VideoBufferInfo_ComponentInfo::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.ComponentInfo.size)
}

// -------------------------------------------------------------------

// VideoBufferInfo

// required .livekit.proto.VideoBufferType type = 1;
inline bool VideoBufferInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoBufferInfo::has_type() const {
  return _internal_has_type();
}
inline void VideoBufferInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::VideoBufferType VideoBufferInfo::_internal_type() const {
  return static_cast< ::livekit::proto::VideoBufferType >(_impl_.type_);
}
inline ::livekit::proto::VideoBufferType VideoBufferInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.type)
  return _internal_type();
}
inline void VideoBufferInfo::_internal_set_type(::livekit::proto::VideoBufferType value) {
  assert(::livekit::proto::VideoBufferType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void VideoBufferInfo::set_type(::livekit::proto::VideoBufferType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.type)
}

// required uint32 width = 2;
inline bool VideoBufferInfo::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoBufferInfo::has_width() const {
  return _internal_has_width();
}
inline void VideoBufferInfo::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VideoBufferInfo::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoBufferInfo::width() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.width)
  return _internal_width();
}
inline void VideoBufferInfo::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}
inline void VideoBufferInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.width)
}

// required uint32 height = 3;
inline bool VideoBufferInfo::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VideoBufferInfo::has_height() const {
  return _internal_has_height();
}
inline void VideoBufferInfo::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t VideoBufferInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoBufferInfo::height() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.height)
  return _internal_height();
}
inline void VideoBufferInfo::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.height_ = value;
}
inline void VideoBufferInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.height)
}

// required uint64 data_ptr = 4;
inline bool VideoBufferInfo::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoBufferInfo::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void VideoBufferInfo::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t VideoBufferInfo::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t VideoBufferInfo::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.data_ptr)
  return _internal_data_ptr();
}
inline void VideoBufferInfo::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_ptr_ = value;
}
inline void VideoBufferInfo::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.data_ptr)
}

// optional uint32 stride = 6;
inline bool VideoBufferInfo::_internal_has_stride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VideoBufferInfo::has_stride() const {
  return _internal_has_stride();
}
inline void VideoBufferInfo::clear_stride() {
  _impl_.stride_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t VideoBufferInfo::_internal_stride() const {
  return _impl_.stride_;
}
inline uint32_t VideoBufferInfo::stride() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.stride)
  return _internal_stride();
}
inline void VideoBufferInfo::_internal_set_stride(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.stride_ = value;
}
inline void VideoBufferInfo::set_stride(uint32_t value) {
  _internal_set_stride(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoBufferInfo.stride)
}

// repeated .livekit.proto.VideoBufferInfo.ComponentInfo components = 7;
inline int VideoBufferInfo::_internal_components_size() const {
  return _impl_.components_.size();
}
inline int VideoBufferInfo::components_size() const {
  return _internal_components_size();
}
inline void VideoBufferInfo::clear_components() {
  _impl_.components_.Clear();
}
inline ::livekit::proto::VideoBufferInfo_ComponentInfo* VideoBufferInfo::mutable_components(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoBufferInfo.components)
  return _impl_.components_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::VideoBufferInfo_ComponentInfo >*
VideoBufferInfo::mutable_components() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.VideoBufferInfo.components)
  return &_impl_.components_;
}
inline const ::livekit::proto::VideoBufferInfo_ComponentInfo& VideoBufferInfo::_internal_components(int index) const {
  return _impl_.components_.Get(index);
}
inline const ::livekit::proto::VideoBufferInfo_ComponentInfo& VideoBufferInfo::components(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoBufferInfo.components)
  return _internal_components(index);
}
inline ::livekit::proto::VideoBufferInfo_ComponentInfo* VideoBufferInfo::_internal_add_components() {
  return _impl_.components_.Add();
}
inline ::livekit::proto::VideoBufferInfo_ComponentInfo* VideoBufferInfo::add_components() {
  ::livekit::proto::VideoBufferInfo_ComponentInfo* _add = _internal_add_components();
  // @@protoc_insertion_point(field_add:livekit.proto.VideoBufferInfo.components)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::VideoBufferInfo_ComponentInfo >&
VideoBufferInfo::components() const {
  // @@protoc_insertion_point(field_list:livekit.proto.VideoBufferInfo.components)
  return _impl_.components_;
}

// -------------------------------------------------------------------

// OwnedVideoBuffer

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedVideoBuffer::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedVideoBuffer::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoBuffer::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoBuffer::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoBuffer.handle)
  return _internal_handle();
}
inline void OwnedVideoBuffer::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoBuffer.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoBuffer::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoBuffer::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoBuffer.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoBuffer::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoBuffer::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoBuffer.handle)
  return _msg;
}
inline void OwnedVideoBuffer::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoBuffer.handle)
}

// required .livekit.proto.VideoBufferInfo info = 2;
inline bool OwnedVideoBuffer::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedVideoBuffer::has_info() const {
  return _internal_has_info();
}
inline void OwnedVideoBuffer::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::VideoBufferInfo& OwnedVideoBuffer::_internal_info() const {
  const ::livekit::proto::VideoBufferInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoBufferInfo&>(
      ::livekit::proto::_VideoBufferInfo_default_instance_);
}
inline const ::livekit::proto::VideoBufferInfo& OwnedVideoBuffer::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoBuffer.info)
  return _internal_info();
}
inline void OwnedVideoBuffer::unsafe_arena_set_allocated_info(
    ::livekit::proto::VideoBufferInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoBuffer.info)
}
inline ::livekit::proto::VideoBufferInfo* OwnedVideoBuffer::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* OwnedVideoBuffer::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoBuffer.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoBufferInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoBufferInfo* OwnedVideoBuffer::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoBufferInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::VideoBufferInfo* OwnedVideoBuffer::mutable_info() {
  ::livekit::proto::VideoBufferInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoBuffer.info)
  return _msg;
}
inline void OwnedVideoBuffer::set_allocated_info(::livekit::proto::VideoBufferInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoBuffer.info)
}

// -------------------------------------------------------------------

// VideoStreamInfo

// required .livekit.proto.VideoStreamType type = 1;
inline bool VideoStreamInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoStreamInfo::has_type() const {
  return _internal_has_type();
}
inline void VideoStreamInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::VideoStreamType VideoStreamInfo::_internal_type() const {
  return static_cast< ::livekit::proto::VideoStreamType >(_impl_.type_);
}
inline ::livekit::proto::VideoStreamType VideoStreamInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamInfo.type)
  return _internal_type();
}
inline void VideoStreamInfo::_internal_set_type(::livekit::proto::VideoStreamType value) {
  assert(::livekit::proto::VideoStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void VideoStreamInfo::set_type(::livekit::proto::VideoStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamInfo.type)
}

// -------------------------------------------------------------------

// OwnedVideoStream

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedVideoStream::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedVideoStream::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoStream::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoStream::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoStream.handle)
  return _internal_handle();
}
inline void OwnedVideoStream::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoStream.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoStream::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoStream::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoStream.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoStream::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoStream::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoStream.handle)
  return _msg;
}
inline void OwnedVideoStream::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoStream.handle)
}

// required .livekit.proto.VideoStreamInfo info = 2;
inline bool OwnedVideoStream::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedVideoStream::has_info() const {
  return _internal_has_info();
}
inline void OwnedVideoStream::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::VideoStreamInfo& OwnedVideoStream::_internal_info() const {
  const ::livekit::proto::VideoStreamInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoStreamInfo&>(
      ::livekit::proto::_VideoStreamInfo_default_instance_);
}
inline const ::livekit::proto::VideoStreamInfo& OwnedVideoStream::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoStream.info)
  return _internal_info();
}
inline void OwnedVideoStream::unsafe_arena_set_allocated_info(
    ::livekit::proto::VideoStreamInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoStream.info)
}
inline ::livekit::proto::VideoStreamInfo* OwnedVideoStream::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoStreamInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoStreamInfo* OwnedVideoStream::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoStream.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoStreamInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoStreamInfo* OwnedVideoStream::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoStreamInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::VideoStreamInfo* OwnedVideoStream::mutable_info() {
  ::livekit::proto::VideoStreamInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoStream.info)
  return _msg;
}
inline void OwnedVideoStream::set_allocated_info(::livekit::proto::VideoStreamInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoStream.info)
}

// -------------------------------------------------------------------

// VideoStreamEvent

// required uint64 stream_handle = 1;
inline bool VideoStreamEvent::_internal_has_stream_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoStreamEvent::has_stream_handle() const {
  return _internal_has_stream_handle();
}
inline void VideoStreamEvent::clear_stream_handle() {
  _impl_.stream_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VideoStreamEvent::_internal_stream_handle() const {
  return _impl_.stream_handle_;
}
inline uint64_t VideoStreamEvent::stream_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamEvent.stream_handle)
  return _internal_stream_handle();
}
inline void VideoStreamEvent::_internal_set_stream_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_handle_ = value;
}
inline void VideoStreamEvent::set_stream_handle(uint64_t value) {
  _internal_set_stream_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoStreamEvent.stream_handle)
}

// .livekit.proto.VideoFrameReceived frame_received = 2;
inline bool VideoStreamEvent::_internal_has_frame_received() const {
  return message_case() == kFrameReceived;
}
inline bool VideoStreamEvent::has_frame_received() const {
  return _internal_has_frame_received();
}
inline void VideoStreamEvent::set_has_frame_received() {
  _impl_._oneof_case_[0] = kFrameReceived;
}
inline void VideoStreamEvent::clear_frame_received() {
  if (_internal_has_frame_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.frame_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::VideoFrameReceived* VideoStreamEvent::release_frame_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoStreamEvent.frame_received)
  if (_internal_has_frame_received()) {
    clear_has_message();
    ::livekit::proto::VideoFrameReceived* temp = _impl_.message_.frame_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.frame_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::VideoFrameReceived& VideoStreamEvent::_internal_frame_received() const {
  return _internal_has_frame_received()
      ? *_impl_.message_.frame_received_
      : reinterpret_cast< ::livekit::proto::VideoFrameReceived&>(::livekit::proto::_VideoFrameReceived_default_instance_);
}
inline const ::livekit::proto::VideoFrameReceived& VideoStreamEvent::frame_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamEvent.frame_received)
  return _internal_frame_received();
}
inline ::livekit::proto::VideoFrameReceived* VideoStreamEvent::unsafe_arena_release_frame_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.VideoStreamEvent.frame_received)
  if (_internal_has_frame_received()) {
    clear_has_message();
    ::livekit::proto::VideoFrameReceived* temp = _impl_.message_.frame_received_;
    _impl_.message_.frame_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VideoStreamEvent::unsafe_arena_set_allocated_frame_received(::livekit::proto::VideoFrameReceived* frame_received) {
  clear_message();
  if (frame_received) {
    set_has_frame_received();
    _impl_.message_.frame_received_ = frame_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoStreamEvent.frame_received)
}
inline ::livekit::proto::VideoFrameReceived* VideoStreamEvent::_internal_mutable_frame_received() {
  if (!_internal_has_frame_received()) {
    clear_message();
    set_has_frame_received();
    _impl_.message_.frame_received_ = CreateMaybeMessage< ::livekit::proto::VideoFrameReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.frame_received_;
}
inline ::livekit::proto::VideoFrameReceived* VideoStreamEvent::mutable_frame_received() {
  ::livekit::proto::VideoFrameReceived* _msg = _internal_mutable_frame_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoStreamEvent.frame_received)
  return _msg;
}

// .livekit.proto.VideoStreamEOS eos = 3;
inline bool VideoStreamEvent::_internal_has_eos() const {
  return message_case() == kEos;
}
inline bool VideoStreamEvent::has_eos() const {
  return _internal_has_eos();
}
inline void VideoStreamEvent::set_has_eos() {
  _impl_._oneof_case_[0] = kEos;
}
inline void VideoStreamEvent::clear_eos() {
  if (_internal_has_eos()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.eos_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::VideoStreamEOS* VideoStreamEvent::release_eos() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoStreamEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::VideoStreamEOS* temp = _impl_.message_.eos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::VideoStreamEOS& VideoStreamEvent::_internal_eos() const {
  return _internal_has_eos()
      ? *_impl_.message_.eos_
      : reinterpret_cast< ::livekit::proto::VideoStreamEOS&>(::livekit::proto::_VideoStreamEOS_default_instance_);
}
inline const ::livekit::proto::VideoStreamEOS& VideoStreamEvent::eos() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoStreamEvent.eos)
  return _internal_eos();
}
inline ::livekit::proto::VideoStreamEOS* VideoStreamEvent::unsafe_arena_release_eos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.VideoStreamEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::VideoStreamEOS* temp = _impl_.message_.eos_;
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VideoStreamEvent::unsafe_arena_set_allocated_eos(::livekit::proto::VideoStreamEOS* eos) {
  clear_message();
  if (eos) {
    set_has_eos();
    _impl_.message_.eos_ = eos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoStreamEvent.eos)
}
inline ::livekit::proto::VideoStreamEOS* VideoStreamEvent::_internal_mutable_eos() {
  if (!_internal_has_eos()) {
    clear_message();
    set_has_eos();
    _impl_.message_.eos_ = CreateMaybeMessage< ::livekit::proto::VideoStreamEOS >(GetArenaForAllocation());
  }
  return _impl_.message_.eos_;
}
inline ::livekit::proto::VideoStreamEOS* VideoStreamEvent::mutable_eos() {
  ::livekit::proto::VideoStreamEOS* _msg = _internal_mutable_eos();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoStreamEvent.eos)
  return _msg;
}

inline bool VideoStreamEvent::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void VideoStreamEvent::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline VideoStreamEvent::MessageCase VideoStreamEvent::message_case() const {
  return VideoStreamEvent::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VideoFrameReceived

// required .livekit.proto.OwnedVideoBuffer buffer = 1;
inline bool VideoFrameReceived::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool VideoFrameReceived::has_buffer() const {
  return _internal_has_buffer();
}
inline void VideoFrameReceived::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedVideoBuffer& VideoFrameReceived::_internal_buffer() const {
  const ::livekit::proto::OwnedVideoBuffer* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedVideoBuffer&>(
      ::livekit::proto::_OwnedVideoBuffer_default_instance_);
}
inline const ::livekit::proto::OwnedVideoBuffer& VideoFrameReceived::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoFrameReceived.buffer)
  return _internal_buffer();
}
inline void VideoFrameReceived::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::OwnedVideoBuffer* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.VideoFrameReceived.buffer)
}
inline ::livekit::proto::OwnedVideoBuffer* VideoFrameReceived::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoBuffer* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedVideoBuffer* VideoFrameReceived::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.VideoFrameReceived.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedVideoBuffer* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedVideoBuffer* VideoFrameReceived::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedVideoBuffer>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::OwnedVideoBuffer* VideoFrameReceived::mutable_buffer() {
  ::livekit::proto::OwnedVideoBuffer* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.VideoFrameReceived.buffer)
  return _msg;
}
inline void VideoFrameReceived::set_allocated_buffer(::livekit::proto::OwnedVideoBuffer* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.VideoFrameReceived.buffer)
}

// required int64 timestamp_us = 2;
inline bool VideoFrameReceived::_internal_has_timestamp_us() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoFrameReceived::has_timestamp_us() const {
  return _internal_has_timestamp_us();
}
inline void VideoFrameReceived::clear_timestamp_us() {
  _impl_.timestamp_us_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t VideoFrameReceived::_internal_timestamp_us() const {
  return _impl_.timestamp_us_;
}
inline int64_t VideoFrameReceived::timestamp_us() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoFrameReceived.timestamp_us)
  return _internal_timestamp_us();
}
inline void VideoFrameReceived::_internal_set_timestamp_us(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_us_ = value;
}
inline void VideoFrameReceived::set_timestamp_us(int64_t value) {
  _internal_set_timestamp_us(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoFrameReceived.timestamp_us)
}

// required .livekit.proto.VideoRotation rotation = 3;
inline bool VideoFrameReceived::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoFrameReceived::has_rotation() const {
  return _internal_has_rotation();
}
inline void VideoFrameReceived::clear_rotation() {
  _impl_.rotation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::VideoRotation VideoFrameReceived::_internal_rotation() const {
  return static_cast< ::livekit::proto::VideoRotation >(_impl_.rotation_);
}
inline ::livekit::proto::VideoRotation VideoFrameReceived::rotation() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoFrameReceived.rotation)
  return _internal_rotation();
}
inline void VideoFrameReceived::_internal_set_rotation(::livekit::proto::VideoRotation value) {
  assert(::livekit::proto::VideoRotation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rotation_ = value;
}
inline void VideoFrameReceived::set_rotation(::livekit::proto::VideoRotation value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoFrameReceived.rotation)
}

// -------------------------------------------------------------------

// VideoStreamEOS

// -------------------------------------------------------------------

// VideoSourceResolution

// required uint32 width = 1;
inline bool VideoSourceResolution::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoSourceResolution::has_width() const {
  return _internal_has_width();
}
inline void VideoSourceResolution::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t VideoSourceResolution::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoSourceResolution::width() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoSourceResolution.width)
  return _internal_width();
}
inline void VideoSourceResolution::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void VideoSourceResolution::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoSourceResolution.width)
}

// required uint32 height = 2;
inline bool VideoSourceResolution::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoSourceResolution::has_height() const {
  return _internal_has_height();
}
inline void VideoSourceResolution::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t VideoSourceResolution::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoSourceResolution::height() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoSourceResolution.height)
  return _internal_height();
}
inline void VideoSourceResolution::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void VideoSourceResolution::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoSourceResolution.height)
}

// -------------------------------------------------------------------

// VideoSourceInfo

// required .livekit.proto.VideoSourceType type = 1;
inline bool VideoSourceInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoSourceInfo::has_type() const {
  return _internal_has_type();
}
inline void VideoSourceInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::VideoSourceType VideoSourceInfo::_internal_type() const {
  return static_cast< ::livekit::proto::VideoSourceType >(_impl_.type_);
}
inline ::livekit::proto::VideoSourceType VideoSourceInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoSourceInfo.type)
  return _internal_type();
}
inline void VideoSourceInfo::_internal_set_type(::livekit::proto::VideoSourceType value) {
  assert(::livekit::proto::VideoSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void VideoSourceInfo::set_type(::livekit::proto::VideoSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoSourceInfo.type)
}

// -------------------------------------------------------------------

// OwnedVideoSource

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedVideoSource::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedVideoSource::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoSource::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedVideoSource::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoSource.handle)
  return _internal_handle();
}
inline void OwnedVideoSource::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoSource.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoSource::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoSource::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoSource.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoSource::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedVideoSource::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoSource.handle)
  return _msg;
}
inline void OwnedVideoSource::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoSource.handle)
}

// required .livekit.proto.VideoSourceInfo info = 2;
inline bool OwnedVideoSource::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedVideoSource::has_info() const {
  return _internal_has_info();
}
inline void OwnedVideoSource::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::VideoSourceInfo& OwnedVideoSource::_internal_info() const {
  const ::livekit::proto::VideoSourceInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoSourceInfo&>(
      ::livekit::proto::_VideoSourceInfo_default_instance_);
}
inline const ::livekit::proto::VideoSourceInfo& OwnedVideoSource::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedVideoSource.info)
  return _internal_info();
}
inline void OwnedVideoSource::unsafe_arena_set_allocated_info(
    ::livekit::proto::VideoSourceInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedVideoSource.info)
}
inline ::livekit::proto::VideoSourceInfo* OwnedVideoSource::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoSourceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoSourceInfo* OwnedVideoSource::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedVideoSource.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoSourceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoSourceInfo* OwnedVideoSource::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoSourceInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::VideoSourceInfo* OwnedVideoSource::mutable_info() {
  ::livekit::proto::VideoSourceInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedVideoSource.info)
  return _msg;
}
inline void OwnedVideoSource::set_allocated_info(::livekit::proto::VideoSourceInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedVideoSource.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::proto::VideoCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::VideoCodec>() {
  return ::livekit::proto::VideoCodec_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::VideoRotation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::VideoRotation>() {
  return ::livekit::proto::VideoRotation_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::VideoBufferType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::VideoBufferType>() {
  return ::livekit::proto::VideoBufferType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::VideoStreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::VideoStreamType>() {
  return ::livekit::proto::VideoStreamType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::VideoSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::VideoSourceType>() {
  return ::livekit::proto::VideoSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_video_5fframe_2eproto
