// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_rtc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5frtc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5frtc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5frtc_2eproto;
namespace livekit {
class AddTrackRequest;
struct AddTrackRequestDefaultTypeInternal;
extern AddTrackRequestDefaultTypeInternal _AddTrackRequest_default_instance_;
class ConnectionQualityInfo;
struct ConnectionQualityInfoDefaultTypeInternal;
extern ConnectionQualityInfoDefaultTypeInternal _ConnectionQualityInfo_default_instance_;
class ConnectionQualityUpdate;
struct ConnectionQualityUpdateDefaultTypeInternal;
extern ConnectionQualityUpdateDefaultTypeInternal _ConnectionQualityUpdate_default_instance_;
class DataChannelInfo;
struct DataChannelInfoDefaultTypeInternal;
extern DataChannelInfoDefaultTypeInternal _DataChannelInfo_default_instance_;
class ICEServer;
struct ICEServerDefaultTypeInternal;
extern ICEServerDefaultTypeInternal _ICEServer_default_instance_;
class JoinResponse;
struct JoinResponseDefaultTypeInternal;
extern JoinResponseDefaultTypeInternal _JoinResponse_default_instance_;
class LeaveRequest;
struct LeaveRequestDefaultTypeInternal;
extern LeaveRequestDefaultTypeInternal _LeaveRequest_default_instance_;
class MuteTrackRequest;
struct MuteTrackRequestDefaultTypeInternal;
extern MuteTrackRequestDefaultTypeInternal _MuteTrackRequest_default_instance_;
class ParticipantUpdate;
struct ParticipantUpdateDefaultTypeInternal;
extern ParticipantUpdateDefaultTypeInternal _ParticipantUpdate_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class ReconnectResponse;
struct ReconnectResponseDefaultTypeInternal;
extern ReconnectResponseDefaultTypeInternal _ReconnectResponse_default_instance_;
class RegionInfo;
struct RegionInfoDefaultTypeInternal;
extern RegionInfoDefaultTypeInternal _RegionInfo_default_instance_;
class RegionSettings;
struct RegionSettingsDefaultTypeInternal;
extern RegionSettingsDefaultTypeInternal _RegionSettings_default_instance_;
class RequestResponse;
struct RequestResponseDefaultTypeInternal;
extern RequestResponseDefaultTypeInternal _RequestResponse_default_instance_;
class RoomUpdate;
struct RoomUpdateDefaultTypeInternal;
extern RoomUpdateDefaultTypeInternal _RoomUpdate_default_instance_;
class SessionDescription;
struct SessionDescriptionDefaultTypeInternal;
extern SessionDescriptionDefaultTypeInternal _SessionDescription_default_instance_;
class SignalRequest;
struct SignalRequestDefaultTypeInternal;
extern SignalRequestDefaultTypeInternal _SignalRequest_default_instance_;
class SignalResponse;
struct SignalResponseDefaultTypeInternal;
extern SignalResponseDefaultTypeInternal _SignalResponse_default_instance_;
class SimulateScenario;
struct SimulateScenarioDefaultTypeInternal;
extern SimulateScenarioDefaultTypeInternal _SimulateScenario_default_instance_;
class SimulcastCodec;
struct SimulcastCodecDefaultTypeInternal;
extern SimulcastCodecDefaultTypeInternal _SimulcastCodec_default_instance_;
class SpeakersChanged;
struct SpeakersChangedDefaultTypeInternal;
extern SpeakersChangedDefaultTypeInternal _SpeakersChanged_default_instance_;
class StreamStateInfo;
struct StreamStateInfoDefaultTypeInternal;
extern StreamStateInfoDefaultTypeInternal _StreamStateInfo_default_instance_;
class StreamStateUpdate;
struct StreamStateUpdateDefaultTypeInternal;
extern StreamStateUpdateDefaultTypeInternal _StreamStateUpdate_default_instance_;
class SubscribedCodec;
struct SubscribedCodecDefaultTypeInternal;
extern SubscribedCodecDefaultTypeInternal _SubscribedCodec_default_instance_;
class SubscribedQuality;
struct SubscribedQualityDefaultTypeInternal;
extern SubscribedQualityDefaultTypeInternal _SubscribedQuality_default_instance_;
class SubscribedQualityUpdate;
struct SubscribedQualityUpdateDefaultTypeInternal;
extern SubscribedQualityUpdateDefaultTypeInternal _SubscribedQualityUpdate_default_instance_;
class SubscriptionPermission;
struct SubscriptionPermissionDefaultTypeInternal;
extern SubscriptionPermissionDefaultTypeInternal _SubscriptionPermission_default_instance_;
class SubscriptionPermissionUpdate;
struct SubscriptionPermissionUpdateDefaultTypeInternal;
extern SubscriptionPermissionUpdateDefaultTypeInternal _SubscriptionPermissionUpdate_default_instance_;
class SubscriptionResponse;
struct SubscriptionResponseDefaultTypeInternal;
extern SubscriptionResponseDefaultTypeInternal _SubscriptionResponse_default_instance_;
class SyncState;
struct SyncStateDefaultTypeInternal;
extern SyncStateDefaultTypeInternal _SyncState_default_instance_;
class TrackPermission;
struct TrackPermissionDefaultTypeInternal;
extern TrackPermissionDefaultTypeInternal _TrackPermission_default_instance_;
class TrackPublishedResponse;
struct TrackPublishedResponseDefaultTypeInternal;
extern TrackPublishedResponseDefaultTypeInternal _TrackPublishedResponse_default_instance_;
class TrackSubscribed;
struct TrackSubscribedDefaultTypeInternal;
extern TrackSubscribedDefaultTypeInternal _TrackSubscribed_default_instance_;
class TrackUnpublishedResponse;
struct TrackUnpublishedResponseDefaultTypeInternal;
extern TrackUnpublishedResponseDefaultTypeInternal _TrackUnpublishedResponse_default_instance_;
class TrickleRequest;
struct TrickleRequestDefaultTypeInternal;
extern TrickleRequestDefaultTypeInternal _TrickleRequest_default_instance_;
class UpdateLocalAudioTrack;
struct UpdateLocalAudioTrackDefaultTypeInternal;
extern UpdateLocalAudioTrackDefaultTypeInternal _UpdateLocalAudioTrack_default_instance_;
class UpdateLocalVideoTrack;
struct UpdateLocalVideoTrackDefaultTypeInternal;
extern UpdateLocalVideoTrackDefaultTypeInternal _UpdateLocalVideoTrack_default_instance_;
class UpdateParticipantMetadata;
struct UpdateParticipantMetadataDefaultTypeInternal;
extern UpdateParticipantMetadataDefaultTypeInternal _UpdateParticipantMetadata_default_instance_;
class UpdateParticipantMetadata_AttributesEntry_DoNotUse;
struct UpdateParticipantMetadata_AttributesEntry_DoNotUseDefaultTypeInternal;
extern UpdateParticipantMetadata_AttributesEntry_DoNotUseDefaultTypeInternal _UpdateParticipantMetadata_AttributesEntry_DoNotUse_default_instance_;
class UpdateSubscription;
struct UpdateSubscriptionDefaultTypeInternal;
extern UpdateSubscriptionDefaultTypeInternal _UpdateSubscription_default_instance_;
class UpdateTrackSettings;
struct UpdateTrackSettingsDefaultTypeInternal;
extern UpdateTrackSettingsDefaultTypeInternal _UpdateTrackSettings_default_instance_;
class UpdateVideoLayers;
struct UpdateVideoLayersDefaultTypeInternal;
extern UpdateVideoLayersDefaultTypeInternal _UpdateVideoLayers_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::AddTrackRequest* Arena::CreateMaybeMessage<::livekit::AddTrackRequest>(Arena*);
template<> ::livekit::ConnectionQualityInfo* Arena::CreateMaybeMessage<::livekit::ConnectionQualityInfo>(Arena*);
template<> ::livekit::ConnectionQualityUpdate* Arena::CreateMaybeMessage<::livekit::ConnectionQualityUpdate>(Arena*);
template<> ::livekit::DataChannelInfo* Arena::CreateMaybeMessage<::livekit::DataChannelInfo>(Arena*);
template<> ::livekit::ICEServer* Arena::CreateMaybeMessage<::livekit::ICEServer>(Arena*);
template<> ::livekit::JoinResponse* Arena::CreateMaybeMessage<::livekit::JoinResponse>(Arena*);
template<> ::livekit::LeaveRequest* Arena::CreateMaybeMessage<::livekit::LeaveRequest>(Arena*);
template<> ::livekit::MuteTrackRequest* Arena::CreateMaybeMessage<::livekit::MuteTrackRequest>(Arena*);
template<> ::livekit::ParticipantUpdate* Arena::CreateMaybeMessage<::livekit::ParticipantUpdate>(Arena*);
template<> ::livekit::Ping* Arena::CreateMaybeMessage<::livekit::Ping>(Arena*);
template<> ::livekit::Pong* Arena::CreateMaybeMessage<::livekit::Pong>(Arena*);
template<> ::livekit::ReconnectResponse* Arena::CreateMaybeMessage<::livekit::ReconnectResponse>(Arena*);
template<> ::livekit::RegionInfo* Arena::CreateMaybeMessage<::livekit::RegionInfo>(Arena*);
template<> ::livekit::RegionSettings* Arena::CreateMaybeMessage<::livekit::RegionSettings>(Arena*);
template<> ::livekit::RequestResponse* Arena::CreateMaybeMessage<::livekit::RequestResponse>(Arena*);
template<> ::livekit::RoomUpdate* Arena::CreateMaybeMessage<::livekit::RoomUpdate>(Arena*);
template<> ::livekit::SessionDescription* Arena::CreateMaybeMessage<::livekit::SessionDescription>(Arena*);
template<> ::livekit::SignalRequest* Arena::CreateMaybeMessage<::livekit::SignalRequest>(Arena*);
template<> ::livekit::SignalResponse* Arena::CreateMaybeMessage<::livekit::SignalResponse>(Arena*);
template<> ::livekit::SimulateScenario* Arena::CreateMaybeMessage<::livekit::SimulateScenario>(Arena*);
template<> ::livekit::SimulcastCodec* Arena::CreateMaybeMessage<::livekit::SimulcastCodec>(Arena*);
template<> ::livekit::SpeakersChanged* Arena::CreateMaybeMessage<::livekit::SpeakersChanged>(Arena*);
template<> ::livekit::StreamStateInfo* Arena::CreateMaybeMessage<::livekit::StreamStateInfo>(Arena*);
template<> ::livekit::StreamStateUpdate* Arena::CreateMaybeMessage<::livekit::StreamStateUpdate>(Arena*);
template<> ::livekit::SubscribedCodec* Arena::CreateMaybeMessage<::livekit::SubscribedCodec>(Arena*);
template<> ::livekit::SubscribedQuality* Arena::CreateMaybeMessage<::livekit::SubscribedQuality>(Arena*);
template<> ::livekit::SubscribedQualityUpdate* Arena::CreateMaybeMessage<::livekit::SubscribedQualityUpdate>(Arena*);
template<> ::livekit::SubscriptionPermission* Arena::CreateMaybeMessage<::livekit::SubscriptionPermission>(Arena*);
template<> ::livekit::SubscriptionPermissionUpdate* Arena::CreateMaybeMessage<::livekit::SubscriptionPermissionUpdate>(Arena*);
template<> ::livekit::SubscriptionResponse* Arena::CreateMaybeMessage<::livekit::SubscriptionResponse>(Arena*);
template<> ::livekit::SyncState* Arena::CreateMaybeMessage<::livekit::SyncState>(Arena*);
template<> ::livekit::TrackPermission* Arena::CreateMaybeMessage<::livekit::TrackPermission>(Arena*);
template<> ::livekit::TrackPublishedResponse* Arena::CreateMaybeMessage<::livekit::TrackPublishedResponse>(Arena*);
template<> ::livekit::TrackSubscribed* Arena::CreateMaybeMessage<::livekit::TrackSubscribed>(Arena*);
template<> ::livekit::TrackUnpublishedResponse* Arena::CreateMaybeMessage<::livekit::TrackUnpublishedResponse>(Arena*);
template<> ::livekit::TrickleRequest* Arena::CreateMaybeMessage<::livekit::TrickleRequest>(Arena*);
template<> ::livekit::UpdateLocalAudioTrack* Arena::CreateMaybeMessage<::livekit::UpdateLocalAudioTrack>(Arena*);
template<> ::livekit::UpdateLocalVideoTrack* Arena::CreateMaybeMessage<::livekit::UpdateLocalVideoTrack>(Arena*);
template<> ::livekit::UpdateParticipantMetadata* Arena::CreateMaybeMessage<::livekit::UpdateParticipantMetadata>(Arena*);
template<> ::livekit::UpdateParticipantMetadata_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::UpdateParticipantMetadata_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::UpdateSubscription* Arena::CreateMaybeMessage<::livekit::UpdateSubscription>(Arena*);
template<> ::livekit::UpdateTrackSettings* Arena::CreateMaybeMessage<::livekit::UpdateTrackSettings>(Arena*);
template<> ::livekit::UpdateVideoLayers* Arena::CreateMaybeMessage<::livekit::UpdateVideoLayers>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum LeaveRequest_Action : int {
  LeaveRequest_Action_DISCONNECT = 0,
  LeaveRequest_Action_RESUME = 1,
  LeaveRequest_Action_RECONNECT = 2,
  LeaveRequest_Action_LeaveRequest_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LeaveRequest_Action_LeaveRequest_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LeaveRequest_Action_IsValid(int value);
constexpr LeaveRequest_Action LeaveRequest_Action_Action_MIN = LeaveRequest_Action_DISCONNECT;
constexpr LeaveRequest_Action LeaveRequest_Action_Action_MAX = LeaveRequest_Action_RECONNECT;
constexpr int LeaveRequest_Action_Action_ARRAYSIZE = LeaveRequest_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaveRequest_Action_descriptor();
template<typename T>
inline const std::string& LeaveRequest_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaveRequest_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaveRequest_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaveRequest_Action_descriptor(), enum_t_value);
}
inline bool LeaveRequest_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaveRequest_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaveRequest_Action>(
    LeaveRequest_Action_descriptor(), name, value);
}
enum RequestResponse_Reason : int {
  RequestResponse_Reason_OK = 0,
  RequestResponse_Reason_NOT_FOUND = 1,
  RequestResponse_Reason_NOT_ALLOWED = 2,
  RequestResponse_Reason_LIMIT_EXCEEDED = 3,
  RequestResponse_Reason_RequestResponse_Reason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestResponse_Reason_RequestResponse_Reason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestResponse_Reason_IsValid(int value);
constexpr RequestResponse_Reason RequestResponse_Reason_Reason_MIN = RequestResponse_Reason_OK;
constexpr RequestResponse_Reason RequestResponse_Reason_Reason_MAX = RequestResponse_Reason_LIMIT_EXCEEDED;
constexpr int RequestResponse_Reason_Reason_ARRAYSIZE = RequestResponse_Reason_Reason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestResponse_Reason_descriptor();
template<typename T>
inline const std::string& RequestResponse_Reason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestResponse_Reason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestResponse_Reason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestResponse_Reason_descriptor(), enum_t_value);
}
inline bool RequestResponse_Reason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestResponse_Reason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestResponse_Reason>(
    RequestResponse_Reason_descriptor(), name, value);
}
enum SignalTarget : int {
  PUBLISHER = 0,
  SUBSCRIBER = 1,
  SignalTarget_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SignalTarget_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SignalTarget_IsValid(int value);
constexpr SignalTarget SignalTarget_MIN = PUBLISHER;
constexpr SignalTarget SignalTarget_MAX = SUBSCRIBER;
constexpr int SignalTarget_ARRAYSIZE = SignalTarget_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalTarget_descriptor();
template<typename T>
inline const std::string& SignalTarget_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalTarget>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalTarget_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalTarget_descriptor(), enum_t_value);
}
inline bool SignalTarget_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalTarget* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalTarget>(
    SignalTarget_descriptor(), name, value);
}
enum StreamState : int {
  ACTIVE = 0,
  PAUSED = 1,
  StreamState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamState_IsValid(int value);
constexpr StreamState StreamState_MIN = ACTIVE;
constexpr StreamState StreamState_MAX = PAUSED;
constexpr int StreamState_ARRAYSIZE = StreamState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamState_descriptor();
template<typename T>
inline const std::string& StreamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamState_descriptor(), enum_t_value);
}
inline bool StreamState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamState>(
    StreamState_descriptor(), name, value);
}
enum CandidateProtocol : int {
  UDP = 0,
  TCP = 1,
  TLS = 2,
  CandidateProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CandidateProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CandidateProtocol_IsValid(int value);
constexpr CandidateProtocol CandidateProtocol_MIN = UDP;
constexpr CandidateProtocol CandidateProtocol_MAX = TLS;
constexpr int CandidateProtocol_ARRAYSIZE = CandidateProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CandidateProtocol_descriptor();
template<typename T>
inline const std::string& CandidateProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CandidateProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CandidateProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CandidateProtocol_descriptor(), enum_t_value);
}
inline bool CandidateProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CandidateProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CandidateProtocol>(
    CandidateProtocol_descriptor(), name, value);
}
// ===================================================================

class SignalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SignalRequest) */ {
 public:
  inline SignalRequest() : SignalRequest(nullptr) {}
  ~SignalRequest() override;
  explicit PROTOBUF_CONSTEXPR SignalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalRequest(const SignalRequest& from);
  SignalRequest(SignalRequest&& from) noexcept
    : SignalRequest() {
    *this = ::std::move(from);
  }

  inline SignalRequest& operator=(const SignalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalRequest& operator=(SignalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalRequest& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kOffer = 1,
    kAnswer = 2,
    kTrickle = 3,
    kAddTrack = 4,
    kMute = 5,
    kSubscription = 6,
    kTrackSetting = 7,
    kLeave = 8,
    kUpdateLayers = 10,
    kSubscriptionPermission = 11,
    kSyncState = 12,
    kSimulate = 13,
    kPing = 14,
    kUpdateMetadata = 15,
    kPingReq = 16,
    kUpdateAudioTrack = 17,
    kUpdateVideoTrack = 18,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SignalRequest* internal_default_instance() {
    return reinterpret_cast<const SignalRequest*>(
               &_SignalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignalRequest& a, SignalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalRequest& from) {
    SignalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SignalRequest";
  }
  protected:
  explicit SignalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kTrickleFieldNumber = 3,
    kAddTrackFieldNumber = 4,
    kMuteFieldNumber = 5,
    kSubscriptionFieldNumber = 6,
    kTrackSettingFieldNumber = 7,
    kLeaveFieldNumber = 8,
    kUpdateLayersFieldNumber = 10,
    kSubscriptionPermissionFieldNumber = 11,
    kSyncStateFieldNumber = 12,
    kSimulateFieldNumber = 13,
    kPingFieldNumber = 14,
    kUpdateMetadataFieldNumber = 15,
    kPingReqFieldNumber = 16,
    kUpdateAudioTrackFieldNumber = 17,
    kUpdateVideoTrackFieldNumber = 18,
  };
  // .livekit.SessionDescription offer = 1;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::livekit::SessionDescription& offer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_offer();
  ::livekit::SessionDescription* mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* offer);
  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::livekit::SessionDescription* offer);
  ::livekit::SessionDescription* unsafe_arena_release_offer();

  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.TrickleRequest trickle = 3;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;
  public:
  void clear_trickle();
  const ::livekit::TrickleRequest& trickle() const;
  PROTOBUF_NODISCARD ::livekit::TrickleRequest* release_trickle();
  ::livekit::TrickleRequest* mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* trickle);
  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* _internal_mutable_trickle();
  public:
  void unsafe_arena_set_allocated_trickle(
      ::livekit::TrickleRequest* trickle);
  ::livekit::TrickleRequest* unsafe_arena_release_trickle();

  // .livekit.AddTrackRequest add_track = 4;
  bool has_add_track() const;
  private:
  bool _internal_has_add_track() const;
  public:
  void clear_add_track();
  const ::livekit::AddTrackRequest& add_track() const;
  PROTOBUF_NODISCARD ::livekit::AddTrackRequest* release_add_track();
  ::livekit::AddTrackRequest* mutable_add_track();
  void set_allocated_add_track(::livekit::AddTrackRequest* add_track);
  private:
  const ::livekit::AddTrackRequest& _internal_add_track() const;
  ::livekit::AddTrackRequest* _internal_mutable_add_track();
  public:
  void unsafe_arena_set_allocated_add_track(
      ::livekit::AddTrackRequest* add_track);
  ::livekit::AddTrackRequest* unsafe_arena_release_add_track();

  // .livekit.MuteTrackRequest mute = 5;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  const ::livekit::MuteTrackRequest& mute() const;
  PROTOBUF_NODISCARD ::livekit::MuteTrackRequest* release_mute();
  ::livekit::MuteTrackRequest* mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* mute);
  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* _internal_mutable_mute();
  public:
  void unsafe_arena_set_allocated_mute(
      ::livekit::MuteTrackRequest* mute);
  ::livekit::MuteTrackRequest* unsafe_arena_release_mute();

  // .livekit.UpdateSubscription subscription = 6;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::livekit::UpdateSubscription& subscription() const;
  PROTOBUF_NODISCARD ::livekit::UpdateSubscription* release_subscription();
  ::livekit::UpdateSubscription* mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* subscription);
  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::livekit::UpdateSubscription* subscription);
  ::livekit::UpdateSubscription* unsafe_arena_release_subscription();

  // .livekit.UpdateTrackSettings track_setting = 7;
  bool has_track_setting() const;
  private:
  bool _internal_has_track_setting() const;
  public:
  void clear_track_setting();
  const ::livekit::UpdateTrackSettings& track_setting() const;
  PROTOBUF_NODISCARD ::livekit::UpdateTrackSettings* release_track_setting();
  ::livekit::UpdateTrackSettings* mutable_track_setting();
  void set_allocated_track_setting(::livekit::UpdateTrackSettings* track_setting);
  private:
  const ::livekit::UpdateTrackSettings& _internal_track_setting() const;
  ::livekit::UpdateTrackSettings* _internal_mutable_track_setting();
  public:
  void unsafe_arena_set_allocated_track_setting(
      ::livekit::UpdateTrackSettings* track_setting);
  ::livekit::UpdateTrackSettings* unsafe_arena_release_track_setting();

  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;
  public:
  void clear_leave();
  const ::livekit::LeaveRequest& leave() const;
  PROTOBUF_NODISCARD ::livekit::LeaveRequest* release_leave();
  ::livekit::LeaveRequest* mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* leave);
  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* _internal_mutable_leave();
  public:
  void unsafe_arena_set_allocated_leave(
      ::livekit::LeaveRequest* leave);
  ::livekit::LeaveRequest* unsafe_arena_release_leave();

  // .livekit.UpdateVideoLayers update_layers = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_update_layers() const;
  private:
  bool _internal_has_update_layers() const;
  public:
  PROTOBUF_DEPRECATED void clear_update_layers();
  PROTOBUF_DEPRECATED const ::livekit::UpdateVideoLayers& update_layers() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::UpdateVideoLayers* release_update_layers();
  PROTOBUF_DEPRECATED ::livekit::UpdateVideoLayers* mutable_update_layers();
  PROTOBUF_DEPRECATED void set_allocated_update_layers(::livekit::UpdateVideoLayers* update_layers);
  private:
  const ::livekit::UpdateVideoLayers& _internal_update_layers() const;
  ::livekit::UpdateVideoLayers* _internal_mutable_update_layers();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_update_layers(
      ::livekit::UpdateVideoLayers* update_layers);
  PROTOBUF_DEPRECATED ::livekit::UpdateVideoLayers* unsafe_arena_release_update_layers();

  // .livekit.SubscriptionPermission subscription_permission = 11;
  bool has_subscription_permission() const;
  private:
  bool _internal_has_subscription_permission() const;
  public:
  void clear_subscription_permission();
  const ::livekit::SubscriptionPermission& subscription_permission() const;
  PROTOBUF_NODISCARD ::livekit::SubscriptionPermission* release_subscription_permission();
  ::livekit::SubscriptionPermission* mutable_subscription_permission();
  void set_allocated_subscription_permission(::livekit::SubscriptionPermission* subscription_permission);
  private:
  const ::livekit::SubscriptionPermission& _internal_subscription_permission() const;
  ::livekit::SubscriptionPermission* _internal_mutable_subscription_permission();
  public:
  void unsafe_arena_set_allocated_subscription_permission(
      ::livekit::SubscriptionPermission* subscription_permission);
  ::livekit::SubscriptionPermission* unsafe_arena_release_subscription_permission();

  // .livekit.SyncState sync_state = 12;
  bool has_sync_state() const;
  private:
  bool _internal_has_sync_state() const;
  public:
  void clear_sync_state();
  const ::livekit::SyncState& sync_state() const;
  PROTOBUF_NODISCARD ::livekit::SyncState* release_sync_state();
  ::livekit::SyncState* mutable_sync_state();
  void set_allocated_sync_state(::livekit::SyncState* sync_state);
  private:
  const ::livekit::SyncState& _internal_sync_state() const;
  ::livekit::SyncState* _internal_mutable_sync_state();
  public:
  void unsafe_arena_set_allocated_sync_state(
      ::livekit::SyncState* sync_state);
  ::livekit::SyncState* unsafe_arena_release_sync_state();

  // .livekit.SimulateScenario simulate = 13;
  bool has_simulate() const;
  private:
  bool _internal_has_simulate() const;
  public:
  void clear_simulate();
  const ::livekit::SimulateScenario& simulate() const;
  PROTOBUF_NODISCARD ::livekit::SimulateScenario* release_simulate();
  ::livekit::SimulateScenario* mutable_simulate();
  void set_allocated_simulate(::livekit::SimulateScenario* simulate);
  private:
  const ::livekit::SimulateScenario& _internal_simulate() const;
  ::livekit::SimulateScenario* _internal_mutable_simulate();
  public:
  void unsafe_arena_set_allocated_simulate(
      ::livekit::SimulateScenario* simulate);
  ::livekit::SimulateScenario* unsafe_arena_release_simulate();

  // int64 ping = 14;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  int64_t ping() const;
  void set_ping(int64_t value);
  private:
  int64_t _internal_ping() const;
  void _internal_set_ping(int64_t value);
  public:

  // .livekit.UpdateParticipantMetadata update_metadata = 15;
  bool has_update_metadata() const;
  private:
  bool _internal_has_update_metadata() const;
  public:
  void clear_update_metadata();
  const ::livekit::UpdateParticipantMetadata& update_metadata() const;
  PROTOBUF_NODISCARD ::livekit::UpdateParticipantMetadata* release_update_metadata();
  ::livekit::UpdateParticipantMetadata* mutable_update_metadata();
  void set_allocated_update_metadata(::livekit::UpdateParticipantMetadata* update_metadata);
  private:
  const ::livekit::UpdateParticipantMetadata& _internal_update_metadata() const;
  ::livekit::UpdateParticipantMetadata* _internal_mutable_update_metadata();
  public:
  void unsafe_arena_set_allocated_update_metadata(
      ::livekit::UpdateParticipantMetadata* update_metadata);
  ::livekit::UpdateParticipantMetadata* unsafe_arena_release_update_metadata();

  // .livekit.Ping ping_req = 16;
  bool has_ping_req() const;
  private:
  bool _internal_has_ping_req() const;
  public:
  void clear_ping_req();
  const ::livekit::Ping& ping_req() const;
  PROTOBUF_NODISCARD ::livekit::Ping* release_ping_req();
  ::livekit::Ping* mutable_ping_req();
  void set_allocated_ping_req(::livekit::Ping* ping_req);
  private:
  const ::livekit::Ping& _internal_ping_req() const;
  ::livekit::Ping* _internal_mutable_ping_req();
  public:
  void unsafe_arena_set_allocated_ping_req(
      ::livekit::Ping* ping_req);
  ::livekit::Ping* unsafe_arena_release_ping_req();

  // .livekit.UpdateLocalAudioTrack update_audio_track = 17;
  bool has_update_audio_track() const;
  private:
  bool _internal_has_update_audio_track() const;
  public:
  void clear_update_audio_track();
  const ::livekit::UpdateLocalAudioTrack& update_audio_track() const;
  PROTOBUF_NODISCARD ::livekit::UpdateLocalAudioTrack* release_update_audio_track();
  ::livekit::UpdateLocalAudioTrack* mutable_update_audio_track();
  void set_allocated_update_audio_track(::livekit::UpdateLocalAudioTrack* update_audio_track);
  private:
  const ::livekit::UpdateLocalAudioTrack& _internal_update_audio_track() const;
  ::livekit::UpdateLocalAudioTrack* _internal_mutable_update_audio_track();
  public:
  void unsafe_arena_set_allocated_update_audio_track(
      ::livekit::UpdateLocalAudioTrack* update_audio_track);
  ::livekit::UpdateLocalAudioTrack* unsafe_arena_release_update_audio_track();

  // .livekit.UpdateLocalVideoTrack update_video_track = 18;
  bool has_update_video_track() const;
  private:
  bool _internal_has_update_video_track() const;
  public:
  void clear_update_video_track();
  const ::livekit::UpdateLocalVideoTrack& update_video_track() const;
  PROTOBUF_NODISCARD ::livekit::UpdateLocalVideoTrack* release_update_video_track();
  ::livekit::UpdateLocalVideoTrack* mutable_update_video_track();
  void set_allocated_update_video_track(::livekit::UpdateLocalVideoTrack* update_video_track);
  private:
  const ::livekit::UpdateLocalVideoTrack& _internal_update_video_track() const;
  ::livekit::UpdateLocalVideoTrack* _internal_mutable_update_video_track();
  public:
  void unsafe_arena_set_allocated_update_video_track(
      ::livekit::UpdateLocalVideoTrack* update_video_track);
  ::livekit::UpdateLocalVideoTrack* unsafe_arena_release_update_video_track();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalRequest)
 private:
  class _Internal;
  void set_has_offer();
  void set_has_answer();
  void set_has_trickle();
  void set_has_add_track();
  void set_has_mute();
  void set_has_subscription();
  void set_has_track_setting();
  void set_has_leave();
  void set_has_update_layers();
  void set_has_subscription_permission();
  void set_has_sync_state();
  void set_has_simulate();
  void set_has_ping();
  void set_has_update_metadata();
  void set_has_ping_req();
  void set_has_update_audio_track();
  void set_has_update_video_track();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::SessionDescription* offer_;
      ::livekit::SessionDescription* answer_;
      ::livekit::TrickleRequest* trickle_;
      ::livekit::AddTrackRequest* add_track_;
      ::livekit::MuteTrackRequest* mute_;
      ::livekit::UpdateSubscription* subscription_;
      ::livekit::UpdateTrackSettings* track_setting_;
      ::livekit::LeaveRequest* leave_;
      ::livekit::UpdateVideoLayers* update_layers_;
      ::livekit::SubscriptionPermission* subscription_permission_;
      ::livekit::SyncState* sync_state_;
      ::livekit::SimulateScenario* simulate_;
      int64_t ping_;
      ::livekit::UpdateParticipantMetadata* update_metadata_;
      ::livekit::Ping* ping_req_;
      ::livekit::UpdateLocalAudioTrack* update_audio_track_;
      ::livekit::UpdateLocalVideoTrack* update_video_track_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SignalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SignalResponse) */ {
 public:
  inline SignalResponse() : SignalResponse(nullptr) {}
  ~SignalResponse() override;
  explicit PROTOBUF_CONSTEXPR SignalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalResponse(const SignalResponse& from);
  SignalResponse(SignalResponse&& from) noexcept
    : SignalResponse() {
    *this = ::std::move(from);
  }

  inline SignalResponse& operator=(const SignalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalResponse& operator=(SignalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kJoin = 1,
    kAnswer = 2,
    kOffer = 3,
    kTrickle = 4,
    kUpdate = 5,
    kTrackPublished = 6,
    kLeave = 8,
    kMute = 9,
    kSpeakersChanged = 10,
    kRoomUpdate = 11,
    kConnectionQuality = 12,
    kStreamStateUpdate = 13,
    kSubscribedQualityUpdate = 14,
    kSubscriptionPermissionUpdate = 15,
    kRefreshToken = 16,
    kTrackUnpublished = 17,
    kPong = 18,
    kReconnect = 19,
    kPongResp = 20,
    kSubscriptionResponse = 21,
    kRequestResponse = 22,
    kTrackSubscribed = 23,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SignalResponse* internal_default_instance() {
    return reinterpret_cast<const SignalResponse*>(
               &_SignalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignalResponse& a, SignalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalResponse& from) {
    SignalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SignalResponse";
  }
  protected:
  explicit SignalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJoinFieldNumber = 1,
    kAnswerFieldNumber = 2,
    kOfferFieldNumber = 3,
    kTrickleFieldNumber = 4,
    kUpdateFieldNumber = 5,
    kTrackPublishedFieldNumber = 6,
    kLeaveFieldNumber = 8,
    kMuteFieldNumber = 9,
    kSpeakersChangedFieldNumber = 10,
    kRoomUpdateFieldNumber = 11,
    kConnectionQualityFieldNumber = 12,
    kStreamStateUpdateFieldNumber = 13,
    kSubscribedQualityUpdateFieldNumber = 14,
    kSubscriptionPermissionUpdateFieldNumber = 15,
    kRefreshTokenFieldNumber = 16,
    kTrackUnpublishedFieldNumber = 17,
    kPongFieldNumber = 18,
    kReconnectFieldNumber = 19,
    kPongRespFieldNumber = 20,
    kSubscriptionResponseFieldNumber = 21,
    kRequestResponseFieldNumber = 22,
    kTrackSubscribedFieldNumber = 23,
  };
  // .livekit.JoinResponse join = 1;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::livekit::JoinResponse& join() const;
  PROTOBUF_NODISCARD ::livekit::JoinResponse* release_join();
  ::livekit::JoinResponse* mutable_join();
  void set_allocated_join(::livekit::JoinResponse* join);
  private:
  const ::livekit::JoinResponse& _internal_join() const;
  ::livekit::JoinResponse* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::livekit::JoinResponse* join);
  ::livekit::JoinResponse* unsafe_arena_release_join();

  // .livekit.SessionDescription answer = 2;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.SessionDescription offer = 3;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::livekit::SessionDescription& offer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_offer();
  ::livekit::SessionDescription* mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* offer);
  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::livekit::SessionDescription* offer);
  ::livekit::SessionDescription* unsafe_arena_release_offer();

  // .livekit.TrickleRequest trickle = 4;
  bool has_trickle() const;
  private:
  bool _internal_has_trickle() const;
  public:
  void clear_trickle();
  const ::livekit::TrickleRequest& trickle() const;
  PROTOBUF_NODISCARD ::livekit::TrickleRequest* release_trickle();
  ::livekit::TrickleRequest* mutable_trickle();
  void set_allocated_trickle(::livekit::TrickleRequest* trickle);
  private:
  const ::livekit::TrickleRequest& _internal_trickle() const;
  ::livekit::TrickleRequest* _internal_mutable_trickle();
  public:
  void unsafe_arena_set_allocated_trickle(
      ::livekit::TrickleRequest* trickle);
  ::livekit::TrickleRequest* unsafe_arena_release_trickle();

  // .livekit.ParticipantUpdate update = 5;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::livekit::ParticipantUpdate& update() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantUpdate* release_update();
  ::livekit::ParticipantUpdate* mutable_update();
  void set_allocated_update(::livekit::ParticipantUpdate* update);
  private:
  const ::livekit::ParticipantUpdate& _internal_update() const;
  ::livekit::ParticipantUpdate* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::livekit::ParticipantUpdate* update);
  ::livekit::ParticipantUpdate* unsafe_arena_release_update();

  // .livekit.TrackPublishedResponse track_published = 6;
  bool has_track_published() const;
  private:
  bool _internal_has_track_published() const;
  public:
  void clear_track_published();
  const ::livekit::TrackPublishedResponse& track_published() const;
  PROTOBUF_NODISCARD ::livekit::TrackPublishedResponse* release_track_published();
  ::livekit::TrackPublishedResponse* mutable_track_published();
  void set_allocated_track_published(::livekit::TrackPublishedResponse* track_published);
  private:
  const ::livekit::TrackPublishedResponse& _internal_track_published() const;
  ::livekit::TrackPublishedResponse* _internal_mutable_track_published();
  public:
  void unsafe_arena_set_allocated_track_published(
      ::livekit::TrackPublishedResponse* track_published);
  ::livekit::TrackPublishedResponse* unsafe_arena_release_track_published();

  // .livekit.LeaveRequest leave = 8;
  bool has_leave() const;
  private:
  bool _internal_has_leave() const;
  public:
  void clear_leave();
  const ::livekit::LeaveRequest& leave() const;
  PROTOBUF_NODISCARD ::livekit::LeaveRequest* release_leave();
  ::livekit::LeaveRequest* mutable_leave();
  void set_allocated_leave(::livekit::LeaveRequest* leave);
  private:
  const ::livekit::LeaveRequest& _internal_leave() const;
  ::livekit::LeaveRequest* _internal_mutable_leave();
  public:
  void unsafe_arena_set_allocated_leave(
      ::livekit::LeaveRequest* leave);
  ::livekit::LeaveRequest* unsafe_arena_release_leave();

  // .livekit.MuteTrackRequest mute = 9;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  const ::livekit::MuteTrackRequest& mute() const;
  PROTOBUF_NODISCARD ::livekit::MuteTrackRequest* release_mute();
  ::livekit::MuteTrackRequest* mutable_mute();
  void set_allocated_mute(::livekit::MuteTrackRequest* mute);
  private:
  const ::livekit::MuteTrackRequest& _internal_mute() const;
  ::livekit::MuteTrackRequest* _internal_mutable_mute();
  public:
  void unsafe_arena_set_allocated_mute(
      ::livekit::MuteTrackRequest* mute);
  ::livekit::MuteTrackRequest* unsafe_arena_release_mute();

  // .livekit.SpeakersChanged speakers_changed = 10;
  bool has_speakers_changed() const;
  private:
  bool _internal_has_speakers_changed() const;
  public:
  void clear_speakers_changed();
  const ::livekit::SpeakersChanged& speakers_changed() const;
  PROTOBUF_NODISCARD ::livekit::SpeakersChanged* release_speakers_changed();
  ::livekit::SpeakersChanged* mutable_speakers_changed();
  void set_allocated_speakers_changed(::livekit::SpeakersChanged* speakers_changed);
  private:
  const ::livekit::SpeakersChanged& _internal_speakers_changed() const;
  ::livekit::SpeakersChanged* _internal_mutable_speakers_changed();
  public:
  void unsafe_arena_set_allocated_speakers_changed(
      ::livekit::SpeakersChanged* speakers_changed);
  ::livekit::SpeakersChanged* unsafe_arena_release_speakers_changed();

  // .livekit.RoomUpdate room_update = 11;
  bool has_room_update() const;
  private:
  bool _internal_has_room_update() const;
  public:
  void clear_room_update();
  const ::livekit::RoomUpdate& room_update() const;
  PROTOBUF_NODISCARD ::livekit::RoomUpdate* release_room_update();
  ::livekit::RoomUpdate* mutable_room_update();
  void set_allocated_room_update(::livekit::RoomUpdate* room_update);
  private:
  const ::livekit::RoomUpdate& _internal_room_update() const;
  ::livekit::RoomUpdate* _internal_mutable_room_update();
  public:
  void unsafe_arena_set_allocated_room_update(
      ::livekit::RoomUpdate* room_update);
  ::livekit::RoomUpdate* unsafe_arena_release_room_update();

  // .livekit.ConnectionQualityUpdate connection_quality = 12;
  bool has_connection_quality() const;
  private:
  bool _internal_has_connection_quality() const;
  public:
  void clear_connection_quality();
  const ::livekit::ConnectionQualityUpdate& connection_quality() const;
  PROTOBUF_NODISCARD ::livekit::ConnectionQualityUpdate* release_connection_quality();
  ::livekit::ConnectionQualityUpdate* mutable_connection_quality();
  void set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* connection_quality);
  private:
  const ::livekit::ConnectionQualityUpdate& _internal_connection_quality() const;
  ::livekit::ConnectionQualityUpdate* _internal_mutable_connection_quality();
  public:
  void unsafe_arena_set_allocated_connection_quality(
      ::livekit::ConnectionQualityUpdate* connection_quality);
  ::livekit::ConnectionQualityUpdate* unsafe_arena_release_connection_quality();

  // .livekit.StreamStateUpdate stream_state_update = 13;
  bool has_stream_state_update() const;
  private:
  bool _internal_has_stream_state_update() const;
  public:
  void clear_stream_state_update();
  const ::livekit::StreamStateUpdate& stream_state_update() const;
  PROTOBUF_NODISCARD ::livekit::StreamStateUpdate* release_stream_state_update();
  ::livekit::StreamStateUpdate* mutable_stream_state_update();
  void set_allocated_stream_state_update(::livekit::StreamStateUpdate* stream_state_update);
  private:
  const ::livekit::StreamStateUpdate& _internal_stream_state_update() const;
  ::livekit::StreamStateUpdate* _internal_mutable_stream_state_update();
  public:
  void unsafe_arena_set_allocated_stream_state_update(
      ::livekit::StreamStateUpdate* stream_state_update);
  ::livekit::StreamStateUpdate* unsafe_arena_release_stream_state_update();

  // .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
  bool has_subscribed_quality_update() const;
  private:
  bool _internal_has_subscribed_quality_update() const;
  public:
  void clear_subscribed_quality_update();
  const ::livekit::SubscribedQualityUpdate& subscribed_quality_update() const;
  PROTOBUF_NODISCARD ::livekit::SubscribedQualityUpdate* release_subscribed_quality_update();
  ::livekit::SubscribedQualityUpdate* mutable_subscribed_quality_update();
  void set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* subscribed_quality_update);
  private:
  const ::livekit::SubscribedQualityUpdate& _internal_subscribed_quality_update() const;
  ::livekit::SubscribedQualityUpdate* _internal_mutable_subscribed_quality_update();
  public:
  void unsafe_arena_set_allocated_subscribed_quality_update(
      ::livekit::SubscribedQualityUpdate* subscribed_quality_update);
  ::livekit::SubscribedQualityUpdate* unsafe_arena_release_subscribed_quality_update();

  // .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
  bool has_subscription_permission_update() const;
  private:
  bool _internal_has_subscription_permission_update() const;
  public:
  void clear_subscription_permission_update();
  const ::livekit::SubscriptionPermissionUpdate& subscription_permission_update() const;
  PROTOBUF_NODISCARD ::livekit::SubscriptionPermissionUpdate* release_subscription_permission_update();
  ::livekit::SubscriptionPermissionUpdate* mutable_subscription_permission_update();
  void set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* subscription_permission_update);
  private:
  const ::livekit::SubscriptionPermissionUpdate& _internal_subscription_permission_update() const;
  ::livekit::SubscriptionPermissionUpdate* _internal_mutable_subscription_permission_update();
  public:
  void unsafe_arena_set_allocated_subscription_permission_update(
      ::livekit::SubscriptionPermissionUpdate* subscription_permission_update);
  ::livekit::SubscriptionPermissionUpdate* unsafe_arena_release_subscription_permission_update();

  // string refresh_token = 16;
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // .livekit.TrackUnpublishedResponse track_unpublished = 17;
  bool has_track_unpublished() const;
  private:
  bool _internal_has_track_unpublished() const;
  public:
  void clear_track_unpublished();
  const ::livekit::TrackUnpublishedResponse& track_unpublished() const;
  PROTOBUF_NODISCARD ::livekit::TrackUnpublishedResponse* release_track_unpublished();
  ::livekit::TrackUnpublishedResponse* mutable_track_unpublished();
  void set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* track_unpublished);
  private:
  const ::livekit::TrackUnpublishedResponse& _internal_track_unpublished() const;
  ::livekit::TrackUnpublishedResponse* _internal_mutable_track_unpublished();
  public:
  void unsafe_arena_set_allocated_track_unpublished(
      ::livekit::TrackUnpublishedResponse* track_unpublished);
  ::livekit::TrackUnpublishedResponse* unsafe_arena_release_track_unpublished();

  // int64 pong = 18;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  int64_t pong() const;
  void set_pong(int64_t value);
  private:
  int64_t _internal_pong() const;
  void _internal_set_pong(int64_t value);
  public:

  // .livekit.ReconnectResponse reconnect = 19;
  bool has_reconnect() const;
  private:
  bool _internal_has_reconnect() const;
  public:
  void clear_reconnect();
  const ::livekit::ReconnectResponse& reconnect() const;
  PROTOBUF_NODISCARD ::livekit::ReconnectResponse* release_reconnect();
  ::livekit::ReconnectResponse* mutable_reconnect();
  void set_allocated_reconnect(::livekit::ReconnectResponse* reconnect);
  private:
  const ::livekit::ReconnectResponse& _internal_reconnect() const;
  ::livekit::ReconnectResponse* _internal_mutable_reconnect();
  public:
  void unsafe_arena_set_allocated_reconnect(
      ::livekit::ReconnectResponse* reconnect);
  ::livekit::ReconnectResponse* unsafe_arena_release_reconnect();

  // .livekit.Pong pong_resp = 20;
  bool has_pong_resp() const;
  private:
  bool _internal_has_pong_resp() const;
  public:
  void clear_pong_resp();
  const ::livekit::Pong& pong_resp() const;
  PROTOBUF_NODISCARD ::livekit::Pong* release_pong_resp();
  ::livekit::Pong* mutable_pong_resp();
  void set_allocated_pong_resp(::livekit::Pong* pong_resp);
  private:
  const ::livekit::Pong& _internal_pong_resp() const;
  ::livekit::Pong* _internal_mutable_pong_resp();
  public:
  void unsafe_arena_set_allocated_pong_resp(
      ::livekit::Pong* pong_resp);
  ::livekit::Pong* unsafe_arena_release_pong_resp();

  // .livekit.SubscriptionResponse subscription_response = 21;
  bool has_subscription_response() const;
  private:
  bool _internal_has_subscription_response() const;
  public:
  void clear_subscription_response();
  const ::livekit::SubscriptionResponse& subscription_response() const;
  PROTOBUF_NODISCARD ::livekit::SubscriptionResponse* release_subscription_response();
  ::livekit::SubscriptionResponse* mutable_subscription_response();
  void set_allocated_subscription_response(::livekit::SubscriptionResponse* subscription_response);
  private:
  const ::livekit::SubscriptionResponse& _internal_subscription_response() const;
  ::livekit::SubscriptionResponse* _internal_mutable_subscription_response();
  public:
  void unsafe_arena_set_allocated_subscription_response(
      ::livekit::SubscriptionResponse* subscription_response);
  ::livekit::SubscriptionResponse* unsafe_arena_release_subscription_response();

  // .livekit.RequestResponse request_response = 22;
  bool has_request_response() const;
  private:
  bool _internal_has_request_response() const;
  public:
  void clear_request_response();
  const ::livekit::RequestResponse& request_response() const;
  PROTOBUF_NODISCARD ::livekit::RequestResponse* release_request_response();
  ::livekit::RequestResponse* mutable_request_response();
  void set_allocated_request_response(::livekit::RequestResponse* request_response);
  private:
  const ::livekit::RequestResponse& _internal_request_response() const;
  ::livekit::RequestResponse* _internal_mutable_request_response();
  public:
  void unsafe_arena_set_allocated_request_response(
      ::livekit::RequestResponse* request_response);
  ::livekit::RequestResponse* unsafe_arena_release_request_response();

  // .livekit.TrackSubscribed track_subscribed = 23;
  bool has_track_subscribed() const;
  private:
  bool _internal_has_track_subscribed() const;
  public:
  void clear_track_subscribed();
  const ::livekit::TrackSubscribed& track_subscribed() const;
  PROTOBUF_NODISCARD ::livekit::TrackSubscribed* release_track_subscribed();
  ::livekit::TrackSubscribed* mutable_track_subscribed();
  void set_allocated_track_subscribed(::livekit::TrackSubscribed* track_subscribed);
  private:
  const ::livekit::TrackSubscribed& _internal_track_subscribed() const;
  ::livekit::TrackSubscribed* _internal_mutable_track_subscribed();
  public:
  void unsafe_arena_set_allocated_track_subscribed(
      ::livekit::TrackSubscribed* track_subscribed);
  ::livekit::TrackSubscribed* unsafe_arena_release_track_subscribed();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SignalResponse)
 private:
  class _Internal;
  void set_has_join();
  void set_has_answer();
  void set_has_offer();
  void set_has_trickle();
  void set_has_update();
  void set_has_track_published();
  void set_has_leave();
  void set_has_mute();
  void set_has_speakers_changed();
  void set_has_room_update();
  void set_has_connection_quality();
  void set_has_stream_state_update();
  void set_has_subscribed_quality_update();
  void set_has_subscription_permission_update();
  void set_has_refresh_token();
  void set_has_track_unpublished();
  void set_has_pong();
  void set_has_reconnect();
  void set_has_pong_resp();
  void set_has_subscription_response();
  void set_has_request_response();
  void set_has_track_subscribed();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::JoinResponse* join_;
      ::livekit::SessionDescription* answer_;
      ::livekit::SessionDescription* offer_;
      ::livekit::TrickleRequest* trickle_;
      ::livekit::ParticipantUpdate* update_;
      ::livekit::TrackPublishedResponse* track_published_;
      ::livekit::LeaveRequest* leave_;
      ::livekit::MuteTrackRequest* mute_;
      ::livekit::SpeakersChanged* speakers_changed_;
      ::livekit::RoomUpdate* room_update_;
      ::livekit::ConnectionQualityUpdate* connection_quality_;
      ::livekit::StreamStateUpdate* stream_state_update_;
      ::livekit::SubscribedQualityUpdate* subscribed_quality_update_;
      ::livekit::SubscriptionPermissionUpdate* subscription_permission_update_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
      ::livekit::TrackUnpublishedResponse* track_unpublished_;
      int64_t pong_;
      ::livekit::ReconnectResponse* reconnect_;
      ::livekit::Pong* pong_resp_;
      ::livekit::SubscriptionResponse* subscription_response_;
      ::livekit::RequestResponse* request_response_;
      ::livekit::TrackSubscribed* track_subscribed_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SimulcastCodec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SimulcastCodec) */ {
 public:
  inline SimulcastCodec() : SimulcastCodec(nullptr) {}
  ~SimulcastCodec() override;
  explicit PROTOBUF_CONSTEXPR SimulcastCodec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulcastCodec(const SimulcastCodec& from);
  SimulcastCodec(SimulcastCodec&& from) noexcept
    : SimulcastCodec() {
    *this = ::std::move(from);
  }

  inline SimulcastCodec& operator=(const SimulcastCodec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulcastCodec& operator=(SimulcastCodec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulcastCodec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimulcastCodec* internal_default_instance() {
    return reinterpret_cast<const SimulcastCodec*>(
               &_SimulcastCodec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SimulcastCodec& a, SimulcastCodec& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulcastCodec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulcastCodec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulcastCodec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulcastCodec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulcastCodec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimulcastCodec& from) {
    SimulcastCodec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulcastCodec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SimulcastCodec";
  }
  protected:
  explicit SimulcastCodec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecFieldNumber = 1,
    kCidFieldNumber = 2,
  };
  // string codec = 1;
  void clear_codec();
  const std::string& codec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* codec);
  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(const std::string& value);
  std::string* _internal_mutable_codec();
  public:

  // string cid = 2;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SimulcastCodec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class AddTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AddTrackRequest) */ {
 public:
  inline AddTrackRequest() : AddTrackRequest(nullptr) {}
  ~AddTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR AddTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddTrackRequest(const AddTrackRequest& from);
  AddTrackRequest(AddTrackRequest&& from) noexcept
    : AddTrackRequest() {
    *this = ::std::move(from);
  }

  inline AddTrackRequest& operator=(const AddTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddTrackRequest& operator=(AddTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddTrackRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrackRequest*>(
               &_AddTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AddTrackRequest& a, AddTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddTrackRequest& from) {
    AddTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AddTrackRequest";
  }
  protected:
  explicit AddTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 9,
    kSimulcastCodecsFieldNumber = 10,
    kCidFieldNumber = 1,
    kNameFieldNumber = 2,
    kSidFieldNumber = 11,
    kStreamFieldNumber = 15,
    kTypeFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kSourceFieldNumber = 8,
    kMutedFieldNumber = 6,
    kDisableDtxFieldNumber = 7,
    kStereoFieldNumber = 12,
    kDisableRedFieldNumber = 13,
    kEncryptionFieldNumber = 14,
    kBackupCodecPolicyFieldNumber = 16,
  };
  // repeated .livekit.VideoLayer layers = 9;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // repeated .livekit.SimulcastCodec simulcast_codecs = 10;
  int simulcast_codecs_size() const;
  private:
  int _internal_simulcast_codecs_size() const;
  public:
  void clear_simulcast_codecs();
  ::livekit::SimulcastCodec* mutable_simulcast_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodec >*
      mutable_simulcast_codecs();
  private:
  const ::livekit::SimulcastCodec& _internal_simulcast_codecs(int index) const;
  ::livekit::SimulcastCodec* _internal_add_simulcast_codecs();
  public:
  const ::livekit::SimulcastCodec& simulcast_codecs(int index) const;
  ::livekit::SimulcastCodec* add_simulcast_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodec >&
      simulcast_codecs() const;

  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sid = 11;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string stream = 15;
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // .livekit.TrackType type = 3;
  void clear_type();
  ::livekit::TrackType type() const;
  void set_type(::livekit::TrackType value);
  private:
  ::livekit::TrackType _internal_type() const;
  void _internal_set_type(::livekit::TrackType value);
  public:

  // uint32 width = 4;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 5;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // .livekit.TrackSource source = 8;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // bool muted = 6;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // bool disable_dtx = 7;
  void clear_disable_dtx();
  bool disable_dtx() const;
  void set_disable_dtx(bool value);
  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);
  public:

  // bool stereo = 12;
  void clear_stereo();
  bool stereo() const;
  void set_stereo(bool value);
  private:
  bool _internal_stereo() const;
  void _internal_set_stereo(bool value);
  public:

  // bool disable_red = 13;
  void clear_disable_red();
  bool disable_red() const;
  void set_disable_red(bool value);
  private:
  bool _internal_disable_red() const;
  void _internal_set_disable_red(bool value);
  public:

  // .livekit.Encryption.Type encryption = 14;
  void clear_encryption();
  ::livekit::Encryption_Type encryption() const;
  void set_encryption(::livekit::Encryption_Type value);
  private:
  ::livekit::Encryption_Type _internal_encryption() const;
  void _internal_set_encryption(::livekit::Encryption_Type value);
  public:

  // .livekit.BackupCodecPolicy backup_codec_policy = 16;
  void clear_backup_codec_policy();
  ::livekit::BackupCodecPolicy backup_codec_policy() const;
  void set_backup_codec_policy(::livekit::BackupCodecPolicy value);
  private:
  ::livekit::BackupCodecPolicy _internal_backup_codec_policy() const;
  void _internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.AddTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodec > simulcast_codecs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    int type_;
    uint32_t width_;
    uint32_t height_;
    int source_;
    bool muted_;
    bool disable_dtx_;
    bool stereo_;
    bool disable_red_;
    int encryption_;
    int backup_codec_policy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrickleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrickleRequest) */ {
 public:
  inline TrickleRequest() : TrickleRequest(nullptr) {}
  ~TrickleRequest() override;
  explicit PROTOBUF_CONSTEXPR TrickleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrickleRequest(const TrickleRequest& from);
  TrickleRequest(TrickleRequest&& from) noexcept
    : TrickleRequest() {
    *this = ::std::move(from);
  }

  inline TrickleRequest& operator=(const TrickleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrickleRequest& operator=(TrickleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrickleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrickleRequest* internal_default_instance() {
    return reinterpret_cast<const TrickleRequest*>(
               &_TrickleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrickleRequest& a, TrickleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TrickleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrickleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrickleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrickleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrickleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrickleRequest& from) {
    TrickleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrickleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrickleRequest";
  }
  protected:
  explicit TrickleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateInitFieldNumber = 1,
    kTargetFieldNumber = 2,
    kFinalFieldNumber = 3,
  };
  // string candidateInit = 1;
  void clear_candidateinit();
  const std::string& candidateinit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidateinit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidateinit();
  PROTOBUF_NODISCARD std::string* release_candidateinit();
  void set_allocated_candidateinit(std::string* candidateinit);
  private:
  const std::string& _internal_candidateinit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidateinit(const std::string& value);
  std::string* _internal_mutable_candidateinit();
  public:

  // .livekit.SignalTarget target = 2;
  void clear_target();
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);
  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);
  public:

  // bool final = 3;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrickleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidateinit_;
    int target_;
    bool final_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class MuteTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.MuteTrackRequest) */ {
 public:
  inline MuteTrackRequest() : MuteTrackRequest(nullptr) {}
  ~MuteTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR MuteTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MuteTrackRequest(const MuteTrackRequest& from);
  MuteTrackRequest(MuteTrackRequest&& from) noexcept
    : MuteTrackRequest() {
    *this = ::std::move(from);
  }

  inline MuteTrackRequest& operator=(const MuteTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuteTrackRequest& operator=(MuteTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuteTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuteTrackRequest* internal_default_instance() {
    return reinterpret_cast<const MuteTrackRequest*>(
               &_MuteTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MuteTrackRequest& a, MuteTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MuteTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuteTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuteTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MuteTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MuteTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MuteTrackRequest& from) {
    MuteTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MuteTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.MuteTrackRequest";
  }
  protected:
  explicit MuteTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kMutedFieldNumber = 2,
  };
  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // bool muted = 2;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.MuteTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    bool muted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class JoinResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.JoinResponse) */ {
 public:
  inline JoinResponse() : JoinResponse(nullptr) {}
  ~JoinResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinResponse(const JoinResponse& from);
  JoinResponse(JoinResponse&& from) noexcept
    : JoinResponse() {
    *this = ::std::move(from);
  }

  inline JoinResponse& operator=(const JoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinResponse& operator=(JoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinResponse* internal_default_instance() {
    return reinterpret_cast<const JoinResponse*>(
               &_JoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoinResponse& a, JoinResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinResponse& from) {
    JoinResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.JoinResponse";
  }
  protected:
  explicit JoinResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherParticipantsFieldNumber = 3,
    kIceServersFieldNumber = 5,
    kEnabledPublishCodecsFieldNumber = 14,
    kServerVersionFieldNumber = 4,
    kAlternativeUrlFieldNumber = 7,
    kServerRegionFieldNumber = 9,
    kSifTrailerFieldNumber = 13,
    kRoomFieldNumber = 1,
    kParticipantFieldNumber = 2,
    kClientConfigurationFieldNumber = 8,
    kServerInfoFieldNumber = 12,
    kPingTimeoutFieldNumber = 10,
    kSubscriberPrimaryFieldNumber = 6,
    kFastPublishFieldNumber = 15,
    kPingIntervalFieldNumber = 11,
  };
  // repeated .livekit.ParticipantInfo other_participants = 3;
  int other_participants_size() const;
  private:
  int _internal_other_participants_size() const;
  public:
  void clear_other_participants();
  ::livekit::ParticipantInfo* mutable_other_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
      mutable_other_participants();
  private:
  const ::livekit::ParticipantInfo& _internal_other_participants(int index) const;
  ::livekit::ParticipantInfo* _internal_add_other_participants();
  public:
  const ::livekit::ParticipantInfo& other_participants(int index) const;
  ::livekit::ParticipantInfo* add_other_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
      other_participants() const;

  // repeated .livekit.ICEServer ice_servers = 5;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;
  public:
  void clear_ice_servers();
  ::livekit::ICEServer* mutable_ice_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
      mutable_ice_servers();
  private:
  const ::livekit::ICEServer& _internal_ice_servers(int index) const;
  ::livekit::ICEServer* _internal_add_ice_servers();
  public:
  const ::livekit::ICEServer& ice_servers(int index) const;
  ::livekit::ICEServer* add_ice_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
      ice_servers() const;

  // repeated .livekit.Codec enabled_publish_codecs = 14;
  int enabled_publish_codecs_size() const;
  private:
  int _internal_enabled_publish_codecs_size() const;
  public:
  void clear_enabled_publish_codecs();
  ::livekit::Codec* mutable_enabled_publish_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
      mutable_enabled_publish_codecs();
  private:
  const ::livekit::Codec& _internal_enabled_publish_codecs(int index) const;
  ::livekit::Codec* _internal_add_enabled_publish_codecs();
  public:
  const ::livekit::Codec& enabled_publish_codecs(int index) const;
  ::livekit::Codec* add_enabled_publish_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
      enabled_publish_codecs() const;

  // string server_version = 4;
  void clear_server_version();
  const std::string& server_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_version();
  PROTOBUF_NODISCARD std::string* release_server_version();
  void set_allocated_server_version(std::string* server_version);
  private:
  const std::string& _internal_server_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_version(const std::string& value);
  std::string* _internal_mutable_server_version();
  public:

  // string alternative_url = 7;
  void clear_alternative_url();
  const std::string& alternative_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alternative_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alternative_url();
  PROTOBUF_NODISCARD std::string* release_alternative_url();
  void set_allocated_alternative_url(std::string* alternative_url);
  private:
  const std::string& _internal_alternative_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alternative_url(const std::string& value);
  std::string* _internal_mutable_alternative_url();
  public:

  // string server_region = 9;
  void clear_server_region();
  const std::string& server_region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_region();
  PROTOBUF_NODISCARD std::string* release_server_region();
  void set_allocated_server_region(std::string* server_region);
  private:
  const std::string& _internal_server_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_region(const std::string& value);
  std::string* _internal_mutable_server_region();
  public:

  // bytes sif_trailer = 13;
  void clear_sif_trailer();
  const std::string& sif_trailer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sif_trailer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sif_trailer();
  PROTOBUF_NODISCARD std::string* release_sif_trailer();
  void set_allocated_sif_trailer(std::string* sif_trailer);
  private:
  const std::string& _internal_sif_trailer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sif_trailer(const std::string& value);
  std::string* _internal_mutable_sif_trailer();
  public:

  // .livekit.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // .livekit.ParticipantInfo participant = 2;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::ParticipantInfo& participant() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantInfo* release_participant();
  ::livekit::ParticipantInfo* mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* participant);
  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::ParticipantInfo* participant);
  ::livekit::ParticipantInfo* unsafe_arena_release_participant();

  // .livekit.ClientConfiguration client_configuration = 8;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;
  public:
  void clear_client_configuration();
  const ::livekit::ClientConfiguration& client_configuration() const;
  PROTOBUF_NODISCARD ::livekit::ClientConfiguration* release_client_configuration();
  ::livekit::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration);
  private:
  const ::livekit::ClientConfiguration& _internal_client_configuration() const;
  ::livekit::ClientConfiguration* _internal_mutable_client_configuration();
  public:
  void unsafe_arena_set_allocated_client_configuration(
      ::livekit::ClientConfiguration* client_configuration);
  ::livekit::ClientConfiguration* unsafe_arena_release_client_configuration();

  // .livekit.ServerInfo server_info = 12;
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;
  public:
  void clear_server_info();
  const ::livekit::ServerInfo& server_info() const;
  PROTOBUF_NODISCARD ::livekit::ServerInfo* release_server_info();
  ::livekit::ServerInfo* mutable_server_info();
  void set_allocated_server_info(::livekit::ServerInfo* server_info);
  private:
  const ::livekit::ServerInfo& _internal_server_info() const;
  ::livekit::ServerInfo* _internal_mutable_server_info();
  public:
  void unsafe_arena_set_allocated_server_info(
      ::livekit::ServerInfo* server_info);
  ::livekit::ServerInfo* unsafe_arena_release_server_info();

  // int32 ping_timeout = 10;
  void clear_ping_timeout();
  int32_t ping_timeout() const;
  void set_ping_timeout(int32_t value);
  private:
  int32_t _internal_ping_timeout() const;
  void _internal_set_ping_timeout(int32_t value);
  public:

  // bool subscriber_primary = 6;
  void clear_subscriber_primary();
  bool subscriber_primary() const;
  void set_subscriber_primary(bool value);
  private:
  bool _internal_subscriber_primary() const;
  void _internal_set_subscriber_primary(bool value);
  public:

  // bool fast_publish = 15;
  void clear_fast_publish();
  bool fast_publish() const;
  void set_fast_publish(bool value);
  private:
  bool _internal_fast_publish() const;
  void _internal_set_fast_publish(bool value);
  public:

  // int32 ping_interval = 11;
  void clear_ping_interval();
  int32_t ping_interval() const;
  void set_ping_interval(int32_t value);
  private:
  int32_t _internal_ping_interval() const;
  void _internal_set_ping_interval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.JoinResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo > other_participants_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer > ice_servers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec > enabled_publish_codecs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alternative_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sif_trailer_;
    ::livekit::Room* room_;
    ::livekit::ParticipantInfo* participant_;
    ::livekit::ClientConfiguration* client_configuration_;
    ::livekit::ServerInfo* server_info_;
    int32_t ping_timeout_;
    bool subscriber_primary_;
    bool fast_publish_;
    int32_t ping_interval_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ReconnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ReconnectResponse) */ {
 public:
  inline ReconnectResponse() : ReconnectResponse(nullptr) {}
  ~ReconnectResponse() override;
  explicit PROTOBUF_CONSTEXPR ReconnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReconnectResponse(const ReconnectResponse& from);
  ReconnectResponse(ReconnectResponse&& from) noexcept
    : ReconnectResponse() {
    *this = ::std::move(from);
  }

  inline ReconnectResponse& operator=(const ReconnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectResponse& operator=(ReconnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconnectResponse* internal_default_instance() {
    return reinterpret_cast<const ReconnectResponse*>(
               &_ReconnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReconnectResponse& a, ReconnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReconnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReconnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReconnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReconnectResponse& from) {
    ReconnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReconnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ReconnectResponse";
  }
  protected:
  explicit ReconnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIceServersFieldNumber = 1,
    kClientConfigurationFieldNumber = 2,
  };
  // repeated .livekit.ICEServer ice_servers = 1;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;
  public:
  void clear_ice_servers();
  ::livekit::ICEServer* mutable_ice_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
      mutable_ice_servers();
  private:
  const ::livekit::ICEServer& _internal_ice_servers(int index) const;
  ::livekit::ICEServer* _internal_add_ice_servers();
  public:
  const ::livekit::ICEServer& ice_servers(int index) const;
  ::livekit::ICEServer* add_ice_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
      ice_servers() const;

  // .livekit.ClientConfiguration client_configuration = 2;
  bool has_client_configuration() const;
  private:
  bool _internal_has_client_configuration() const;
  public:
  void clear_client_configuration();
  const ::livekit::ClientConfiguration& client_configuration() const;
  PROTOBUF_NODISCARD ::livekit::ClientConfiguration* release_client_configuration();
  ::livekit::ClientConfiguration* mutable_client_configuration();
  void set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration);
  private:
  const ::livekit::ClientConfiguration& _internal_client_configuration() const;
  ::livekit::ClientConfiguration* _internal_mutable_client_configuration();
  public:
  void unsafe_arena_set_allocated_client_configuration(
      ::livekit::ClientConfiguration* client_configuration);
  ::livekit::ClientConfiguration* unsafe_arena_release_client_configuration();

  // @@protoc_insertion_point(class_scope:livekit.ReconnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer > ice_servers_;
    ::livekit::ClientConfiguration* client_configuration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackPublishedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackPublishedResponse) */ {
 public:
  inline TrackPublishedResponse() : TrackPublishedResponse(nullptr) {}
  ~TrackPublishedResponse() override;
  explicit PROTOBUF_CONSTEXPR TrackPublishedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPublishedResponse(const TrackPublishedResponse& from);
  TrackPublishedResponse(TrackPublishedResponse&& from) noexcept
    : TrackPublishedResponse() {
    *this = ::std::move(from);
  }

  inline TrackPublishedResponse& operator=(const TrackPublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublishedResponse& operator=(TrackPublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublishedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPublishedResponse* internal_default_instance() {
    return reinterpret_cast<const TrackPublishedResponse*>(
               &_TrackPublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TrackPublishedResponse& a, TrackPublishedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPublishedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublishedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublishedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPublishedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPublishedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPublishedResponse& from) {
    TrackPublishedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPublishedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackPublishedResponse";
  }
  protected:
  explicit TrackPublishedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCidFieldNumber = 1,
    kTrackFieldNumber = 2,
  };
  // string cid = 1;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // .livekit.TrackInfo track = 2;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::TrackInfo& track() const;
  PROTOBUF_NODISCARD ::livekit::TrackInfo* release_track();
  ::livekit::TrackInfo* mutable_track();
  void set_allocated_track(::livekit::TrackInfo* track);
  private:
  const ::livekit::TrackInfo& _internal_track() const;
  ::livekit::TrackInfo* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::TrackInfo* track);
  ::livekit::TrackInfo* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.TrackPublishedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    ::livekit::TrackInfo* track_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackUnpublishedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackUnpublishedResponse) */ {
 public:
  inline TrackUnpublishedResponse() : TrackUnpublishedResponse(nullptr) {}
  ~TrackUnpublishedResponse() override;
  explicit PROTOBUF_CONSTEXPR TrackUnpublishedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUnpublishedResponse(const TrackUnpublishedResponse& from);
  TrackUnpublishedResponse(TrackUnpublishedResponse&& from) noexcept
    : TrackUnpublishedResponse() {
    *this = ::std::move(from);
  }

  inline TrackUnpublishedResponse& operator=(const TrackUnpublishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnpublishedResponse& operator=(TrackUnpublishedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnpublishedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUnpublishedResponse* internal_default_instance() {
    return reinterpret_cast<const TrackUnpublishedResponse*>(
               &_TrackUnpublishedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrackUnpublishedResponse& a, TrackUnpublishedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUnpublishedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnpublishedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnpublishedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUnpublishedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUnpublishedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackUnpublishedResponse& from) {
    TrackUnpublishedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUnpublishedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackUnpublishedResponse";
  }
  protected:
  explicit TrackUnpublishedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackUnpublishedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SessionDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SessionDescription) */ {
 public:
  inline SessionDescription() : SessionDescription(nullptr) {}
  ~SessionDescription() override;
  explicit PROTOBUF_CONSTEXPR SessionDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionDescription(const SessionDescription& from);
  SessionDescription(SessionDescription&& from) noexcept
    : SessionDescription() {
    *this = ::std::move(from);
  }

  inline SessionDescription& operator=(const SessionDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionDescription& operator=(SessionDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionDescription* internal_default_instance() {
    return reinterpret_cast<const SessionDescription*>(
               &_SessionDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SessionDescription& a, SessionDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionDescription& from) {
    SessionDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SessionDescription";
  }
  protected:
  explicit SessionDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSdpFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string sdp = 2;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SessionDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ParticipantUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantUpdate) */ {
 public:
  inline ParticipantUpdate() : ParticipantUpdate(nullptr) {}
  ~ParticipantUpdate() override;
  explicit PROTOBUF_CONSTEXPR ParticipantUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantUpdate(const ParticipantUpdate& from);
  ParticipantUpdate(ParticipantUpdate&& from) noexcept
    : ParticipantUpdate() {
    *this = ::std::move(from);
  }

  inline ParticipantUpdate& operator=(const ParticipantUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantUpdate& operator=(ParticipantUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantUpdate* internal_default_instance() {
    return reinterpret_cast<const ParticipantUpdate*>(
               &_ParticipantUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ParticipantUpdate& a, ParticipantUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantUpdate& from) {
    ParticipantUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantUpdate";
  }
  protected:
  explicit ParticipantUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .livekit.ParticipantInfo participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::livekit::ParticipantInfo* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
      mutable_participants();
  private:
  const ::livekit::ParticipantInfo& _internal_participants(int index) const;
  ::livekit::ParticipantInfo* _internal_add_participants();
  public:
  const ::livekit::ParticipantInfo& participants(int index) const;
  ::livekit::ParticipantInfo* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
      participants() const;

  // @@protoc_insertion_point(class_scope:livekit.ParticipantUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo > participants_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateSubscription) */ {
 public:
  inline UpdateSubscription() : UpdateSubscription(nullptr) {}
  ~UpdateSubscription() override;
  explicit PROTOBUF_CONSTEXPR UpdateSubscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscription(const UpdateSubscription& from);
  UpdateSubscription(UpdateSubscription&& from) noexcept
    : UpdateSubscription() {
    *this = ::std::move(from);
  }

  inline UpdateSubscription& operator=(const UpdateSubscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscription& operator=(UpdateSubscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscription* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscription*>(
               &_UpdateSubscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateSubscription& a, UpdateSubscription& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSubscription& from) {
    UpdateSubscription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateSubscription";
  }
  protected:
  explicit UpdateSubscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 1,
    kParticipantTracksFieldNumber = 3,
    kSubscribeFieldNumber = 2,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // repeated .livekit.ParticipantTracks participant_tracks = 3;
  int participant_tracks_size() const;
  private:
  int _internal_participant_tracks_size() const;
  public:
  void clear_participant_tracks();
  ::livekit::ParticipantTracks* mutable_participant_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
      mutable_participant_tracks();
  private:
  const ::livekit::ParticipantTracks& _internal_participant_tracks(int index) const;
  ::livekit::ParticipantTracks* _internal_add_participant_tracks();
  public:
  const ::livekit::ParticipantTracks& participant_tracks(int index) const;
  ::livekit::ParticipantTracks* add_participant_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
      participant_tracks() const;

  // bool subscribe = 2;
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateSubscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks > participant_tracks_;
    bool subscribe_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateTrackSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateTrackSettings) */ {
 public:
  inline UpdateTrackSettings() : UpdateTrackSettings(nullptr) {}
  ~UpdateTrackSettings() override;
  explicit PROTOBUF_CONSTEXPR UpdateTrackSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTrackSettings(const UpdateTrackSettings& from);
  UpdateTrackSettings(UpdateTrackSettings&& from) noexcept
    : UpdateTrackSettings() {
    *this = ::std::move(from);
  }

  inline UpdateTrackSettings& operator=(const UpdateTrackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTrackSettings& operator=(UpdateTrackSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTrackSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTrackSettings* internal_default_instance() {
    return reinterpret_cast<const UpdateTrackSettings*>(
               &_UpdateTrackSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateTrackSettings& a, UpdateTrackSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTrackSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTrackSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTrackSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTrackSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTrackSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTrackSettings& from) {
    UpdateTrackSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTrackSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateTrackSettings";
  }
  protected:
  explicit UpdateTrackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 1,
    kDisabledFieldNumber = 3,
    kQualityFieldNumber = 4,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kFpsFieldNumber = 7,
    kPriorityFieldNumber = 8,
  };
  // repeated string track_sids = 1;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // bool disabled = 3;
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // .livekit.VideoQuality quality = 4;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // uint32 width = 5;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 6;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 fps = 7;
  void clear_fps();
  uint32_t fps() const;
  void set_fps(uint32_t value);
  private:
  uint32_t _internal_fps() const;
  void _internal_set_fps(uint32_t value);
  public:

  // uint32 priority = 8;
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateTrackSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
    bool disabled_;
    int quality_;
    uint32_t width_;
    uint32_t height_;
    uint32_t fps_;
    uint32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalAudioTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateLocalAudioTrack) */ {
 public:
  inline UpdateLocalAudioTrack() : UpdateLocalAudioTrack(nullptr) {}
  ~UpdateLocalAudioTrack() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalAudioTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalAudioTrack(const UpdateLocalAudioTrack& from);
  UpdateLocalAudioTrack(UpdateLocalAudioTrack&& from) noexcept
    : UpdateLocalAudioTrack() {
    *this = ::std::move(from);
  }

  inline UpdateLocalAudioTrack& operator=(const UpdateLocalAudioTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalAudioTrack& operator=(UpdateLocalAudioTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalAudioTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalAudioTrack* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalAudioTrack*>(
               &_UpdateLocalAudioTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateLocalAudioTrack& a, UpdateLocalAudioTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalAudioTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalAudioTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalAudioTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalAudioTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalAudioTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalAudioTrack& from) {
    UpdateLocalAudioTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalAudioTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateLocalAudioTrack";
  }
  protected:
  explicit UpdateLocalAudioTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.AudioTrackFeature features = 2;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  private:
  ::livekit::AudioTrackFeature _internal_features(int index) const;
  void _internal_add_features(::livekit::AudioTrackFeature value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_features();
  public:
  ::livekit::AudioTrackFeature features(int index) const;
  void set_features(int index, ::livekit::AudioTrackFeature value);
  void add_features(::livekit::AudioTrackFeature value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_features();

  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateLocalAudioTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> features_;
    mutable std::atomic<int> _features_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateLocalVideoTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateLocalVideoTrack) */ {
 public:
  inline UpdateLocalVideoTrack() : UpdateLocalVideoTrack(nullptr) {}
  ~UpdateLocalVideoTrack() override;
  explicit PROTOBUF_CONSTEXPR UpdateLocalVideoTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateLocalVideoTrack(const UpdateLocalVideoTrack& from);
  UpdateLocalVideoTrack(UpdateLocalVideoTrack&& from) noexcept
    : UpdateLocalVideoTrack() {
    *this = ::std::move(from);
  }

  inline UpdateLocalVideoTrack& operator=(const UpdateLocalVideoTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateLocalVideoTrack& operator=(UpdateLocalVideoTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateLocalVideoTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateLocalVideoTrack* internal_default_instance() {
    return reinterpret_cast<const UpdateLocalVideoTrack*>(
               &_UpdateLocalVideoTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateLocalVideoTrack& a, UpdateLocalVideoTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateLocalVideoTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateLocalVideoTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateLocalVideoTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateLocalVideoTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateLocalVideoTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateLocalVideoTrack& from) {
    UpdateLocalVideoTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateLocalVideoTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateLocalVideoTrack";
  }
  protected:
  explicit UpdateLocalVideoTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // uint32 width = 2;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateLocalVideoTrack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    uint32_t width_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class LeaveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.LeaveRequest) */ {
 public:
  inline LeaveRequest() : LeaveRequest(nullptr) {}
  ~LeaveRequest() override;
  explicit PROTOBUF_CONSTEXPR LeaveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRequest(const LeaveRequest& from);
  LeaveRequest(LeaveRequest&& from) noexcept
    : LeaveRequest() {
    *this = ::std::move(from);
  }

  inline LeaveRequest& operator=(const LeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRequest& operator=(LeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRequest* internal_default_instance() {
    return reinterpret_cast<const LeaveRequest*>(
               &_LeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LeaveRequest& a, LeaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaveRequest& from) {
    LeaveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.LeaveRequest";
  }
  protected:
  explicit LeaveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LeaveRequest_Action Action;
  static constexpr Action DISCONNECT =
    LeaveRequest_Action_DISCONNECT;
  static constexpr Action RESUME =
    LeaveRequest_Action_RESUME;
  static constexpr Action RECONNECT =
    LeaveRequest_Action_RECONNECT;
  static inline bool Action_IsValid(int value) {
    return LeaveRequest_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    LeaveRequest_Action_Action_MIN;
  static constexpr Action Action_MAX =
    LeaveRequest_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    LeaveRequest_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return LeaveRequest_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return LeaveRequest_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return LeaveRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 4,
    kCanReconnectFieldNumber = 1,
    kReasonFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // .livekit.RegionSettings regions = 4;
  bool has_regions() const;
  private:
  bool _internal_has_regions() const;
  public:
  void clear_regions();
  const ::livekit::RegionSettings& regions() const;
  PROTOBUF_NODISCARD ::livekit::RegionSettings* release_regions();
  ::livekit::RegionSettings* mutable_regions();
  void set_allocated_regions(::livekit::RegionSettings* regions);
  private:
  const ::livekit::RegionSettings& _internal_regions() const;
  ::livekit::RegionSettings* _internal_mutable_regions();
  public:
  void unsafe_arena_set_allocated_regions(
      ::livekit::RegionSettings* regions);
  ::livekit::RegionSettings* unsafe_arena_release_regions();

  // bool can_reconnect = 1;
  void clear_can_reconnect();
  bool can_reconnect() const;
  void set_can_reconnect(bool value);
  private:
  bool _internal_can_reconnect() const;
  void _internal_set_can_reconnect(bool value);
  public:

  // .livekit.DisconnectReason reason = 2;
  void clear_reason();
  ::livekit::DisconnectReason reason() const;
  void set_reason(::livekit::DisconnectReason value);
  private:
  ::livekit::DisconnectReason _internal_reason() const;
  void _internal_set_reason(::livekit::DisconnectReason value);
  public:

  // .livekit.LeaveRequest.Action action = 3;
  void clear_action();
  ::livekit::LeaveRequest_Action action() const;
  void set_action(::livekit::LeaveRequest_Action value);
  private:
  ::livekit::LeaveRequest_Action _internal_action() const;
  void _internal_set_action(::livekit::LeaveRequest_Action value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.LeaveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::RegionSettings* regions_;
    bool can_reconnect_;
    int reason_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateVideoLayers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateVideoLayers) */ {
 public:
  inline UpdateVideoLayers() : UpdateVideoLayers(nullptr) {}
  ~UpdateVideoLayers() override;
  explicit PROTOBUF_CONSTEXPR UpdateVideoLayers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateVideoLayers(const UpdateVideoLayers& from);
  UpdateVideoLayers(UpdateVideoLayers&& from) noexcept
    : UpdateVideoLayers() {
    *this = ::std::move(from);
  }

  inline UpdateVideoLayers& operator=(const UpdateVideoLayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateVideoLayers& operator=(UpdateVideoLayers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateVideoLayers& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateVideoLayers* internal_default_instance() {
    return reinterpret_cast<const UpdateVideoLayers*>(
               &_UpdateVideoLayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateVideoLayers& a, UpdateVideoLayers& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateVideoLayers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateVideoLayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateVideoLayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateVideoLayers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateVideoLayers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateVideoLayers& from) {
    UpdateVideoLayers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateVideoLayers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateVideoLayers";
  }
  protected:
  explicit UpdateVideoLayers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 2,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.VideoLayer layers = 2;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateVideoLayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class UpdateParticipantMetadata_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateParticipantMetadata_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateParticipantMetadata_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UpdateParticipantMetadata_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UpdateParticipantMetadata_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UpdateParticipantMetadata_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UpdateParticipantMetadata_AttributesEntry_DoNotUse& other);
  static const UpdateParticipantMetadata_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateParticipantMetadata_AttributesEntry_DoNotUse*>(&_UpdateParticipantMetadata_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.UpdateParticipantMetadata.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.UpdateParticipantMetadata.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};

// -------------------------------------------------------------------

class UpdateParticipantMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateParticipantMetadata) */ {
 public:
  inline UpdateParticipantMetadata() : UpdateParticipantMetadata(nullptr) {}
  ~UpdateParticipantMetadata() override;
  explicit PROTOBUF_CONSTEXPR UpdateParticipantMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateParticipantMetadata(const UpdateParticipantMetadata& from);
  UpdateParticipantMetadata(UpdateParticipantMetadata&& from) noexcept
    : UpdateParticipantMetadata() {
    *this = ::std::move(from);
  }

  inline UpdateParticipantMetadata& operator=(const UpdateParticipantMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateParticipantMetadata& operator=(UpdateParticipantMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateParticipantMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateParticipantMetadata* internal_default_instance() {
    return reinterpret_cast<const UpdateParticipantMetadata*>(
               &_UpdateParticipantMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateParticipantMetadata& a, UpdateParticipantMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateParticipantMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateParticipantMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateParticipantMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateParticipantMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateParticipantMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateParticipantMetadata& from) {
    UpdateParticipantMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateParticipantMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateParticipantMetadata";
  }
  protected:
  explicit UpdateParticipantMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kMetadataFieldNumber = 1,
    kNameFieldNumber = 2,
    kRequestIdFieldNumber = 4,
  };
  // map<string, string> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string metadata = 1;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 request_id = 4;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateParticipantMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UpdateParticipantMetadata_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ICEServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ICEServer) */ {
 public:
  inline ICEServer() : ICEServer(nullptr) {}
  ~ICEServer() override;
  explicit PROTOBUF_CONSTEXPR ICEServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ICEServer(const ICEServer& from);
  ICEServer(ICEServer&& from) noexcept
    : ICEServer() {
    *this = ::std::move(from);
  }

  inline ICEServer& operator=(const ICEServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ICEServer& operator=(ICEServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ICEServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ICEServer* internal_default_instance() {
    return reinterpret_cast<const ICEServer*>(
               &_ICEServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ICEServer& a, ICEServer& b) {
    a.Swap(&b);
  }
  inline void Swap(ICEServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ICEServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ICEServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ICEServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ICEServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ICEServer& from) {
    ICEServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ICEServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ICEServer";
  }
  protected:
  explicit ICEServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kCredentialFieldNumber = 3,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string credential = 3;
  void clear_credential();
  const std::string& credential() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credential(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credential();
  PROTOBUF_NODISCARD std::string* release_credential();
  void set_allocated_credential(std::string* credential);
  private:
  const std::string& _internal_credential() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credential(const std::string& value);
  std::string* _internal_mutable_credential();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ICEServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credential_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SpeakersChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SpeakersChanged) */ {
 public:
  inline SpeakersChanged() : SpeakersChanged(nullptr) {}
  ~SpeakersChanged() override;
  explicit PROTOBUF_CONSTEXPR SpeakersChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeakersChanged(const SpeakersChanged& from);
  SpeakersChanged(SpeakersChanged&& from) noexcept
    : SpeakersChanged() {
    *this = ::std::move(from);
  }

  inline SpeakersChanged& operator=(const SpeakersChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakersChanged& operator=(SpeakersChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakersChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakersChanged* internal_default_instance() {
    return reinterpret_cast<const SpeakersChanged*>(
               &_SpeakersChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SpeakersChanged& a, SpeakersChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakersChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakersChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakersChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakersChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeakersChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeakersChanged& from) {
    SpeakersChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeakersChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SpeakersChanged";
  }
  protected:
  explicit SpeakersChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakersFieldNumber = 1,
  };
  // repeated .livekit.SpeakerInfo speakers = 1;
  int speakers_size() const;
  private:
  int _internal_speakers_size() const;
  public:
  void clear_speakers();
  ::livekit::SpeakerInfo* mutable_speakers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
      mutable_speakers();
  private:
  const ::livekit::SpeakerInfo& _internal_speakers(int index) const;
  ::livekit::SpeakerInfo* _internal_add_speakers();
  public:
  const ::livekit::SpeakerInfo& speakers(int index) const;
  ::livekit::SpeakerInfo* add_speakers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
      speakers() const;

  // @@protoc_insertion_point(class_scope:livekit.SpeakersChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo > speakers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class RoomUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomUpdate) */ {
 public:
  inline RoomUpdate() : RoomUpdate(nullptr) {}
  ~RoomUpdate() override;
  explicit PROTOBUF_CONSTEXPR RoomUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomUpdate(const RoomUpdate& from);
  RoomUpdate(RoomUpdate&& from) noexcept
    : RoomUpdate() {
    *this = ::std::move(from);
  }

  inline RoomUpdate& operator=(const RoomUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomUpdate& operator=(RoomUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomUpdate* internal_default_instance() {
    return reinterpret_cast<const RoomUpdate*>(
               &_RoomUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RoomUpdate& a, RoomUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomUpdate& from) {
    RoomUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomUpdate";
  }
  protected:
  explicit RoomUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .livekit.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // @@protoc_insertion_point(class_scope:livekit.RoomUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::Room* room_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ConnectionQualityInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityInfo) */ {
 public:
  inline ConnectionQualityInfo() : ConnectionQualityInfo(nullptr) {}
  ~ConnectionQualityInfo() override;
  explicit PROTOBUF_CONSTEXPR ConnectionQualityInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionQualityInfo(const ConnectionQualityInfo& from);
  ConnectionQualityInfo(ConnectionQualityInfo&& from) noexcept
    : ConnectionQualityInfo() {
    *this = ::std::move(from);
  }

  inline ConnectionQualityInfo& operator=(const ConnectionQualityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityInfo& operator=(ConnectionQualityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionQualityInfo* internal_default_instance() {
    return reinterpret_cast<const ConnectionQualityInfo*>(
               &_ConnectionQualityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConnectionQualityInfo& a, ConnectionQualityInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionQualityInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionQualityInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionQualityInfo& from) {
    ConnectionQualityInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionQualityInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ConnectionQualityInfo";
  }
  protected:
  explicit ConnectionQualityInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kQualityFieldNumber = 2,
    kScoreFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // .livekit.ConnectionQuality quality = 2;
  void clear_quality();
  ::livekit::ConnectionQuality quality() const;
  void set_quality(::livekit::ConnectionQuality value);
  private:
  ::livekit::ConnectionQuality _internal_quality() const;
  void _internal_set_quality(::livekit::ConnectionQuality value);
  public:

  // float score = 3;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    int quality_;
    float score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class ConnectionQualityUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ConnectionQualityUpdate) */ {
 public:
  inline ConnectionQualityUpdate() : ConnectionQualityUpdate(nullptr) {}
  ~ConnectionQualityUpdate() override;
  explicit PROTOBUF_CONSTEXPR ConnectionQualityUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionQualityUpdate(const ConnectionQualityUpdate& from);
  ConnectionQualityUpdate(ConnectionQualityUpdate&& from) noexcept
    : ConnectionQualityUpdate() {
    *this = ::std::move(from);
  }

  inline ConnectionQualityUpdate& operator=(const ConnectionQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityUpdate& operator=(ConnectionQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionQualityUpdate* internal_default_instance() {
    return reinterpret_cast<const ConnectionQualityUpdate*>(
               &_ConnectionQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ConnectionQualityUpdate& a, ConnectionQualityUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionQualityUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionQualityUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionQualityUpdate& from) {
    ConnectionQualityUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionQualityUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ConnectionQualityUpdate";
  }
  protected:
  explicit ConnectionQualityUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 1,
  };
  // repeated .livekit.ConnectionQualityInfo updates = 1;
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::livekit::ConnectionQualityInfo* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >*
      mutable_updates();
  private:
  const ::livekit::ConnectionQualityInfo& _internal_updates(int index) const;
  ::livekit::ConnectionQualityInfo* _internal_add_updates();
  public:
  const ::livekit::ConnectionQualityInfo& updates(int index) const;
  ::livekit::ConnectionQualityInfo* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >&
      updates() const;

  // @@protoc_insertion_point(class_scope:livekit.ConnectionQualityUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo > updates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class StreamStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamStateInfo) */ {
 public:
  inline StreamStateInfo() : StreamStateInfo(nullptr) {}
  ~StreamStateInfo() override;
  explicit PROTOBUF_CONSTEXPR StreamStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStateInfo(const StreamStateInfo& from);
  StreamStateInfo(StreamStateInfo&& from) noexcept
    : StreamStateInfo() {
    *this = ::std::move(from);
  }

  inline StreamStateInfo& operator=(const StreamStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateInfo& operator=(StreamStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStateInfo* internal_default_instance() {
    return reinterpret_cast<const StreamStateInfo*>(
               &_StreamStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StreamStateInfo& a, StreamStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStateInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamStateInfo& from) {
    StreamStateInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStateInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamStateInfo";
  }
  protected:
  explicit StreamStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string track_sid = 2;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // .livekit.StreamState state = 3;
  void clear_state();
  ::livekit::StreamState state() const;
  void set_state(::livekit::StreamState value);
  private:
  ::livekit::StreamState _internal_state() const;
  void _internal_set_state(::livekit::StreamState value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.StreamStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class StreamStateUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.StreamStateUpdate) */ {
 public:
  inline StreamStateUpdate() : StreamStateUpdate(nullptr) {}
  ~StreamStateUpdate() override;
  explicit PROTOBUF_CONSTEXPR StreamStateUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStateUpdate(const StreamStateUpdate& from);
  StreamStateUpdate(StreamStateUpdate&& from) noexcept
    : StreamStateUpdate() {
    *this = ::std::move(from);
  }

  inline StreamStateUpdate& operator=(const StreamStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStateUpdate& operator=(StreamStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStateUpdate* internal_default_instance() {
    return reinterpret_cast<const StreamStateUpdate*>(
               &_StreamStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StreamStateUpdate& a, StreamStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamStateUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStateUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamStateUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamStateUpdate& from) {
    StreamStateUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamStateUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.StreamStateUpdate";
  }
  protected:
  explicit StreamStateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamStatesFieldNumber = 1,
  };
  // repeated .livekit.StreamStateInfo stream_states = 1;
  int stream_states_size() const;
  private:
  int _internal_stream_states_size() const;
  public:
  void clear_stream_states();
  ::livekit::StreamStateInfo* mutable_stream_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >*
      mutable_stream_states();
  private:
  const ::livekit::StreamStateInfo& _internal_stream_states(int index) const;
  ::livekit::StreamStateInfo* _internal_add_stream_states();
  public:
  const ::livekit::StreamStateInfo& stream_states(int index) const;
  ::livekit::StreamStateInfo* add_stream_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >&
      stream_states() const;

  // @@protoc_insertion_point(class_scope:livekit.StreamStateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo > stream_states_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscribedQuality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscribedQuality) */ {
 public:
  inline SubscribedQuality() : SubscribedQuality(nullptr) {}
  ~SubscribedQuality() override;
  explicit PROTOBUF_CONSTEXPR SubscribedQuality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedQuality(const SubscribedQuality& from);
  SubscribedQuality(SubscribedQuality&& from) noexcept
    : SubscribedQuality() {
    *this = ::std::move(from);
  }

  inline SubscribedQuality& operator=(const SubscribedQuality& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQuality& operator=(SubscribedQuality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQuality& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedQuality* internal_default_instance() {
    return reinterpret_cast<const SubscribedQuality*>(
               &_SubscribedQuality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SubscribedQuality& a, SubscribedQuality& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribedQuality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQuality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQuality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedQuality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribedQuality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribedQuality& from) {
    SubscribedQuality::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribedQuality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscribedQuality";
  }
  protected:
  explicit SubscribedQuality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // .livekit.VideoQuality quality = 1;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // bool enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscribedQuality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int quality_;
    bool enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscribedCodec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscribedCodec) */ {
 public:
  inline SubscribedCodec() : SubscribedCodec(nullptr) {}
  ~SubscribedCodec() override;
  explicit PROTOBUF_CONSTEXPR SubscribedCodec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedCodec(const SubscribedCodec& from);
  SubscribedCodec(SubscribedCodec&& from) noexcept
    : SubscribedCodec() {
    *this = ::std::move(from);
  }

  inline SubscribedCodec& operator=(const SubscribedCodec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedCodec& operator=(SubscribedCodec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedCodec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedCodec* internal_default_instance() {
    return reinterpret_cast<const SubscribedCodec*>(
               &_SubscribedCodec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SubscribedCodec& a, SubscribedCodec& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribedCodec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedCodec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedCodec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedCodec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribedCodec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribedCodec& from) {
    SubscribedCodec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribedCodec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscribedCodec";
  }
  protected:
  explicit SubscribedCodec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualitiesFieldNumber = 2,
    kCodecFieldNumber = 1,
  };
  // repeated .livekit.SubscribedQuality qualities = 2;
  int qualities_size() const;
  private:
  int _internal_qualities_size() const;
  public:
  void clear_qualities();
  ::livekit::SubscribedQuality* mutable_qualities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
      mutable_qualities();
  private:
  const ::livekit::SubscribedQuality& _internal_qualities(int index) const;
  ::livekit::SubscribedQuality* _internal_add_qualities();
  public:
  const ::livekit::SubscribedQuality& qualities(int index) const;
  ::livekit::SubscribedQuality* add_qualities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
      qualities() const;

  // string codec = 1;
  void clear_codec();
  const std::string& codec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codec();
  PROTOBUF_NODISCARD std::string* release_codec();
  void set_allocated_codec(std::string* codec);
  private:
  const std::string& _internal_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec(const std::string& value);
  std::string* _internal_mutable_codec();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscribedCodec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality > qualities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscribedQualityUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscribedQualityUpdate) */ {
 public:
  inline SubscribedQualityUpdate() : SubscribedQualityUpdate(nullptr) {}
  ~SubscribedQualityUpdate() override;
  explicit PROTOBUF_CONSTEXPR SubscribedQualityUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedQualityUpdate(const SubscribedQualityUpdate& from);
  SubscribedQualityUpdate(SubscribedQualityUpdate&& from) noexcept
    : SubscribedQualityUpdate() {
    *this = ::std::move(from);
  }

  inline SubscribedQualityUpdate& operator=(const SubscribedQualityUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedQualityUpdate& operator=(SubscribedQualityUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribedQualityUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedQualityUpdate* internal_default_instance() {
    return reinterpret_cast<const SubscribedQualityUpdate*>(
               &_SubscribedQualityUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SubscribedQualityUpdate& a, SubscribedQualityUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribedQualityUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedQualityUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedQualityUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedQualityUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribedQualityUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribedQualityUpdate& from) {
    SubscribedQualityUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribedQualityUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscribedQualityUpdate";
  }
  protected:
  explicit SubscribedQualityUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribedQualitiesFieldNumber = 2,
    kSubscribedCodecsFieldNumber = 3,
    kTrackSidFieldNumber = 1,
  };
  // repeated .livekit.SubscribedQuality subscribed_qualities = 2;
  int subscribed_qualities_size() const;
  private:
  int _internal_subscribed_qualities_size() const;
  public:
  void clear_subscribed_qualities();
  ::livekit::SubscribedQuality* mutable_subscribed_qualities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
      mutable_subscribed_qualities();
  private:
  const ::livekit::SubscribedQuality& _internal_subscribed_qualities(int index) const;
  ::livekit::SubscribedQuality* _internal_add_subscribed_qualities();
  public:
  const ::livekit::SubscribedQuality& subscribed_qualities(int index) const;
  ::livekit::SubscribedQuality* add_subscribed_qualities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
      subscribed_qualities() const;

  // repeated .livekit.SubscribedCodec subscribed_codecs = 3;
  int subscribed_codecs_size() const;
  private:
  int _internal_subscribed_codecs_size() const;
  public:
  void clear_subscribed_codecs();
  ::livekit::SubscribedCodec* mutable_subscribed_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedCodec >*
      mutable_subscribed_codecs();
  private:
  const ::livekit::SubscribedCodec& _internal_subscribed_codecs(int index) const;
  ::livekit::SubscribedCodec* _internal_add_subscribed_codecs();
  public:
  const ::livekit::SubscribedCodec& subscribed_codecs(int index) const;
  ::livekit::SubscribedCodec* add_subscribed_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedCodec >&
      subscribed_codecs() const;

  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscribedQualityUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality > subscribed_qualities_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedCodec > subscribed_codecs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackPermission) */ {
 public:
  inline TrackPermission() : TrackPermission(nullptr) {}
  ~TrackPermission() override;
  explicit PROTOBUF_CONSTEXPR TrackPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPermission(const TrackPermission& from);
  TrackPermission(TrackPermission&& from) noexcept
    : TrackPermission() {
    *this = ::std::move(from);
  }

  inline TrackPermission& operator=(const TrackPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPermission& operator=(TrackPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPermission* internal_default_instance() {
    return reinterpret_cast<const TrackPermission*>(
               &_TrackPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TrackPermission& a, TrackPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPermission& from) {
    TrackPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackPermission";
  }
  protected:
  explicit TrackPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 3,
    kParticipantSidFieldNumber = 1,
    kParticipantIdentityFieldNumber = 4,
    kAllTracksFieldNumber = 2,
  };
  // repeated string track_sids = 3;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string participant_identity = 4;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // bool all_tracks = 2;
  void clear_all_tracks();
  bool all_tracks() const;
  void set_all_tracks(bool value);
  private:
  bool _internal_all_tracks() const;
  void _internal_set_all_tracks(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    bool all_tracks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermission) */ {
 public:
  inline SubscriptionPermission() : SubscriptionPermission(nullptr) {}
  ~SubscriptionPermission() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionPermission(const SubscriptionPermission& from);
  SubscriptionPermission(SubscriptionPermission&& from) noexcept
    : SubscriptionPermission() {
    *this = ::std::move(from);
  }

  inline SubscriptionPermission& operator=(const SubscriptionPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermission& operator=(SubscriptionPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionPermission* internal_default_instance() {
    return reinterpret_cast<const SubscriptionPermission*>(
               &_SubscriptionPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SubscriptionPermission& a, SubscriptionPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionPermission& from) {
    SubscriptionPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscriptionPermission";
  }
  protected:
  explicit SubscriptionPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackPermissionsFieldNumber = 2,
    kAllParticipantsFieldNumber = 1,
  };
  // repeated .livekit.TrackPermission track_permissions = 2;
  int track_permissions_size() const;
  private:
  int _internal_track_permissions_size() const;
  public:
  void clear_track_permissions();
  ::livekit::TrackPermission* mutable_track_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >*
      mutable_track_permissions();
  private:
  const ::livekit::TrackPermission& _internal_track_permissions(int index) const;
  ::livekit::TrackPermission* _internal_add_track_permissions();
  public:
  const ::livekit::TrackPermission& track_permissions(int index) const;
  ::livekit::TrackPermission* add_track_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >&
      track_permissions() const;

  // bool all_participants = 1;
  void clear_all_participants();
  bool all_participants() const;
  void set_all_participants(bool value);
  private:
  bool _internal_all_participants() const;
  void _internal_set_all_participants(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission > track_permissions_;
    bool all_participants_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionPermissionUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscriptionPermissionUpdate) */ {
 public:
  inline SubscriptionPermissionUpdate() : SubscriptionPermissionUpdate(nullptr) {}
  ~SubscriptionPermissionUpdate() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionPermissionUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionPermissionUpdate(const SubscriptionPermissionUpdate& from);
  SubscriptionPermissionUpdate(SubscriptionPermissionUpdate&& from) noexcept
    : SubscriptionPermissionUpdate() {
    *this = ::std::move(from);
  }

  inline SubscriptionPermissionUpdate& operator=(const SubscriptionPermissionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionPermissionUpdate& operator=(SubscriptionPermissionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionPermissionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionPermissionUpdate* internal_default_instance() {
    return reinterpret_cast<const SubscriptionPermissionUpdate*>(
               &_SubscriptionPermissionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SubscriptionPermissionUpdate& a, SubscriptionPermissionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionPermissionUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionPermissionUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionPermissionUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionPermissionUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionPermissionUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionPermissionUpdate& from) {
    SubscriptionPermissionUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionPermissionUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscriptionPermissionUpdate";
  }
  protected:
  explicit SubscriptionPermissionUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantSidFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kAllowedFieldNumber = 3,
  };
  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // string track_sid = 2;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // bool allowed = 3;
  void clear_allowed();
  bool allowed() const;
  void set_allowed(bool value);
  private:
  bool _internal_allowed() const;
  void _internal_set_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscriptionPermissionUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    bool allowed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SyncState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SyncState) */ {
 public:
  inline SyncState() : SyncState(nullptr) {}
  ~SyncState() override;
  explicit PROTOBUF_CONSTEXPR SyncState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncState(const SyncState& from);
  SyncState(SyncState&& from) noexcept
    : SyncState() {
    *this = ::std::move(from);
  }

  inline SyncState& operator=(const SyncState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncState& operator=(SyncState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncState& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncState* internal_default_instance() {
    return reinterpret_cast<const SyncState*>(
               &_SyncState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SyncState& a, SyncState& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncState& from) {
    SyncState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SyncState";
  }
  protected:
  explicit SyncState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishTracksFieldNumber = 3,
    kDataChannelsFieldNumber = 4,
    kTrackSidsDisabledFieldNumber = 6,
    kAnswerFieldNumber = 1,
    kSubscriptionFieldNumber = 2,
    kOfferFieldNumber = 5,
  };
  // repeated .livekit.TrackPublishedResponse publish_tracks = 3;
  int publish_tracks_size() const;
  private:
  int _internal_publish_tracks_size() const;
  public:
  void clear_publish_tracks();
  ::livekit::TrackPublishedResponse* mutable_publish_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >*
      mutable_publish_tracks();
  private:
  const ::livekit::TrackPublishedResponse& _internal_publish_tracks(int index) const;
  ::livekit::TrackPublishedResponse* _internal_add_publish_tracks();
  public:
  const ::livekit::TrackPublishedResponse& publish_tracks(int index) const;
  ::livekit::TrackPublishedResponse* add_publish_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >&
      publish_tracks() const;

  // repeated .livekit.DataChannelInfo data_channels = 4;
  int data_channels_size() const;
  private:
  int _internal_data_channels_size() const;
  public:
  void clear_data_channels();
  ::livekit::DataChannelInfo* mutable_data_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >*
      mutable_data_channels();
  private:
  const ::livekit::DataChannelInfo& _internal_data_channels(int index) const;
  ::livekit::DataChannelInfo* _internal_add_data_channels();
  public:
  const ::livekit::DataChannelInfo& data_channels(int index) const;
  ::livekit::DataChannelInfo* add_data_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >&
      data_channels() const;

  // repeated string track_sids_disabled = 6;
  int track_sids_disabled_size() const;
  private:
  int _internal_track_sids_disabled_size() const;
  public:
  void clear_track_sids_disabled();
  const std::string& track_sids_disabled(int index) const;
  std::string* mutable_track_sids_disabled(int index);
  void set_track_sids_disabled(int index, const std::string& value);
  void set_track_sids_disabled(int index, std::string&& value);
  void set_track_sids_disabled(int index, const char* value);
  void set_track_sids_disabled(int index, const char* value, size_t size);
  std::string* add_track_sids_disabled();
  void add_track_sids_disabled(const std::string& value);
  void add_track_sids_disabled(std::string&& value);
  void add_track_sids_disabled(const char* value);
  void add_track_sids_disabled(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids_disabled() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids_disabled();
  private:
  const std::string& _internal_track_sids_disabled(int index) const;
  std::string* _internal_add_track_sids_disabled();
  public:

  // .livekit.SessionDescription answer = 1;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const ::livekit::SessionDescription& answer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_answer();
  ::livekit::SessionDescription* mutable_answer();
  void set_allocated_answer(::livekit::SessionDescription* answer);
  private:
  const ::livekit::SessionDescription& _internal_answer() const;
  ::livekit::SessionDescription* _internal_mutable_answer();
  public:
  void unsafe_arena_set_allocated_answer(
      ::livekit::SessionDescription* answer);
  ::livekit::SessionDescription* unsafe_arena_release_answer();

  // .livekit.UpdateSubscription subscription = 2;
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::livekit::UpdateSubscription& subscription() const;
  PROTOBUF_NODISCARD ::livekit::UpdateSubscription* release_subscription();
  ::livekit::UpdateSubscription* mutable_subscription();
  void set_allocated_subscription(::livekit::UpdateSubscription* subscription);
  private:
  const ::livekit::UpdateSubscription& _internal_subscription() const;
  ::livekit::UpdateSubscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::livekit::UpdateSubscription* subscription);
  ::livekit::UpdateSubscription* unsafe_arena_release_subscription();

  // .livekit.SessionDescription offer = 5;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::livekit::SessionDescription& offer() const;
  PROTOBUF_NODISCARD ::livekit::SessionDescription* release_offer();
  ::livekit::SessionDescription* mutable_offer();
  void set_allocated_offer(::livekit::SessionDescription* offer);
  private:
  const ::livekit::SessionDescription& _internal_offer() const;
  ::livekit::SessionDescription* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::livekit::SessionDescription* offer);
  ::livekit::SessionDescription* unsafe_arena_release_offer();

  // @@protoc_insertion_point(class_scope:livekit.SyncState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse > publish_tracks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo > data_channels_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_disabled_;
    ::livekit::SessionDescription* answer_;
    ::livekit::UpdateSubscription* subscription_;
    ::livekit::SessionDescription* offer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class DataChannelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataChannelInfo) */ {
 public:
  inline DataChannelInfo() : DataChannelInfo(nullptr) {}
  ~DataChannelInfo() override;
  explicit PROTOBUF_CONSTEXPR DataChannelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChannelInfo(const DataChannelInfo& from);
  DataChannelInfo(DataChannelInfo&& from) noexcept
    : DataChannelInfo() {
    *this = ::std::move(from);
  }

  inline DataChannelInfo& operator=(const DataChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChannelInfo& operator=(DataChannelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChannelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataChannelInfo* internal_default_instance() {
    return reinterpret_cast<const DataChannelInfo*>(
               &_DataChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DataChannelInfo& a, DataChannelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChannelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChannelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChannelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChannelInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChannelInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataChannelInfo& from) {
    DataChannelInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChannelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataChannelInfo";
  }
  protected:
  explicit DataChannelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kIdFieldNumber = 2,
    kTargetFieldNumber = 3,
  };
  // string label = 1;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // uint32 id = 2;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .livekit.SignalTarget target = 3;
  void clear_target();
  ::livekit::SignalTarget target() const;
  void set_target(::livekit::SignalTarget value);
  private:
  ::livekit::SignalTarget _internal_target() const;
  void _internal_set_target(::livekit::SignalTarget value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataChannelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    uint32_t id_;
    int target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SimulateScenario final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SimulateScenario) */ {
 public:
  inline SimulateScenario() : SimulateScenario(nullptr) {}
  ~SimulateScenario() override;
  explicit PROTOBUF_CONSTEXPR SimulateScenario(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulateScenario(const SimulateScenario& from);
  SimulateScenario(SimulateScenario&& from) noexcept
    : SimulateScenario() {
    *this = ::std::move(from);
  }

  inline SimulateScenario& operator=(const SimulateScenario& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulateScenario& operator=(SimulateScenario&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulateScenario& default_instance() {
    return *internal_default_instance();
  }
  enum ScenarioCase {
    kSpeakerUpdate = 1,
    kNodeFailure = 2,
    kMigration = 3,
    kServerLeave = 4,
    kSwitchCandidateProtocol = 5,
    kSubscriberBandwidth = 6,
    kDisconnectSignalOnResume = 7,
    kDisconnectSignalOnResumeNoMessages = 8,
    kLeaveRequestFullReconnect = 9,
    SCENARIO_NOT_SET = 0,
  };

  static inline const SimulateScenario* internal_default_instance() {
    return reinterpret_cast<const SimulateScenario*>(
               &_SimulateScenario_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SimulateScenario& a, SimulateScenario& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulateScenario* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulateScenario* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulateScenario* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulateScenario>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulateScenario& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimulateScenario& from) {
    SimulateScenario::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulateScenario* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SimulateScenario";
  }
  protected:
  explicit SimulateScenario(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakerUpdateFieldNumber = 1,
    kNodeFailureFieldNumber = 2,
    kMigrationFieldNumber = 3,
    kServerLeaveFieldNumber = 4,
    kSwitchCandidateProtocolFieldNumber = 5,
    kSubscriberBandwidthFieldNumber = 6,
    kDisconnectSignalOnResumeFieldNumber = 7,
    kDisconnectSignalOnResumeNoMessagesFieldNumber = 8,
    kLeaveRequestFullReconnectFieldNumber = 9,
  };
  // int32 speaker_update = 1;
  bool has_speaker_update() const;
  private:
  bool _internal_has_speaker_update() const;
  public:
  void clear_speaker_update();
  int32_t speaker_update() const;
  void set_speaker_update(int32_t value);
  private:
  int32_t _internal_speaker_update() const;
  void _internal_set_speaker_update(int32_t value);
  public:

  // bool node_failure = 2;
  bool has_node_failure() const;
  private:
  bool _internal_has_node_failure() const;
  public:
  void clear_node_failure();
  bool node_failure() const;
  void set_node_failure(bool value);
  private:
  bool _internal_node_failure() const;
  void _internal_set_node_failure(bool value);
  public:

  // bool migration = 3;
  bool has_migration() const;
  private:
  bool _internal_has_migration() const;
  public:
  void clear_migration();
  bool migration() const;
  void set_migration(bool value);
  private:
  bool _internal_migration() const;
  void _internal_set_migration(bool value);
  public:

  // bool server_leave = 4;
  bool has_server_leave() const;
  private:
  bool _internal_has_server_leave() const;
  public:
  void clear_server_leave();
  bool server_leave() const;
  void set_server_leave(bool value);
  private:
  bool _internal_server_leave() const;
  void _internal_set_server_leave(bool value);
  public:

  // .livekit.CandidateProtocol switch_candidate_protocol = 5;
  bool has_switch_candidate_protocol() const;
  private:
  bool _internal_has_switch_candidate_protocol() const;
  public:
  void clear_switch_candidate_protocol();
  ::livekit::CandidateProtocol switch_candidate_protocol() const;
  void set_switch_candidate_protocol(::livekit::CandidateProtocol value);
  private:
  ::livekit::CandidateProtocol _internal_switch_candidate_protocol() const;
  void _internal_set_switch_candidate_protocol(::livekit::CandidateProtocol value);
  public:

  // int64 subscriber_bandwidth = 6;
  bool has_subscriber_bandwidth() const;
  private:
  bool _internal_has_subscriber_bandwidth() const;
  public:
  void clear_subscriber_bandwidth();
  int64_t subscriber_bandwidth() const;
  void set_subscriber_bandwidth(int64_t value);
  private:
  int64_t _internal_subscriber_bandwidth() const;
  void _internal_set_subscriber_bandwidth(int64_t value);
  public:

  // bool disconnect_signal_on_resume = 7;
  bool has_disconnect_signal_on_resume() const;
  private:
  bool _internal_has_disconnect_signal_on_resume() const;
  public:
  void clear_disconnect_signal_on_resume();
  bool disconnect_signal_on_resume() const;
  void set_disconnect_signal_on_resume(bool value);
  private:
  bool _internal_disconnect_signal_on_resume() const;
  void _internal_set_disconnect_signal_on_resume(bool value);
  public:

  // bool disconnect_signal_on_resume_no_messages = 8;
  bool has_disconnect_signal_on_resume_no_messages() const;
  private:
  bool _internal_has_disconnect_signal_on_resume_no_messages() const;
  public:
  void clear_disconnect_signal_on_resume_no_messages();
  bool disconnect_signal_on_resume_no_messages() const;
  void set_disconnect_signal_on_resume_no_messages(bool value);
  private:
  bool _internal_disconnect_signal_on_resume_no_messages() const;
  void _internal_set_disconnect_signal_on_resume_no_messages(bool value);
  public:

  // bool leave_request_full_reconnect = 9;
  bool has_leave_request_full_reconnect() const;
  private:
  bool _internal_has_leave_request_full_reconnect() const;
  public:
  void clear_leave_request_full_reconnect();
  bool leave_request_full_reconnect() const;
  void set_leave_request_full_reconnect(bool value);
  private:
  bool _internal_leave_request_full_reconnect() const;
  void _internal_set_leave_request_full_reconnect(bool value);
  public:

  void clear_scenario();
  ScenarioCase scenario_case() const;
  // @@protoc_insertion_point(class_scope:livekit.SimulateScenario)
 private:
  class _Internal;
  void set_has_speaker_update();
  void set_has_node_failure();
  void set_has_migration();
  void set_has_server_leave();
  void set_has_switch_candidate_protocol();
  void set_has_subscriber_bandwidth();
  void set_has_disconnect_signal_on_resume();
  void set_has_disconnect_signal_on_resume_no_messages();
  void set_has_leave_request_full_reconnect();

  inline bool has_scenario() const;
  inline void clear_has_scenario();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ScenarioUnion {
      constexpr ScenarioUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t speaker_update_;
      bool node_failure_;
      bool migration_;
      bool server_leave_;
      int switch_candidate_protocol_;
      int64_t subscriber_bandwidth_;
      bool disconnect_signal_on_resume_;
      bool disconnect_signal_on_resume_no_messages_;
      bool leave_request_full_reconnect_;
    } scenario_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping& from) {
    Ping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kRttFieldNumber = 2,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int64 rtt = 2;
  void clear_rtt();
  int64_t rtt() const;
  void set_rtt(int64_t value);
  private:
  int64_t _internal_rtt() const;
  void _internal_set_rtt(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    int64_t rtt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class Pong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  explicit PROTOBUF_CONSTEXPR Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pong& from) {
    Pong::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastPingTimestampFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // int64 last_ping_timestamp = 1;
  void clear_last_ping_timestamp();
  int64_t last_ping_timestamp() const;
  void set_last_ping_timestamp(int64_t value);
  private:
  int64_t _internal_last_ping_timestamp() const;
  void _internal_set_last_ping_timestamp(int64_t value);
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t last_ping_timestamp_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class RegionSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RegionSettings) */ {
 public:
  inline RegionSettings() : RegionSettings(nullptr) {}
  ~RegionSettings() override;
  explicit PROTOBUF_CONSTEXPR RegionSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionSettings(const RegionSettings& from);
  RegionSettings(RegionSettings&& from) noexcept
    : RegionSettings() {
    *this = ::std::move(from);
  }

  inline RegionSettings& operator=(const RegionSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionSettings& operator=(RegionSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionSettings* internal_default_instance() {
    return reinterpret_cast<const RegionSettings*>(
               &_RegionSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(RegionSettings& a, RegionSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionSettings& from) {
    RegionSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RegionSettings";
  }
  protected:
  explicit RegionSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
  };
  // repeated .livekit.RegionInfo regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::livekit::RegionInfo* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RegionInfo >*
      mutable_regions();
  private:
  const ::livekit::RegionInfo& _internal_regions(int index) const;
  ::livekit::RegionInfo* _internal_add_regions();
  public:
  const ::livekit::RegionInfo& regions(int index) const;
  ::livekit::RegionInfo* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RegionInfo >&
      regions() const;

  // @@protoc_insertion_point(class_scope:livekit.RegionSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RegionInfo > regions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class RegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RegionInfo) */ {
 public:
  inline RegionInfo() : RegionInfo(nullptr) {}
  ~RegionInfo() override;
  explicit PROTOBUF_CONSTEXPR RegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionInfo(const RegionInfo& from);
  RegionInfo(RegionInfo&& from) noexcept
    : RegionInfo() {
    *this = ::std::move(from);
  }

  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInfo& operator=(RegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionInfo* internal_default_instance() {
    return reinterpret_cast<const RegionInfo*>(
               &_RegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RegionInfo& a, RegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionInfo& from) {
    RegionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RegionInfo";
  }
  protected:
  explicit RegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kUrlFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // string region = 1;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // int64 distance = 3;
  void clear_distance();
  int64_t distance() const;
  void set_distance(int64_t value);
  private:
  int64_t _internal_distance() const;
  void _internal_set_distance(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    int64_t distance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SubscriptionResponse) */ {
 public:
  inline SubscriptionResponse() : SubscriptionResponse(nullptr) {}
  ~SubscriptionResponse() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionResponse(const SubscriptionResponse& from);
  SubscriptionResponse(SubscriptionResponse&& from) noexcept
    : SubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline SubscriptionResponse& operator=(const SubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionResponse& operator=(SubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const SubscriptionResponse*>(
               &_SubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SubscriptionResponse& a, SubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionResponse& from) {
    SubscriptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SubscriptionResponse";
  }
  protected:
  explicit SubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // .livekit.SubscriptionError err = 2;
  void clear_err();
  ::livekit::SubscriptionError err() const;
  void set_err(::livekit::SubscriptionError value);
  private:
  ::livekit::SubscriptionError _internal_err() const;
  void _internal_set_err(::livekit::SubscriptionError value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    int err_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class RequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RequestResponse) */ {
 public:
  inline RequestResponse() : RequestResponse(nullptr) {}
  ~RequestResponse() override;
  explicit PROTOBUF_CONSTEXPR RequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestResponse(const RequestResponse& from);
  RequestResponse(RequestResponse&& from) noexcept
    : RequestResponse() {
    *this = ::std::move(from);
  }

  inline RequestResponse& operator=(const RequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResponse& operator=(RequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestResponse* internal_default_instance() {
    return reinterpret_cast<const RequestResponse*>(
               &_RequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(RequestResponse& a, RequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestResponse& from) {
    RequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RequestResponse";
  }
  protected:
  explicit RequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RequestResponse_Reason Reason;
  static constexpr Reason OK =
    RequestResponse_Reason_OK;
  static constexpr Reason NOT_FOUND =
    RequestResponse_Reason_NOT_FOUND;
  static constexpr Reason NOT_ALLOWED =
    RequestResponse_Reason_NOT_ALLOWED;
  static constexpr Reason LIMIT_EXCEEDED =
    RequestResponse_Reason_LIMIT_EXCEEDED;
  static inline bool Reason_IsValid(int value) {
    return RequestResponse_Reason_IsValid(value);
  }
  static constexpr Reason Reason_MIN =
    RequestResponse_Reason_Reason_MIN;
  static constexpr Reason Reason_MAX =
    RequestResponse_Reason_Reason_MAX;
  static constexpr int Reason_ARRAYSIZE =
    RequestResponse_Reason_Reason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Reason_descriptor() {
    return RequestResponse_Reason_descriptor();
  }
  template<typename T>
  static inline const std::string& Reason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Reason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Reason_Name.");
    return RequestResponse_Reason_Name(enum_t_value);
  }
  static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Reason* value) {
    return RequestResponse_Reason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kRequestIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 request_id = 1;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // .livekit.RequestResponse.Reason reason = 2;
  void clear_reason();
  ::livekit::RequestResponse_Reason reason() const;
  void set_reason(::livekit::RequestResponse_Reason value);
  private:
  ::livekit::RequestResponse_Reason _internal_reason() const;
  void _internal_set_reason(::livekit::RequestResponse_Reason value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t request_id_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// -------------------------------------------------------------------

class TrackSubscribed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackSubscribed) */ {
 public:
  inline TrackSubscribed() : TrackSubscribed(nullptr) {}
  ~TrackSubscribed() override;
  explicit PROTOBUF_CONSTEXPR TrackSubscribed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSubscribed(const TrackSubscribed& from);
  TrackSubscribed(TrackSubscribed&& from) noexcept
    : TrackSubscribed() {
    *this = ::std::move(from);
  }

  inline TrackSubscribed& operator=(const TrackSubscribed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSubscribed& operator=(TrackSubscribed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSubscribed& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackSubscribed* internal_default_instance() {
    return reinterpret_cast<const TrackSubscribed*>(
               &_TrackSubscribed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(TrackSubscribed& a, TrackSubscribed& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSubscribed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSubscribed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSubscribed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSubscribed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSubscribed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackSubscribed& from) {
    TrackSubscribed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSubscribed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackSubscribed";
  }
  protected:
  explicit TrackSubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // string track_sid = 1;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackSubscribed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5frtc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignalRequest

// .livekit.SessionDescription offer = 1;
inline bool SignalRequest::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalRequest::has_offer() const {
  return _internal_has_offer();
}
inline void SignalRequest::set_has_offer() {
  _impl_._oneof_case_[0] = kOffer;
}
inline void SignalRequest::clear_offer() {
  if (_internal_has_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.offer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalRequest::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_offer() const {
  return _internal_has_offer()
      ? *_impl_.message_.offer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::offer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* SignalRequest::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.offer_;
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_offer(::livekit::SessionDescription* offer) {
  clear_message();
  if (offer) {
    set_has_offer();
    _impl_.message_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.offer)
}
inline ::livekit::SessionDescription* SignalRequest::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_message();
    set_has_offer();
    _impl_.message_.offer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return _impl_.message_.offer_;
}
inline ::livekit::SessionDescription* SignalRequest::mutable_offer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.offer)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalRequest::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalRequest::has_answer() const {
  return _internal_has_answer();
}
inline void SignalRequest::set_has_answer() {
  _impl_._oneof_case_[0] = kAnswer;
}
inline void SignalRequest::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.answer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalRequest::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalRequest::_internal_answer() const {
  return _internal_has_answer()
      ? *_impl_.message_.answer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalRequest::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* SignalRequest::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.answer_;
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_answer(::livekit::SessionDescription* answer) {
  clear_message();
  if (answer) {
    set_has_answer();
    _impl_.message_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.answer)
}
inline ::livekit::SessionDescription* SignalRequest::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_message();
    set_has_answer();
    _impl_.message_.answer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return _impl_.message_.answer_;
}
inline ::livekit::SessionDescription* SignalRequest::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.answer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 3;
inline bool SignalRequest::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalRequest::has_trickle() const {
  return _internal_has_trickle();
}
inline void SignalRequest::set_has_trickle() {
  _impl_._oneof_case_[0] = kTrickle;
}
inline void SignalRequest::clear_trickle() {
  if (_internal_has_trickle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.trickle_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* SignalRequest::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = _impl_.message_.trickle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalRequest::_internal_trickle() const {
  return _internal_has_trickle()
      ? *_impl_.message_.trickle_
      : reinterpret_cast< ::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalRequest::trickle() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* SignalRequest::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = _impl_.message_.trickle_;
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* trickle) {
  clear_message();
  if (trickle) {
    set_has_trickle();
    _impl_.message_.trickle_ = trickle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.trickle)
}
inline ::livekit::TrickleRequest* SignalRequest::_internal_mutable_trickle() {
  if (!_internal_has_trickle()) {
    clear_message();
    set_has_trickle();
    _impl_.message_.trickle_ = CreateMaybeMessage< ::livekit::TrickleRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.trickle_;
}
inline ::livekit::TrickleRequest* SignalRequest::mutable_trickle() {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.trickle)
  return _msg;
}

// .livekit.AddTrackRequest add_track = 4;
inline bool SignalRequest::_internal_has_add_track() const {
  return message_case() == kAddTrack;
}
inline bool SignalRequest::has_add_track() const {
  return _internal_has_add_track();
}
inline void SignalRequest::set_has_add_track() {
  _impl_._oneof_case_[0] = kAddTrack;
}
inline void SignalRequest::clear_add_track() {
  if (_internal_has_add_track()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.add_track_;
    }
    clear_has_message();
  }
}
inline ::livekit::AddTrackRequest* SignalRequest::release_add_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.add_track)
  if (_internal_has_add_track()) {
    clear_has_message();
    ::livekit::AddTrackRequest* temp = _impl_.message_.add_track_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AddTrackRequest& SignalRequest::_internal_add_track() const {
  return _internal_has_add_track()
      ? *_impl_.message_.add_track_
      : reinterpret_cast< ::livekit::AddTrackRequest&>(::livekit::_AddTrackRequest_default_instance_);
}
inline const ::livekit::AddTrackRequest& SignalRequest::add_track() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.add_track)
  return _internal_add_track();
}
inline ::livekit::AddTrackRequest* SignalRequest::unsafe_arena_release_add_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.add_track)
  if (_internal_has_add_track()) {
    clear_has_message();
    ::livekit::AddTrackRequest* temp = _impl_.message_.add_track_;
    _impl_.message_.add_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_add_track(::livekit::AddTrackRequest* add_track) {
  clear_message();
  if (add_track) {
    set_has_add_track();
    _impl_.message_.add_track_ = add_track;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.add_track)
}
inline ::livekit::AddTrackRequest* SignalRequest::_internal_mutable_add_track() {
  if (!_internal_has_add_track()) {
    clear_message();
    set_has_add_track();
    _impl_.message_.add_track_ = CreateMaybeMessage< ::livekit::AddTrackRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.add_track_;
}
inline ::livekit::AddTrackRequest* SignalRequest::mutable_add_track() {
  ::livekit::AddTrackRequest* _msg = _internal_mutable_add_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.add_track)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 5;
inline bool SignalRequest::_internal_has_mute() const {
  return message_case() == kMute;
}
inline bool SignalRequest::has_mute() const {
  return _internal_has_mute();
}
inline void SignalRequest::set_has_mute() {
  _impl_._oneof_case_[0] = kMute;
}
inline void SignalRequest::clear_mute() {
  if (_internal_has_mute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.mute_;
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* SignalRequest::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = _impl_.message_.mute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalRequest::_internal_mute() const {
  return _internal_has_mute()
      ? *_impl_.message_.mute_
      : reinterpret_cast< ::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalRequest::mute() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* SignalRequest::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = _impl_.message_.mute_;
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* mute) {
  clear_message();
  if (mute) {
    set_has_mute();
    _impl_.message_.mute_ = mute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.mute)
}
inline ::livekit::MuteTrackRequest* SignalRequest::_internal_mutable_mute() {
  if (!_internal_has_mute()) {
    clear_message();
    set_has_mute();
    _impl_.message_.mute_ = CreateMaybeMessage< ::livekit::MuteTrackRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.mute_;
}
inline ::livekit::MuteTrackRequest* SignalRequest::mutable_mute() {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.mute)
  return _msg;
}

// .livekit.UpdateSubscription subscription = 6;
inline bool SignalRequest::_internal_has_subscription() const {
  return message_case() == kSubscription;
}
inline bool SignalRequest::has_subscription() const {
  return _internal_has_subscription();
}
inline void SignalRequest::set_has_subscription() {
  _impl_._oneof_case_[0] = kSubscription;
}
inline void SignalRequest::clear_subscription() {
  if (_internal_has_subscription()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.subscription_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateSubscription* SignalRequest::release_subscription() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription)
  if (_internal_has_subscription()) {
    clear_has_message();
    ::livekit::UpdateSubscription* temp = _impl_.message_.subscription_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateSubscription& SignalRequest::_internal_subscription() const {
  return _internal_has_subscription()
      ? *_impl_.message_.subscription_
      : reinterpret_cast< ::livekit::UpdateSubscription&>(::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SignalRequest::subscription() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription)
  return _internal_subscription();
}
inline ::livekit::UpdateSubscription* SignalRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription)
  if (_internal_has_subscription()) {
    clear_has_message();
    ::livekit::UpdateSubscription* temp = _impl_.message_.subscription_;
    _impl_.message_.subscription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription(::livekit::UpdateSubscription* subscription) {
  clear_message();
  if (subscription) {
    set_has_subscription();
    _impl_.message_.subscription_ = subscription;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription)
}
inline ::livekit::UpdateSubscription* SignalRequest::_internal_mutable_subscription() {
  if (!_internal_has_subscription()) {
    clear_message();
    set_has_subscription();
    _impl_.message_.subscription_ = CreateMaybeMessage< ::livekit::UpdateSubscription >(GetArenaForAllocation());
  }
  return _impl_.message_.subscription_;
}
inline ::livekit::UpdateSubscription* SignalRequest::mutable_subscription() {
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription)
  return _msg;
}

// .livekit.UpdateTrackSettings track_setting = 7;
inline bool SignalRequest::_internal_has_track_setting() const {
  return message_case() == kTrackSetting;
}
inline bool SignalRequest::has_track_setting() const {
  return _internal_has_track_setting();
}
inline void SignalRequest::set_has_track_setting() {
  _impl_._oneof_case_[0] = kTrackSetting;
}
inline void SignalRequest::clear_track_setting() {
  if (_internal_has_track_setting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_setting_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateTrackSettings* SignalRequest::release_track_setting() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.track_setting)
  if (_internal_has_track_setting()) {
    clear_has_message();
    ::livekit::UpdateTrackSettings* temp = _impl_.message_.track_setting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::_internal_track_setting() const {
  return _internal_has_track_setting()
      ? *_impl_.message_.track_setting_
      : reinterpret_cast< ::livekit::UpdateTrackSettings&>(::livekit::_UpdateTrackSettings_default_instance_);
}
inline const ::livekit::UpdateTrackSettings& SignalRequest::track_setting() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.track_setting)
  return _internal_track_setting();
}
inline ::livekit::UpdateTrackSettings* SignalRequest::unsafe_arena_release_track_setting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.track_setting)
  if (_internal_has_track_setting()) {
    clear_has_message();
    ::livekit::UpdateTrackSettings* temp = _impl_.message_.track_setting_;
    _impl_.message_.track_setting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_track_setting(::livekit::UpdateTrackSettings* track_setting) {
  clear_message();
  if (track_setting) {
    set_has_track_setting();
    _impl_.message_.track_setting_ = track_setting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.track_setting)
}
inline ::livekit::UpdateTrackSettings* SignalRequest::_internal_mutable_track_setting() {
  if (!_internal_has_track_setting()) {
    clear_message();
    set_has_track_setting();
    _impl_.message_.track_setting_ = CreateMaybeMessage< ::livekit::UpdateTrackSettings >(GetArenaForAllocation());
  }
  return _impl_.message_.track_setting_;
}
inline ::livekit::UpdateTrackSettings* SignalRequest::mutable_track_setting() {
  ::livekit::UpdateTrackSettings* _msg = _internal_mutable_track_setting();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.track_setting)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalRequest::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalRequest::has_leave() const {
  return _internal_has_leave();
}
inline void SignalRequest::set_has_leave() {
  _impl_._oneof_case_[0] = kLeave;
}
inline void SignalRequest::clear_leave() {
  if (_internal_has_leave()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.leave_;
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* SignalRequest::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = _impl_.message_.leave_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalRequest::_internal_leave() const {
  return _internal_has_leave()
      ? *_impl_.message_.leave_
      : reinterpret_cast< ::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalRequest::leave() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* SignalRequest::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = _impl_.message_.leave_;
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* leave) {
  clear_message();
  if (leave) {
    set_has_leave();
    _impl_.message_.leave_ = leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.leave)
}
inline ::livekit::LeaveRequest* SignalRequest::_internal_mutable_leave() {
  if (!_internal_has_leave()) {
    clear_message();
    set_has_leave();
    _impl_.message_.leave_ = CreateMaybeMessage< ::livekit::LeaveRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.leave_;
}
inline ::livekit::LeaveRequest* SignalRequest::mutable_leave() {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.leave)
  return _msg;
}

// .livekit.UpdateVideoLayers update_layers = 10 [deprecated = true];
inline bool SignalRequest::_internal_has_update_layers() const {
  return message_case() == kUpdateLayers;
}
inline bool SignalRequest::has_update_layers() const {
  return _internal_has_update_layers();
}
inline void SignalRequest::set_has_update_layers() {
  _impl_._oneof_case_[0] = kUpdateLayers;
}
inline void SignalRequest::clear_update_layers() {
  if (_internal_has_update_layers()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_layers_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateVideoLayers* SignalRequest::release_update_layers() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_layers)
  if (_internal_has_update_layers()) {
    clear_has_message();
    ::livekit::UpdateVideoLayers* temp = _impl_.message_.update_layers_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::_internal_update_layers() const {
  return _internal_has_update_layers()
      ? *_impl_.message_.update_layers_
      : reinterpret_cast< ::livekit::UpdateVideoLayers&>(::livekit::_UpdateVideoLayers_default_instance_);
}
inline const ::livekit::UpdateVideoLayers& SignalRequest::update_layers() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_layers)
  return _internal_update_layers();
}
inline ::livekit::UpdateVideoLayers* SignalRequest::unsafe_arena_release_update_layers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_layers)
  if (_internal_has_update_layers()) {
    clear_has_message();
    ::livekit::UpdateVideoLayers* temp = _impl_.message_.update_layers_;
    _impl_.message_.update_layers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_layers(::livekit::UpdateVideoLayers* update_layers) {
  clear_message();
  if (update_layers) {
    set_has_update_layers();
    _impl_.message_.update_layers_ = update_layers;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_layers)
}
inline ::livekit::UpdateVideoLayers* SignalRequest::_internal_mutable_update_layers() {
  if (!_internal_has_update_layers()) {
    clear_message();
    set_has_update_layers();
    _impl_.message_.update_layers_ = CreateMaybeMessage< ::livekit::UpdateVideoLayers >(GetArenaForAllocation());
  }
  return _impl_.message_.update_layers_;
}
inline ::livekit::UpdateVideoLayers* SignalRequest::mutable_update_layers() {
  ::livekit::UpdateVideoLayers* _msg = _internal_mutable_update_layers();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_layers)
  return _msg;
}

// .livekit.SubscriptionPermission subscription_permission = 11;
inline bool SignalRequest::_internal_has_subscription_permission() const {
  return message_case() == kSubscriptionPermission;
}
inline bool SignalRequest::has_subscription_permission() const {
  return _internal_has_subscription_permission();
}
inline void SignalRequest::set_has_subscription_permission() {
  _impl_._oneof_case_[0] = kSubscriptionPermission;
}
inline void SignalRequest::clear_subscription_permission() {
  if (_internal_has_subscription_permission()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.subscription_permission_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermission* SignalRequest::release_subscription_permission() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.subscription_permission)
  if (_internal_has_subscription_permission()) {
    clear_has_message();
    ::livekit::SubscriptionPermission* temp = _impl_.message_.subscription_permission_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermission& SignalRequest::_internal_subscription_permission() const {
  return _internal_has_subscription_permission()
      ? *_impl_.message_.subscription_permission_
      : reinterpret_cast< ::livekit::SubscriptionPermission&>(::livekit::_SubscriptionPermission_default_instance_);
}
inline const ::livekit::SubscriptionPermission& SignalRequest::subscription_permission() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.subscription_permission)
  return _internal_subscription_permission();
}
inline ::livekit::SubscriptionPermission* SignalRequest::unsafe_arena_release_subscription_permission() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.subscription_permission)
  if (_internal_has_subscription_permission()) {
    clear_has_message();
    ::livekit::SubscriptionPermission* temp = _impl_.message_.subscription_permission_;
    _impl_.message_.subscription_permission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_subscription_permission(::livekit::SubscriptionPermission* subscription_permission) {
  clear_message();
  if (subscription_permission) {
    set_has_subscription_permission();
    _impl_.message_.subscription_permission_ = subscription_permission;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.subscription_permission)
}
inline ::livekit::SubscriptionPermission* SignalRequest::_internal_mutable_subscription_permission() {
  if (!_internal_has_subscription_permission()) {
    clear_message();
    set_has_subscription_permission();
    _impl_.message_.subscription_permission_ = CreateMaybeMessage< ::livekit::SubscriptionPermission >(GetArenaForAllocation());
  }
  return _impl_.message_.subscription_permission_;
}
inline ::livekit::SubscriptionPermission* SignalRequest::mutable_subscription_permission() {
  ::livekit::SubscriptionPermission* _msg = _internal_mutable_subscription_permission();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.subscription_permission)
  return _msg;
}

// .livekit.SyncState sync_state = 12;
inline bool SignalRequest::_internal_has_sync_state() const {
  return message_case() == kSyncState;
}
inline bool SignalRequest::has_sync_state() const {
  return _internal_has_sync_state();
}
inline void SignalRequest::set_has_sync_state() {
  _impl_._oneof_case_[0] = kSyncState;
}
inline void SignalRequest::clear_sync_state() {
  if (_internal_has_sync_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.sync_state_;
    }
    clear_has_message();
  }
}
inline ::livekit::SyncState* SignalRequest::release_sync_state() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.sync_state)
  if (_internal_has_sync_state()) {
    clear_has_message();
    ::livekit::SyncState* temp = _impl_.message_.sync_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SyncState& SignalRequest::_internal_sync_state() const {
  return _internal_has_sync_state()
      ? *_impl_.message_.sync_state_
      : reinterpret_cast< ::livekit::SyncState&>(::livekit::_SyncState_default_instance_);
}
inline const ::livekit::SyncState& SignalRequest::sync_state() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.sync_state)
  return _internal_sync_state();
}
inline ::livekit::SyncState* SignalRequest::unsafe_arena_release_sync_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.sync_state)
  if (_internal_has_sync_state()) {
    clear_has_message();
    ::livekit::SyncState* temp = _impl_.message_.sync_state_;
    _impl_.message_.sync_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_sync_state(::livekit::SyncState* sync_state) {
  clear_message();
  if (sync_state) {
    set_has_sync_state();
    _impl_.message_.sync_state_ = sync_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.sync_state)
}
inline ::livekit::SyncState* SignalRequest::_internal_mutable_sync_state() {
  if (!_internal_has_sync_state()) {
    clear_message();
    set_has_sync_state();
    _impl_.message_.sync_state_ = CreateMaybeMessage< ::livekit::SyncState >(GetArenaForAllocation());
  }
  return _impl_.message_.sync_state_;
}
inline ::livekit::SyncState* SignalRequest::mutable_sync_state() {
  ::livekit::SyncState* _msg = _internal_mutable_sync_state();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.sync_state)
  return _msg;
}

// .livekit.SimulateScenario simulate = 13;
inline bool SignalRequest::_internal_has_simulate() const {
  return message_case() == kSimulate;
}
inline bool SignalRequest::has_simulate() const {
  return _internal_has_simulate();
}
inline void SignalRequest::set_has_simulate() {
  _impl_._oneof_case_[0] = kSimulate;
}
inline void SignalRequest::clear_simulate() {
  if (_internal_has_simulate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.simulate_;
    }
    clear_has_message();
  }
}
inline ::livekit::SimulateScenario* SignalRequest::release_simulate() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.simulate)
  if (_internal_has_simulate()) {
    clear_has_message();
    ::livekit::SimulateScenario* temp = _impl_.message_.simulate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SimulateScenario& SignalRequest::_internal_simulate() const {
  return _internal_has_simulate()
      ? *_impl_.message_.simulate_
      : reinterpret_cast< ::livekit::SimulateScenario&>(::livekit::_SimulateScenario_default_instance_);
}
inline const ::livekit::SimulateScenario& SignalRequest::simulate() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.simulate)
  return _internal_simulate();
}
inline ::livekit::SimulateScenario* SignalRequest::unsafe_arena_release_simulate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.simulate)
  if (_internal_has_simulate()) {
    clear_has_message();
    ::livekit::SimulateScenario* temp = _impl_.message_.simulate_;
    _impl_.message_.simulate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_simulate(::livekit::SimulateScenario* simulate) {
  clear_message();
  if (simulate) {
    set_has_simulate();
    _impl_.message_.simulate_ = simulate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.simulate)
}
inline ::livekit::SimulateScenario* SignalRequest::_internal_mutable_simulate() {
  if (!_internal_has_simulate()) {
    clear_message();
    set_has_simulate();
    _impl_.message_.simulate_ = CreateMaybeMessage< ::livekit::SimulateScenario >(GetArenaForAllocation());
  }
  return _impl_.message_.simulate_;
}
inline ::livekit::SimulateScenario* SignalRequest::mutable_simulate() {
  ::livekit::SimulateScenario* _msg = _internal_mutable_simulate();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.simulate)
  return _msg;
}

// int64 ping = 14;
inline bool SignalRequest::_internal_has_ping() const {
  return message_case() == kPing;
}
inline bool SignalRequest::has_ping() const {
  return _internal_has_ping();
}
inline void SignalRequest::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void SignalRequest::clear_ping() {
  if (_internal_has_ping()) {
    _impl_.message_.ping_ = int64_t{0};
    clear_has_message();
  }
}
inline int64_t SignalRequest::_internal_ping() const {
  if (_internal_has_ping()) {
    return _impl_.message_.ping_;
  }
  return int64_t{0};
}
inline void SignalRequest::_internal_set_ping(int64_t value) {
  if (!_internal_has_ping()) {
    clear_message();
    set_has_ping();
  }
  _impl_.message_.ping_ = value;
}
inline int64_t SignalRequest::ping() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.ping)
  return _internal_ping();
}
inline void SignalRequest::set_ping(int64_t value) {
  _internal_set_ping(value);
  // @@protoc_insertion_point(field_set:livekit.SignalRequest.ping)
}

// .livekit.UpdateParticipantMetadata update_metadata = 15;
inline bool SignalRequest::_internal_has_update_metadata() const {
  return message_case() == kUpdateMetadata;
}
inline bool SignalRequest::has_update_metadata() const {
  return _internal_has_update_metadata();
}
inline void SignalRequest::set_has_update_metadata() {
  _impl_._oneof_case_[0] = kUpdateMetadata;
}
inline void SignalRequest::clear_update_metadata() {
  if (_internal_has_update_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_metadata_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateParticipantMetadata* SignalRequest::release_update_metadata() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_metadata)
  if (_internal_has_update_metadata()) {
    clear_has_message();
    ::livekit::UpdateParticipantMetadata* temp = _impl_.message_.update_metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateParticipantMetadata& SignalRequest::_internal_update_metadata() const {
  return _internal_has_update_metadata()
      ? *_impl_.message_.update_metadata_
      : reinterpret_cast< ::livekit::UpdateParticipantMetadata&>(::livekit::_UpdateParticipantMetadata_default_instance_);
}
inline const ::livekit::UpdateParticipantMetadata& SignalRequest::update_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_metadata)
  return _internal_update_metadata();
}
inline ::livekit::UpdateParticipantMetadata* SignalRequest::unsafe_arena_release_update_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_metadata)
  if (_internal_has_update_metadata()) {
    clear_has_message();
    ::livekit::UpdateParticipantMetadata* temp = _impl_.message_.update_metadata_;
    _impl_.message_.update_metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_metadata(::livekit::UpdateParticipantMetadata* update_metadata) {
  clear_message();
  if (update_metadata) {
    set_has_update_metadata();
    _impl_.message_.update_metadata_ = update_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_metadata)
}
inline ::livekit::UpdateParticipantMetadata* SignalRequest::_internal_mutable_update_metadata() {
  if (!_internal_has_update_metadata()) {
    clear_message();
    set_has_update_metadata();
    _impl_.message_.update_metadata_ = CreateMaybeMessage< ::livekit::UpdateParticipantMetadata >(GetArenaForAllocation());
  }
  return _impl_.message_.update_metadata_;
}
inline ::livekit::UpdateParticipantMetadata* SignalRequest::mutable_update_metadata() {
  ::livekit::UpdateParticipantMetadata* _msg = _internal_mutable_update_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_metadata)
  return _msg;
}

// .livekit.Ping ping_req = 16;
inline bool SignalRequest::_internal_has_ping_req() const {
  return message_case() == kPingReq;
}
inline bool SignalRequest::has_ping_req() const {
  return _internal_has_ping_req();
}
inline void SignalRequest::set_has_ping_req() {
  _impl_._oneof_case_[0] = kPingReq;
}
inline void SignalRequest::clear_ping_req() {
  if (_internal_has_ping_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ping_req_;
    }
    clear_has_message();
  }
}
inline ::livekit::Ping* SignalRequest::release_ping_req() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.ping_req)
  if (_internal_has_ping_req()) {
    clear_has_message();
    ::livekit::Ping* temp = _impl_.message_.ping_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ping_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::Ping& SignalRequest::_internal_ping_req() const {
  return _internal_has_ping_req()
      ? *_impl_.message_.ping_req_
      : reinterpret_cast< ::livekit::Ping&>(::livekit::_Ping_default_instance_);
}
inline const ::livekit::Ping& SignalRequest::ping_req() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.ping_req)
  return _internal_ping_req();
}
inline ::livekit::Ping* SignalRequest::unsafe_arena_release_ping_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.ping_req)
  if (_internal_has_ping_req()) {
    clear_has_message();
    ::livekit::Ping* temp = _impl_.message_.ping_req_;
    _impl_.message_.ping_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_ping_req(::livekit::Ping* ping_req) {
  clear_message();
  if (ping_req) {
    set_has_ping_req();
    _impl_.message_.ping_req_ = ping_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.ping_req)
}
inline ::livekit::Ping* SignalRequest::_internal_mutable_ping_req() {
  if (!_internal_has_ping_req()) {
    clear_message();
    set_has_ping_req();
    _impl_.message_.ping_req_ = CreateMaybeMessage< ::livekit::Ping >(GetArenaForAllocation());
  }
  return _impl_.message_.ping_req_;
}
inline ::livekit::Ping* SignalRequest::mutable_ping_req() {
  ::livekit::Ping* _msg = _internal_mutable_ping_req();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.ping_req)
  return _msg;
}

// .livekit.UpdateLocalAudioTrack update_audio_track = 17;
inline bool SignalRequest::_internal_has_update_audio_track() const {
  return message_case() == kUpdateAudioTrack;
}
inline bool SignalRequest::has_update_audio_track() const {
  return _internal_has_update_audio_track();
}
inline void SignalRequest::set_has_update_audio_track() {
  _impl_._oneof_case_[0] = kUpdateAudioTrack;
}
inline void SignalRequest::clear_update_audio_track() {
  if (_internal_has_update_audio_track()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_audio_track_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateLocalAudioTrack* SignalRequest::release_update_audio_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_audio_track)
  if (_internal_has_update_audio_track()) {
    clear_has_message();
    ::livekit::UpdateLocalAudioTrack* temp = _impl_.message_.update_audio_track_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_audio_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateLocalAudioTrack& SignalRequest::_internal_update_audio_track() const {
  return _internal_has_update_audio_track()
      ? *_impl_.message_.update_audio_track_
      : reinterpret_cast< ::livekit::UpdateLocalAudioTrack&>(::livekit::_UpdateLocalAudioTrack_default_instance_);
}
inline const ::livekit::UpdateLocalAudioTrack& SignalRequest::update_audio_track() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_audio_track)
  return _internal_update_audio_track();
}
inline ::livekit::UpdateLocalAudioTrack* SignalRequest::unsafe_arena_release_update_audio_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_audio_track)
  if (_internal_has_update_audio_track()) {
    clear_has_message();
    ::livekit::UpdateLocalAudioTrack* temp = _impl_.message_.update_audio_track_;
    _impl_.message_.update_audio_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_audio_track(::livekit::UpdateLocalAudioTrack* update_audio_track) {
  clear_message();
  if (update_audio_track) {
    set_has_update_audio_track();
    _impl_.message_.update_audio_track_ = update_audio_track;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_audio_track)
}
inline ::livekit::UpdateLocalAudioTrack* SignalRequest::_internal_mutable_update_audio_track() {
  if (!_internal_has_update_audio_track()) {
    clear_message();
    set_has_update_audio_track();
    _impl_.message_.update_audio_track_ = CreateMaybeMessage< ::livekit::UpdateLocalAudioTrack >(GetArenaForAllocation());
  }
  return _impl_.message_.update_audio_track_;
}
inline ::livekit::UpdateLocalAudioTrack* SignalRequest::mutable_update_audio_track() {
  ::livekit::UpdateLocalAudioTrack* _msg = _internal_mutable_update_audio_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_audio_track)
  return _msg;
}

// .livekit.UpdateLocalVideoTrack update_video_track = 18;
inline bool SignalRequest::_internal_has_update_video_track() const {
  return message_case() == kUpdateVideoTrack;
}
inline bool SignalRequest::has_update_video_track() const {
  return _internal_has_update_video_track();
}
inline void SignalRequest::set_has_update_video_track() {
  _impl_._oneof_case_[0] = kUpdateVideoTrack;
}
inline void SignalRequest::clear_update_video_track() {
  if (_internal_has_update_video_track()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_video_track_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateLocalVideoTrack* SignalRequest::release_update_video_track() {
  // @@protoc_insertion_point(field_release:livekit.SignalRequest.update_video_track)
  if (_internal_has_update_video_track()) {
    clear_has_message();
    ::livekit::UpdateLocalVideoTrack* temp = _impl_.message_.update_video_track_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_video_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateLocalVideoTrack& SignalRequest::_internal_update_video_track() const {
  return _internal_has_update_video_track()
      ? *_impl_.message_.update_video_track_
      : reinterpret_cast< ::livekit::UpdateLocalVideoTrack&>(::livekit::_UpdateLocalVideoTrack_default_instance_);
}
inline const ::livekit::UpdateLocalVideoTrack& SignalRequest::update_video_track() const {
  // @@protoc_insertion_point(field_get:livekit.SignalRequest.update_video_track)
  return _internal_update_video_track();
}
inline ::livekit::UpdateLocalVideoTrack* SignalRequest::unsafe_arena_release_update_video_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalRequest.update_video_track)
  if (_internal_has_update_video_track()) {
    clear_has_message();
    ::livekit::UpdateLocalVideoTrack* temp = _impl_.message_.update_video_track_;
    _impl_.message_.update_video_track_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalRequest::unsafe_arena_set_allocated_update_video_track(::livekit::UpdateLocalVideoTrack* update_video_track) {
  clear_message();
  if (update_video_track) {
    set_has_update_video_track();
    _impl_.message_.update_video_track_ = update_video_track;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalRequest.update_video_track)
}
inline ::livekit::UpdateLocalVideoTrack* SignalRequest::_internal_mutable_update_video_track() {
  if (!_internal_has_update_video_track()) {
    clear_message();
    set_has_update_video_track();
    _impl_.message_.update_video_track_ = CreateMaybeMessage< ::livekit::UpdateLocalVideoTrack >(GetArenaForAllocation());
  }
  return _impl_.message_.update_video_track_;
}
inline ::livekit::UpdateLocalVideoTrack* SignalRequest::mutable_update_video_track() {
  ::livekit::UpdateLocalVideoTrack* _msg = _internal_mutable_update_video_track();
  // @@protoc_insertion_point(field_mutable:livekit.SignalRequest.update_video_track)
  return _msg;
}

inline bool SignalRequest::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalRequest::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalRequest::MessageCase SignalRequest::message_case() const {
  return SignalRequest::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignalResponse

// .livekit.JoinResponse join = 1;
inline bool SignalResponse::_internal_has_join() const {
  return message_case() == kJoin;
}
inline bool SignalResponse::has_join() const {
  return _internal_has_join();
}
inline void SignalResponse::set_has_join() {
  _impl_._oneof_case_[0] = kJoin;
}
inline void SignalResponse::clear_join() {
  if (_internal_has_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.join_;
    }
    clear_has_message();
  }
}
inline ::livekit::JoinResponse* SignalResponse::release_join() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.join)
  if (_internal_has_join()) {
    clear_has_message();
    ::livekit::JoinResponse* temp = _impl_.message_.join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JoinResponse& SignalResponse::_internal_join() const {
  return _internal_has_join()
      ? *_impl_.message_.join_
      : reinterpret_cast< ::livekit::JoinResponse&>(::livekit::_JoinResponse_default_instance_);
}
inline const ::livekit::JoinResponse& SignalResponse::join() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.join)
  return _internal_join();
}
inline ::livekit::JoinResponse* SignalResponse::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.join)
  if (_internal_has_join()) {
    clear_has_message();
    ::livekit::JoinResponse* temp = _impl_.message_.join_;
    _impl_.message_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_join(::livekit::JoinResponse* join) {
  clear_message();
  if (join) {
    set_has_join();
    _impl_.message_.join_ = join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.join)
}
inline ::livekit::JoinResponse* SignalResponse::_internal_mutable_join() {
  if (!_internal_has_join()) {
    clear_message();
    set_has_join();
    _impl_.message_.join_ = CreateMaybeMessage< ::livekit::JoinResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.join_;
}
inline ::livekit::JoinResponse* SignalResponse::mutable_join() {
  ::livekit::JoinResponse* _msg = _internal_mutable_join();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.join)
  return _msg;
}

// .livekit.SessionDescription answer = 2;
inline bool SignalResponse::_internal_has_answer() const {
  return message_case() == kAnswer;
}
inline bool SignalResponse::has_answer() const {
  return _internal_has_answer();
}
inline void SignalResponse::set_has_answer() {
  _impl_._oneof_case_[0] = kAnswer;
}
inline void SignalResponse::clear_answer() {
  if (_internal_has_answer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.answer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalResponse::release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.answer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_answer() const {
  return _internal_has_answer()
      ? *_impl_.message_.answer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.answer)
  return _internal_answer();
}
inline ::livekit::SessionDescription* SignalResponse::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.answer)
  if (_internal_has_answer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.answer_;
    _impl_.message_.answer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_answer(::livekit::SessionDescription* answer) {
  clear_message();
  if (answer) {
    set_has_answer();
    _impl_.message_.answer_ = answer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.answer)
}
inline ::livekit::SessionDescription* SignalResponse::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_message();
    set_has_answer();
    _impl_.message_.answer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return _impl_.message_.answer_;
}
inline ::livekit::SessionDescription* SignalResponse::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.answer)
  return _msg;
}

// .livekit.SessionDescription offer = 3;
inline bool SignalResponse::_internal_has_offer() const {
  return message_case() == kOffer;
}
inline bool SignalResponse::has_offer() const {
  return _internal_has_offer();
}
inline void SignalResponse::set_has_offer() {
  _impl_._oneof_case_[0] = kOffer;
}
inline void SignalResponse::clear_offer() {
  if (_internal_has_offer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.offer_;
    }
    clear_has_message();
  }
}
inline ::livekit::SessionDescription* SignalResponse::release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.offer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SessionDescription& SignalResponse::_internal_offer() const {
  return _internal_has_offer()
      ? *_impl_.message_.offer_
      : reinterpret_cast< ::livekit::SessionDescription&>(::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SignalResponse::offer() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.offer)
  return _internal_offer();
}
inline ::livekit::SessionDescription* SignalResponse::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.offer)
  if (_internal_has_offer()) {
    clear_has_message();
    ::livekit::SessionDescription* temp = _impl_.message_.offer_;
    _impl_.message_.offer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_offer(::livekit::SessionDescription* offer) {
  clear_message();
  if (offer) {
    set_has_offer();
    _impl_.message_.offer_ = offer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.offer)
}
inline ::livekit::SessionDescription* SignalResponse::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_message();
    set_has_offer();
    _impl_.message_.offer_ = CreateMaybeMessage< ::livekit::SessionDescription >(GetArenaForAllocation());
  }
  return _impl_.message_.offer_;
}
inline ::livekit::SessionDescription* SignalResponse::mutable_offer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.offer)
  return _msg;
}

// .livekit.TrickleRequest trickle = 4;
inline bool SignalResponse::_internal_has_trickle() const {
  return message_case() == kTrickle;
}
inline bool SignalResponse::has_trickle() const {
  return _internal_has_trickle();
}
inline void SignalResponse::set_has_trickle() {
  _impl_._oneof_case_[0] = kTrickle;
}
inline void SignalResponse::clear_trickle() {
  if (_internal_has_trickle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.trickle_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrickleRequest* SignalResponse::release_trickle() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = _impl_.message_.trickle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrickleRequest& SignalResponse::_internal_trickle() const {
  return _internal_has_trickle()
      ? *_impl_.message_.trickle_
      : reinterpret_cast< ::livekit::TrickleRequest&>(::livekit::_TrickleRequest_default_instance_);
}
inline const ::livekit::TrickleRequest& SignalResponse::trickle() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.trickle)
  return _internal_trickle();
}
inline ::livekit::TrickleRequest* SignalResponse::unsafe_arena_release_trickle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.trickle)
  if (_internal_has_trickle()) {
    clear_has_message();
    ::livekit::TrickleRequest* temp = _impl_.message_.trickle_;
    _impl_.message_.trickle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_trickle(::livekit::TrickleRequest* trickle) {
  clear_message();
  if (trickle) {
    set_has_trickle();
    _impl_.message_.trickle_ = trickle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.trickle)
}
inline ::livekit::TrickleRequest* SignalResponse::_internal_mutable_trickle() {
  if (!_internal_has_trickle()) {
    clear_message();
    set_has_trickle();
    _impl_.message_.trickle_ = CreateMaybeMessage< ::livekit::TrickleRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.trickle_;
}
inline ::livekit::TrickleRequest* SignalResponse::mutable_trickle() {
  ::livekit::TrickleRequest* _msg = _internal_mutable_trickle();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.trickle)
  return _msg;
}

// .livekit.ParticipantUpdate update = 5;
inline bool SignalResponse::_internal_has_update() const {
  return message_case() == kUpdate;
}
inline bool SignalResponse::has_update() const {
  return _internal_has_update();
}
inline void SignalResponse::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void SignalResponse::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_;
    }
    clear_has_message();
  }
}
inline ::livekit::ParticipantUpdate* SignalResponse::release_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.update)
  if (_internal_has_update()) {
    clear_has_message();
    ::livekit::ParticipantUpdate* temp = _impl_.message_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ParticipantUpdate& SignalResponse::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.message_.update_
      : reinterpret_cast< ::livekit::ParticipantUpdate&>(::livekit::_ParticipantUpdate_default_instance_);
}
inline const ::livekit::ParticipantUpdate& SignalResponse::update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.update)
  return _internal_update();
}
inline ::livekit::ParticipantUpdate* SignalResponse::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.update)
  if (_internal_has_update()) {
    clear_has_message();
    ::livekit::ParticipantUpdate* temp = _impl_.message_.update_;
    _impl_.message_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_update(::livekit::ParticipantUpdate* update) {
  clear_message();
  if (update) {
    set_has_update();
    _impl_.message_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.update)
}
inline ::livekit::ParticipantUpdate* SignalResponse::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_message();
    set_has_update();
    _impl_.message_.update_ = CreateMaybeMessage< ::livekit::ParticipantUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.update_;
}
inline ::livekit::ParticipantUpdate* SignalResponse::mutable_update() {
  ::livekit::ParticipantUpdate* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.update)
  return _msg;
}

// .livekit.TrackPublishedResponse track_published = 6;
inline bool SignalResponse::_internal_has_track_published() const {
  return message_case() == kTrackPublished;
}
inline bool SignalResponse::has_track_published() const {
  return _internal_has_track_published();
}
inline void SignalResponse::set_has_track_published() {
  _impl_._oneof_case_[0] = kTrackPublished;
}
inline void SignalResponse::clear_track_published() {
  if (_internal_has_track_published()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_published_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrackPublishedResponse* SignalResponse::release_track_published() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
    ::livekit::TrackPublishedResponse* temp = _impl_.message_.track_published_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::_internal_track_published() const {
  return _internal_has_track_published()
      ? *_impl_.message_.track_published_
      : reinterpret_cast< ::livekit::TrackPublishedResponse&>(::livekit::_TrackPublishedResponse_default_instance_);
}
inline const ::livekit::TrackPublishedResponse& SignalResponse::track_published() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_published)
  return _internal_track_published();
}
inline ::livekit::TrackPublishedResponse* SignalResponse::unsafe_arena_release_track_published() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
    ::livekit::TrackPublishedResponse* temp = _impl_.message_.track_published_;
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_published(::livekit::TrackPublishedResponse* track_published) {
  clear_message();
  if (track_published) {
    set_has_track_published();
    _impl_.message_.track_published_ = track_published;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_published)
}
inline ::livekit::TrackPublishedResponse* SignalResponse::_internal_mutable_track_published() {
  if (!_internal_has_track_published()) {
    clear_message();
    set_has_track_published();
    _impl_.message_.track_published_ = CreateMaybeMessage< ::livekit::TrackPublishedResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.track_published_;
}
inline ::livekit::TrackPublishedResponse* SignalResponse::mutable_track_published() {
  ::livekit::TrackPublishedResponse* _msg = _internal_mutable_track_published();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_published)
  return _msg;
}

// .livekit.LeaveRequest leave = 8;
inline bool SignalResponse::_internal_has_leave() const {
  return message_case() == kLeave;
}
inline bool SignalResponse::has_leave() const {
  return _internal_has_leave();
}
inline void SignalResponse::set_has_leave() {
  _impl_._oneof_case_[0] = kLeave;
}
inline void SignalResponse::clear_leave() {
  if (_internal_has_leave()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.leave_;
    }
    clear_has_message();
  }
}
inline ::livekit::LeaveRequest* SignalResponse::release_leave() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = _impl_.message_.leave_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::LeaveRequest& SignalResponse::_internal_leave() const {
  return _internal_has_leave()
      ? *_impl_.message_.leave_
      : reinterpret_cast< ::livekit::LeaveRequest&>(::livekit::_LeaveRequest_default_instance_);
}
inline const ::livekit::LeaveRequest& SignalResponse::leave() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.leave)
  return _internal_leave();
}
inline ::livekit::LeaveRequest* SignalResponse::unsafe_arena_release_leave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.leave)
  if (_internal_has_leave()) {
    clear_has_message();
    ::livekit::LeaveRequest* temp = _impl_.message_.leave_;
    _impl_.message_.leave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_leave(::livekit::LeaveRequest* leave) {
  clear_message();
  if (leave) {
    set_has_leave();
    _impl_.message_.leave_ = leave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.leave)
}
inline ::livekit::LeaveRequest* SignalResponse::_internal_mutable_leave() {
  if (!_internal_has_leave()) {
    clear_message();
    set_has_leave();
    _impl_.message_.leave_ = CreateMaybeMessage< ::livekit::LeaveRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.leave_;
}
inline ::livekit::LeaveRequest* SignalResponse::mutable_leave() {
  ::livekit::LeaveRequest* _msg = _internal_mutable_leave();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.leave)
  return _msg;
}

// .livekit.MuteTrackRequest mute = 9;
inline bool SignalResponse::_internal_has_mute() const {
  return message_case() == kMute;
}
inline bool SignalResponse::has_mute() const {
  return _internal_has_mute();
}
inline void SignalResponse::set_has_mute() {
  _impl_._oneof_case_[0] = kMute;
}
inline void SignalResponse::clear_mute() {
  if (_internal_has_mute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.mute_;
    }
    clear_has_message();
  }
}
inline ::livekit::MuteTrackRequest* SignalResponse::release_mute() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = _impl_.message_.mute_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MuteTrackRequest& SignalResponse::_internal_mute() const {
  return _internal_has_mute()
      ? *_impl_.message_.mute_
      : reinterpret_cast< ::livekit::MuteTrackRequest&>(::livekit::_MuteTrackRequest_default_instance_);
}
inline const ::livekit::MuteTrackRequest& SignalResponse::mute() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.mute)
  return _internal_mute();
}
inline ::livekit::MuteTrackRequest* SignalResponse::unsafe_arena_release_mute() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.mute)
  if (_internal_has_mute()) {
    clear_has_message();
    ::livekit::MuteTrackRequest* temp = _impl_.message_.mute_;
    _impl_.message_.mute_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_mute(::livekit::MuteTrackRequest* mute) {
  clear_message();
  if (mute) {
    set_has_mute();
    _impl_.message_.mute_ = mute;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.mute)
}
inline ::livekit::MuteTrackRequest* SignalResponse::_internal_mutable_mute() {
  if (!_internal_has_mute()) {
    clear_message();
    set_has_mute();
    _impl_.message_.mute_ = CreateMaybeMessage< ::livekit::MuteTrackRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.mute_;
}
inline ::livekit::MuteTrackRequest* SignalResponse::mutable_mute() {
  ::livekit::MuteTrackRequest* _msg = _internal_mutable_mute();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.mute)
  return _msg;
}

// .livekit.SpeakersChanged speakers_changed = 10;
inline bool SignalResponse::_internal_has_speakers_changed() const {
  return message_case() == kSpeakersChanged;
}
inline bool SignalResponse::has_speakers_changed() const {
  return _internal_has_speakers_changed();
}
inline void SignalResponse::set_has_speakers_changed() {
  _impl_._oneof_case_[0] = kSpeakersChanged;
}
inline void SignalResponse::clear_speakers_changed() {
  if (_internal_has_speakers_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.speakers_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::SpeakersChanged* SignalResponse::release_speakers_changed() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.speakers_changed)
  if (_internal_has_speakers_changed()) {
    clear_has_message();
    ::livekit::SpeakersChanged* temp = _impl_.message_.speakers_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SpeakersChanged& SignalResponse::_internal_speakers_changed() const {
  return _internal_has_speakers_changed()
      ? *_impl_.message_.speakers_changed_
      : reinterpret_cast< ::livekit::SpeakersChanged&>(::livekit::_SpeakersChanged_default_instance_);
}
inline const ::livekit::SpeakersChanged& SignalResponse::speakers_changed() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.speakers_changed)
  return _internal_speakers_changed();
}
inline ::livekit::SpeakersChanged* SignalResponse::unsafe_arena_release_speakers_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.speakers_changed)
  if (_internal_has_speakers_changed()) {
    clear_has_message();
    ::livekit::SpeakersChanged* temp = _impl_.message_.speakers_changed_;
    _impl_.message_.speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_speakers_changed(::livekit::SpeakersChanged* speakers_changed) {
  clear_message();
  if (speakers_changed) {
    set_has_speakers_changed();
    _impl_.message_.speakers_changed_ = speakers_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.speakers_changed)
}
inline ::livekit::SpeakersChanged* SignalResponse::_internal_mutable_speakers_changed() {
  if (!_internal_has_speakers_changed()) {
    clear_message();
    set_has_speakers_changed();
    _impl_.message_.speakers_changed_ = CreateMaybeMessage< ::livekit::SpeakersChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.speakers_changed_;
}
inline ::livekit::SpeakersChanged* SignalResponse::mutable_speakers_changed() {
  ::livekit::SpeakersChanged* _msg = _internal_mutable_speakers_changed();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.speakers_changed)
  return _msg;
}

// .livekit.RoomUpdate room_update = 11;
inline bool SignalResponse::_internal_has_room_update() const {
  return message_case() == kRoomUpdate;
}
inline bool SignalResponse::has_room_update() const {
  return _internal_has_room_update();
}
inline void SignalResponse::set_has_room_update() {
  _impl_._oneof_case_[0] = kRoomUpdate;
}
inline void SignalResponse::clear_room_update() {
  if (_internal_has_room_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.room_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::RoomUpdate* SignalResponse::release_room_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.room_update)
  if (_internal_has_room_update()) {
    clear_has_message();
    ::livekit::RoomUpdate* temp = _impl_.message_.room_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RoomUpdate& SignalResponse::_internal_room_update() const {
  return _internal_has_room_update()
      ? *_impl_.message_.room_update_
      : reinterpret_cast< ::livekit::RoomUpdate&>(::livekit::_RoomUpdate_default_instance_);
}
inline const ::livekit::RoomUpdate& SignalResponse::room_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.room_update)
  return _internal_room_update();
}
inline ::livekit::RoomUpdate* SignalResponse::unsafe_arena_release_room_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.room_update)
  if (_internal_has_room_update()) {
    clear_has_message();
    ::livekit::RoomUpdate* temp = _impl_.message_.room_update_;
    _impl_.message_.room_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_room_update(::livekit::RoomUpdate* room_update) {
  clear_message();
  if (room_update) {
    set_has_room_update();
    _impl_.message_.room_update_ = room_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.room_update)
}
inline ::livekit::RoomUpdate* SignalResponse::_internal_mutable_room_update() {
  if (!_internal_has_room_update()) {
    clear_message();
    set_has_room_update();
    _impl_.message_.room_update_ = CreateMaybeMessage< ::livekit::RoomUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.room_update_;
}
inline ::livekit::RoomUpdate* SignalResponse::mutable_room_update() {
  ::livekit::RoomUpdate* _msg = _internal_mutable_room_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.room_update)
  return _msg;
}

// .livekit.ConnectionQualityUpdate connection_quality = 12;
inline bool SignalResponse::_internal_has_connection_quality() const {
  return message_case() == kConnectionQuality;
}
inline bool SignalResponse::has_connection_quality() const {
  return _internal_has_connection_quality();
}
inline void SignalResponse::set_has_connection_quality() {
  _impl_._oneof_case_[0] = kConnectionQuality;
}
inline void SignalResponse::clear_connection_quality() {
  if (_internal_has_connection_quality()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.connection_quality_;
    }
    clear_has_message();
  }
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::release_connection_quality() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.connection_quality)
  if (_internal_has_connection_quality()) {
    clear_has_message();
    ::livekit::ConnectionQualityUpdate* temp = _impl_.message_.connection_quality_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::_internal_connection_quality() const {
  return _internal_has_connection_quality()
      ? *_impl_.message_.connection_quality_
      : reinterpret_cast< ::livekit::ConnectionQualityUpdate&>(::livekit::_ConnectionQualityUpdate_default_instance_);
}
inline const ::livekit::ConnectionQualityUpdate& SignalResponse::connection_quality() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.connection_quality)
  return _internal_connection_quality();
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::unsafe_arena_release_connection_quality() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.connection_quality)
  if (_internal_has_connection_quality()) {
    clear_has_message();
    ::livekit::ConnectionQualityUpdate* temp = _impl_.message_.connection_quality_;
    _impl_.message_.connection_quality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_connection_quality(::livekit::ConnectionQualityUpdate* connection_quality) {
  clear_message();
  if (connection_quality) {
    set_has_connection_quality();
    _impl_.message_.connection_quality_ = connection_quality;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.connection_quality)
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::_internal_mutable_connection_quality() {
  if (!_internal_has_connection_quality()) {
    clear_message();
    set_has_connection_quality();
    _impl_.message_.connection_quality_ = CreateMaybeMessage< ::livekit::ConnectionQualityUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.connection_quality_;
}
inline ::livekit::ConnectionQualityUpdate* SignalResponse::mutable_connection_quality() {
  ::livekit::ConnectionQualityUpdate* _msg = _internal_mutable_connection_quality();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.connection_quality)
  return _msg;
}

// .livekit.StreamStateUpdate stream_state_update = 13;
inline bool SignalResponse::_internal_has_stream_state_update() const {
  return message_case() == kStreamStateUpdate;
}
inline bool SignalResponse::has_stream_state_update() const {
  return _internal_has_stream_state_update();
}
inline void SignalResponse::set_has_stream_state_update() {
  _impl_._oneof_case_[0] = kStreamStateUpdate;
}
inline void SignalResponse::clear_stream_state_update() {
  if (_internal_has_stream_state_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stream_state_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::StreamStateUpdate* SignalResponse::release_stream_state_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.stream_state_update)
  if (_internal_has_stream_state_update()) {
    clear_has_message();
    ::livekit::StreamStateUpdate* temp = _impl_.message_.stream_state_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::StreamStateUpdate& SignalResponse::_internal_stream_state_update() const {
  return _internal_has_stream_state_update()
      ? *_impl_.message_.stream_state_update_
      : reinterpret_cast< ::livekit::StreamStateUpdate&>(::livekit::_StreamStateUpdate_default_instance_);
}
inline const ::livekit::StreamStateUpdate& SignalResponse::stream_state_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.stream_state_update)
  return _internal_stream_state_update();
}
inline ::livekit::StreamStateUpdate* SignalResponse::unsafe_arena_release_stream_state_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.stream_state_update)
  if (_internal_has_stream_state_update()) {
    clear_has_message();
    ::livekit::StreamStateUpdate* temp = _impl_.message_.stream_state_update_;
    _impl_.message_.stream_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_stream_state_update(::livekit::StreamStateUpdate* stream_state_update) {
  clear_message();
  if (stream_state_update) {
    set_has_stream_state_update();
    _impl_.message_.stream_state_update_ = stream_state_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.stream_state_update)
}
inline ::livekit::StreamStateUpdate* SignalResponse::_internal_mutable_stream_state_update() {
  if (!_internal_has_stream_state_update()) {
    clear_message();
    set_has_stream_state_update();
    _impl_.message_.stream_state_update_ = CreateMaybeMessage< ::livekit::StreamStateUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.stream_state_update_;
}
inline ::livekit::StreamStateUpdate* SignalResponse::mutable_stream_state_update() {
  ::livekit::StreamStateUpdate* _msg = _internal_mutable_stream_state_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.stream_state_update)
  return _msg;
}

// .livekit.SubscribedQualityUpdate subscribed_quality_update = 14;
inline bool SignalResponse::_internal_has_subscribed_quality_update() const {
  return message_case() == kSubscribedQualityUpdate;
}
inline bool SignalResponse::has_subscribed_quality_update() const {
  return _internal_has_subscribed_quality_update();
}
inline void SignalResponse::set_has_subscribed_quality_update() {
  _impl_._oneof_case_[0] = kSubscribedQualityUpdate;
}
inline void SignalResponse::clear_subscribed_quality_update() {
  if (_internal_has_subscribed_quality_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.subscribed_quality_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscribed_quality_update)
  if (_internal_has_subscribed_quality_update()) {
    clear_has_message();
    ::livekit::SubscribedQualityUpdate* temp = _impl_.message_.subscribed_quality_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::_internal_subscribed_quality_update() const {
  return _internal_has_subscribed_quality_update()
      ? *_impl_.message_.subscribed_quality_update_
      : reinterpret_cast< ::livekit::SubscribedQualityUpdate&>(::livekit::_SubscribedQualityUpdate_default_instance_);
}
inline const ::livekit::SubscribedQualityUpdate& SignalResponse::subscribed_quality_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscribed_quality_update)
  return _internal_subscribed_quality_update();
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::unsafe_arena_release_subscribed_quality_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscribed_quality_update)
  if (_internal_has_subscribed_quality_update()) {
    clear_has_message();
    ::livekit::SubscribedQualityUpdate* temp = _impl_.message_.subscribed_quality_update_;
    _impl_.message_.subscribed_quality_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscribed_quality_update(::livekit::SubscribedQualityUpdate* subscribed_quality_update) {
  clear_message();
  if (subscribed_quality_update) {
    set_has_subscribed_quality_update();
    _impl_.message_.subscribed_quality_update_ = subscribed_quality_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscribed_quality_update)
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::_internal_mutable_subscribed_quality_update() {
  if (!_internal_has_subscribed_quality_update()) {
    clear_message();
    set_has_subscribed_quality_update();
    _impl_.message_.subscribed_quality_update_ = CreateMaybeMessage< ::livekit::SubscribedQualityUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.subscribed_quality_update_;
}
inline ::livekit::SubscribedQualityUpdate* SignalResponse::mutable_subscribed_quality_update() {
  ::livekit::SubscribedQualityUpdate* _msg = _internal_mutable_subscribed_quality_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscribed_quality_update)
  return _msg;
}

// .livekit.SubscriptionPermissionUpdate subscription_permission_update = 15;
inline bool SignalResponse::_internal_has_subscription_permission_update() const {
  return message_case() == kSubscriptionPermissionUpdate;
}
inline bool SignalResponse::has_subscription_permission_update() const {
  return _internal_has_subscription_permission_update();
}
inline void SignalResponse::set_has_subscription_permission_update() {
  _impl_._oneof_case_[0] = kSubscriptionPermissionUpdate;
}
inline void SignalResponse::clear_subscription_permission_update() {
  if (_internal_has_subscription_permission_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.subscription_permission_update_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::release_subscription_permission_update() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscription_permission_update)
  if (_internal_has_subscription_permission_update()) {
    clear_has_message();
    ::livekit::SubscriptionPermissionUpdate* temp = _impl_.message_.subscription_permission_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::_internal_subscription_permission_update() const {
  return _internal_has_subscription_permission_update()
      ? *_impl_.message_.subscription_permission_update_
      : reinterpret_cast< ::livekit::SubscriptionPermissionUpdate&>(::livekit::_SubscriptionPermissionUpdate_default_instance_);
}
inline const ::livekit::SubscriptionPermissionUpdate& SignalResponse::subscription_permission_update() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscription_permission_update)
  return _internal_subscription_permission_update();
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::unsafe_arena_release_subscription_permission_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscription_permission_update)
  if (_internal_has_subscription_permission_update()) {
    clear_has_message();
    ::livekit::SubscriptionPermissionUpdate* temp = _impl_.message_.subscription_permission_update_;
    _impl_.message_.subscription_permission_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscription_permission_update(::livekit::SubscriptionPermissionUpdate* subscription_permission_update) {
  clear_message();
  if (subscription_permission_update) {
    set_has_subscription_permission_update();
    _impl_.message_.subscription_permission_update_ = subscription_permission_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscription_permission_update)
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::_internal_mutable_subscription_permission_update() {
  if (!_internal_has_subscription_permission_update()) {
    clear_message();
    set_has_subscription_permission_update();
    _impl_.message_.subscription_permission_update_ = CreateMaybeMessage< ::livekit::SubscriptionPermissionUpdate >(GetArenaForAllocation());
  }
  return _impl_.message_.subscription_permission_update_;
}
inline ::livekit::SubscriptionPermissionUpdate* SignalResponse::mutable_subscription_permission_update() {
  ::livekit::SubscriptionPermissionUpdate* _msg = _internal_mutable_subscription_permission_update();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscription_permission_update)
  return _msg;
}

// string refresh_token = 16;
inline bool SignalResponse::_internal_has_refresh_token() const {
  return message_case() == kRefreshToken;
}
inline bool SignalResponse::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void SignalResponse::set_has_refresh_token() {
  _impl_._oneof_case_[0] = kRefreshToken;
}
inline void SignalResponse::clear_refresh_token() {
  if (_internal_has_refresh_token()) {
    _impl_.message_.refresh_token_.Destroy();
    clear_has_message();
  }
}
inline const std::string& SignalResponse::refresh_token() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline void SignalResponse::set_refresh_token(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  _impl_.message_.refresh_token_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SignalResponse.refresh_token)
}
inline std::string* SignalResponse::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.refresh_token)
  return _s;
}
inline const std::string& SignalResponse::_internal_refresh_token() const {
  if (_internal_has_refresh_token()) {
    return _impl_.message_.refresh_token_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SignalResponse::_internal_set_refresh_token(const std::string& value) {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  _impl_.message_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalResponse::_internal_mutable_refresh_token() {
  if (!_internal_has_refresh_token()) {
    clear_message();
    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitDefault();
  }
  return _impl_.message_.refresh_token_.Mutable(      GetArenaForAllocation());
}
inline std::string* SignalResponse::release_refresh_token() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.refresh_token)
  if (_internal_has_refresh_token()) {
    clear_has_message();
    return _impl_.message_.refresh_token_.Release();
  } else {
    return nullptr;
  }
}
inline void SignalResponse::set_allocated_refresh_token(std::string* refresh_token) {
  if (has_message()) {
    clear_message();
  }
  if (refresh_token != nullptr) {
    set_has_refresh_token();
    _impl_.message_.refresh_token_.InitAllocated(refresh_token, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.SignalResponse.refresh_token)
}

// .livekit.TrackUnpublishedResponse track_unpublished = 17;
inline bool SignalResponse::_internal_has_track_unpublished() const {
  return message_case() == kTrackUnpublished;
}
inline bool SignalResponse::has_track_unpublished() const {
  return _internal_has_track_unpublished();
}
inline void SignalResponse::set_has_track_unpublished() {
  _impl_._oneof_case_[0] = kTrackUnpublished;
}
inline void SignalResponse::clear_track_unpublished() {
  if (_internal_has_track_unpublished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_unpublished_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::release_track_unpublished() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
    ::livekit::TrackUnpublishedResponse* temp = _impl_.message_.track_unpublished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::_internal_track_unpublished() const {
  return _internal_has_track_unpublished()
      ? *_impl_.message_.track_unpublished_
      : reinterpret_cast< ::livekit::TrackUnpublishedResponse&>(::livekit::_TrackUnpublishedResponse_default_instance_);
}
inline const ::livekit::TrackUnpublishedResponse& SignalResponse::track_unpublished() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_unpublished)
  return _internal_track_unpublished();
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::unsafe_arena_release_track_unpublished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
    ::livekit::TrackUnpublishedResponse* temp = _impl_.message_.track_unpublished_;
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_unpublished(::livekit::TrackUnpublishedResponse* track_unpublished) {
  clear_message();
  if (track_unpublished) {
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = track_unpublished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_unpublished)
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::_internal_mutable_track_unpublished() {
  if (!_internal_has_track_unpublished()) {
    clear_message();
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = CreateMaybeMessage< ::livekit::TrackUnpublishedResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.track_unpublished_;
}
inline ::livekit::TrackUnpublishedResponse* SignalResponse::mutable_track_unpublished() {
  ::livekit::TrackUnpublishedResponse* _msg = _internal_mutable_track_unpublished();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_unpublished)
  return _msg;
}

// int64 pong = 18;
inline bool SignalResponse::_internal_has_pong() const {
  return message_case() == kPong;
}
inline bool SignalResponse::has_pong() const {
  return _internal_has_pong();
}
inline void SignalResponse::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void SignalResponse::clear_pong() {
  if (_internal_has_pong()) {
    _impl_.message_.pong_ = int64_t{0};
    clear_has_message();
  }
}
inline int64_t SignalResponse::_internal_pong() const {
  if (_internal_has_pong()) {
    return _impl_.message_.pong_;
  }
  return int64_t{0};
}
inline void SignalResponse::_internal_set_pong(int64_t value) {
  if (!_internal_has_pong()) {
    clear_message();
    set_has_pong();
  }
  _impl_.message_.pong_ = value;
}
inline int64_t SignalResponse::pong() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.pong)
  return _internal_pong();
}
inline void SignalResponse::set_pong(int64_t value) {
  _internal_set_pong(value);
  // @@protoc_insertion_point(field_set:livekit.SignalResponse.pong)
}

// .livekit.ReconnectResponse reconnect = 19;
inline bool SignalResponse::_internal_has_reconnect() const {
  return message_case() == kReconnect;
}
inline bool SignalResponse::has_reconnect() const {
  return _internal_has_reconnect();
}
inline void SignalResponse::set_has_reconnect() {
  _impl_._oneof_case_[0] = kReconnect;
}
inline void SignalResponse::clear_reconnect() {
  if (_internal_has_reconnect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.reconnect_;
    }
    clear_has_message();
  }
}
inline ::livekit::ReconnectResponse* SignalResponse::release_reconnect() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.reconnect)
  if (_internal_has_reconnect()) {
    clear_has_message();
    ::livekit::ReconnectResponse* temp = _impl_.message_.reconnect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.reconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ReconnectResponse& SignalResponse::_internal_reconnect() const {
  return _internal_has_reconnect()
      ? *_impl_.message_.reconnect_
      : reinterpret_cast< ::livekit::ReconnectResponse&>(::livekit::_ReconnectResponse_default_instance_);
}
inline const ::livekit::ReconnectResponse& SignalResponse::reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.reconnect)
  return _internal_reconnect();
}
inline ::livekit::ReconnectResponse* SignalResponse::unsafe_arena_release_reconnect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.reconnect)
  if (_internal_has_reconnect()) {
    clear_has_message();
    ::livekit::ReconnectResponse* temp = _impl_.message_.reconnect_;
    _impl_.message_.reconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_reconnect(::livekit::ReconnectResponse* reconnect) {
  clear_message();
  if (reconnect) {
    set_has_reconnect();
    _impl_.message_.reconnect_ = reconnect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.reconnect)
}
inline ::livekit::ReconnectResponse* SignalResponse::_internal_mutable_reconnect() {
  if (!_internal_has_reconnect()) {
    clear_message();
    set_has_reconnect();
    _impl_.message_.reconnect_ = CreateMaybeMessage< ::livekit::ReconnectResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.reconnect_;
}
inline ::livekit::ReconnectResponse* SignalResponse::mutable_reconnect() {
  ::livekit::ReconnectResponse* _msg = _internal_mutable_reconnect();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.reconnect)
  return _msg;
}

// .livekit.Pong pong_resp = 20;
inline bool SignalResponse::_internal_has_pong_resp() const {
  return message_case() == kPongResp;
}
inline bool SignalResponse::has_pong_resp() const {
  return _internal_has_pong_resp();
}
inline void SignalResponse::set_has_pong_resp() {
  _impl_._oneof_case_[0] = kPongResp;
}
inline void SignalResponse::clear_pong_resp() {
  if (_internal_has_pong_resp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.pong_resp_;
    }
    clear_has_message();
  }
}
inline ::livekit::Pong* SignalResponse::release_pong_resp() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.pong_resp)
  if (_internal_has_pong_resp()) {
    clear_has_message();
    ::livekit::Pong* temp = _impl_.message_.pong_resp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pong_resp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::Pong& SignalResponse::_internal_pong_resp() const {
  return _internal_has_pong_resp()
      ? *_impl_.message_.pong_resp_
      : reinterpret_cast< ::livekit::Pong&>(::livekit::_Pong_default_instance_);
}
inline const ::livekit::Pong& SignalResponse::pong_resp() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.pong_resp)
  return _internal_pong_resp();
}
inline ::livekit::Pong* SignalResponse::unsafe_arena_release_pong_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.pong_resp)
  if (_internal_has_pong_resp()) {
    clear_has_message();
    ::livekit::Pong* temp = _impl_.message_.pong_resp_;
    _impl_.message_.pong_resp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_pong_resp(::livekit::Pong* pong_resp) {
  clear_message();
  if (pong_resp) {
    set_has_pong_resp();
    _impl_.message_.pong_resp_ = pong_resp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.pong_resp)
}
inline ::livekit::Pong* SignalResponse::_internal_mutable_pong_resp() {
  if (!_internal_has_pong_resp()) {
    clear_message();
    set_has_pong_resp();
    _impl_.message_.pong_resp_ = CreateMaybeMessage< ::livekit::Pong >(GetArenaForAllocation());
  }
  return _impl_.message_.pong_resp_;
}
inline ::livekit::Pong* SignalResponse::mutable_pong_resp() {
  ::livekit::Pong* _msg = _internal_mutable_pong_resp();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.pong_resp)
  return _msg;
}

// .livekit.SubscriptionResponse subscription_response = 21;
inline bool SignalResponse::_internal_has_subscription_response() const {
  return message_case() == kSubscriptionResponse;
}
inline bool SignalResponse::has_subscription_response() const {
  return _internal_has_subscription_response();
}
inline void SignalResponse::set_has_subscription_response() {
  _impl_._oneof_case_[0] = kSubscriptionResponse;
}
inline void SignalResponse::clear_subscription_response() {
  if (_internal_has_subscription_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.subscription_response_;
    }
    clear_has_message();
  }
}
inline ::livekit::SubscriptionResponse* SignalResponse::release_subscription_response() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.subscription_response)
  if (_internal_has_subscription_response()) {
    clear_has_message();
    ::livekit::SubscriptionResponse* temp = _impl_.message_.subscription_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.subscription_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SubscriptionResponse& SignalResponse::_internal_subscription_response() const {
  return _internal_has_subscription_response()
      ? *_impl_.message_.subscription_response_
      : reinterpret_cast< ::livekit::SubscriptionResponse&>(::livekit::_SubscriptionResponse_default_instance_);
}
inline const ::livekit::SubscriptionResponse& SignalResponse::subscription_response() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.subscription_response)
  return _internal_subscription_response();
}
inline ::livekit::SubscriptionResponse* SignalResponse::unsafe_arena_release_subscription_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.subscription_response)
  if (_internal_has_subscription_response()) {
    clear_has_message();
    ::livekit::SubscriptionResponse* temp = _impl_.message_.subscription_response_;
    _impl_.message_.subscription_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_subscription_response(::livekit::SubscriptionResponse* subscription_response) {
  clear_message();
  if (subscription_response) {
    set_has_subscription_response();
    _impl_.message_.subscription_response_ = subscription_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.subscription_response)
}
inline ::livekit::SubscriptionResponse* SignalResponse::_internal_mutable_subscription_response() {
  if (!_internal_has_subscription_response()) {
    clear_message();
    set_has_subscription_response();
    _impl_.message_.subscription_response_ = CreateMaybeMessage< ::livekit::SubscriptionResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.subscription_response_;
}
inline ::livekit::SubscriptionResponse* SignalResponse::mutable_subscription_response() {
  ::livekit::SubscriptionResponse* _msg = _internal_mutable_subscription_response();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.subscription_response)
  return _msg;
}

// .livekit.RequestResponse request_response = 22;
inline bool SignalResponse::_internal_has_request_response() const {
  return message_case() == kRequestResponse;
}
inline bool SignalResponse::has_request_response() const {
  return _internal_has_request_response();
}
inline void SignalResponse::set_has_request_response() {
  _impl_._oneof_case_[0] = kRequestResponse;
}
inline void SignalResponse::clear_request_response() {
  if (_internal_has_request_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.request_response_;
    }
    clear_has_message();
  }
}
inline ::livekit::RequestResponse* SignalResponse::release_request_response() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.request_response)
  if (_internal_has_request_response()) {
    clear_has_message();
    ::livekit::RequestResponse* temp = _impl_.message_.request_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RequestResponse& SignalResponse::_internal_request_response() const {
  return _internal_has_request_response()
      ? *_impl_.message_.request_response_
      : reinterpret_cast< ::livekit::RequestResponse&>(::livekit::_RequestResponse_default_instance_);
}
inline const ::livekit::RequestResponse& SignalResponse::request_response() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.request_response)
  return _internal_request_response();
}
inline ::livekit::RequestResponse* SignalResponse::unsafe_arena_release_request_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.request_response)
  if (_internal_has_request_response()) {
    clear_has_message();
    ::livekit::RequestResponse* temp = _impl_.message_.request_response_;
    _impl_.message_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_request_response(::livekit::RequestResponse* request_response) {
  clear_message();
  if (request_response) {
    set_has_request_response();
    _impl_.message_.request_response_ = request_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.request_response)
}
inline ::livekit::RequestResponse* SignalResponse::_internal_mutable_request_response() {
  if (!_internal_has_request_response()) {
    clear_message();
    set_has_request_response();
    _impl_.message_.request_response_ = CreateMaybeMessage< ::livekit::RequestResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.request_response_;
}
inline ::livekit::RequestResponse* SignalResponse::mutable_request_response() {
  ::livekit::RequestResponse* _msg = _internal_mutable_request_response();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.request_response)
  return _msg;
}

// .livekit.TrackSubscribed track_subscribed = 23;
inline bool SignalResponse::_internal_has_track_subscribed() const {
  return message_case() == kTrackSubscribed;
}
inline bool SignalResponse::has_track_subscribed() const {
  return _internal_has_track_subscribed();
}
inline void SignalResponse::set_has_track_subscribed() {
  _impl_._oneof_case_[0] = kTrackSubscribed;
}
inline void SignalResponse::clear_track_subscribed() {
  if (_internal_has_track_subscribed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_subscribed_;
    }
    clear_has_message();
  }
}
inline ::livekit::TrackSubscribed* SignalResponse::release_track_subscribed() {
  // @@protoc_insertion_point(field_release:livekit.SignalResponse.track_subscribed)
  if (_internal_has_track_subscribed()) {
    clear_has_message();
    ::livekit::TrackSubscribed* temp = _impl_.message_.track_subscribed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::TrackSubscribed& SignalResponse::_internal_track_subscribed() const {
  return _internal_has_track_subscribed()
      ? *_impl_.message_.track_subscribed_
      : reinterpret_cast< ::livekit::TrackSubscribed&>(::livekit::_TrackSubscribed_default_instance_);
}
inline const ::livekit::TrackSubscribed& SignalResponse::track_subscribed() const {
  // @@protoc_insertion_point(field_get:livekit.SignalResponse.track_subscribed)
  return _internal_track_subscribed();
}
inline ::livekit::TrackSubscribed* SignalResponse::unsafe_arena_release_track_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.SignalResponse.track_subscribed)
  if (_internal_has_track_subscribed()) {
    clear_has_message();
    ::livekit::TrackSubscribed* temp = _impl_.message_.track_subscribed_;
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SignalResponse::unsafe_arena_set_allocated_track_subscribed(::livekit::TrackSubscribed* track_subscribed) {
  clear_message();
  if (track_subscribed) {
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = track_subscribed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SignalResponse.track_subscribed)
}
inline ::livekit::TrackSubscribed* SignalResponse::_internal_mutable_track_subscribed() {
  if (!_internal_has_track_subscribed()) {
    clear_message();
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = CreateMaybeMessage< ::livekit::TrackSubscribed >(GetArenaForAllocation());
  }
  return _impl_.message_.track_subscribed_;
}
inline ::livekit::TrackSubscribed* SignalResponse::mutable_track_subscribed() {
  ::livekit::TrackSubscribed* _msg = _internal_mutable_track_subscribed();
  // @@protoc_insertion_point(field_mutable:livekit.SignalResponse.track_subscribed)
  return _msg;
}

inline bool SignalResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SignalResponse::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SignalResponse::MessageCase SignalResponse::message_case() const {
  return SignalResponse::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SimulcastCodec

// string codec = 1;
inline void SimulcastCodec::clear_codec() {
  _impl_.codec_.ClearToEmpty();
}
inline const std::string& SimulcastCodec::codec() const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodec.codec)
  return _internal_codec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulcastCodec::set_codec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.codec_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodec.codec)
}
inline std::string* SimulcastCodec::mutable_codec() {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodec.codec)
  return _s;
}
inline const std::string& SimulcastCodec::_internal_codec() const {
  return _impl_.codec_.Get();
}
inline void SimulcastCodec::_internal_set_codec(const std::string& value) {
  
  _impl_.codec_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulcastCodec::_internal_mutable_codec() {
  
  return _impl_.codec_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulcastCodec::release_codec() {
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodec.codec)
  return _impl_.codec_.Release();
}
inline void SimulcastCodec::set_allocated_codec(std::string* codec) {
  if (codec != nullptr) {
    
  } else {
    
  }
  _impl_.codec_.SetAllocated(codec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.codec_.IsDefault()) {
    _impl_.codec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodec.codec)
}

// string cid = 2;
inline void SimulcastCodec::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& SimulcastCodec::cid() const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodec.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulcastCodec::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodec.cid)
}
inline std::string* SimulcastCodec::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodec.cid)
  return _s;
}
inline const std::string& SimulcastCodec::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void SimulcastCodec::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulcastCodec::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulcastCodec::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodec.cid)
  return _impl_.cid_.Release();
}
inline void SimulcastCodec::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodec.cid)
}

// -------------------------------------------------------------------

// AddTrackRequest

// string cid = 1;
inline void AddTrackRequest::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::cid() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.cid)
}
inline std::string* AddTrackRequest::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.cid)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void AddTrackRequest::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.cid)
  return _impl_.cid_.Release();
}
inline void AddTrackRequest::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.cid)
}

// string name = 2;
inline void AddTrackRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.name)
}
inline std::string* AddTrackRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.name)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AddTrackRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.name)
  return _impl_.name_.Release();
}
inline void AddTrackRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.name)
}

// .livekit.TrackType type = 3;
inline void AddTrackRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::livekit::TrackType AddTrackRequest::_internal_type() const {
  return static_cast< ::livekit::TrackType >(_impl_.type_);
}
inline ::livekit::TrackType AddTrackRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.type)
  return _internal_type();
}
inline void AddTrackRequest::_internal_set_type(::livekit::TrackType value) {
  
  _impl_.type_ = value;
}
inline void AddTrackRequest::set_type(::livekit::TrackType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.type)
}

// uint32 width = 4;
inline void AddTrackRequest::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t AddTrackRequest::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t AddTrackRequest::width() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.width)
  return _internal_width();
}
inline void AddTrackRequest::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void AddTrackRequest::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.width)
}

// uint32 height = 5;
inline void AddTrackRequest::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t AddTrackRequest::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t AddTrackRequest::height() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.height)
  return _internal_height();
}
inline void AddTrackRequest::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void AddTrackRequest::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.height)
}

// bool muted = 6;
inline void AddTrackRequest::clear_muted() {
  _impl_.muted_ = false;
}
inline bool AddTrackRequest::_internal_muted() const {
  return _impl_.muted_;
}
inline bool AddTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.muted)
  return _internal_muted();
}
inline void AddTrackRequest::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void AddTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.muted)
}

// bool disable_dtx = 7;
inline void AddTrackRequest::clear_disable_dtx() {
  _impl_.disable_dtx_ = false;
}
inline bool AddTrackRequest::_internal_disable_dtx() const {
  return _impl_.disable_dtx_;
}
inline bool AddTrackRequest::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.disable_dtx)
  return _internal_disable_dtx();
}
inline void AddTrackRequest::_internal_set_disable_dtx(bool value) {
  
  _impl_.disable_dtx_ = value;
}
inline void AddTrackRequest::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.disable_dtx)
}

// .livekit.TrackSource source = 8;
inline void AddTrackRequest::clear_source() {
  _impl_.source_ = 0;
}
inline ::livekit::TrackSource AddTrackRequest::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(_impl_.source_);
}
inline ::livekit::TrackSource AddTrackRequest::source() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.source)
  return _internal_source();
}
inline void AddTrackRequest::_internal_set_source(::livekit::TrackSource value) {
  
  _impl_.source_ = value;
}
inline void AddTrackRequest::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.source)
}

// repeated .livekit.VideoLayer layers = 9;
inline int AddTrackRequest::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int AddTrackRequest::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* AddTrackRequest::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
AddTrackRequest::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.AddTrackRequest.layers)
  return &_impl_.layers_;
}
inline const ::livekit::VideoLayer& AddTrackRequest::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::livekit::VideoLayer& AddTrackRequest::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* AddTrackRequest::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::livekit::VideoLayer* AddTrackRequest::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.AddTrackRequest.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
AddTrackRequest::layers() const {
  // @@protoc_insertion_point(field_list:livekit.AddTrackRequest.layers)
  return _impl_.layers_;
}

// repeated .livekit.SimulcastCodec simulcast_codecs = 10;
inline int AddTrackRequest::_internal_simulcast_codecs_size() const {
  return _impl_.simulcast_codecs_.size();
}
inline int AddTrackRequest::simulcast_codecs_size() const {
  return _internal_simulcast_codecs_size();
}
inline void AddTrackRequest::clear_simulcast_codecs() {
  _impl_.simulcast_codecs_.Clear();
}
inline ::livekit::SimulcastCodec* AddTrackRequest::mutable_simulcast_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.simulcast_codecs)
  return _impl_.simulcast_codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodec >*
AddTrackRequest::mutable_simulcast_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.AddTrackRequest.simulcast_codecs)
  return &_impl_.simulcast_codecs_;
}
inline const ::livekit::SimulcastCodec& AddTrackRequest::_internal_simulcast_codecs(int index) const {
  return _impl_.simulcast_codecs_.Get(index);
}
inline const ::livekit::SimulcastCodec& AddTrackRequest::simulcast_codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.simulcast_codecs)
  return _internal_simulcast_codecs(index);
}
inline ::livekit::SimulcastCodec* AddTrackRequest::_internal_add_simulcast_codecs() {
  return _impl_.simulcast_codecs_.Add();
}
inline ::livekit::SimulcastCodec* AddTrackRequest::add_simulcast_codecs() {
  ::livekit::SimulcastCodec* _add = _internal_add_simulcast_codecs();
  // @@protoc_insertion_point(field_add:livekit.AddTrackRequest.simulcast_codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodec >&
AddTrackRequest::simulcast_codecs() const {
  // @@protoc_insertion_point(field_list:livekit.AddTrackRequest.simulcast_codecs)
  return _impl_.simulcast_codecs_;
}

// string sid = 11;
inline void AddTrackRequest::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::sid() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.sid)
}
inline std::string* AddTrackRequest::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.sid)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void AddTrackRequest::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.sid)
  return _impl_.sid_.Release();
}
inline void AddTrackRequest::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.sid)
}

// bool stereo = 12;
inline void AddTrackRequest::clear_stereo() {
  _impl_.stereo_ = false;
}
inline bool AddTrackRequest::_internal_stereo() const {
  return _impl_.stereo_;
}
inline bool AddTrackRequest::stereo() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.stereo)
  return _internal_stereo();
}
inline void AddTrackRequest::_internal_set_stereo(bool value) {
  
  _impl_.stereo_ = value;
}
inline void AddTrackRequest::set_stereo(bool value) {
  _internal_set_stereo(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.stereo)
}

// bool disable_red = 13;
inline void AddTrackRequest::clear_disable_red() {
  _impl_.disable_red_ = false;
}
inline bool AddTrackRequest::_internal_disable_red() const {
  return _impl_.disable_red_;
}
inline bool AddTrackRequest::disable_red() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.disable_red)
  return _internal_disable_red();
}
inline void AddTrackRequest::_internal_set_disable_red(bool value) {
  
  _impl_.disable_red_ = value;
}
inline void AddTrackRequest::set_disable_red(bool value) {
  _internal_set_disable_red(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.disable_red)
}

// .livekit.Encryption.Type encryption = 14;
inline void AddTrackRequest::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::livekit::Encryption_Type AddTrackRequest::_internal_encryption() const {
  return static_cast< ::livekit::Encryption_Type >(_impl_.encryption_);
}
inline ::livekit::Encryption_Type AddTrackRequest::encryption() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.encryption)
  return _internal_encryption();
}
inline void AddTrackRequest::_internal_set_encryption(::livekit::Encryption_Type value) {
  
  _impl_.encryption_ = value;
}
inline void AddTrackRequest::set_encryption(::livekit::Encryption_Type value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.encryption)
}

// string stream = 15;
inline void AddTrackRequest::clear_stream() {
  _impl_.stream_.ClearToEmpty();
}
inline const std::string& AddTrackRequest::stream() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddTrackRequest::set_stream(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.stream)
}
inline std::string* AddTrackRequest::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.AddTrackRequest.stream)
  return _s;
}
inline const std::string& AddTrackRequest::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void AddTrackRequest::_internal_set_stream(const std::string& value) {
  
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* AddTrackRequest::_internal_mutable_stream() {
  
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* AddTrackRequest::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.AddTrackRequest.stream)
  return _impl_.stream_.Release();
}
inline void AddTrackRequest::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AddTrackRequest.stream)
}

// .livekit.BackupCodecPolicy backup_codec_policy = 16;
inline void AddTrackRequest::clear_backup_codec_policy() {
  _impl_.backup_codec_policy_ = 0;
}
inline ::livekit::BackupCodecPolicy AddTrackRequest::_internal_backup_codec_policy() const {
  return static_cast< ::livekit::BackupCodecPolicy >(_impl_.backup_codec_policy_);
}
inline ::livekit::BackupCodecPolicy AddTrackRequest::backup_codec_policy() const {
  // @@protoc_insertion_point(field_get:livekit.AddTrackRequest.backup_codec_policy)
  return _internal_backup_codec_policy();
}
inline void AddTrackRequest::_internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  
  _impl_.backup_codec_policy_ = value;
}
inline void AddTrackRequest::set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  _internal_set_backup_codec_policy(value);
  // @@protoc_insertion_point(field_set:livekit.AddTrackRequest.backup_codec_policy)
}

// -------------------------------------------------------------------

// TrickleRequest

// string candidateInit = 1;
inline void TrickleRequest::clear_candidateinit() {
  _impl_.candidateinit_.ClearToEmpty();
}
inline const std::string& TrickleRequest::candidateinit() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.candidateInit)
  return _internal_candidateinit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrickleRequest::set_candidateinit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.candidateinit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.candidateInit)
}
inline std::string* TrickleRequest::mutable_candidateinit() {
  std::string* _s = _internal_mutable_candidateinit();
  // @@protoc_insertion_point(field_mutable:livekit.TrickleRequest.candidateInit)
  return _s;
}
inline const std::string& TrickleRequest::_internal_candidateinit() const {
  return _impl_.candidateinit_.Get();
}
inline void TrickleRequest::_internal_set_candidateinit(const std::string& value) {
  
  _impl_.candidateinit_.Set(value, GetArenaForAllocation());
}
inline std::string* TrickleRequest::_internal_mutable_candidateinit() {
  
  return _impl_.candidateinit_.Mutable(GetArenaForAllocation());
}
inline std::string* TrickleRequest::release_candidateinit() {
  // @@protoc_insertion_point(field_release:livekit.TrickleRequest.candidateInit)
  return _impl_.candidateinit_.Release();
}
inline void TrickleRequest::set_allocated_candidateinit(std::string* candidateinit) {
  if (candidateinit != nullptr) {
    
  } else {
    
  }
  _impl_.candidateinit_.SetAllocated(candidateinit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.candidateinit_.IsDefault()) {
    _impl_.candidateinit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrickleRequest.candidateInit)
}

// .livekit.SignalTarget target = 2;
inline void TrickleRequest::clear_target() {
  _impl_.target_ = 0;
}
inline ::livekit::SignalTarget TrickleRequest::_internal_target() const {
  return static_cast< ::livekit::SignalTarget >(_impl_.target_);
}
inline ::livekit::SignalTarget TrickleRequest::target() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.target)
  return _internal_target();
}
inline void TrickleRequest::_internal_set_target(::livekit::SignalTarget value) {
  
  _impl_.target_ = value;
}
inline void TrickleRequest::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.target)
}

// bool final = 3;
inline void TrickleRequest::clear_final() {
  _impl_.final_ = false;
}
inline bool TrickleRequest::_internal_final() const {
  return _impl_.final_;
}
inline bool TrickleRequest::final() const {
  // @@protoc_insertion_point(field_get:livekit.TrickleRequest.final)
  return _internal_final();
}
inline void TrickleRequest::_internal_set_final(bool value) {
  
  _impl_.final_ = value;
}
inline void TrickleRequest::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:livekit.TrickleRequest.final)
}

// -------------------------------------------------------------------

// MuteTrackRequest

// string sid = 1;
inline void MuteTrackRequest::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& MuteTrackRequest::sid() const {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MuteTrackRequest::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.sid)
}
inline std::string* MuteTrackRequest::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.MuteTrackRequest.sid)
  return _s;
}
inline const std::string& MuteTrackRequest::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void MuteTrackRequest::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* MuteTrackRequest::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* MuteTrackRequest::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.MuteTrackRequest.sid)
  return _impl_.sid_.Release();
}
inline void MuteTrackRequest::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteTrackRequest.sid)
}

// bool muted = 2;
inline void MuteTrackRequest::clear_muted() {
  _impl_.muted_ = false;
}
inline bool MuteTrackRequest::_internal_muted() const {
  return _impl_.muted_;
}
inline bool MuteTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.MuteTrackRequest.muted)
  return _internal_muted();
}
inline void MuteTrackRequest::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void MuteTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.MuteTrackRequest.muted)
}

// -------------------------------------------------------------------

// JoinResponse

// .livekit.Room room = 1;
inline bool JoinResponse::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool JoinResponse::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& JoinResponse::_internal_room() const {
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& JoinResponse::room() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.room)
  return _internal_room();
}
inline void JoinResponse::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.room)
}
inline ::livekit::Room* JoinResponse::release_room() {
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* JoinResponse::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.room)
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* JoinResponse::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::Room* JoinResponse::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.room)
  return _msg;
}
inline void JoinResponse::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.room)
}

// .livekit.ParticipantInfo participant = 2;
inline bool JoinResponse::_internal_has_participant() const {
  return this != internal_default_instance() && _impl_.participant_ != nullptr;
}
inline bool JoinResponse::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::ParticipantInfo& JoinResponse::_internal_participant() const {
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(
      ::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& JoinResponse::participant() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.participant)
  return _internal_participant();
}
inline void JoinResponse::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = participant;
  if (participant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.participant)
}
inline ::livekit::ParticipantInfo* JoinResponse::release_participant() {
  
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantInfo* JoinResponse::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.participant)
  
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* JoinResponse::_internal_mutable_participant() {
  
  if (_impl_.participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantInfo>(GetArenaForAllocation());
    _impl_.participant_ = p;
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* JoinResponse::mutable_participant() {
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.participant)
  return _msg;
}
inline void JoinResponse::set_allocated_participant(::livekit::ParticipantInfo* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.participant)
}

// repeated .livekit.ParticipantInfo other_participants = 3;
inline int JoinResponse::_internal_other_participants_size() const {
  return _impl_.other_participants_.size();
}
inline int JoinResponse::other_participants_size() const {
  return _internal_other_participants_size();
}
inline ::livekit::ParticipantInfo* JoinResponse::mutable_other_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.other_participants)
  return _impl_.other_participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
JoinResponse::mutable_other_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.other_participants)
  return &_impl_.other_participants_;
}
inline const ::livekit::ParticipantInfo& JoinResponse::_internal_other_participants(int index) const {
  return _impl_.other_participants_.Get(index);
}
inline const ::livekit::ParticipantInfo& JoinResponse::other_participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.other_participants)
  return _internal_other_participants(index);
}
inline ::livekit::ParticipantInfo* JoinResponse::_internal_add_other_participants() {
  return _impl_.other_participants_.Add();
}
inline ::livekit::ParticipantInfo* JoinResponse::add_other_participants() {
  ::livekit::ParticipantInfo* _add = _internal_add_other_participants();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.other_participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
JoinResponse::other_participants() const {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.other_participants)
  return _impl_.other_participants_;
}

// string server_version = 4;
inline void JoinResponse::clear_server_version() {
  _impl_.server_version_.ClearToEmpty();
}
inline const std::string& JoinResponse::server_version() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_version)
  return _internal_server_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_server_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_version)
}
inline std::string* JoinResponse::mutable_server_version() {
  std::string* _s = _internal_mutable_server_version();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_version)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_version() const {
  return _impl_.server_version_.Get();
}
inline void JoinResponse::_internal_set_server_version(const std::string& value) {
  
  _impl_.server_version_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_server_version() {
  
  return _impl_.server_version_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinResponse::release_server_version() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_version)
  return _impl_.server_version_.Release();
}
inline void JoinResponse::set_allocated_server_version(std::string* server_version) {
  if (server_version != nullptr) {
    
  } else {
    
  }
  _impl_.server_version_.SetAllocated(server_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_version_.IsDefault()) {
    _impl_.server_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_version)
}

// repeated .livekit.ICEServer ice_servers = 5;
inline int JoinResponse::_internal_ice_servers_size() const {
  return _impl_.ice_servers_.size();
}
inline int JoinResponse::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void JoinResponse::clear_ice_servers() {
  _impl_.ice_servers_.Clear();
}
inline ::livekit::ICEServer* JoinResponse::mutable_ice_servers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.ice_servers)
  return _impl_.ice_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
JoinResponse::mutable_ice_servers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.ice_servers)
  return &_impl_.ice_servers_;
}
inline const ::livekit::ICEServer& JoinResponse::_internal_ice_servers(int index) const {
  return _impl_.ice_servers_.Get(index);
}
inline const ::livekit::ICEServer& JoinResponse::ice_servers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ice_servers)
  return _internal_ice_servers(index);
}
inline ::livekit::ICEServer* JoinResponse::_internal_add_ice_servers() {
  return _impl_.ice_servers_.Add();
}
inline ::livekit::ICEServer* JoinResponse::add_ice_servers() {
  ::livekit::ICEServer* _add = _internal_add_ice_servers();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.ice_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
JoinResponse::ice_servers() const {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.ice_servers)
  return _impl_.ice_servers_;
}

// bool subscriber_primary = 6;
inline void JoinResponse::clear_subscriber_primary() {
  _impl_.subscriber_primary_ = false;
}
inline bool JoinResponse::_internal_subscriber_primary() const {
  return _impl_.subscriber_primary_;
}
inline bool JoinResponse::subscriber_primary() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.subscriber_primary)
  return _internal_subscriber_primary();
}
inline void JoinResponse::_internal_set_subscriber_primary(bool value) {
  
  _impl_.subscriber_primary_ = value;
}
inline void JoinResponse::set_subscriber_primary(bool value) {
  _internal_set_subscriber_primary(value);
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.subscriber_primary)
}

// string alternative_url = 7;
inline void JoinResponse::clear_alternative_url() {
  _impl_.alternative_url_.ClearToEmpty();
}
inline const std::string& JoinResponse::alternative_url() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.alternative_url)
  return _internal_alternative_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_alternative_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alternative_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.alternative_url)
}
inline std::string* JoinResponse::mutable_alternative_url() {
  std::string* _s = _internal_mutable_alternative_url();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.alternative_url)
  return _s;
}
inline const std::string& JoinResponse::_internal_alternative_url() const {
  return _impl_.alternative_url_.Get();
}
inline void JoinResponse::_internal_set_alternative_url(const std::string& value) {
  
  _impl_.alternative_url_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_alternative_url() {
  
  return _impl_.alternative_url_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinResponse::release_alternative_url() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.alternative_url)
  return _impl_.alternative_url_.Release();
}
inline void JoinResponse::set_allocated_alternative_url(std::string* alternative_url) {
  if (alternative_url != nullptr) {
    
  } else {
    
  }
  _impl_.alternative_url_.SetAllocated(alternative_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alternative_url_.IsDefault()) {
    _impl_.alternative_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.alternative_url)
}

// .livekit.ClientConfiguration client_configuration = 8;
inline bool JoinResponse::_internal_has_client_configuration() const {
  return this != internal_default_instance() && _impl_.client_configuration_ != nullptr;
}
inline bool JoinResponse::has_client_configuration() const {
  return _internal_has_client_configuration();
}
inline const ::livekit::ClientConfiguration& JoinResponse::_internal_client_configuration() const {
  const ::livekit::ClientConfiguration* p = _impl_.client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ClientConfiguration&>(
      ::livekit::_ClientConfiguration_default_instance_);
}
inline const ::livekit::ClientConfiguration& JoinResponse::client_configuration() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.client_configuration)
  return _internal_client_configuration();
}
inline void JoinResponse::unsafe_arena_set_allocated_client_configuration(
    ::livekit::ClientConfiguration* client_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_configuration_);
  }
  _impl_.client_configuration_ = client_configuration;
  if (client_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.client_configuration)
}
inline ::livekit::ClientConfiguration* JoinResponse::release_client_configuration() {
  
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ClientConfiguration* JoinResponse::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.client_configuration)
  
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  return temp;
}
inline ::livekit::ClientConfiguration* JoinResponse::_internal_mutable_client_configuration() {
  
  if (_impl_.client_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ClientConfiguration>(GetArenaForAllocation());
    _impl_.client_configuration_ = p;
  }
  return _impl_.client_configuration_;
}
inline ::livekit::ClientConfiguration* JoinResponse::mutable_client_configuration() {
  ::livekit::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.client_configuration)
  return _msg;
}
inline void JoinResponse::set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_configuration_);
  }
  if (client_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration));
    if (message_arena != submessage_arena) {
      client_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_configuration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_configuration_ = client_configuration;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.client_configuration)
}

// string server_region = 9;
inline void JoinResponse::clear_server_region() {
  _impl_.server_region_.ClearToEmpty();
}
inline const std::string& JoinResponse::server_region() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_region)
  return _internal_server_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_server_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.server_region)
}
inline std::string* JoinResponse::mutable_server_region() {
  std::string* _s = _internal_mutable_server_region();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_region)
  return _s;
}
inline const std::string& JoinResponse::_internal_server_region() const {
  return _impl_.server_region_.Get();
}
inline void JoinResponse::_internal_set_server_region(const std::string& value) {
  
  _impl_.server_region_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_server_region() {
  
  return _impl_.server_region_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinResponse::release_server_region() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_region)
  return _impl_.server_region_.Release();
}
inline void JoinResponse::set_allocated_server_region(std::string* server_region) {
  if (server_region != nullptr) {
    
  } else {
    
  }
  _impl_.server_region_.SetAllocated(server_region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_region_.IsDefault()) {
    _impl_.server_region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_region)
}

// int32 ping_timeout = 10;
inline void JoinResponse::clear_ping_timeout() {
  _impl_.ping_timeout_ = 0;
}
inline int32_t JoinResponse::_internal_ping_timeout() const {
  return _impl_.ping_timeout_;
}
inline int32_t JoinResponse::ping_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ping_timeout)
  return _internal_ping_timeout();
}
inline void JoinResponse::_internal_set_ping_timeout(int32_t value) {
  
  _impl_.ping_timeout_ = value;
}
inline void JoinResponse::set_ping_timeout(int32_t value) {
  _internal_set_ping_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.ping_timeout)
}

// int32 ping_interval = 11;
inline void JoinResponse::clear_ping_interval() {
  _impl_.ping_interval_ = 0;
}
inline int32_t JoinResponse::_internal_ping_interval() const {
  return _impl_.ping_interval_;
}
inline int32_t JoinResponse::ping_interval() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.ping_interval)
  return _internal_ping_interval();
}
inline void JoinResponse::_internal_set_ping_interval(int32_t value) {
  
  _impl_.ping_interval_ = value;
}
inline void JoinResponse::set_ping_interval(int32_t value) {
  _internal_set_ping_interval(value);
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.ping_interval)
}

// .livekit.ServerInfo server_info = 12;
inline bool JoinResponse::_internal_has_server_info() const {
  return this != internal_default_instance() && _impl_.server_info_ != nullptr;
}
inline bool JoinResponse::has_server_info() const {
  return _internal_has_server_info();
}
inline const ::livekit::ServerInfo& JoinResponse::_internal_server_info() const {
  const ::livekit::ServerInfo* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ServerInfo&>(
      ::livekit::_ServerInfo_default_instance_);
}
inline const ::livekit::ServerInfo& JoinResponse::server_info() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.server_info)
  return _internal_server_info();
}
inline void JoinResponse::unsafe_arena_set_allocated_server_info(
    ::livekit::ServerInfo* server_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = server_info;
  if (server_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JoinResponse.server_info)
}
inline ::livekit::ServerInfo* JoinResponse::release_server_info() {
  
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ServerInfo* JoinResponse::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.server_info)
  
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::livekit::ServerInfo* JoinResponse::_internal_mutable_server_info() {
  
  if (_impl_.server_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ServerInfo>(GetArenaForAllocation());
    _impl_.server_info_ = p;
  }
  return _impl_.server_info_;
}
inline ::livekit::ServerInfo* JoinResponse::mutable_server_info() {
  ::livekit::ServerInfo* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.server_info)
  return _msg;
}
inline void JoinResponse::set_allocated_server_info(::livekit::ServerInfo* server_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  if (server_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_info));
    if (message_arena != submessage_arena) {
      server_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.server_info)
}

// bytes sif_trailer = 13;
inline void JoinResponse::clear_sif_trailer() {
  _impl_.sif_trailer_.ClearToEmpty();
}
inline const std::string& JoinResponse::sif_trailer() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.sif_trailer)
  return _internal_sif_trailer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinResponse::set_sif_trailer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sif_trailer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.sif_trailer)
}
inline std::string* JoinResponse::mutable_sif_trailer() {
  std::string* _s = _internal_mutable_sif_trailer();
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.sif_trailer)
  return _s;
}
inline const std::string& JoinResponse::_internal_sif_trailer() const {
  return _impl_.sif_trailer_.Get();
}
inline void JoinResponse::_internal_set_sif_trailer(const std::string& value) {
  
  _impl_.sif_trailer_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinResponse::_internal_mutable_sif_trailer() {
  
  return _impl_.sif_trailer_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinResponse::release_sif_trailer() {
  // @@protoc_insertion_point(field_release:livekit.JoinResponse.sif_trailer)
  return _impl_.sif_trailer_.Release();
}
inline void JoinResponse::set_allocated_sif_trailer(std::string* sif_trailer) {
  if (sif_trailer != nullptr) {
    
  } else {
    
  }
  _impl_.sif_trailer_.SetAllocated(sif_trailer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sif_trailer_.IsDefault()) {
    _impl_.sif_trailer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JoinResponse.sif_trailer)
}

// repeated .livekit.Codec enabled_publish_codecs = 14;
inline int JoinResponse::_internal_enabled_publish_codecs_size() const {
  return _impl_.enabled_publish_codecs_.size();
}
inline int JoinResponse::enabled_publish_codecs_size() const {
  return _internal_enabled_publish_codecs_size();
}
inline ::livekit::Codec* JoinResponse::mutable_enabled_publish_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.JoinResponse.enabled_publish_codecs)
  return _impl_.enabled_publish_codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
JoinResponse::mutable_enabled_publish_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.JoinResponse.enabled_publish_codecs)
  return &_impl_.enabled_publish_codecs_;
}
inline const ::livekit::Codec& JoinResponse::_internal_enabled_publish_codecs(int index) const {
  return _impl_.enabled_publish_codecs_.Get(index);
}
inline const ::livekit::Codec& JoinResponse::enabled_publish_codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.enabled_publish_codecs)
  return _internal_enabled_publish_codecs(index);
}
inline ::livekit::Codec* JoinResponse::_internal_add_enabled_publish_codecs() {
  return _impl_.enabled_publish_codecs_.Add();
}
inline ::livekit::Codec* JoinResponse::add_enabled_publish_codecs() {
  ::livekit::Codec* _add = _internal_add_enabled_publish_codecs();
  // @@protoc_insertion_point(field_add:livekit.JoinResponse.enabled_publish_codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
JoinResponse::enabled_publish_codecs() const {
  // @@protoc_insertion_point(field_list:livekit.JoinResponse.enabled_publish_codecs)
  return _impl_.enabled_publish_codecs_;
}

// bool fast_publish = 15;
inline void JoinResponse::clear_fast_publish() {
  _impl_.fast_publish_ = false;
}
inline bool JoinResponse::_internal_fast_publish() const {
  return _impl_.fast_publish_;
}
inline bool JoinResponse::fast_publish() const {
  // @@protoc_insertion_point(field_get:livekit.JoinResponse.fast_publish)
  return _internal_fast_publish();
}
inline void JoinResponse::_internal_set_fast_publish(bool value) {
  
  _impl_.fast_publish_ = value;
}
inline void JoinResponse::set_fast_publish(bool value) {
  _internal_set_fast_publish(value);
  // @@protoc_insertion_point(field_set:livekit.JoinResponse.fast_publish)
}

// -------------------------------------------------------------------

// ReconnectResponse

// repeated .livekit.ICEServer ice_servers = 1;
inline int ReconnectResponse::_internal_ice_servers_size() const {
  return _impl_.ice_servers_.size();
}
inline int ReconnectResponse::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void ReconnectResponse::clear_ice_servers() {
  _impl_.ice_servers_.Clear();
}
inline ::livekit::ICEServer* ReconnectResponse::mutable_ice_servers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ReconnectResponse.ice_servers)
  return _impl_.ice_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >*
ReconnectResponse::mutable_ice_servers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ReconnectResponse.ice_servers)
  return &_impl_.ice_servers_;
}
inline const ::livekit::ICEServer& ReconnectResponse::_internal_ice_servers(int index) const {
  return _impl_.ice_servers_.Get(index);
}
inline const ::livekit::ICEServer& ReconnectResponse::ice_servers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ReconnectResponse.ice_servers)
  return _internal_ice_servers(index);
}
inline ::livekit::ICEServer* ReconnectResponse::_internal_add_ice_servers() {
  return _impl_.ice_servers_.Add();
}
inline ::livekit::ICEServer* ReconnectResponse::add_ice_servers() {
  ::livekit::ICEServer* _add = _internal_add_ice_servers();
  // @@protoc_insertion_point(field_add:livekit.ReconnectResponse.ice_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ICEServer >&
ReconnectResponse::ice_servers() const {
  // @@protoc_insertion_point(field_list:livekit.ReconnectResponse.ice_servers)
  return _impl_.ice_servers_;
}

// .livekit.ClientConfiguration client_configuration = 2;
inline bool ReconnectResponse::_internal_has_client_configuration() const {
  return this != internal_default_instance() && _impl_.client_configuration_ != nullptr;
}
inline bool ReconnectResponse::has_client_configuration() const {
  return _internal_has_client_configuration();
}
inline const ::livekit::ClientConfiguration& ReconnectResponse::_internal_client_configuration() const {
  const ::livekit::ClientConfiguration* p = _impl_.client_configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ClientConfiguration&>(
      ::livekit::_ClientConfiguration_default_instance_);
}
inline const ::livekit::ClientConfiguration& ReconnectResponse::client_configuration() const {
  // @@protoc_insertion_point(field_get:livekit.ReconnectResponse.client_configuration)
  return _internal_client_configuration();
}
inline void ReconnectResponse::unsafe_arena_set_allocated_client_configuration(
    ::livekit::ClientConfiguration* client_configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_configuration_);
  }
  _impl_.client_configuration_ = client_configuration;
  if (client_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ReconnectResponse.client_configuration)
}
inline ::livekit::ClientConfiguration* ReconnectResponse::release_client_configuration() {
  
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ClientConfiguration* ReconnectResponse::unsafe_arena_release_client_configuration() {
  // @@protoc_insertion_point(field_release:livekit.ReconnectResponse.client_configuration)
  
  ::livekit::ClientConfiguration* temp = _impl_.client_configuration_;
  _impl_.client_configuration_ = nullptr;
  return temp;
}
inline ::livekit::ClientConfiguration* ReconnectResponse::_internal_mutable_client_configuration() {
  
  if (_impl_.client_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ClientConfiguration>(GetArenaForAllocation());
    _impl_.client_configuration_ = p;
  }
  return _impl_.client_configuration_;
}
inline ::livekit::ClientConfiguration* ReconnectResponse::mutable_client_configuration() {
  ::livekit::ClientConfiguration* _msg = _internal_mutable_client_configuration();
  // @@protoc_insertion_point(field_mutable:livekit.ReconnectResponse.client_configuration)
  return _msg;
}
inline void ReconnectResponse::set_allocated_client_configuration(::livekit::ClientConfiguration* client_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_configuration_);
  }
  if (client_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_configuration));
    if (message_arena != submessage_arena) {
      client_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_configuration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.client_configuration_ = client_configuration;
  // @@protoc_insertion_point(field_set_allocated:livekit.ReconnectResponse.client_configuration)
}

// -------------------------------------------------------------------

// TrackPublishedResponse

// string cid = 1;
inline void TrackPublishedResponse::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& TrackPublishedResponse::cid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublishedResponse::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPublishedResponse.cid)
}
inline std::string* TrackPublishedResponse::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.cid)
  return _s;
}
inline const std::string& TrackPublishedResponse::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void TrackPublishedResponse::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublishedResponse::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublishedResponse::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.cid)
  return _impl_.cid_.Release();
}
inline void TrackPublishedResponse::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.cid)
}

// .livekit.TrackInfo track = 2;
inline bool TrackPublishedResponse::_internal_has_track() const {
  return this != internal_default_instance() && _impl_.track_ != nullptr;
}
inline bool TrackPublishedResponse::has_track() const {
  return _internal_has_track();
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::_internal_track() const {
  const ::livekit::TrackInfo* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TrackInfo&>(
      ::livekit::_TrackInfo_default_instance_);
}
inline const ::livekit::TrackInfo& TrackPublishedResponse::track() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPublishedResponse.track)
  return _internal_track();
}
inline void TrackPublishedResponse::unsafe_arena_set_allocated_track(
    ::livekit::TrackInfo* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackPublishedResponse.track)
}
inline ::livekit::TrackInfo* TrackPublishedResponse::release_track() {
  
  ::livekit::TrackInfo* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.TrackPublishedResponse.track)
  
  ::livekit::TrackInfo* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::_internal_mutable_track() {
  
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::TrackInfo>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::livekit::TrackInfo* TrackPublishedResponse::mutable_track() {
  ::livekit::TrackInfo* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPublishedResponse.track)
  return _msg;
}
inline void TrackPublishedResponse::set_allocated_track(::livekit::TrackInfo* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track));
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPublishedResponse.track)
}

// -------------------------------------------------------------------

// TrackUnpublishedResponse

// string track_sid = 1;
inline void TrackUnpublishedResponse::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& TrackUnpublishedResponse::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackUnpublishedResponse.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnpublishedResponse::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackUnpublishedResponse.track_sid)
}
inline std::string* TrackUnpublishedResponse::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackUnpublishedResponse.track_sid)
  return _s;
}
inline const std::string& TrackUnpublishedResponse::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackUnpublishedResponse::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnpublishedResponse::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnpublishedResponse::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackUnpublishedResponse.track_sid)
  return _impl_.track_sid_.Release();
}
inline void TrackUnpublishedResponse::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackUnpublishedResponse.track_sid)
}

// -------------------------------------------------------------------

// SessionDescription

// string type = 1;
inline void SessionDescription::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& SessionDescription::type() const {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionDescription::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.type)
}
inline std::string* SessionDescription::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.type)
  return _s;
}
inline const std::string& SessionDescription::_internal_type() const {
  return _impl_.type_.Get();
}
inline void SessionDescription::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionDescription::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionDescription::release_type() {
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.type)
  return _impl_.type_.Release();
}
inline void SessionDescription::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.type)
}

// string sdp = 2;
inline void SessionDescription::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& SessionDescription::sdp() const {
  // @@protoc_insertion_point(field_get:livekit.SessionDescription.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionDescription::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SessionDescription.sdp)
}
inline std::string* SessionDescription::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:livekit.SessionDescription.sdp)
  return _s;
}
inline const std::string& SessionDescription::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void SessionDescription::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionDescription::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionDescription::release_sdp() {
  // @@protoc_insertion_point(field_release:livekit.SessionDescription.sdp)
  return _impl_.sdp_.Release();
}
inline void SessionDescription::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SessionDescription.sdp)
}

// -------------------------------------------------------------------

// ParticipantUpdate

// repeated .livekit.ParticipantInfo participants = 1;
inline int ParticipantUpdate::_internal_participants_size() const {
  return _impl_.participants_.size();
}
inline int ParticipantUpdate::participants_size() const {
  return _internal_participants_size();
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantUpdate.participants)
  return _impl_.participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
ParticipantUpdate::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantUpdate.participants)
  return &_impl_.participants_;
}
inline const ::livekit::ParticipantInfo& ParticipantUpdate::_internal_participants(int index) const {
  return _impl_.participants_.Get(index);
}
inline const ::livekit::ParticipantInfo& ParticipantUpdate::participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantUpdate.participants)
  return _internal_participants(index);
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::_internal_add_participants() {
  return _impl_.participants_.Add();
}
inline ::livekit::ParticipantInfo* ParticipantUpdate::add_participants() {
  ::livekit::ParticipantInfo* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:livekit.ParticipantUpdate.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
ParticipantUpdate::participants() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantUpdate.participants)
  return _impl_.participants_;
}

// -------------------------------------------------------------------

// UpdateSubscription

// repeated string track_sids = 1;
inline int UpdateSubscription::_internal_track_sids_size() const {
  return _impl_.track_sids_.size();
}
inline int UpdateSubscription::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateSubscription::clear_track_sids() {
  _impl_.track_sids_.Clear();
}
inline std::string* UpdateSubscription::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateSubscription.track_sids)
  return _s;
}
inline const std::string& UpdateSubscription::_internal_track_sids(int index) const {
  return _impl_.track_sids_.Get(index);
}
inline const std::string& UpdateSubscription::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.track_sids)
  return _internal_track_sids(index);
}
inline std::string* UpdateSubscription::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.track_sids)
  return _impl_.track_sids_.Mutable(index);
}
inline void UpdateSubscription::set_track_sids(int index, const std::string& value) {
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, std::string&& value) {
  _impl_.track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::set_track_sids(int index, const char* value, size_t size) {
  _impl_.track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateSubscription.track_sids)
}
inline std::string* UpdateSubscription::_internal_add_track_sids() {
  return _impl_.track_sids_.Add();
}
inline void UpdateSubscription::add_track_sids(const std::string& value) {
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(std::string&& value) {
  _impl_.track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateSubscription.track_sids)
}
inline void UpdateSubscription::add_track_sids(const char* value, size_t size) {
  _impl_.track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateSubscription.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateSubscription::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.track_sids)
  return _impl_.track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateSubscription::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.track_sids)
  return &_impl_.track_sids_;
}

// bool subscribe = 2;
inline void UpdateSubscription::clear_subscribe() {
  _impl_.subscribe_ = false;
}
inline bool UpdateSubscription::_internal_subscribe() const {
  return _impl_.subscribe_;
}
inline bool UpdateSubscription::subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.subscribe)
  return _internal_subscribe();
}
inline void UpdateSubscription::_internal_set_subscribe(bool value) {
  
  _impl_.subscribe_ = value;
}
inline void UpdateSubscription::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscription.subscribe)
}

// repeated .livekit.ParticipantTracks participant_tracks = 3;
inline int UpdateSubscription::_internal_participant_tracks_size() const {
  return _impl_.participant_tracks_.size();
}
inline int UpdateSubscription::participant_tracks_size() const {
  return _internal_participant_tracks_size();
}
inline ::livekit::ParticipantTracks* UpdateSubscription::mutable_participant_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscription.participant_tracks)
  return _impl_.participant_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
UpdateSubscription::mutable_participant_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscription.participant_tracks)
  return &_impl_.participant_tracks_;
}
inline const ::livekit::ParticipantTracks& UpdateSubscription::_internal_participant_tracks(int index) const {
  return _impl_.participant_tracks_.Get(index);
}
inline const ::livekit::ParticipantTracks& UpdateSubscription::participant_tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscription.participant_tracks)
  return _internal_participant_tracks(index);
}
inline ::livekit::ParticipantTracks* UpdateSubscription::_internal_add_participant_tracks() {
  return _impl_.participant_tracks_.Add();
}
inline ::livekit::ParticipantTracks* UpdateSubscription::add_participant_tracks() {
  ::livekit::ParticipantTracks* _add = _internal_add_participant_tracks();
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscription.participant_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
UpdateSubscription::participant_tracks() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscription.participant_tracks)
  return _impl_.participant_tracks_;
}

// -------------------------------------------------------------------

// UpdateTrackSettings

// repeated string track_sids = 1;
inline int UpdateTrackSettings::_internal_track_sids_size() const {
  return _impl_.track_sids_.size();
}
inline int UpdateTrackSettings::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateTrackSettings::clear_track_sids() {
  _impl_.track_sids_.Clear();
}
inline std::string* UpdateTrackSettings::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateTrackSettings.track_sids)
  return _s;
}
inline const std::string& UpdateTrackSettings::_internal_track_sids(int index) const {
  return _impl_.track_sids_.Get(index);
}
inline const std::string& UpdateTrackSettings::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.track_sids)
  return _internal_track_sids(index);
}
inline std::string* UpdateTrackSettings::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateTrackSettings.track_sids)
  return _impl_.track_sids_.Mutable(index);
}
inline void UpdateTrackSettings::set_track_sids(int index, const std::string& value) {
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, std::string&& value) {
  _impl_.track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::set_track_sids(int index, const char* value, size_t size) {
  _impl_.track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateTrackSettings.track_sids)
}
inline std::string* UpdateTrackSettings::_internal_add_track_sids() {
  return _impl_.track_sids_.Add();
}
inline void UpdateTrackSettings::add_track_sids(const std::string& value) {
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(std::string&& value) {
  _impl_.track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateTrackSettings.track_sids)
}
inline void UpdateTrackSettings::add_track_sids(const char* value, size_t size) {
  _impl_.track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateTrackSettings.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateTrackSettings::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateTrackSettings.track_sids)
  return _impl_.track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateTrackSettings::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateTrackSettings.track_sids)
  return &_impl_.track_sids_;
}

// bool disabled = 3;
inline void UpdateTrackSettings::clear_disabled() {
  _impl_.disabled_ = false;
}
inline bool UpdateTrackSettings::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool UpdateTrackSettings::disabled() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.disabled)
  return _internal_disabled();
}
inline void UpdateTrackSettings::_internal_set_disabled(bool value) {
  
  _impl_.disabled_ = value;
}
inline void UpdateTrackSettings::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.disabled)
}

// .livekit.VideoQuality quality = 4;
inline void UpdateTrackSettings::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::livekit::VideoQuality UpdateTrackSettings::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(_impl_.quality_);
}
inline ::livekit::VideoQuality UpdateTrackSettings::quality() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.quality)
  return _internal_quality();
}
inline void UpdateTrackSettings::_internal_set_quality(::livekit::VideoQuality value) {
  
  _impl_.quality_ = value;
}
inline void UpdateTrackSettings::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.quality)
}

// uint32 width = 5;
inline void UpdateTrackSettings::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t UpdateTrackSettings::width() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.width)
  return _internal_width();
}
inline void UpdateTrackSettings::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void UpdateTrackSettings::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.width)
}

// uint32 height = 6;
inline void UpdateTrackSettings::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t UpdateTrackSettings::height() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.height)
  return _internal_height();
}
inline void UpdateTrackSettings::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void UpdateTrackSettings::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.height)
}

// uint32 fps = 7;
inline void UpdateTrackSettings::clear_fps() {
  _impl_.fps_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_fps() const {
  return _impl_.fps_;
}
inline uint32_t UpdateTrackSettings::fps() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.fps)
  return _internal_fps();
}
inline void UpdateTrackSettings::_internal_set_fps(uint32_t value) {
  
  _impl_.fps_ = value;
}
inline void UpdateTrackSettings::set_fps(uint32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.fps)
}

// uint32 priority = 8;
inline void UpdateTrackSettings::clear_priority() {
  _impl_.priority_ = 0u;
}
inline uint32_t UpdateTrackSettings::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t UpdateTrackSettings::priority() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateTrackSettings.priority)
  return _internal_priority();
}
inline void UpdateTrackSettings::_internal_set_priority(uint32_t value) {
  
  _impl_.priority_ = value;
}
inline void UpdateTrackSettings::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateTrackSettings.priority)
}

// -------------------------------------------------------------------

// UpdateLocalAudioTrack

// string track_sid = 1;
inline void UpdateLocalAudioTrack::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& UpdateLocalAudioTrack::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalAudioTrack.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocalAudioTrack::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalAudioTrack.track_sid)
}
inline std::string* UpdateLocalAudioTrack::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLocalAudioTrack.track_sid)
  return _s;
}
inline const std::string& UpdateLocalAudioTrack::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void UpdateLocalAudioTrack::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocalAudioTrack::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocalAudioTrack::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.UpdateLocalAudioTrack.track_sid)
  return _impl_.track_sid_.Release();
}
inline void UpdateLocalAudioTrack::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLocalAudioTrack.track_sid)
}

// repeated .livekit.AudioTrackFeature features = 2;
inline int UpdateLocalAudioTrack::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int UpdateLocalAudioTrack::features_size() const {
  return _internal_features_size();
}
inline void UpdateLocalAudioTrack::clear_features() {
  _impl_.features_.Clear();
}
inline ::livekit::AudioTrackFeature UpdateLocalAudioTrack::_internal_features(int index) const {
  return static_cast< ::livekit::AudioTrackFeature >(_impl_.features_.Get(index));
}
inline ::livekit::AudioTrackFeature UpdateLocalAudioTrack::features(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalAudioTrack.features)
  return _internal_features(index);
}
inline void UpdateLocalAudioTrack::set_features(int index, ::livekit::AudioTrackFeature value) {
  _impl_.features_.Set(index, value);
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalAudioTrack.features)
}
inline void UpdateLocalAudioTrack::_internal_add_features(::livekit::AudioTrackFeature value) {
  _impl_.features_.Add(value);
}
inline void UpdateLocalAudioTrack::add_features(::livekit::AudioTrackFeature value) {
  _internal_add_features(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateLocalAudioTrack.features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UpdateLocalAudioTrack::features() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateLocalAudioTrack.features)
  return _impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateLocalAudioTrack::_internal_mutable_features() {
  return &_impl_.features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UpdateLocalAudioTrack::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateLocalAudioTrack.features)
  return _internal_mutable_features();
}

// -------------------------------------------------------------------

// UpdateLocalVideoTrack

// string track_sid = 1;
inline void UpdateLocalVideoTrack::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& UpdateLocalVideoTrack::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateLocalVideoTrack::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.track_sid)
}
inline std::string* UpdateLocalVideoTrack::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateLocalVideoTrack.track_sid)
  return _s;
}
inline const std::string& UpdateLocalVideoTrack::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void UpdateLocalVideoTrack::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateLocalVideoTrack::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateLocalVideoTrack::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.UpdateLocalVideoTrack.track_sid)
  return _impl_.track_sid_.Release();
}
inline void UpdateLocalVideoTrack::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateLocalVideoTrack.track_sid)
}

// uint32 width = 2;
inline void UpdateLocalVideoTrack::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t UpdateLocalVideoTrack::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t UpdateLocalVideoTrack::width() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.width)
  return _internal_width();
}
inline void UpdateLocalVideoTrack::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void UpdateLocalVideoTrack::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.width)
}

// uint32 height = 3;
inline void UpdateLocalVideoTrack::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t UpdateLocalVideoTrack::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t UpdateLocalVideoTrack::height() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateLocalVideoTrack.height)
  return _internal_height();
}
inline void UpdateLocalVideoTrack::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void UpdateLocalVideoTrack::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateLocalVideoTrack.height)
}

// -------------------------------------------------------------------

// LeaveRequest

// bool can_reconnect = 1;
inline void LeaveRequest::clear_can_reconnect() {
  _impl_.can_reconnect_ = false;
}
inline bool LeaveRequest::_internal_can_reconnect() const {
  return _impl_.can_reconnect_;
}
inline bool LeaveRequest::can_reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.can_reconnect)
  return _internal_can_reconnect();
}
inline void LeaveRequest::_internal_set_can_reconnect(bool value) {
  
  _impl_.can_reconnect_ = value;
}
inline void LeaveRequest::set_can_reconnect(bool value) {
  _internal_set_can_reconnect(value);
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.can_reconnect)
}

// .livekit.DisconnectReason reason = 2;
inline void LeaveRequest::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::livekit::DisconnectReason LeaveRequest::_internal_reason() const {
  return static_cast< ::livekit::DisconnectReason >(_impl_.reason_);
}
inline ::livekit::DisconnectReason LeaveRequest::reason() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.reason)
  return _internal_reason();
}
inline void LeaveRequest::_internal_set_reason(::livekit::DisconnectReason value) {
  
  _impl_.reason_ = value;
}
inline void LeaveRequest::set_reason(::livekit::DisconnectReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.reason)
}

// .livekit.LeaveRequest.Action action = 3;
inline void LeaveRequest::clear_action() {
  _impl_.action_ = 0;
}
inline ::livekit::LeaveRequest_Action LeaveRequest::_internal_action() const {
  return static_cast< ::livekit::LeaveRequest_Action >(_impl_.action_);
}
inline ::livekit::LeaveRequest_Action LeaveRequest::action() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.action)
  return _internal_action();
}
inline void LeaveRequest::_internal_set_action(::livekit::LeaveRequest_Action value) {
  
  _impl_.action_ = value;
}
inline void LeaveRequest::set_action(::livekit::LeaveRequest_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:livekit.LeaveRequest.action)
}

// .livekit.RegionSettings regions = 4;
inline bool LeaveRequest::_internal_has_regions() const {
  return this != internal_default_instance() && _impl_.regions_ != nullptr;
}
inline bool LeaveRequest::has_regions() const {
  return _internal_has_regions();
}
inline void LeaveRequest::clear_regions() {
  if (GetArenaForAllocation() == nullptr && _impl_.regions_ != nullptr) {
    delete _impl_.regions_;
  }
  _impl_.regions_ = nullptr;
}
inline const ::livekit::RegionSettings& LeaveRequest::_internal_regions() const {
  const ::livekit::RegionSettings* p = _impl_.regions_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RegionSettings&>(
      ::livekit::_RegionSettings_default_instance_);
}
inline const ::livekit::RegionSettings& LeaveRequest::regions() const {
  // @@protoc_insertion_point(field_get:livekit.LeaveRequest.regions)
  return _internal_regions();
}
inline void LeaveRequest::unsafe_arena_set_allocated_regions(
    ::livekit::RegionSettings* regions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regions_);
  }
  _impl_.regions_ = regions;
  if (regions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.LeaveRequest.regions)
}
inline ::livekit::RegionSettings* LeaveRequest::release_regions() {
  
  ::livekit::RegionSettings* temp = _impl_.regions_;
  _impl_.regions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RegionSettings* LeaveRequest::unsafe_arena_release_regions() {
  // @@protoc_insertion_point(field_release:livekit.LeaveRequest.regions)
  
  ::livekit::RegionSettings* temp = _impl_.regions_;
  _impl_.regions_ = nullptr;
  return temp;
}
inline ::livekit::RegionSettings* LeaveRequest::_internal_mutable_regions() {
  
  if (_impl_.regions_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RegionSettings>(GetArenaForAllocation());
    _impl_.regions_ = p;
  }
  return _impl_.regions_;
}
inline ::livekit::RegionSettings* LeaveRequest::mutable_regions() {
  ::livekit::RegionSettings* _msg = _internal_mutable_regions();
  // @@protoc_insertion_point(field_mutable:livekit.LeaveRequest.regions)
  return _msg;
}
inline void LeaveRequest::set_allocated_regions(::livekit::RegionSettings* regions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.regions_;
  }
  if (regions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regions);
    if (message_arena != submessage_arena) {
      regions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.regions_ = regions;
  // @@protoc_insertion_point(field_set_allocated:livekit.LeaveRequest.regions)
}

// -------------------------------------------------------------------

// UpdateVideoLayers

// string track_sid = 1;
inline void UpdateVideoLayers::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& UpdateVideoLayers::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateVideoLayers::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateVideoLayers.track_sid)
}
inline std::string* UpdateVideoLayers::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.track_sid)
  return _s;
}
inline const std::string& UpdateVideoLayers::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void UpdateVideoLayers::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateVideoLayers::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateVideoLayers::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.UpdateVideoLayers.track_sid)
  return _impl_.track_sid_.Release();
}
inline void UpdateVideoLayers::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateVideoLayers.track_sid)
}

// repeated .livekit.VideoLayer layers = 2;
inline int UpdateVideoLayers::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int UpdateVideoLayers::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* UpdateVideoLayers::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateVideoLayers.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
UpdateVideoLayers::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateVideoLayers.layers)
  return &_impl_.layers_;
}
inline const ::livekit::VideoLayer& UpdateVideoLayers::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::livekit::VideoLayer& UpdateVideoLayers::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateVideoLayers.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* UpdateVideoLayers::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::livekit::VideoLayer* UpdateVideoLayers::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.UpdateVideoLayers.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
UpdateVideoLayers::layers() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateVideoLayers.layers)
  return _impl_.layers_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateParticipantMetadata

// string metadata = 1;
inline void UpdateParticipantMetadata::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& UpdateParticipantMetadata::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantMetadata::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.metadata)
}
inline std::string* UpdateParticipantMetadata::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantMetadata.metadata)
  return _s;
}
inline const std::string& UpdateParticipantMetadata::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void UpdateParticipantMetadata::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantMetadata::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantMetadata::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantMetadata.metadata)
  return _impl_.metadata_.Release();
}
inline void UpdateParticipantMetadata::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantMetadata.metadata)
}

// string name = 2;
inline void UpdateParticipantMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateParticipantMetadata::name() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.name)
}
inline std::string* UpdateParticipantMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantMetadata.name)
  return _s;
}
inline const std::string& UpdateParticipantMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateParticipantMetadata::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantMetadata::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantMetadata::release_name() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantMetadata.name)
  return _impl_.name_.Release();
}
inline void UpdateParticipantMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantMetadata.name)
}

// map<string, string> attributes = 3;
inline int UpdateParticipantMetadata::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int UpdateParticipantMetadata::attributes_size() const {
  return _internal_attributes_size();
}
inline void UpdateParticipantMetadata::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateParticipantMetadata::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateParticipantMetadata::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.UpdateParticipantMetadata.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateParticipantMetadata::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateParticipantMetadata::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.UpdateParticipantMetadata.attributes)
  return _internal_mutable_attributes();
}

// uint32 request_id = 4;
inline void UpdateParticipantMetadata::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t UpdateParticipantMetadata::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t UpdateParticipantMetadata::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantMetadata.request_id)
  return _internal_request_id();
}
inline void UpdateParticipantMetadata::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void UpdateParticipantMetadata::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantMetadata.request_id)
}

// -------------------------------------------------------------------

// ICEServer

// repeated string urls = 1;
inline int ICEServer::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int ICEServer::urls_size() const {
  return _internal_urls_size();
}
inline void ICEServer::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* ICEServer::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.ICEServer.urls)
  return _s;
}
inline const std::string& ICEServer::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& ICEServer::urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.urls)
  return _internal_urls(index);
}
inline std::string* ICEServer::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.urls)
  return _impl_.urls_.Mutable(index);
}
inline void ICEServer::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.ICEServer.urls)
}
inline void ICEServer::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.ICEServer.urls)
}
inline std::string* ICEServer::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void ICEServer::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.ICEServer.urls)
}
inline void ICEServer::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.ICEServer.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ICEServer::urls() const {
  // @@protoc_insertion_point(field_list:livekit.ICEServer.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ICEServer::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ICEServer.urls)
  return &_impl_.urls_;
}

// string username = 2;
inline void ICEServer::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ICEServer::username() const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.username)
}
inline std::string* ICEServer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.username)
  return _s;
}
inline const std::string& ICEServer::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ICEServer::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ICEServer::release_username() {
  // @@protoc_insertion_point(field_release:livekit.ICEServer.username)
  return _impl_.username_.Release();
}
inline void ICEServer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.username)
}

// string credential = 3;
inline void ICEServer::clear_credential() {
  _impl_.credential_.ClearToEmpty();
}
inline const std::string& ICEServer::credential() const {
  // @@protoc_insertion_point(field_get:livekit.ICEServer.credential)
  return _internal_credential();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ICEServer::set_credential(ArgT0&& arg0, ArgT... args) {
 
 _impl_.credential_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ICEServer.credential)
}
inline std::string* ICEServer::mutable_credential() {
  std::string* _s = _internal_mutable_credential();
  // @@protoc_insertion_point(field_mutable:livekit.ICEServer.credential)
  return _s;
}
inline const std::string& ICEServer::_internal_credential() const {
  return _impl_.credential_.Get();
}
inline void ICEServer::_internal_set_credential(const std::string& value) {
  
  _impl_.credential_.Set(value, GetArenaForAllocation());
}
inline std::string* ICEServer::_internal_mutable_credential() {
  
  return _impl_.credential_.Mutable(GetArenaForAllocation());
}
inline std::string* ICEServer::release_credential() {
  // @@protoc_insertion_point(field_release:livekit.ICEServer.credential)
  return _impl_.credential_.Release();
}
inline void ICEServer::set_allocated_credential(std::string* credential) {
  if (credential != nullptr) {
    
  } else {
    
  }
  _impl_.credential_.SetAllocated(credential, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credential_.IsDefault()) {
    _impl_.credential_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ICEServer.credential)
}

// -------------------------------------------------------------------

// SpeakersChanged

// repeated .livekit.SpeakerInfo speakers = 1;
inline int SpeakersChanged::_internal_speakers_size() const {
  return _impl_.speakers_.size();
}
inline int SpeakersChanged::speakers_size() const {
  return _internal_speakers_size();
}
inline ::livekit::SpeakerInfo* SpeakersChanged::mutable_speakers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SpeakersChanged.speakers)
  return _impl_.speakers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
SpeakersChanged::mutable_speakers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SpeakersChanged.speakers)
  return &_impl_.speakers_;
}
inline const ::livekit::SpeakerInfo& SpeakersChanged::_internal_speakers(int index) const {
  return _impl_.speakers_.Get(index);
}
inline const ::livekit::SpeakerInfo& SpeakersChanged::speakers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SpeakersChanged.speakers)
  return _internal_speakers(index);
}
inline ::livekit::SpeakerInfo* SpeakersChanged::_internal_add_speakers() {
  return _impl_.speakers_.Add();
}
inline ::livekit::SpeakerInfo* SpeakersChanged::add_speakers() {
  ::livekit::SpeakerInfo* _add = _internal_add_speakers();
  // @@protoc_insertion_point(field_add:livekit.SpeakersChanged.speakers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
SpeakersChanged::speakers() const {
  // @@protoc_insertion_point(field_list:livekit.SpeakersChanged.speakers)
  return _impl_.speakers_;
}

// -------------------------------------------------------------------

// RoomUpdate

// .livekit.Room room = 1;
inline bool RoomUpdate::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool RoomUpdate::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& RoomUpdate::_internal_room() const {
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& RoomUpdate::room() const {
  // @@protoc_insertion_point(field_get:livekit.RoomUpdate.room)
  return _internal_room();
}
inline void RoomUpdate::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomUpdate.room)
}
inline ::livekit::Room* RoomUpdate::release_room() {
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* RoomUpdate::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.RoomUpdate.room)
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* RoomUpdate::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::Room* RoomUpdate::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.RoomUpdate.room)
  return _msg;
}
inline void RoomUpdate::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomUpdate.room)
}

// -------------------------------------------------------------------

// ConnectionQualityInfo

// string participant_sid = 1;
inline void ConnectionQualityInfo::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& ConnectionQualityInfo::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionQualityInfo::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.participant_sid)
}
inline std::string* ConnectionQualityInfo::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityInfo.participant_sid)
  return _s;
}
inline const std::string& ConnectionQualityInfo::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void ConnectionQualityInfo::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionQualityInfo::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectionQualityInfo::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.ConnectionQualityInfo.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void ConnectionQualityInfo::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ConnectionQualityInfo.participant_sid)
}

// .livekit.ConnectionQuality quality = 2;
inline void ConnectionQualityInfo::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::_internal_quality() const {
  return static_cast< ::livekit::ConnectionQuality >(_impl_.quality_);
}
inline ::livekit::ConnectionQuality ConnectionQualityInfo::quality() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.quality)
  return _internal_quality();
}
inline void ConnectionQualityInfo::_internal_set_quality(::livekit::ConnectionQuality value) {
  
  _impl_.quality_ = value;
}
inline void ConnectionQualityInfo::set_quality(::livekit::ConnectionQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.quality)
}

// float score = 3;
inline void ConnectionQualityInfo::clear_score() {
  _impl_.score_ = 0;
}
inline float ConnectionQualityInfo::_internal_score() const {
  return _impl_.score_;
}
inline float ConnectionQualityInfo::score() const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityInfo.score)
  return _internal_score();
}
inline void ConnectionQualityInfo::_internal_set_score(float value) {
  
  _impl_.score_ = value;
}
inline void ConnectionQualityInfo::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:livekit.ConnectionQualityInfo.score)
}

// -------------------------------------------------------------------

// ConnectionQualityUpdate

// repeated .livekit.ConnectionQualityInfo updates = 1;
inline int ConnectionQualityUpdate::_internal_updates_size() const {
  return _impl_.updates_.size();
}
inline int ConnectionQualityUpdate::updates_size() const {
  return _internal_updates_size();
}
inline void ConnectionQualityUpdate::clear_updates() {
  _impl_.updates_.Clear();
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ConnectionQualityUpdate.updates)
  return _impl_.updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >*
ConnectionQualityUpdate::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ConnectionQualityUpdate.updates)
  return &_impl_.updates_;
}
inline const ::livekit::ConnectionQualityInfo& ConnectionQualityUpdate::_internal_updates(int index) const {
  return _impl_.updates_.Get(index);
}
inline const ::livekit::ConnectionQualityInfo& ConnectionQualityUpdate::updates(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ConnectionQualityUpdate.updates)
  return _internal_updates(index);
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::_internal_add_updates() {
  return _impl_.updates_.Add();
}
inline ::livekit::ConnectionQualityInfo* ConnectionQualityUpdate::add_updates() {
  ::livekit::ConnectionQualityInfo* _add = _internal_add_updates();
  // @@protoc_insertion_point(field_add:livekit.ConnectionQualityUpdate.updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ConnectionQualityInfo >&
ConnectionQualityUpdate::updates() const {
  // @@protoc_insertion_point(field_list:livekit.ConnectionQualityUpdate.updates)
  return _impl_.updates_;
}

// -------------------------------------------------------------------

// StreamStateInfo

// string participant_sid = 1;
inline void StreamStateInfo::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& StreamStateInfo::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStateInfo::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.participant_sid)
}
inline std::string* StreamStateInfo::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.participant_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void StreamStateInfo::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamStateInfo::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void StreamStateInfo::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.participant_sid)
}

// string track_sid = 2;
inline void StreamStateInfo::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& StreamStateInfo::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStateInfo::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.track_sid)
}
inline std::string* StreamStateInfo::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateInfo.track_sid)
  return _s;
}
inline const std::string& StreamStateInfo::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void StreamStateInfo::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamStateInfo::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamStateInfo::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.StreamStateInfo.track_sid)
  return _impl_.track_sid_.Release();
}
inline void StreamStateInfo::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.StreamStateInfo.track_sid)
}

// .livekit.StreamState state = 3;
inline void StreamStateInfo::clear_state() {
  _impl_.state_ = 0;
}
inline ::livekit::StreamState StreamStateInfo::_internal_state() const {
  return static_cast< ::livekit::StreamState >(_impl_.state_);
}
inline ::livekit::StreamState StreamStateInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateInfo.state)
  return _internal_state();
}
inline void StreamStateInfo::_internal_set_state(::livekit::StreamState value) {
  
  _impl_.state_ = value;
}
inline void StreamStateInfo::set_state(::livekit::StreamState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.StreamStateInfo.state)
}

// -------------------------------------------------------------------

// StreamStateUpdate

// repeated .livekit.StreamStateInfo stream_states = 1;
inline int StreamStateUpdate::_internal_stream_states_size() const {
  return _impl_.stream_states_.size();
}
inline int StreamStateUpdate::stream_states_size() const {
  return _internal_stream_states_size();
}
inline void StreamStateUpdate::clear_stream_states() {
  _impl_.stream_states_.Clear();
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::mutable_stream_states(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.StreamStateUpdate.stream_states)
  return _impl_.stream_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >*
StreamStateUpdate::mutable_stream_states() {
  // @@protoc_insertion_point(field_mutable_list:livekit.StreamStateUpdate.stream_states)
  return &_impl_.stream_states_;
}
inline const ::livekit::StreamStateInfo& StreamStateUpdate::_internal_stream_states(int index) const {
  return _impl_.stream_states_.Get(index);
}
inline const ::livekit::StreamStateInfo& StreamStateUpdate::stream_states(int index) const {
  // @@protoc_insertion_point(field_get:livekit.StreamStateUpdate.stream_states)
  return _internal_stream_states(index);
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::_internal_add_stream_states() {
  return _impl_.stream_states_.Add();
}
inline ::livekit::StreamStateInfo* StreamStateUpdate::add_stream_states() {
  ::livekit::StreamStateInfo* _add = _internal_add_stream_states();
  // @@protoc_insertion_point(field_add:livekit.StreamStateUpdate.stream_states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::StreamStateInfo >&
StreamStateUpdate::stream_states() const {
  // @@protoc_insertion_point(field_list:livekit.StreamStateUpdate.stream_states)
  return _impl_.stream_states_;
}

// -------------------------------------------------------------------

// SubscribedQuality

// .livekit.VideoQuality quality = 1;
inline void SubscribedQuality::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::livekit::VideoQuality SubscribedQuality::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(_impl_.quality_);
}
inline ::livekit::VideoQuality SubscribedQuality::quality() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.quality)
  return _internal_quality();
}
inline void SubscribedQuality::_internal_set_quality(::livekit::VideoQuality value) {
  
  _impl_.quality_ = value;
}
inline void SubscribedQuality::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.quality)
}

// bool enabled = 2;
inline void SubscribedQuality::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool SubscribedQuality::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool SubscribedQuality::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQuality.enabled)
  return _internal_enabled();
}
inline void SubscribedQuality::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void SubscribedQuality::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.SubscribedQuality.enabled)
}

// -------------------------------------------------------------------

// SubscribedCodec

// string codec = 1;
inline void SubscribedCodec::clear_codec() {
  _impl_.codec_.ClearToEmpty();
}
inline const std::string& SubscribedCodec::codec() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedCodec.codec)
  return _internal_codec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribedCodec::set_codec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.codec_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscribedCodec.codec)
}
inline std::string* SubscribedCodec::mutable_codec() {
  std::string* _s = _internal_mutable_codec();
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedCodec.codec)
  return _s;
}
inline const std::string& SubscribedCodec::_internal_codec() const {
  return _impl_.codec_.Get();
}
inline void SubscribedCodec::_internal_set_codec(const std::string& value) {
  
  _impl_.codec_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribedCodec::_internal_mutable_codec() {
  
  return _impl_.codec_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribedCodec::release_codec() {
  // @@protoc_insertion_point(field_release:livekit.SubscribedCodec.codec)
  return _impl_.codec_.Release();
}
inline void SubscribedCodec::set_allocated_codec(std::string* codec) {
  if (codec != nullptr) {
    
  } else {
    
  }
  _impl_.codec_.SetAllocated(codec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.codec_.IsDefault()) {
    _impl_.codec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscribedCodec.codec)
}

// repeated .livekit.SubscribedQuality qualities = 2;
inline int SubscribedCodec::_internal_qualities_size() const {
  return _impl_.qualities_.size();
}
inline int SubscribedCodec::qualities_size() const {
  return _internal_qualities_size();
}
inline void SubscribedCodec::clear_qualities() {
  _impl_.qualities_.Clear();
}
inline ::livekit::SubscribedQuality* SubscribedCodec::mutable_qualities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedCodec.qualities)
  return _impl_.qualities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
SubscribedCodec::mutable_qualities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedCodec.qualities)
  return &_impl_.qualities_;
}
inline const ::livekit::SubscribedQuality& SubscribedCodec::_internal_qualities(int index) const {
  return _impl_.qualities_.Get(index);
}
inline const ::livekit::SubscribedQuality& SubscribedCodec::qualities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedCodec.qualities)
  return _internal_qualities(index);
}
inline ::livekit::SubscribedQuality* SubscribedCodec::_internal_add_qualities() {
  return _impl_.qualities_.Add();
}
inline ::livekit::SubscribedQuality* SubscribedCodec::add_qualities() {
  ::livekit::SubscribedQuality* _add = _internal_add_qualities();
  // @@protoc_insertion_point(field_add:livekit.SubscribedCodec.qualities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
SubscribedCodec::qualities() const {
  // @@protoc_insertion_point(field_list:livekit.SubscribedCodec.qualities)
  return _impl_.qualities_;
}

// -------------------------------------------------------------------

// SubscribedQualityUpdate

// string track_sid = 1;
inline void SubscribedQualityUpdate::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& SubscribedQualityUpdate::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribedQualityUpdate::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscribedQualityUpdate.track_sid)
}
inline std::string* SubscribedQualityUpdate::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.track_sid)
  return _s;
}
inline const std::string& SubscribedQualityUpdate::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void SubscribedQualityUpdate::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscribedQualityUpdate::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscribedQualityUpdate::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscribedQualityUpdate.track_sid)
  return _impl_.track_sid_.Release();
}
inline void SubscribedQualityUpdate::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscribedQualityUpdate.track_sid)
}

// repeated .livekit.SubscribedQuality subscribed_qualities = 2;
inline int SubscribedQualityUpdate::_internal_subscribed_qualities_size() const {
  return _impl_.subscribed_qualities_.size();
}
inline int SubscribedQualityUpdate::subscribed_qualities_size() const {
  return _internal_subscribed_qualities_size();
}
inline void SubscribedQualityUpdate::clear_subscribed_qualities() {
  _impl_.subscribed_qualities_.Clear();
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::mutable_subscribed_qualities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _impl_.subscribed_qualities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >*
SubscribedQualityUpdate::mutable_subscribed_qualities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return &_impl_.subscribed_qualities_;
}
inline const ::livekit::SubscribedQuality& SubscribedQualityUpdate::_internal_subscribed_qualities(int index) const {
  return _impl_.subscribed_qualities_.Get(index);
}
inline const ::livekit::SubscribedQuality& SubscribedQualityUpdate::subscribed_qualities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _internal_subscribed_qualities(index);
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::_internal_add_subscribed_qualities() {
  return _impl_.subscribed_qualities_.Add();
}
inline ::livekit::SubscribedQuality* SubscribedQualityUpdate::add_subscribed_qualities() {
  ::livekit::SubscribedQuality* _add = _internal_add_subscribed_qualities();
  // @@protoc_insertion_point(field_add:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedQuality >&
SubscribedQualityUpdate::subscribed_qualities() const {
  // @@protoc_insertion_point(field_list:livekit.SubscribedQualityUpdate.subscribed_qualities)
  return _impl_.subscribed_qualities_;
}

// repeated .livekit.SubscribedCodec subscribed_codecs = 3;
inline int SubscribedQualityUpdate::_internal_subscribed_codecs_size() const {
  return _impl_.subscribed_codecs_.size();
}
inline int SubscribedQualityUpdate::subscribed_codecs_size() const {
  return _internal_subscribed_codecs_size();
}
inline void SubscribedQualityUpdate::clear_subscribed_codecs() {
  _impl_.subscribed_codecs_.Clear();
}
inline ::livekit::SubscribedCodec* SubscribedQualityUpdate::mutable_subscribed_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _impl_.subscribed_codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedCodec >*
SubscribedQualityUpdate::mutable_subscribed_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return &_impl_.subscribed_codecs_;
}
inline const ::livekit::SubscribedCodec& SubscribedQualityUpdate::_internal_subscribed_codecs(int index) const {
  return _impl_.subscribed_codecs_.Get(index);
}
inline const ::livekit::SubscribedCodec& SubscribedQualityUpdate::subscribed_codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _internal_subscribed_codecs(index);
}
inline ::livekit::SubscribedCodec* SubscribedQualityUpdate::_internal_add_subscribed_codecs() {
  return _impl_.subscribed_codecs_.Add();
}
inline ::livekit::SubscribedCodec* SubscribedQualityUpdate::add_subscribed_codecs() {
  ::livekit::SubscribedCodec* _add = _internal_add_subscribed_codecs();
  // @@protoc_insertion_point(field_add:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SubscribedCodec >&
SubscribedQualityUpdate::subscribed_codecs() const {
  // @@protoc_insertion_point(field_list:livekit.SubscribedQualityUpdate.subscribed_codecs)
  return _impl_.subscribed_codecs_;
}

// -------------------------------------------------------------------

// TrackPermission

// string participant_sid = 1;
inline void TrackPermission::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& TrackPermission::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPermission::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_sid)
}
inline std::string* TrackPermission::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_sid)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void TrackPermission::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPermission::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPermission::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void TrackPermission::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_sid)
}

// bool all_tracks = 2;
inline void TrackPermission::clear_all_tracks() {
  _impl_.all_tracks_ = false;
}
inline bool TrackPermission::_internal_all_tracks() const {
  return _impl_.all_tracks_;
}
inline bool TrackPermission::all_tracks() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.all_tracks)
  return _internal_all_tracks();
}
inline void TrackPermission::_internal_set_all_tracks(bool value) {
  
  _impl_.all_tracks_ = value;
}
inline void TrackPermission::set_all_tracks(bool value) {
  _internal_set_all_tracks(value);
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.all_tracks)
}

// repeated string track_sids = 3;
inline int TrackPermission::_internal_track_sids_size() const {
  return _impl_.track_sids_.size();
}
inline int TrackPermission::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void TrackPermission::clear_track_sids() {
  _impl_.track_sids_.Clear();
}
inline std::string* TrackPermission::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.TrackPermission.track_sids)
  return _s;
}
inline const std::string& TrackPermission::_internal_track_sids(int index) const {
  return _impl_.track_sids_.Get(index);
}
inline const std::string& TrackPermission::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.track_sids)
  return _internal_track_sids(index);
}
inline std::string* TrackPermission::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.track_sids)
  return _impl_.track_sids_.Mutable(index);
}
inline void TrackPermission::set_track_sids(int index, const std::string& value) {
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, std::string&& value) {
  _impl_.track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::set_track_sids(int index, const char* value, size_t size) {
  _impl_.track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.TrackPermission.track_sids)
}
inline std::string* TrackPermission::_internal_add_track_sids() {
  return _impl_.track_sids_.Add();
}
inline void TrackPermission::add_track_sids(const std::string& value) {
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(std::string&& value) {
  _impl_.track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.TrackPermission.track_sids)
}
inline void TrackPermission::add_track_sids(const char* value, size_t size) {
  _impl_.track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.TrackPermission.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TrackPermission::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.TrackPermission.track_sids)
  return _impl_.track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TrackPermission::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackPermission.track_sids)
  return &_impl_.track_sids_;
}

// string participant_identity = 4;
inline void TrackPermission::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& TrackPermission::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.TrackPermission.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPermission::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackPermission.participant_identity)
}
inline std::string* TrackPermission::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.TrackPermission.participant_identity)
  return _s;
}
inline const std::string& TrackPermission::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackPermission::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPermission::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPermission::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.TrackPermission.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void TrackPermission::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackPermission.participant_identity)
}

// -------------------------------------------------------------------

// SubscriptionPermission

// bool all_participants = 1;
inline void SubscriptionPermission::clear_all_participants() {
  _impl_.all_participants_ = false;
}
inline bool SubscriptionPermission::_internal_all_participants() const {
  return _impl_.all_participants_;
}
inline bool SubscriptionPermission::all_participants() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.all_participants)
  return _internal_all_participants();
}
inline void SubscriptionPermission::_internal_set_all_participants(bool value) {
  
  _impl_.all_participants_ = value;
}
inline void SubscriptionPermission::set_all_participants(bool value) {
  _internal_set_all_participants(value);
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermission.all_participants)
}

// repeated .livekit.TrackPermission track_permissions = 2;
inline int SubscriptionPermission::_internal_track_permissions_size() const {
  return _impl_.track_permissions_.size();
}
inline int SubscriptionPermission::track_permissions_size() const {
  return _internal_track_permissions_size();
}
inline void SubscriptionPermission::clear_track_permissions() {
  _impl_.track_permissions_.Clear();
}
inline ::livekit::TrackPermission* SubscriptionPermission::mutable_track_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermission.track_permissions)
  return _impl_.track_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >*
SubscriptionPermission::mutable_track_permissions() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SubscriptionPermission.track_permissions)
  return &_impl_.track_permissions_;
}
inline const ::livekit::TrackPermission& SubscriptionPermission::_internal_track_permissions(int index) const {
  return _impl_.track_permissions_.Get(index);
}
inline const ::livekit::TrackPermission& SubscriptionPermission::track_permissions(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermission.track_permissions)
  return _internal_track_permissions(index);
}
inline ::livekit::TrackPermission* SubscriptionPermission::_internal_add_track_permissions() {
  return _impl_.track_permissions_.Add();
}
inline ::livekit::TrackPermission* SubscriptionPermission::add_track_permissions() {
  ::livekit::TrackPermission* _add = _internal_add_track_permissions();
  // @@protoc_insertion_point(field_add:livekit.SubscriptionPermission.track_permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPermission >&
SubscriptionPermission::track_permissions() const {
  // @@protoc_insertion_point(field_list:livekit.SubscriptionPermission.track_permissions)
  return _impl_.track_permissions_;
}

// -------------------------------------------------------------------

// SubscriptionPermissionUpdate

// string participant_sid = 1;
inline void SubscriptionPermissionUpdate::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& SubscriptionPermissionUpdate::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionPermissionUpdate::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.participant_sid)
}
inline std::string* SubscriptionPermissionUpdate::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void SubscriptionPermissionUpdate::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.participant_sid)
}

// string track_sid = 2;
inline void SubscriptionPermissionUpdate::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& SubscriptionPermissionUpdate::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionPermissionUpdate::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.track_sid)
}
inline std::string* SubscriptionPermissionUpdate::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionPermissionUpdate.track_sid)
  return _s;
}
inline const std::string& SubscriptionPermissionUpdate::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void SubscriptionPermissionUpdate::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionPermissionUpdate::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscriptionPermissionUpdate.track_sid)
  return _impl_.track_sid_.Release();
}
inline void SubscriptionPermissionUpdate::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionPermissionUpdate.track_sid)
}

// bool allowed = 3;
inline void SubscriptionPermissionUpdate::clear_allowed() {
  _impl_.allowed_ = false;
}
inline bool SubscriptionPermissionUpdate::_internal_allowed() const {
  return _impl_.allowed_;
}
inline bool SubscriptionPermissionUpdate::allowed() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionPermissionUpdate.allowed)
  return _internal_allowed();
}
inline void SubscriptionPermissionUpdate::_internal_set_allowed(bool value) {
  
  _impl_.allowed_ = value;
}
inline void SubscriptionPermissionUpdate::set_allowed(bool value) {
  _internal_set_allowed(value);
  // @@protoc_insertion_point(field_set:livekit.SubscriptionPermissionUpdate.allowed)
}

// -------------------------------------------------------------------

// SyncState

// .livekit.SessionDescription answer = 1;
inline bool SyncState::_internal_has_answer() const {
  return this != internal_default_instance() && _impl_.answer_ != nullptr;
}
inline bool SyncState::has_answer() const {
  return _internal_has_answer();
}
inline void SyncState::clear_answer() {
  if (GetArenaForAllocation() == nullptr && _impl_.answer_ != nullptr) {
    delete _impl_.answer_;
  }
  _impl_.answer_ = nullptr;
}
inline const ::livekit::SessionDescription& SyncState::_internal_answer() const {
  const ::livekit::SessionDescription* p = _impl_.answer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::SessionDescription&>(
      ::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SyncState::answer() const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.answer)
  return _internal_answer();
}
inline void SyncState::unsafe_arena_set_allocated_answer(
    ::livekit::SessionDescription* answer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.answer_);
  }
  _impl_.answer_ = answer;
  if (answer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.answer)
}
inline ::livekit::SessionDescription* SyncState::release_answer() {
  
  ::livekit::SessionDescription* temp = _impl_.answer_;
  _impl_.answer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::SessionDescription* SyncState::unsafe_arena_release_answer() {
  // @@protoc_insertion_point(field_release:livekit.SyncState.answer)
  
  ::livekit::SessionDescription* temp = _impl_.answer_;
  _impl_.answer_ = nullptr;
  return temp;
}
inline ::livekit::SessionDescription* SyncState::_internal_mutable_answer() {
  
  if (_impl_.answer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::SessionDescription>(GetArenaForAllocation());
    _impl_.answer_ = p;
  }
  return _impl_.answer_;
}
inline ::livekit::SessionDescription* SyncState::mutable_answer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.answer)
  return _msg;
}
inline void SyncState::set_allocated_answer(::livekit::SessionDescription* answer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.answer_;
  }
  if (answer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(answer);
    if (message_arena != submessage_arena) {
      answer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, answer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.answer_ = answer;
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.answer)
}

// .livekit.UpdateSubscription subscription = 2;
inline bool SyncState::_internal_has_subscription() const {
  return this != internal_default_instance() && _impl_.subscription_ != nullptr;
}
inline bool SyncState::has_subscription() const {
  return _internal_has_subscription();
}
inline void SyncState::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && _impl_.subscription_ != nullptr) {
    delete _impl_.subscription_;
  }
  _impl_.subscription_ = nullptr;
}
inline const ::livekit::UpdateSubscription& SyncState::_internal_subscription() const {
  const ::livekit::UpdateSubscription* p = _impl_.subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::UpdateSubscription&>(
      ::livekit::_UpdateSubscription_default_instance_);
}
inline const ::livekit::UpdateSubscription& SyncState::subscription() const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.subscription)
  return _internal_subscription();
}
inline void SyncState::unsafe_arena_set_allocated_subscription(
    ::livekit::UpdateSubscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscription_);
  }
  _impl_.subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.subscription)
}
inline ::livekit::UpdateSubscription* SyncState::release_subscription() {
  
  ::livekit::UpdateSubscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::UpdateSubscription* SyncState::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:livekit.SyncState.subscription)
  
  ::livekit::UpdateSubscription* temp = _impl_.subscription_;
  _impl_.subscription_ = nullptr;
  return temp;
}
inline ::livekit::UpdateSubscription* SyncState::_internal_mutable_subscription() {
  
  if (_impl_.subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::UpdateSubscription>(GetArenaForAllocation());
    _impl_.subscription_ = p;
  }
  return _impl_.subscription_;
}
inline ::livekit::UpdateSubscription* SyncState::mutable_subscription() {
  ::livekit::UpdateSubscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.subscription)
  return _msg;
}
inline void SyncState::set_allocated_subscription(::livekit::UpdateSubscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.subscription)
}

// repeated .livekit.TrackPublishedResponse publish_tracks = 3;
inline int SyncState::_internal_publish_tracks_size() const {
  return _impl_.publish_tracks_.size();
}
inline int SyncState::publish_tracks_size() const {
  return _internal_publish_tracks_size();
}
inline void SyncState::clear_publish_tracks() {
  _impl_.publish_tracks_.Clear();
}
inline ::livekit::TrackPublishedResponse* SyncState::mutable_publish_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.publish_tracks)
  return _impl_.publish_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >*
SyncState::mutable_publish_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.publish_tracks)
  return &_impl_.publish_tracks_;
}
inline const ::livekit::TrackPublishedResponse& SyncState::_internal_publish_tracks(int index) const {
  return _impl_.publish_tracks_.Get(index);
}
inline const ::livekit::TrackPublishedResponse& SyncState::publish_tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.publish_tracks)
  return _internal_publish_tracks(index);
}
inline ::livekit::TrackPublishedResponse* SyncState::_internal_add_publish_tracks() {
  return _impl_.publish_tracks_.Add();
}
inline ::livekit::TrackPublishedResponse* SyncState::add_publish_tracks() {
  ::livekit::TrackPublishedResponse* _add = _internal_add_publish_tracks();
  // @@protoc_insertion_point(field_add:livekit.SyncState.publish_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackPublishedResponse >&
SyncState::publish_tracks() const {
  // @@protoc_insertion_point(field_list:livekit.SyncState.publish_tracks)
  return _impl_.publish_tracks_;
}

// repeated .livekit.DataChannelInfo data_channels = 4;
inline int SyncState::_internal_data_channels_size() const {
  return _impl_.data_channels_.size();
}
inline int SyncState::data_channels_size() const {
  return _internal_data_channels_size();
}
inline void SyncState::clear_data_channels() {
  _impl_.data_channels_.Clear();
}
inline ::livekit::DataChannelInfo* SyncState::mutable_data_channels(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.data_channels)
  return _impl_.data_channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >*
SyncState::mutable_data_channels() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.data_channels)
  return &_impl_.data_channels_;
}
inline const ::livekit::DataChannelInfo& SyncState::_internal_data_channels(int index) const {
  return _impl_.data_channels_.Get(index);
}
inline const ::livekit::DataChannelInfo& SyncState::data_channels(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.data_channels)
  return _internal_data_channels(index);
}
inline ::livekit::DataChannelInfo* SyncState::_internal_add_data_channels() {
  return _impl_.data_channels_.Add();
}
inline ::livekit::DataChannelInfo* SyncState::add_data_channels() {
  ::livekit::DataChannelInfo* _add = _internal_add_data_channels();
  // @@protoc_insertion_point(field_add:livekit.SyncState.data_channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::DataChannelInfo >&
SyncState::data_channels() const {
  // @@protoc_insertion_point(field_list:livekit.SyncState.data_channels)
  return _impl_.data_channels_;
}

// .livekit.SessionDescription offer = 5;
inline bool SyncState::_internal_has_offer() const {
  return this != internal_default_instance() && _impl_.offer_ != nullptr;
}
inline bool SyncState::has_offer() const {
  return _internal_has_offer();
}
inline void SyncState::clear_offer() {
  if (GetArenaForAllocation() == nullptr && _impl_.offer_ != nullptr) {
    delete _impl_.offer_;
  }
  _impl_.offer_ = nullptr;
}
inline const ::livekit::SessionDescription& SyncState::_internal_offer() const {
  const ::livekit::SessionDescription* p = _impl_.offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::SessionDescription&>(
      ::livekit::_SessionDescription_default_instance_);
}
inline const ::livekit::SessionDescription& SyncState::offer() const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.offer)
  return _internal_offer();
}
inline void SyncState::unsafe_arena_set_allocated_offer(
    ::livekit::SessionDescription* offer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offer_);
  }
  _impl_.offer_ = offer;
  if (offer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SyncState.offer)
}
inline ::livekit::SessionDescription* SyncState::release_offer() {
  
  ::livekit::SessionDescription* temp = _impl_.offer_;
  _impl_.offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::SessionDescription* SyncState::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_release:livekit.SyncState.offer)
  
  ::livekit::SessionDescription* temp = _impl_.offer_;
  _impl_.offer_ = nullptr;
  return temp;
}
inline ::livekit::SessionDescription* SyncState::_internal_mutable_offer() {
  
  if (_impl_.offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::SessionDescription>(GetArenaForAllocation());
    _impl_.offer_ = p;
  }
  return _impl_.offer_;
}
inline ::livekit::SessionDescription* SyncState::mutable_offer() {
  ::livekit::SessionDescription* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.offer)
  return _msg;
}
inline void SyncState::set_allocated_offer(::livekit::SessionDescription* offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offer_;
  }
  if (offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offer);
    if (message_arena != submessage_arena) {
      offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offer_ = offer;
  // @@protoc_insertion_point(field_set_allocated:livekit.SyncState.offer)
}

// repeated string track_sids_disabled = 6;
inline int SyncState::_internal_track_sids_disabled_size() const {
  return _impl_.track_sids_disabled_.size();
}
inline int SyncState::track_sids_disabled_size() const {
  return _internal_track_sids_disabled_size();
}
inline void SyncState::clear_track_sids_disabled() {
  _impl_.track_sids_disabled_.Clear();
}
inline std::string* SyncState::add_track_sids_disabled() {
  std::string* _s = _internal_add_track_sids_disabled();
  // @@protoc_insertion_point(field_add_mutable:livekit.SyncState.track_sids_disabled)
  return _s;
}
inline const std::string& SyncState::_internal_track_sids_disabled(int index) const {
  return _impl_.track_sids_disabled_.Get(index);
}
inline const std::string& SyncState::track_sids_disabled(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SyncState.track_sids_disabled)
  return _internal_track_sids_disabled(index);
}
inline std::string* SyncState::mutable_track_sids_disabled(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SyncState.track_sids_disabled)
  return _impl_.track_sids_disabled_.Mutable(index);
}
inline void SyncState::set_track_sids_disabled(int index, const std::string& value) {
  _impl_.track_sids_disabled_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::set_track_sids_disabled(int index, std::string&& value) {
  _impl_.track_sids_disabled_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::set_track_sids_disabled(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_disabled_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::set_track_sids_disabled(int index, const char* value, size_t size) {
  _impl_.track_sids_disabled_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.SyncState.track_sids_disabled)
}
inline std::string* SyncState::_internal_add_track_sids_disabled() {
  return _impl_.track_sids_disabled_.Add();
}
inline void SyncState::add_track_sids_disabled(const std::string& value) {
  _impl_.track_sids_disabled_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::add_track_sids_disabled(std::string&& value) {
  _impl_.track_sids_disabled_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::add_track_sids_disabled(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_disabled_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.SyncState.track_sids_disabled)
}
inline void SyncState::add_track_sids_disabled(const char* value, size_t size) {
  _impl_.track_sids_disabled_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.SyncState.track_sids_disabled)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SyncState::track_sids_disabled() const {
  // @@protoc_insertion_point(field_list:livekit.SyncState.track_sids_disabled)
  return _impl_.track_sids_disabled_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SyncState::mutable_track_sids_disabled() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SyncState.track_sids_disabled)
  return &_impl_.track_sids_disabled_;
}

// -------------------------------------------------------------------

// DataChannelInfo

// string label = 1;
inline void DataChannelInfo::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& DataChannelInfo::label() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataChannelInfo::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.label)
}
inline std::string* DataChannelInfo::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:livekit.DataChannelInfo.label)
  return _s;
}
inline const std::string& DataChannelInfo::_internal_label() const {
  return _impl_.label_.Get();
}
inline void DataChannelInfo::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* DataChannelInfo::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* DataChannelInfo::release_label() {
  // @@protoc_insertion_point(field_release:livekit.DataChannelInfo.label)
  return _impl_.label_.Release();
}
inline void DataChannelInfo::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataChannelInfo.label)
}

// uint32 id = 2;
inline void DataChannelInfo::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t DataChannelInfo::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t DataChannelInfo::id() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.id)
  return _internal_id();
}
inline void DataChannelInfo::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void DataChannelInfo::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.id)
}

// .livekit.SignalTarget target = 3;
inline void DataChannelInfo::clear_target() {
  _impl_.target_ = 0;
}
inline ::livekit::SignalTarget DataChannelInfo::_internal_target() const {
  return static_cast< ::livekit::SignalTarget >(_impl_.target_);
}
inline ::livekit::SignalTarget DataChannelInfo::target() const {
  // @@protoc_insertion_point(field_get:livekit.DataChannelInfo.target)
  return _internal_target();
}
inline void DataChannelInfo::_internal_set_target(::livekit::SignalTarget value) {
  
  _impl_.target_ = value;
}
inline void DataChannelInfo::set_target(::livekit::SignalTarget value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:livekit.DataChannelInfo.target)
}

// -------------------------------------------------------------------

// SimulateScenario

// int32 speaker_update = 1;
inline bool SimulateScenario::_internal_has_speaker_update() const {
  return scenario_case() == kSpeakerUpdate;
}
inline bool SimulateScenario::has_speaker_update() const {
  return _internal_has_speaker_update();
}
inline void SimulateScenario::set_has_speaker_update() {
  _impl_._oneof_case_[0] = kSpeakerUpdate;
}
inline void SimulateScenario::clear_speaker_update() {
  if (_internal_has_speaker_update()) {
    _impl_.scenario_.speaker_update_ = 0;
    clear_has_scenario();
  }
}
inline int32_t SimulateScenario::_internal_speaker_update() const {
  if (_internal_has_speaker_update()) {
    return _impl_.scenario_.speaker_update_;
  }
  return 0;
}
inline void SimulateScenario::_internal_set_speaker_update(int32_t value) {
  if (!_internal_has_speaker_update()) {
    clear_scenario();
    set_has_speaker_update();
  }
  _impl_.scenario_.speaker_update_ = value;
}
inline int32_t SimulateScenario::speaker_update() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.speaker_update)
  return _internal_speaker_update();
}
inline void SimulateScenario::set_speaker_update(int32_t value) {
  _internal_set_speaker_update(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.speaker_update)
}

// bool node_failure = 2;
inline bool SimulateScenario::_internal_has_node_failure() const {
  return scenario_case() == kNodeFailure;
}
inline bool SimulateScenario::has_node_failure() const {
  return _internal_has_node_failure();
}
inline void SimulateScenario::set_has_node_failure() {
  _impl_._oneof_case_[0] = kNodeFailure;
}
inline void SimulateScenario::clear_node_failure() {
  if (_internal_has_node_failure()) {
    _impl_.scenario_.node_failure_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_node_failure() const {
  if (_internal_has_node_failure()) {
    return _impl_.scenario_.node_failure_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_node_failure(bool value) {
  if (!_internal_has_node_failure()) {
    clear_scenario();
    set_has_node_failure();
  }
  _impl_.scenario_.node_failure_ = value;
}
inline bool SimulateScenario::node_failure() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.node_failure)
  return _internal_node_failure();
}
inline void SimulateScenario::set_node_failure(bool value) {
  _internal_set_node_failure(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.node_failure)
}

// bool migration = 3;
inline bool SimulateScenario::_internal_has_migration() const {
  return scenario_case() == kMigration;
}
inline bool SimulateScenario::has_migration() const {
  return _internal_has_migration();
}
inline void SimulateScenario::set_has_migration() {
  _impl_._oneof_case_[0] = kMigration;
}
inline void SimulateScenario::clear_migration() {
  if (_internal_has_migration()) {
    _impl_.scenario_.migration_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_migration() const {
  if (_internal_has_migration()) {
    return _impl_.scenario_.migration_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_migration(bool value) {
  if (!_internal_has_migration()) {
    clear_scenario();
    set_has_migration();
  }
  _impl_.scenario_.migration_ = value;
}
inline bool SimulateScenario::migration() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.migration)
  return _internal_migration();
}
inline void SimulateScenario::set_migration(bool value) {
  _internal_set_migration(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.migration)
}

// bool server_leave = 4;
inline bool SimulateScenario::_internal_has_server_leave() const {
  return scenario_case() == kServerLeave;
}
inline bool SimulateScenario::has_server_leave() const {
  return _internal_has_server_leave();
}
inline void SimulateScenario::set_has_server_leave() {
  _impl_._oneof_case_[0] = kServerLeave;
}
inline void SimulateScenario::clear_server_leave() {
  if (_internal_has_server_leave()) {
    _impl_.scenario_.server_leave_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_server_leave() const {
  if (_internal_has_server_leave()) {
    return _impl_.scenario_.server_leave_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_server_leave(bool value) {
  if (!_internal_has_server_leave()) {
    clear_scenario();
    set_has_server_leave();
  }
  _impl_.scenario_.server_leave_ = value;
}
inline bool SimulateScenario::server_leave() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.server_leave)
  return _internal_server_leave();
}
inline void SimulateScenario::set_server_leave(bool value) {
  _internal_set_server_leave(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.server_leave)
}

// .livekit.CandidateProtocol switch_candidate_protocol = 5;
inline bool SimulateScenario::_internal_has_switch_candidate_protocol() const {
  return scenario_case() == kSwitchCandidateProtocol;
}
inline bool SimulateScenario::has_switch_candidate_protocol() const {
  return _internal_has_switch_candidate_protocol();
}
inline void SimulateScenario::set_has_switch_candidate_protocol() {
  _impl_._oneof_case_[0] = kSwitchCandidateProtocol;
}
inline void SimulateScenario::clear_switch_candidate_protocol() {
  if (_internal_has_switch_candidate_protocol()) {
    _impl_.scenario_.switch_candidate_protocol_ = 0;
    clear_has_scenario();
  }
}
inline ::livekit::CandidateProtocol SimulateScenario::_internal_switch_candidate_protocol() const {
  if (_internal_has_switch_candidate_protocol()) {
    return static_cast< ::livekit::CandidateProtocol >(_impl_.scenario_.switch_candidate_protocol_);
  }
  return static_cast< ::livekit::CandidateProtocol >(0);
}
inline ::livekit::CandidateProtocol SimulateScenario::switch_candidate_protocol() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.switch_candidate_protocol)
  return _internal_switch_candidate_protocol();
}
inline void SimulateScenario::_internal_set_switch_candidate_protocol(::livekit::CandidateProtocol value) {
  if (!_internal_has_switch_candidate_protocol()) {
    clear_scenario();
    set_has_switch_candidate_protocol();
  }
  _impl_.scenario_.switch_candidate_protocol_ = value;
}
inline void SimulateScenario::set_switch_candidate_protocol(::livekit::CandidateProtocol value) {
  _internal_set_switch_candidate_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.switch_candidate_protocol)
}

// int64 subscriber_bandwidth = 6;
inline bool SimulateScenario::_internal_has_subscriber_bandwidth() const {
  return scenario_case() == kSubscriberBandwidth;
}
inline bool SimulateScenario::has_subscriber_bandwidth() const {
  return _internal_has_subscriber_bandwidth();
}
inline void SimulateScenario::set_has_subscriber_bandwidth() {
  _impl_._oneof_case_[0] = kSubscriberBandwidth;
}
inline void SimulateScenario::clear_subscriber_bandwidth() {
  if (_internal_has_subscriber_bandwidth()) {
    _impl_.scenario_.subscriber_bandwidth_ = int64_t{0};
    clear_has_scenario();
  }
}
inline int64_t SimulateScenario::_internal_subscriber_bandwidth() const {
  if (_internal_has_subscriber_bandwidth()) {
    return _impl_.scenario_.subscriber_bandwidth_;
  }
  return int64_t{0};
}
inline void SimulateScenario::_internal_set_subscriber_bandwidth(int64_t value) {
  if (!_internal_has_subscriber_bandwidth()) {
    clear_scenario();
    set_has_subscriber_bandwidth();
  }
  _impl_.scenario_.subscriber_bandwidth_ = value;
}
inline int64_t SimulateScenario::subscriber_bandwidth() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.subscriber_bandwidth)
  return _internal_subscriber_bandwidth();
}
inline void SimulateScenario::set_subscriber_bandwidth(int64_t value) {
  _internal_set_subscriber_bandwidth(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.subscriber_bandwidth)
}

// bool disconnect_signal_on_resume = 7;
inline bool SimulateScenario::_internal_has_disconnect_signal_on_resume() const {
  return scenario_case() == kDisconnectSignalOnResume;
}
inline bool SimulateScenario::has_disconnect_signal_on_resume() const {
  return _internal_has_disconnect_signal_on_resume();
}
inline void SimulateScenario::set_has_disconnect_signal_on_resume() {
  _impl_._oneof_case_[0] = kDisconnectSignalOnResume;
}
inline void SimulateScenario::clear_disconnect_signal_on_resume() {
  if (_internal_has_disconnect_signal_on_resume()) {
    _impl_.scenario_.disconnect_signal_on_resume_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_disconnect_signal_on_resume() const {
  if (_internal_has_disconnect_signal_on_resume()) {
    return _impl_.scenario_.disconnect_signal_on_resume_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_disconnect_signal_on_resume(bool value) {
  if (!_internal_has_disconnect_signal_on_resume()) {
    clear_scenario();
    set_has_disconnect_signal_on_resume();
  }
  _impl_.scenario_.disconnect_signal_on_resume_ = value;
}
inline bool SimulateScenario::disconnect_signal_on_resume() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.disconnect_signal_on_resume)
  return _internal_disconnect_signal_on_resume();
}
inline void SimulateScenario::set_disconnect_signal_on_resume(bool value) {
  _internal_set_disconnect_signal_on_resume(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.disconnect_signal_on_resume)
}

// bool disconnect_signal_on_resume_no_messages = 8;
inline bool SimulateScenario::_internal_has_disconnect_signal_on_resume_no_messages() const {
  return scenario_case() == kDisconnectSignalOnResumeNoMessages;
}
inline bool SimulateScenario::has_disconnect_signal_on_resume_no_messages() const {
  return _internal_has_disconnect_signal_on_resume_no_messages();
}
inline void SimulateScenario::set_has_disconnect_signal_on_resume_no_messages() {
  _impl_._oneof_case_[0] = kDisconnectSignalOnResumeNoMessages;
}
inline void SimulateScenario::clear_disconnect_signal_on_resume_no_messages() {
  if (_internal_has_disconnect_signal_on_resume_no_messages()) {
    _impl_.scenario_.disconnect_signal_on_resume_no_messages_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_disconnect_signal_on_resume_no_messages() const {
  if (_internal_has_disconnect_signal_on_resume_no_messages()) {
    return _impl_.scenario_.disconnect_signal_on_resume_no_messages_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_disconnect_signal_on_resume_no_messages(bool value) {
  if (!_internal_has_disconnect_signal_on_resume_no_messages()) {
    clear_scenario();
    set_has_disconnect_signal_on_resume_no_messages();
  }
  _impl_.scenario_.disconnect_signal_on_resume_no_messages_ = value;
}
inline bool SimulateScenario::disconnect_signal_on_resume_no_messages() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.disconnect_signal_on_resume_no_messages)
  return _internal_disconnect_signal_on_resume_no_messages();
}
inline void SimulateScenario::set_disconnect_signal_on_resume_no_messages(bool value) {
  _internal_set_disconnect_signal_on_resume_no_messages(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.disconnect_signal_on_resume_no_messages)
}

// bool leave_request_full_reconnect = 9;
inline bool SimulateScenario::_internal_has_leave_request_full_reconnect() const {
  return scenario_case() == kLeaveRequestFullReconnect;
}
inline bool SimulateScenario::has_leave_request_full_reconnect() const {
  return _internal_has_leave_request_full_reconnect();
}
inline void SimulateScenario::set_has_leave_request_full_reconnect() {
  _impl_._oneof_case_[0] = kLeaveRequestFullReconnect;
}
inline void SimulateScenario::clear_leave_request_full_reconnect() {
  if (_internal_has_leave_request_full_reconnect()) {
    _impl_.scenario_.leave_request_full_reconnect_ = false;
    clear_has_scenario();
  }
}
inline bool SimulateScenario::_internal_leave_request_full_reconnect() const {
  if (_internal_has_leave_request_full_reconnect()) {
    return _impl_.scenario_.leave_request_full_reconnect_;
  }
  return false;
}
inline void SimulateScenario::_internal_set_leave_request_full_reconnect(bool value) {
  if (!_internal_has_leave_request_full_reconnect()) {
    clear_scenario();
    set_has_leave_request_full_reconnect();
  }
  _impl_.scenario_.leave_request_full_reconnect_ = value;
}
inline bool SimulateScenario::leave_request_full_reconnect() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateScenario.leave_request_full_reconnect)
  return _internal_leave_request_full_reconnect();
}
inline void SimulateScenario::set_leave_request_full_reconnect(bool value) {
  _internal_set_leave_request_full_reconnect(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateScenario.leave_request_full_reconnect)
}

inline bool SimulateScenario::has_scenario() const {
  return scenario_case() != SCENARIO_NOT_SET;
}
inline void SimulateScenario::clear_has_scenario() {
  _impl_._oneof_case_[0] = SCENARIO_NOT_SET;
}
inline SimulateScenario::ScenarioCase SimulateScenario::scenario_case() const {
  return SimulateScenario::ScenarioCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ping

// int64 timestamp = 1;
inline void Ping::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Ping::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Ping.timestamp)
  return _internal_timestamp();
}
inline void Ping::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Ping::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.Ping.timestamp)
}

// int64 rtt = 2;
inline void Ping::clear_rtt() {
  _impl_.rtt_ = int64_t{0};
}
inline int64_t Ping::_internal_rtt() const {
  return _impl_.rtt_;
}
inline int64_t Ping::rtt() const {
  // @@protoc_insertion_point(field_get:livekit.Ping.rtt)
  return _internal_rtt();
}
inline void Ping::_internal_set_rtt(int64_t value) {
  
  _impl_.rtt_ = value;
}
inline void Ping::set_rtt(int64_t value) {
  _internal_set_rtt(value);
  // @@protoc_insertion_point(field_set:livekit.Ping.rtt)
}

// -------------------------------------------------------------------

// Pong

// int64 last_ping_timestamp = 1;
inline void Pong::clear_last_ping_timestamp() {
  _impl_.last_ping_timestamp_ = int64_t{0};
}
inline int64_t Pong::_internal_last_ping_timestamp() const {
  return _impl_.last_ping_timestamp_;
}
inline int64_t Pong::last_ping_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Pong.last_ping_timestamp)
  return _internal_last_ping_timestamp();
}
inline void Pong::_internal_set_last_ping_timestamp(int64_t value) {
  
  _impl_.last_ping_timestamp_ = value;
}
inline void Pong::set_last_ping_timestamp(int64_t value) {
  _internal_set_last_ping_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.Pong.last_ping_timestamp)
}

// int64 timestamp = 2;
inline void Pong::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t Pong::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Pong::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.Pong.timestamp)
  return _internal_timestamp();
}
inline void Pong::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Pong::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.Pong.timestamp)
}

// -------------------------------------------------------------------

// RegionSettings

// repeated .livekit.RegionInfo regions = 1;
inline int RegionSettings::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int RegionSettings::regions_size() const {
  return _internal_regions_size();
}
inline void RegionSettings::clear_regions() {
  _impl_.regions_.Clear();
}
inline ::livekit::RegionInfo* RegionSettings::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RegionSettings.regions)
  return _impl_.regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RegionInfo >*
RegionSettings::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RegionSettings.regions)
  return &_impl_.regions_;
}
inline const ::livekit::RegionInfo& RegionSettings::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline const ::livekit::RegionInfo& RegionSettings::regions(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RegionSettings.regions)
  return _internal_regions(index);
}
inline ::livekit::RegionInfo* RegionSettings::_internal_add_regions() {
  return _impl_.regions_.Add();
}
inline ::livekit::RegionInfo* RegionSettings::add_regions() {
  ::livekit::RegionInfo* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:livekit.RegionSettings.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RegionInfo >&
RegionSettings::regions() const {
  // @@protoc_insertion_point(field_list:livekit.RegionSettings.regions)
  return _impl_.regions_;
}

// -------------------------------------------------------------------

// RegionInfo

// string region = 1;
inline void RegionInfo::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& RegionInfo::region() const {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.region)
}
inline std::string* RegionInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.RegionInfo.region)
  return _s;
}
inline const std::string& RegionInfo::_internal_region() const {
  return _impl_.region_.Get();
}
inline void RegionInfo::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionInfo::release_region() {
  // @@protoc_insertion_point(field_release:livekit.RegionInfo.region)
  return _impl_.region_.Release();
}
inline void RegionInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegionInfo.region)
}

// string url = 2;
inline void RegionInfo::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& RegionInfo::url() const {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.url)
}
inline std::string* RegionInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.RegionInfo.url)
  return _s;
}
inline const std::string& RegionInfo::_internal_url() const {
  return _impl_.url_.Get();
}
inline void RegionInfo::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionInfo::release_url() {
  // @@protoc_insertion_point(field_release:livekit.RegionInfo.url)
  return _impl_.url_.Release();
}
inline void RegionInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegionInfo.url)
}

// int64 distance = 3;
inline void RegionInfo::clear_distance() {
  _impl_.distance_ = int64_t{0};
}
inline int64_t RegionInfo::_internal_distance() const {
  return _impl_.distance_;
}
inline int64_t RegionInfo::distance() const {
  // @@protoc_insertion_point(field_get:livekit.RegionInfo.distance)
  return _internal_distance();
}
inline void RegionInfo::_internal_set_distance(int64_t value) {
  
  _impl_.distance_ = value;
}
inline void RegionInfo::set_distance(int64_t value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:livekit.RegionInfo.distance)
}

// -------------------------------------------------------------------

// SubscriptionResponse

// string track_sid = 1;
inline void SubscriptionResponse::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& SubscriptionResponse::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionResponse.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionResponse::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SubscriptionResponse.track_sid)
}
inline std::string* SubscriptionResponse::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SubscriptionResponse.track_sid)
  return _s;
}
inline const std::string& SubscriptionResponse::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void SubscriptionResponse::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionResponse::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionResponse::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.SubscriptionResponse.track_sid)
  return _impl_.track_sid_.Release();
}
inline void SubscriptionResponse::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SubscriptionResponse.track_sid)
}

// .livekit.SubscriptionError err = 2;
inline void SubscriptionResponse::clear_err() {
  _impl_.err_ = 0;
}
inline ::livekit::SubscriptionError SubscriptionResponse::_internal_err() const {
  return static_cast< ::livekit::SubscriptionError >(_impl_.err_);
}
inline ::livekit::SubscriptionError SubscriptionResponse::err() const {
  // @@protoc_insertion_point(field_get:livekit.SubscriptionResponse.err)
  return _internal_err();
}
inline void SubscriptionResponse::_internal_set_err(::livekit::SubscriptionError value) {
  
  _impl_.err_ = value;
}
inline void SubscriptionResponse::set_err(::livekit::SubscriptionError value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:livekit.SubscriptionResponse.err)
}

// -------------------------------------------------------------------

// RequestResponse

// uint32 request_id = 1;
inline void RequestResponse::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t RequestResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t RequestResponse::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.request_id)
  return _internal_request_id();
}
inline void RequestResponse::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void RequestResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.request_id)
}

// .livekit.RequestResponse.Reason reason = 2;
inline void RequestResponse::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::livekit::RequestResponse_Reason RequestResponse::_internal_reason() const {
  return static_cast< ::livekit::RequestResponse_Reason >(_impl_.reason_);
}
inline ::livekit::RequestResponse_Reason RequestResponse::reason() const {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.reason)
  return _internal_reason();
}
inline void RequestResponse::_internal_set_reason(::livekit::RequestResponse_Reason value) {
  
  _impl_.reason_ = value;
}
inline void RequestResponse::set_reason(::livekit::RequestResponse_Reason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.reason)
}

// string message = 3;
inline void RequestResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RequestResponse::message() const {
  // @@protoc_insertion_point(field_get:livekit.RequestResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RequestResponse.message)
}
inline std::string* RequestResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.RequestResponse.message)
  return _s;
}
inline const std::string& RequestResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RequestResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestResponse::release_message() {
  // @@protoc_insertion_point(field_release:livekit.RequestResponse.message)
  return _impl_.message_.Release();
}
inline void RequestResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RequestResponse.message)
}

// -------------------------------------------------------------------

// TrackSubscribed

// string track_sid = 1;
inline void TrackSubscribed::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& TrackSubscribed::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackSubscribed.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackSubscribed::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackSubscribed.track_sid)
}
inline std::string* TrackSubscribed::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackSubscribed.track_sid)
  return _s;
}
inline const std::string& TrackSubscribed::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackSubscribed::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackSubscribed::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackSubscribed::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackSubscribed.track_sid)
  return _impl_.track_sid_.Release();
}
inline void TrackSubscribed::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackSubscribed.track_sid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::LeaveRequest_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::LeaveRequest_Action>() {
  return ::livekit::LeaveRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::livekit::RequestResponse_Reason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::RequestResponse_Reason>() {
  return ::livekit::RequestResponse_Reason_descriptor();
}
template <> struct is_proto_enum< ::livekit::SignalTarget> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::SignalTarget>() {
  return ::livekit::SignalTarget_descriptor();
}
template <> struct is_proto_enum< ::livekit::StreamState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::StreamState>() {
  return ::livekit::StreamState_descriptor();
}
template <> struct is_proto_enum< ::livekit::CandidateProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::CandidateProtocol>() {
  return ::livekit::CandidateProtocol_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5frtc_2eproto
