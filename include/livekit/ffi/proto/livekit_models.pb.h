// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "livekit_metrics.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5fmodels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fmodels_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5fmodels_2eproto;
namespace livekit {
class ActiveSpeakerUpdate;
struct ActiveSpeakerUpdateDefaultTypeInternal;
extern ActiveSpeakerUpdateDefaultTypeInternal _ActiveSpeakerUpdate_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ClientConfiguration;
struct ClientConfigurationDefaultTypeInternal;
extern ClientConfigurationDefaultTypeInternal _ClientConfiguration_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class Codec;
struct CodecDefaultTypeInternal;
extern CodecDefaultTypeInternal _Codec_default_instance_;
class DataPacket;
struct DataPacketDefaultTypeInternal;
extern DataPacketDefaultTypeInternal _DataPacket_default_instance_;
class DataStream;
struct DataStreamDefaultTypeInternal;
extern DataStreamDefaultTypeInternal _DataStream_default_instance_;
class DataStream_ByteHeader;
struct DataStream_ByteHeaderDefaultTypeInternal;
extern DataStream_ByteHeaderDefaultTypeInternal _DataStream_ByteHeader_default_instance_;
class DataStream_Chunk;
struct DataStream_ChunkDefaultTypeInternal;
extern DataStream_ChunkDefaultTypeInternal _DataStream_Chunk_default_instance_;
class DataStream_Header;
struct DataStream_HeaderDefaultTypeInternal;
extern DataStream_HeaderDefaultTypeInternal _DataStream_Header_default_instance_;
class DataStream_Header_AttributesEntry_DoNotUse;
struct DataStream_Header_AttributesEntry_DoNotUseDefaultTypeInternal;
extern DataStream_Header_AttributesEntry_DoNotUseDefaultTypeInternal _DataStream_Header_AttributesEntry_DoNotUse_default_instance_;
class DataStream_TextHeader;
struct DataStream_TextHeaderDefaultTypeInternal;
extern DataStream_TextHeaderDefaultTypeInternal _DataStream_TextHeader_default_instance_;
class DataStream_Trailer;
struct DataStream_TrailerDefaultTypeInternal;
extern DataStream_TrailerDefaultTypeInternal _DataStream_Trailer_default_instance_;
class DataStream_Trailer_AttributesEntry_DoNotUse;
struct DataStream_Trailer_AttributesEntry_DoNotUseDefaultTypeInternal;
extern DataStream_Trailer_AttributesEntry_DoNotUseDefaultTypeInternal _DataStream_Trailer_AttributesEntry_DoNotUse_default_instance_;
class DisabledCodecs;
struct DisabledCodecsDefaultTypeInternal;
extern DisabledCodecsDefaultTypeInternal _DisabledCodecs_default_instance_;
class Encryption;
struct EncryptionDefaultTypeInternal;
extern EncryptionDefaultTypeInternal _Encryption_default_instance_;
class Pagination;
struct PaginationDefaultTypeInternal;
extern PaginationDefaultTypeInternal _Pagination_default_instance_;
class ParticipantInfo;
struct ParticipantInfoDefaultTypeInternal;
extern ParticipantInfoDefaultTypeInternal _ParticipantInfo_default_instance_;
class ParticipantInfo_AttributesEntry_DoNotUse;
struct ParticipantInfo_AttributesEntry_DoNotUseDefaultTypeInternal;
extern ParticipantInfo_AttributesEntry_DoNotUseDefaultTypeInternal _ParticipantInfo_AttributesEntry_DoNotUse_default_instance_;
class ParticipantPermission;
struct ParticipantPermissionDefaultTypeInternal;
extern ParticipantPermissionDefaultTypeInternal _ParticipantPermission_default_instance_;
class ParticipantTracks;
struct ParticipantTracksDefaultTypeInternal;
extern ParticipantTracksDefaultTypeInternal _ParticipantTracks_default_instance_;
class PlayoutDelay;
struct PlayoutDelayDefaultTypeInternal;
extern PlayoutDelayDefaultTypeInternal _PlayoutDelay_default_instance_;
class RTCPSenderReportState;
struct RTCPSenderReportStateDefaultTypeInternal;
extern RTCPSenderReportStateDefaultTypeInternal _RTCPSenderReportState_default_instance_;
class RTPDrift;
struct RTPDriftDefaultTypeInternal;
extern RTPDriftDefaultTypeInternal _RTPDrift_default_instance_;
class RTPForwarderState;
struct RTPForwarderStateDefaultTypeInternal;
extern RTPForwarderStateDefaultTypeInternal _RTPForwarderState_default_instance_;
class RTPMungerState;
struct RTPMungerStateDefaultTypeInternal;
extern RTPMungerStateDefaultTypeInternal _RTPMungerState_default_instance_;
class RTPStats;
struct RTPStatsDefaultTypeInternal;
extern RTPStatsDefaultTypeInternal _RTPStats_default_instance_;
class RTPStats_GapHistogramEntry_DoNotUse;
struct RTPStats_GapHistogramEntry_DoNotUseDefaultTypeInternal;
extern RTPStats_GapHistogramEntry_DoNotUseDefaultTypeInternal _RTPStats_GapHistogramEntry_DoNotUse_default_instance_;
class Room;
struct RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
class RpcAck;
struct RpcAckDefaultTypeInternal;
extern RpcAckDefaultTypeInternal _RpcAck_default_instance_;
class RpcError;
struct RpcErrorDefaultTypeInternal;
extern RpcErrorDefaultTypeInternal _RpcError_default_instance_;
class RpcRequest;
struct RpcRequestDefaultTypeInternal;
extern RpcRequestDefaultTypeInternal _RpcRequest_default_instance_;
class RpcResponse;
struct RpcResponseDefaultTypeInternal;
extern RpcResponseDefaultTypeInternal _RpcResponse_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class SimulcastCodecInfo;
struct SimulcastCodecInfoDefaultTypeInternal;
extern SimulcastCodecInfoDefaultTypeInternal _SimulcastCodecInfo_default_instance_;
class SipDTMF;
struct SipDTMFDefaultTypeInternal;
extern SipDTMFDefaultTypeInternal _SipDTMF_default_instance_;
class SpeakerInfo;
struct SpeakerInfoDefaultTypeInternal;
extern SpeakerInfoDefaultTypeInternal _SpeakerInfo_default_instance_;
class TimedVersion;
struct TimedVersionDefaultTypeInternal;
extern TimedVersionDefaultTypeInternal _TimedVersion_default_instance_;
class TrackInfo;
struct TrackInfoDefaultTypeInternal;
extern TrackInfoDefaultTypeInternal _TrackInfo_default_instance_;
class Transcription;
struct TranscriptionDefaultTypeInternal;
extern TranscriptionDefaultTypeInternal _Transcription_default_instance_;
class TranscriptionSegment;
struct TranscriptionSegmentDefaultTypeInternal;
extern TranscriptionSegmentDefaultTypeInternal _TranscriptionSegment_default_instance_;
class UserPacket;
struct UserPacketDefaultTypeInternal;
extern UserPacketDefaultTypeInternal _UserPacket_default_instance_;
class VP8MungerState;
struct VP8MungerStateDefaultTypeInternal;
extern VP8MungerStateDefaultTypeInternal _VP8MungerState_default_instance_;
class VideoConfiguration;
struct VideoConfigurationDefaultTypeInternal;
extern VideoConfigurationDefaultTypeInternal _VideoConfiguration_default_instance_;
class VideoLayer;
struct VideoLayerDefaultTypeInternal;
extern VideoLayerDefaultTypeInternal _VideoLayer_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::ActiveSpeakerUpdate* Arena::CreateMaybeMessage<::livekit::ActiveSpeakerUpdate>(Arena*);
template<> ::livekit::ChatMessage* Arena::CreateMaybeMessage<::livekit::ChatMessage>(Arena*);
template<> ::livekit::ClientConfiguration* Arena::CreateMaybeMessage<::livekit::ClientConfiguration>(Arena*);
template<> ::livekit::ClientInfo* Arena::CreateMaybeMessage<::livekit::ClientInfo>(Arena*);
template<> ::livekit::Codec* Arena::CreateMaybeMessage<::livekit::Codec>(Arena*);
template<> ::livekit::DataPacket* Arena::CreateMaybeMessage<::livekit::DataPacket>(Arena*);
template<> ::livekit::DataStream* Arena::CreateMaybeMessage<::livekit::DataStream>(Arena*);
template<> ::livekit::DataStream_ByteHeader* Arena::CreateMaybeMessage<::livekit::DataStream_ByteHeader>(Arena*);
template<> ::livekit::DataStream_Chunk* Arena::CreateMaybeMessage<::livekit::DataStream_Chunk>(Arena*);
template<> ::livekit::DataStream_Header* Arena::CreateMaybeMessage<::livekit::DataStream_Header>(Arena*);
template<> ::livekit::DataStream_Header_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::DataStream_Header_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::DataStream_TextHeader* Arena::CreateMaybeMessage<::livekit::DataStream_TextHeader>(Arena*);
template<> ::livekit::DataStream_Trailer* Arena::CreateMaybeMessage<::livekit::DataStream_Trailer>(Arena*);
template<> ::livekit::DataStream_Trailer_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::DataStream_Trailer_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::DisabledCodecs* Arena::CreateMaybeMessage<::livekit::DisabledCodecs>(Arena*);
template<> ::livekit::Encryption* Arena::CreateMaybeMessage<::livekit::Encryption>(Arena*);
template<> ::livekit::Pagination* Arena::CreateMaybeMessage<::livekit::Pagination>(Arena*);
template<> ::livekit::ParticipantInfo* Arena::CreateMaybeMessage<::livekit::ParticipantInfo>(Arena*);
template<> ::livekit::ParticipantInfo_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::ParticipantInfo_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::ParticipantPermission* Arena::CreateMaybeMessage<::livekit::ParticipantPermission>(Arena*);
template<> ::livekit::ParticipantTracks* Arena::CreateMaybeMessage<::livekit::ParticipantTracks>(Arena*);
template<> ::livekit::PlayoutDelay* Arena::CreateMaybeMessage<::livekit::PlayoutDelay>(Arena*);
template<> ::livekit::RTCPSenderReportState* Arena::CreateMaybeMessage<::livekit::RTCPSenderReportState>(Arena*);
template<> ::livekit::RTPDrift* Arena::CreateMaybeMessage<::livekit::RTPDrift>(Arena*);
template<> ::livekit::RTPForwarderState* Arena::CreateMaybeMessage<::livekit::RTPForwarderState>(Arena*);
template<> ::livekit::RTPMungerState* Arena::CreateMaybeMessage<::livekit::RTPMungerState>(Arena*);
template<> ::livekit::RTPStats* Arena::CreateMaybeMessage<::livekit::RTPStats>(Arena*);
template<> ::livekit::RTPStats_GapHistogramEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::RTPStats_GapHistogramEntry_DoNotUse>(Arena*);
template<> ::livekit::Room* Arena::CreateMaybeMessage<::livekit::Room>(Arena*);
template<> ::livekit::RpcAck* Arena::CreateMaybeMessage<::livekit::RpcAck>(Arena*);
template<> ::livekit::RpcError* Arena::CreateMaybeMessage<::livekit::RpcError>(Arena*);
template<> ::livekit::RpcRequest* Arena::CreateMaybeMessage<::livekit::RpcRequest>(Arena*);
template<> ::livekit::RpcResponse* Arena::CreateMaybeMessage<::livekit::RpcResponse>(Arena*);
template<> ::livekit::ServerInfo* Arena::CreateMaybeMessage<::livekit::ServerInfo>(Arena*);
template<> ::livekit::SimulcastCodecInfo* Arena::CreateMaybeMessage<::livekit::SimulcastCodecInfo>(Arena*);
template<> ::livekit::SipDTMF* Arena::CreateMaybeMessage<::livekit::SipDTMF>(Arena*);
template<> ::livekit::SpeakerInfo* Arena::CreateMaybeMessage<::livekit::SpeakerInfo>(Arena*);
template<> ::livekit::TimedVersion* Arena::CreateMaybeMessage<::livekit::TimedVersion>(Arena*);
template<> ::livekit::TrackInfo* Arena::CreateMaybeMessage<::livekit::TrackInfo>(Arena*);
template<> ::livekit::Transcription* Arena::CreateMaybeMessage<::livekit::Transcription>(Arena*);
template<> ::livekit::TranscriptionSegment* Arena::CreateMaybeMessage<::livekit::TranscriptionSegment>(Arena*);
template<> ::livekit::UserPacket* Arena::CreateMaybeMessage<::livekit::UserPacket>(Arena*);
template<> ::livekit::VP8MungerState* Arena::CreateMaybeMessage<::livekit::VP8MungerState>(Arena*);
template<> ::livekit::VideoConfiguration* Arena::CreateMaybeMessage<::livekit::VideoConfiguration>(Arena*);
template<> ::livekit::VideoLayer* Arena::CreateMaybeMessage<::livekit::VideoLayer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum ParticipantInfo_State : int {
  ParticipantInfo_State_JOINING = 0,
  ParticipantInfo_State_JOINED = 1,
  ParticipantInfo_State_ACTIVE = 2,
  ParticipantInfo_State_DISCONNECTED = 3,
  ParticipantInfo_State_ParticipantInfo_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantInfo_State_ParticipantInfo_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantInfo_State_IsValid(int value);
constexpr ParticipantInfo_State ParticipantInfo_State_State_MIN = ParticipantInfo_State_JOINING;
constexpr ParticipantInfo_State ParticipantInfo_State_State_MAX = ParticipantInfo_State_DISCONNECTED;
constexpr int ParticipantInfo_State_State_ARRAYSIZE = ParticipantInfo_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantInfo_State_descriptor();
template<typename T>
inline const std::string& ParticipantInfo_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantInfo_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantInfo_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantInfo_State_descriptor(), enum_t_value);
}
inline bool ParticipantInfo_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantInfo_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantInfo_State>(
    ParticipantInfo_State_descriptor(), name, value);
}
enum ParticipantInfo_Kind : int {
  ParticipantInfo_Kind_STANDARD = 0,
  ParticipantInfo_Kind_INGRESS = 1,
  ParticipantInfo_Kind_EGRESS = 2,
  ParticipantInfo_Kind_SIP = 3,
  ParticipantInfo_Kind_AGENT = 4,
  ParticipantInfo_Kind_ParticipantInfo_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParticipantInfo_Kind_ParticipantInfo_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParticipantInfo_Kind_IsValid(int value);
constexpr ParticipantInfo_Kind ParticipantInfo_Kind_Kind_MIN = ParticipantInfo_Kind_STANDARD;
constexpr ParticipantInfo_Kind ParticipantInfo_Kind_Kind_MAX = ParticipantInfo_Kind_AGENT;
constexpr int ParticipantInfo_Kind_Kind_ARRAYSIZE = ParticipantInfo_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParticipantInfo_Kind_descriptor();
template<typename T>
inline const std::string& ParticipantInfo_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParticipantInfo_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParticipantInfo_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParticipantInfo_Kind_descriptor(), enum_t_value);
}
inline bool ParticipantInfo_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParticipantInfo_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParticipantInfo_Kind>(
    ParticipantInfo_Kind_descriptor(), name, value);
}
enum Encryption_Type : int {
  Encryption_Type_NONE = 0,
  Encryption_Type_GCM = 1,
  Encryption_Type_CUSTOM = 2,
  Encryption_Type_Encryption_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Encryption_Type_Encryption_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Encryption_Type_IsValid(int value);
constexpr Encryption_Type Encryption_Type_Type_MIN = Encryption_Type_NONE;
constexpr Encryption_Type Encryption_Type_Type_MAX = Encryption_Type_CUSTOM;
constexpr int Encryption_Type_Type_ARRAYSIZE = Encryption_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Encryption_Type_descriptor();
template<typename T>
inline const std::string& Encryption_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Encryption_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Encryption_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Encryption_Type_descriptor(), enum_t_value);
}
inline bool Encryption_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Encryption_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Encryption_Type>(
    Encryption_Type_descriptor(), name, value);
}
enum DataPacket_Kind : int {
  DataPacket_Kind_RELIABLE = 0,
  DataPacket_Kind_LOSSY = 1,
  DataPacket_Kind_DataPacket_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataPacket_Kind_DataPacket_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataPacket_Kind_IsValid(int value);
constexpr DataPacket_Kind DataPacket_Kind_Kind_MIN = DataPacket_Kind_RELIABLE;
constexpr DataPacket_Kind DataPacket_Kind_Kind_MAX = DataPacket_Kind_LOSSY;
constexpr int DataPacket_Kind_Kind_ARRAYSIZE = DataPacket_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataPacket_Kind_descriptor();
template<typename T>
inline const std::string& DataPacket_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataPacket_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataPacket_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataPacket_Kind_descriptor(), enum_t_value);
}
inline bool DataPacket_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataPacket_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataPacket_Kind>(
    DataPacket_Kind_descriptor(), name, value);
}
enum ServerInfo_Edition : int {
  ServerInfo_Edition_Standard = 0,
  ServerInfo_Edition_Cloud = 1,
  ServerInfo_Edition_ServerInfo_Edition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServerInfo_Edition_ServerInfo_Edition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServerInfo_Edition_IsValid(int value);
constexpr ServerInfo_Edition ServerInfo_Edition_Edition_MIN = ServerInfo_Edition_Standard;
constexpr ServerInfo_Edition ServerInfo_Edition_Edition_MAX = ServerInfo_Edition_Cloud;
constexpr int ServerInfo_Edition_Edition_ARRAYSIZE = ServerInfo_Edition_Edition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerInfo_Edition_descriptor();
template<typename T>
inline const std::string& ServerInfo_Edition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerInfo_Edition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerInfo_Edition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerInfo_Edition_descriptor(), enum_t_value);
}
inline bool ServerInfo_Edition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerInfo_Edition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerInfo_Edition>(
    ServerInfo_Edition_descriptor(), name, value);
}
enum ClientInfo_SDK : int {
  ClientInfo_SDK_UNKNOWN = 0,
  ClientInfo_SDK_JS = 1,
  ClientInfo_SDK_SWIFT = 2,
  ClientInfo_SDK_ANDROID = 3,
  ClientInfo_SDK_FLUTTER = 4,
  ClientInfo_SDK_GO = 5,
  ClientInfo_SDK_UNITY = 6,
  ClientInfo_SDK_REACT_NATIVE = 7,
  ClientInfo_SDK_RUST = 8,
  ClientInfo_SDK_PYTHON = 9,
  ClientInfo_SDK_CPP = 10,
  ClientInfo_SDK_UNITY_WEB = 11,
  ClientInfo_SDK_NODE = 12,
  ClientInfo_SDK_ClientInfo_SDK_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientInfo_SDK_ClientInfo_SDK_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientInfo_SDK_IsValid(int value);
constexpr ClientInfo_SDK ClientInfo_SDK_SDK_MIN = ClientInfo_SDK_UNKNOWN;
constexpr ClientInfo_SDK ClientInfo_SDK_SDK_MAX = ClientInfo_SDK_NODE;
constexpr int ClientInfo_SDK_SDK_ARRAYSIZE = ClientInfo_SDK_SDK_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientInfo_SDK_descriptor();
template<typename T>
inline const std::string& ClientInfo_SDK_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientInfo_SDK>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientInfo_SDK_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientInfo_SDK_descriptor(), enum_t_value);
}
inline bool ClientInfo_SDK_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientInfo_SDK* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientInfo_SDK>(
    ClientInfo_SDK_descriptor(), name, value);
}
enum DataStream_OperationType : int {
  DataStream_OperationType_CREATE = 0,
  DataStream_OperationType_UPDATE = 1,
  DataStream_OperationType_DELETE = 2,
  DataStream_OperationType_REACTION = 3,
  DataStream_OperationType_DataStream_OperationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataStream_OperationType_DataStream_OperationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataStream_OperationType_IsValid(int value);
constexpr DataStream_OperationType DataStream_OperationType_OperationType_MIN = DataStream_OperationType_CREATE;
constexpr DataStream_OperationType DataStream_OperationType_OperationType_MAX = DataStream_OperationType_REACTION;
constexpr int DataStream_OperationType_OperationType_ARRAYSIZE = DataStream_OperationType_OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataStream_OperationType_descriptor();
template<typename T>
inline const std::string& DataStream_OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataStream_OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataStream_OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataStream_OperationType_descriptor(), enum_t_value);
}
inline bool DataStream_OperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataStream_OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataStream_OperationType>(
    DataStream_OperationType_descriptor(), name, value);
}
enum AudioCodec : int {
  DEFAULT_AC = 0,
  OPUS = 1,
  AAC = 2,
  AudioCodec_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioCodec_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioCodec_IsValid(int value);
constexpr AudioCodec AudioCodec_MIN = DEFAULT_AC;
constexpr AudioCodec AudioCodec_MAX = AAC;
constexpr int AudioCodec_ARRAYSIZE = AudioCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioCodec_descriptor();
template<typename T>
inline const std::string& AudioCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioCodec_descriptor(), enum_t_value);
}
inline bool AudioCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioCodec>(
    AudioCodec_descriptor(), name, value);
}
enum VideoCodec : int {
  DEFAULT_VC = 0,
  H264_BASELINE = 1,
  H264_MAIN = 2,
  H264_HIGH = 3,
  VP8 = 4,
  VideoCodec_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoCodec_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoCodec_IsValid(int value);
constexpr VideoCodec VideoCodec_MIN = DEFAULT_VC;
constexpr VideoCodec VideoCodec_MAX = VP8;
constexpr int VideoCodec_ARRAYSIZE = VideoCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoCodec_descriptor();
template<typename T>
inline const std::string& VideoCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoCodec_descriptor(), enum_t_value);
}
inline bool VideoCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoCodec>(
    VideoCodec_descriptor(), name, value);
}
enum ImageCodec : int {
  IC_DEFAULT = 0,
  IC_JPEG = 1,
  ImageCodec_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImageCodec_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImageCodec_IsValid(int value);
constexpr ImageCodec ImageCodec_MIN = IC_DEFAULT;
constexpr ImageCodec ImageCodec_MAX = IC_JPEG;
constexpr int ImageCodec_ARRAYSIZE = ImageCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageCodec_descriptor();
template<typename T>
inline const std::string& ImageCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageCodec_descriptor(), enum_t_value);
}
inline bool ImageCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageCodec>(
    ImageCodec_descriptor(), name, value);
}
enum BackupCodecPolicy : int {
  REGRESSION = 0,
  SIMULCAST = 1,
  BackupCodecPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BackupCodecPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BackupCodecPolicy_IsValid(int value);
constexpr BackupCodecPolicy BackupCodecPolicy_MIN = REGRESSION;
constexpr BackupCodecPolicy BackupCodecPolicy_MAX = SIMULCAST;
constexpr int BackupCodecPolicy_ARRAYSIZE = BackupCodecPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupCodecPolicy_descriptor();
template<typename T>
inline const std::string& BackupCodecPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BackupCodecPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BackupCodecPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BackupCodecPolicy_descriptor(), enum_t_value);
}
inline bool BackupCodecPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BackupCodecPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BackupCodecPolicy>(
    BackupCodecPolicy_descriptor(), name, value);
}
enum TrackType : int {
  AUDIO = 0,
  VIDEO = 1,
  DATA = 2,
  TrackType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackType_IsValid(int value);
constexpr TrackType TrackType_MIN = AUDIO;
constexpr TrackType TrackType_MAX = DATA;
constexpr int TrackType_ARRAYSIZE = TrackType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackType_descriptor();
template<typename T>
inline const std::string& TrackType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackType_descriptor(), enum_t_value);
}
inline bool TrackType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackType>(
    TrackType_descriptor(), name, value);
}
enum TrackSource : int {
  UNKNOWN = 0,
  CAMERA = 1,
  MICROPHONE = 2,
  SCREEN_SHARE = 3,
  SCREEN_SHARE_AUDIO = 4,
  TrackSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackSource_IsValid(int value);
constexpr TrackSource TrackSource_MIN = UNKNOWN;
constexpr TrackSource TrackSource_MAX = SCREEN_SHARE_AUDIO;
constexpr int TrackSource_ARRAYSIZE = TrackSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSource_descriptor();
template<typename T>
inline const std::string& TrackSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackSource_descriptor(), enum_t_value);
}
inline bool TrackSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackSource>(
    TrackSource_descriptor(), name, value);
}
enum VideoQuality : int {
  LOW = 0,
  MEDIUM = 1,
  HIGH = 2,
  OFF = 3,
  VideoQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VideoQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VideoQuality_IsValid(int value);
constexpr VideoQuality VideoQuality_MIN = LOW;
constexpr VideoQuality VideoQuality_MAX = OFF;
constexpr int VideoQuality_ARRAYSIZE = VideoQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoQuality_descriptor();
template<typename T>
inline const std::string& VideoQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoQuality_descriptor(), enum_t_value);
}
inline bool VideoQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoQuality>(
    VideoQuality_descriptor(), name, value);
}
enum ConnectionQuality : int {
  POOR = 0,
  GOOD = 1,
  EXCELLENT = 2,
  LOST = 3,
  ConnectionQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConnectionQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConnectionQuality_IsValid(int value);
constexpr ConnectionQuality ConnectionQuality_MIN = POOR;
constexpr ConnectionQuality ConnectionQuality_MAX = LOST;
constexpr int ConnectionQuality_ARRAYSIZE = ConnectionQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionQuality_descriptor();
template<typename T>
inline const std::string& ConnectionQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionQuality_descriptor(), enum_t_value);
}
inline bool ConnectionQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionQuality>(
    ConnectionQuality_descriptor(), name, value);
}
enum ClientConfigSetting : int {
  UNSET = 0,
  DISABLED = 1,
  ENABLED = 2,
  ClientConfigSetting_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientConfigSetting_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientConfigSetting_IsValid(int value);
constexpr ClientConfigSetting ClientConfigSetting_MIN = UNSET;
constexpr ClientConfigSetting ClientConfigSetting_MAX = ENABLED;
constexpr int ClientConfigSetting_ARRAYSIZE = ClientConfigSetting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientConfigSetting_descriptor();
template<typename T>
inline const std::string& ClientConfigSetting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientConfigSetting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientConfigSetting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientConfigSetting_descriptor(), enum_t_value);
}
inline bool ClientConfigSetting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientConfigSetting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientConfigSetting>(
    ClientConfigSetting_descriptor(), name, value);
}
enum DisconnectReason : int {
  UNKNOWN_REASON = 0,
  CLIENT_INITIATED = 1,
  DUPLICATE_IDENTITY = 2,
  SERVER_SHUTDOWN = 3,
  PARTICIPANT_REMOVED = 4,
  ROOM_DELETED = 5,
  STATE_MISMATCH = 6,
  JOIN_FAILURE = 7,
  MIGRATION = 8,
  SIGNAL_CLOSE = 9,
  ROOM_CLOSED = 10,
  USER_UNAVAILABLE = 11,
  USER_REJECTED = 12,
  SIP_TRUNK_FAILURE = 13,
  DisconnectReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DisconnectReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DisconnectReason_IsValid(int value);
constexpr DisconnectReason DisconnectReason_MIN = UNKNOWN_REASON;
constexpr DisconnectReason DisconnectReason_MAX = SIP_TRUNK_FAILURE;
constexpr int DisconnectReason_ARRAYSIZE = DisconnectReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DisconnectReason_descriptor();
template<typename T>
inline const std::string& DisconnectReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DisconnectReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DisconnectReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DisconnectReason_descriptor(), enum_t_value);
}
inline bool DisconnectReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisconnectReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DisconnectReason>(
    DisconnectReason_descriptor(), name, value);
}
enum ReconnectReason : int {
  RR_UNKNOWN = 0,
  RR_SIGNAL_DISCONNECTED = 1,
  RR_PUBLISHER_FAILED = 2,
  RR_SUBSCRIBER_FAILED = 3,
  RR_SWITCH_CANDIDATE = 4,
  ReconnectReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReconnectReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReconnectReason_IsValid(int value);
constexpr ReconnectReason ReconnectReason_MIN = RR_UNKNOWN;
constexpr ReconnectReason ReconnectReason_MAX = RR_SWITCH_CANDIDATE;
constexpr int ReconnectReason_ARRAYSIZE = ReconnectReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReconnectReason_descriptor();
template<typename T>
inline const std::string& ReconnectReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReconnectReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReconnectReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReconnectReason_descriptor(), enum_t_value);
}
inline bool ReconnectReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReconnectReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReconnectReason>(
    ReconnectReason_descriptor(), name, value);
}
enum SubscriptionError : int {
  SE_UNKNOWN = 0,
  SE_CODEC_UNSUPPORTED = 1,
  SE_TRACK_NOTFOUND = 2,
  SubscriptionError_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscriptionError_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscriptionError_IsValid(int value);
constexpr SubscriptionError SubscriptionError_MIN = SE_UNKNOWN;
constexpr SubscriptionError SubscriptionError_MAX = SE_TRACK_NOTFOUND;
constexpr int SubscriptionError_ARRAYSIZE = SubscriptionError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscriptionError_descriptor();
template<typename T>
inline const std::string& SubscriptionError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscriptionError_descriptor(), enum_t_value);
}
inline bool SubscriptionError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscriptionError>(
    SubscriptionError_descriptor(), name, value);
}
enum AudioTrackFeature : int {
  TF_STEREO = 0,
  TF_NO_DTX = 1,
  TF_AUTO_GAIN_CONTROL = 2,
  TF_ECHO_CANCELLATION = 3,
  TF_NOISE_SUPPRESSION = 4,
  TF_ENHANCED_NOISE_CANCELLATION = 5,
  AudioTrackFeature_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AudioTrackFeature_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AudioTrackFeature_IsValid(int value);
constexpr AudioTrackFeature AudioTrackFeature_MIN = TF_STEREO;
constexpr AudioTrackFeature AudioTrackFeature_MAX = TF_ENHANCED_NOISE_CANCELLATION;
constexpr int AudioTrackFeature_ARRAYSIZE = AudioTrackFeature_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioTrackFeature_descriptor();
template<typename T>
inline const std::string& AudioTrackFeature_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioTrackFeature>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioTrackFeature_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioTrackFeature_descriptor(), enum_t_value);
}
inline bool AudioTrackFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioTrackFeature* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioTrackFeature>(
    AudioTrackFeature_descriptor(), name, value);
}
// ===================================================================

class Pagination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Pagination) */ {
 public:
  inline Pagination() : Pagination(nullptr) {}
  ~Pagination() override;
  explicit PROTOBUF_CONSTEXPR Pagination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pagination(const Pagination& from);
  Pagination(Pagination&& from) noexcept
    : Pagination() {
    *this = ::std::move(from);
  }

  inline Pagination& operator=(const Pagination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pagination& operator=(Pagination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pagination& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pagination* internal_default_instance() {
    return reinterpret_cast<const Pagination*>(
               &_Pagination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Pagination& a, Pagination& b) {
    a.Swap(&b);
  }
  inline void Swap(Pagination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pagination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pagination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pagination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pagination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pagination& from) {
    Pagination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pagination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Pagination";
  }
  protected:
  explicit Pagination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAfterIdFieldNumber = 1,
    kLimitFieldNumber = 2,
  };
  // string after_id = 1;
  void clear_after_id();
  const std::string& after_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_after_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_after_id();
  PROTOBUF_NODISCARD std::string* release_after_id();
  void set_allocated_after_id(std::string* after_id);
  private:
  const std::string& _internal_after_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_after_id(const std::string& value);
  std::string* _internal_mutable_after_id();
  public:

  // int32 limit = 2;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Pagination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr after_id_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Room) */ {
 public:
  inline Room() : Room(nullptr) {}
  ~Room() override;
  explicit PROTOBUF_CONSTEXPR Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room(const Room& from);
  Room(Room&& from) noexcept
    : Room() {
    *this = ::std::move(from);
  }

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room& operator=(Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room* internal_default_instance() {
    return reinterpret_cast<const Room*>(
               &_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Room& a, Room& b) {
    a.Swap(&b);
  }
  inline void Swap(Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room& from) {
    Room::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Room";
  }
  protected:
  explicit Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledCodecsFieldNumber = 7,
    kSidFieldNumber = 1,
    kNameFieldNumber = 2,
    kTurnPasswordFieldNumber = 6,
    kMetadataFieldNumber = 8,
    kVersionFieldNumber = 13,
    kEmptyTimeoutFieldNumber = 3,
    kMaxParticipantsFieldNumber = 4,
    kCreationTimeFieldNumber = 5,
    kNumParticipantsFieldNumber = 9,
    kActiveRecordingFieldNumber = 10,
    kNumPublishersFieldNumber = 11,
    kDepartureTimeoutFieldNumber = 14,
    kCreationTimeMsFieldNumber = 15,
  };
  // repeated .livekit.Codec enabled_codecs = 7;
  int enabled_codecs_size() const;
  private:
  int _internal_enabled_codecs_size() const;
  public:
  void clear_enabled_codecs();
  ::livekit::Codec* mutable_enabled_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
      mutable_enabled_codecs();
  private:
  const ::livekit::Codec& _internal_enabled_codecs(int index) const;
  ::livekit::Codec* _internal_add_enabled_codecs();
  public:
  const ::livekit::Codec& enabled_codecs(int index) const;
  ::livekit::Codec* add_enabled_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
      enabled_codecs() const;

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string turn_password = 6;
  void clear_turn_password();
  const std::string& turn_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_turn_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_turn_password();
  PROTOBUF_NODISCARD std::string* release_turn_password();
  void set_allocated_turn_password(std::string* turn_password);
  private:
  const std::string& _internal_turn_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_turn_password(const std::string& value);
  std::string* _internal_mutable_turn_password();
  public:

  // string metadata = 8;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // .livekit.TimedVersion version = 13;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::livekit::TimedVersion& version() const;
  PROTOBUF_NODISCARD ::livekit::TimedVersion* release_version();
  ::livekit::TimedVersion* mutable_version();
  void set_allocated_version(::livekit::TimedVersion* version);
  private:
  const ::livekit::TimedVersion& _internal_version() const;
  ::livekit::TimedVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::livekit::TimedVersion* version);
  ::livekit::TimedVersion* unsafe_arena_release_version();

  // uint32 empty_timeout = 3;
  void clear_empty_timeout();
  uint32_t empty_timeout() const;
  void set_empty_timeout(uint32_t value);
  private:
  uint32_t _internal_empty_timeout() const;
  void _internal_set_empty_timeout(uint32_t value);
  public:

  // uint32 max_participants = 4;
  void clear_max_participants();
  uint32_t max_participants() const;
  void set_max_participants(uint32_t value);
  private:
  uint32_t _internal_max_participants() const;
  void _internal_set_max_participants(uint32_t value);
  public:

  // int64 creation_time = 5;
  void clear_creation_time();
  int64_t creation_time() const;
  void set_creation_time(int64_t value);
  private:
  int64_t _internal_creation_time() const;
  void _internal_set_creation_time(int64_t value);
  public:

  // uint32 num_participants = 9;
  void clear_num_participants();
  uint32_t num_participants() const;
  void set_num_participants(uint32_t value);
  private:
  uint32_t _internal_num_participants() const;
  void _internal_set_num_participants(uint32_t value);
  public:

  // bool active_recording = 10;
  void clear_active_recording();
  bool active_recording() const;
  void set_active_recording(bool value);
  private:
  bool _internal_active_recording() const;
  void _internal_set_active_recording(bool value);
  public:

  // uint32 num_publishers = 11;
  void clear_num_publishers();
  uint32_t num_publishers() const;
  void set_num_publishers(uint32_t value);
  private:
  uint32_t _internal_num_publishers() const;
  void _internal_set_num_publishers(uint32_t value);
  public:

  // uint32 departure_timeout = 14;
  void clear_departure_timeout();
  uint32_t departure_timeout() const;
  void set_departure_timeout(uint32_t value);
  private:
  uint32_t _internal_departure_timeout() const;
  void _internal_set_departure_timeout(uint32_t value);
  public:

  // int64 creation_time_ms = 15;
  void clear_creation_time_ms();
  int64_t creation_time_ms() const;
  void set_creation_time_ms(int64_t value);
  private:
  int64_t _internal_creation_time_ms() const;
  void _internal_set_creation_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec > enabled_codecs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr turn_password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::livekit::TimedVersion* version_;
    uint32_t empty_timeout_;
    uint32_t max_participants_;
    int64_t creation_time_;
    uint32_t num_participants_;
    bool active_recording_;
    uint32_t num_publishers_;
    uint32_t departure_timeout_;
    int64_t creation_time_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class Codec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Codec) */ {
 public:
  inline Codec() : Codec(nullptr) {}
  ~Codec() override;
  explicit PROTOBUF_CONSTEXPR Codec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Codec(const Codec& from);
  Codec(Codec&& from) noexcept
    : Codec() {
    *this = ::std::move(from);
  }

  inline Codec& operator=(const Codec& from) {
    CopyFrom(from);
    return *this;
  }
  inline Codec& operator=(Codec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Codec& default_instance() {
    return *internal_default_instance();
  }
  static inline const Codec* internal_default_instance() {
    return reinterpret_cast<const Codec*>(
               &_Codec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Codec& a, Codec& b) {
    a.Swap(&b);
  }
  inline void Swap(Codec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Codec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Codec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Codec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Codec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Codec& from) {
    Codec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Codec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Codec";
  }
  protected:
  explicit Codec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeFieldNumber = 1,
    kFmtpLineFieldNumber = 2,
  };
  // string mime = 1;
  void clear_mime();
  const std::string& mime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime();
  PROTOBUF_NODISCARD std::string* release_mime();
  void set_allocated_mime(std::string* mime);
  private:
  const std::string& _internal_mime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime(const std::string& value);
  std::string* _internal_mutable_mime();
  public:

  // string fmtp_line = 2;
  void clear_fmtp_line();
  const std::string& fmtp_line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fmtp_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fmtp_line();
  PROTOBUF_NODISCARD std::string* release_fmtp_line();
  void set_allocated_fmtp_line(std::string* fmtp_line);
  private:
  const std::string& _internal_fmtp_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fmtp_line(const std::string& value);
  std::string* _internal_mutable_fmtp_line();
  public:

  // @@protoc_insertion_point(class_scope:livekit.Codec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fmtp_line_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class PlayoutDelay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.PlayoutDelay) */ {
 public:
  inline PlayoutDelay() : PlayoutDelay(nullptr) {}
  ~PlayoutDelay() override;
  explicit PROTOBUF_CONSTEXPR PlayoutDelay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayoutDelay(const PlayoutDelay& from);
  PlayoutDelay(PlayoutDelay&& from) noexcept
    : PlayoutDelay() {
    *this = ::std::move(from);
  }

  inline PlayoutDelay& operator=(const PlayoutDelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayoutDelay& operator=(PlayoutDelay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayoutDelay& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayoutDelay* internal_default_instance() {
    return reinterpret_cast<const PlayoutDelay*>(
               &_PlayoutDelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayoutDelay& a, PlayoutDelay& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayoutDelay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayoutDelay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayoutDelay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayoutDelay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayoutDelay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayoutDelay& from) {
    PlayoutDelay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayoutDelay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.PlayoutDelay";
  }
  protected:
  explicit PlayoutDelay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // uint32 min = 2;
  void clear_min();
  uint32_t min() const;
  void set_min(uint32_t value);
  private:
  uint32_t _internal_min() const;
  void _internal_set_min(uint32_t value);
  public:

  // uint32 max = 3;
  void clear_max();
  uint32_t max() const;
  void set_max(uint32_t value);
  private:
  uint32_t _internal_max() const;
  void _internal_set_max(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.PlayoutDelay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enabled_;
    uint32_t min_;
    uint32_t max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantPermission) */ {
 public:
  inline ParticipantPermission() : ParticipantPermission(nullptr) {}
  ~ParticipantPermission() override;
  explicit PROTOBUF_CONSTEXPR ParticipantPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantPermission(const ParticipantPermission& from);
  ParticipantPermission(ParticipantPermission&& from) noexcept
    : ParticipantPermission() {
    *this = ::std::move(from);
  }

  inline ParticipantPermission& operator=(const ParticipantPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantPermission& operator=(ParticipantPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantPermission* internal_default_instance() {
    return reinterpret_cast<const ParticipantPermission*>(
               &_ParticipantPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ParticipantPermission& a, ParticipantPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantPermission& from) {
    ParticipantPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantPermission";
  }
  protected:
  explicit ParticipantPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCanPublishSourcesFieldNumber = 9,
    kCanSubscribeFieldNumber = 1,
    kCanPublishFieldNumber = 2,
    kCanPublishDataFieldNumber = 3,
    kHiddenFieldNumber = 7,
    kRecorderFieldNumber = 8,
    kCanUpdateMetadataFieldNumber = 10,
    kAgentFieldNumber = 11,
    kCanSubscribeMetricsFieldNumber = 12,
  };
  // repeated .livekit.TrackSource can_publish_sources = 9;
  int can_publish_sources_size() const;
  private:
  int _internal_can_publish_sources_size() const;
  public:
  void clear_can_publish_sources();
  private:
  ::livekit::TrackSource _internal_can_publish_sources(int index) const;
  void _internal_add_can_publish_sources(::livekit::TrackSource value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_can_publish_sources();
  public:
  ::livekit::TrackSource can_publish_sources(int index) const;
  void set_can_publish_sources(int index, ::livekit::TrackSource value);
  void add_can_publish_sources(::livekit::TrackSource value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& can_publish_sources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_can_publish_sources();

  // bool can_subscribe = 1;
  void clear_can_subscribe();
  bool can_subscribe() const;
  void set_can_subscribe(bool value);
  private:
  bool _internal_can_subscribe() const;
  void _internal_set_can_subscribe(bool value);
  public:

  // bool can_publish = 2;
  void clear_can_publish();
  bool can_publish() const;
  void set_can_publish(bool value);
  private:
  bool _internal_can_publish() const;
  void _internal_set_can_publish(bool value);
  public:

  // bool can_publish_data = 3;
  void clear_can_publish_data();
  bool can_publish_data() const;
  void set_can_publish_data(bool value);
  private:
  bool _internal_can_publish_data() const;
  void _internal_set_can_publish_data(bool value);
  public:

  // bool hidden = 7;
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // bool recorder = 8 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_recorder();
  PROTOBUF_DEPRECATED bool recorder() const;
  PROTOBUF_DEPRECATED void set_recorder(bool value);
  private:
  bool _internal_recorder() const;
  void _internal_set_recorder(bool value);
  public:

  // bool can_update_metadata = 10;
  void clear_can_update_metadata();
  bool can_update_metadata() const;
  void set_can_update_metadata(bool value);
  private:
  bool _internal_can_update_metadata() const;
  void _internal_set_can_update_metadata(bool value);
  public:

  // bool agent = 11 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_agent();
  PROTOBUF_DEPRECATED bool agent() const;
  PROTOBUF_DEPRECATED void set_agent(bool value);
  private:
  bool _internal_agent() const;
  void _internal_set_agent(bool value);
  public:

  // bool can_subscribe_metrics = 12;
  void clear_can_subscribe_metrics();
  bool can_subscribe_metrics() const;
  void set_can_subscribe_metrics(bool value);
  private:
  bool _internal_can_subscribe_metrics() const;
  void _internal_set_can_subscribe_metrics(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> can_publish_sources_;
    mutable std::atomic<int> _can_publish_sources_cached_byte_size_;
    bool can_subscribe_;
    bool can_publish_;
    bool can_publish_data_;
    bool hidden_;
    bool recorder_;
    bool can_update_metadata_;
    bool agent_;
    bool can_subscribe_metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantInfo_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ParticipantInfo_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ParticipantInfo_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ParticipantInfo_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ParticipantInfo_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ParticipantInfo_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ParticipantInfo_AttributesEntry_DoNotUse& other);
  static const ParticipantInfo_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ParticipantInfo_AttributesEntry_DoNotUse*>(&_ParticipantInfo_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.ParticipantInfo.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.ParticipantInfo.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};

// -------------------------------------------------------------------

class ParticipantInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantInfo) */ {
 public:
  inline ParticipantInfo() : ParticipantInfo(nullptr) {}
  ~ParticipantInfo() override;
  explicit PROTOBUF_CONSTEXPR ParticipantInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantInfo(const ParticipantInfo& from);
  ParticipantInfo(ParticipantInfo&& from) noexcept
    : ParticipantInfo() {
    *this = ::std::move(from);
  }

  inline ParticipantInfo& operator=(const ParticipantInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantInfo& operator=(ParticipantInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantInfo* internal_default_instance() {
    return reinterpret_cast<const ParticipantInfo*>(
               &_ParticipantInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ParticipantInfo& a, ParticipantInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantInfo& from) {
    ParticipantInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantInfo";
  }
  protected:
  explicit ParticipantInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ParticipantInfo_State State;
  static constexpr State JOINING =
    ParticipantInfo_State_JOINING;
  static constexpr State JOINED =
    ParticipantInfo_State_JOINED;
  static constexpr State ACTIVE =
    ParticipantInfo_State_ACTIVE;
  static constexpr State DISCONNECTED =
    ParticipantInfo_State_DISCONNECTED;
  static inline bool State_IsValid(int value) {
    return ParticipantInfo_State_IsValid(value);
  }
  static constexpr State State_MIN =
    ParticipantInfo_State_State_MIN;
  static constexpr State State_MAX =
    ParticipantInfo_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    ParticipantInfo_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return ParticipantInfo_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return ParticipantInfo_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return ParticipantInfo_State_Parse(name, value);
  }

  typedef ParticipantInfo_Kind Kind;
  static constexpr Kind STANDARD =
    ParticipantInfo_Kind_STANDARD;
  static constexpr Kind INGRESS =
    ParticipantInfo_Kind_INGRESS;
  static constexpr Kind EGRESS =
    ParticipantInfo_Kind_EGRESS;
  static constexpr Kind SIP =
    ParticipantInfo_Kind_SIP;
  static constexpr Kind AGENT =
    ParticipantInfo_Kind_AGENT;
  static inline bool Kind_IsValid(int value) {
    return ParticipantInfo_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ParticipantInfo_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ParticipantInfo_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ParticipantInfo_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ParticipantInfo_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ParticipantInfo_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ParticipantInfo_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 4,
    kAttributesFieldNumber = 15,
    kSidFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kMetadataFieldNumber = 5,
    kNameFieldNumber = 9,
    kRegionFieldNumber = 12,
    kPermissionFieldNumber = 11,
    kJoinedAtFieldNumber = 6,
    kStateFieldNumber = 3,
    kVersionFieldNumber = 10,
    kIsPublisherFieldNumber = 13,
    kKindFieldNumber = 14,
    kJoinedAtMsFieldNumber = 17,
    kDisconnectReasonFieldNumber = 16,
  };
  // repeated .livekit.TrackInfo tracks = 4;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::livekit::TrackInfo* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
      mutable_tracks();
  private:
  const ::livekit::TrackInfo& _internal_tracks(int index) const;
  ::livekit::TrackInfo* _internal_add_tracks();
  public:
  const ::livekit::TrackInfo& tracks(int index) const;
  ::livekit::TrackInfo* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
      tracks() const;

  // map<string, string> attributes = 15;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string metadata = 5;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string name = 9;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string region = 12;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // .livekit.ParticipantPermission permission = 11;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::livekit::ParticipantPermission& permission() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantPermission* release_permission();
  ::livekit::ParticipantPermission* mutable_permission();
  void set_allocated_permission(::livekit::ParticipantPermission* permission);
  private:
  const ::livekit::ParticipantPermission& _internal_permission() const;
  ::livekit::ParticipantPermission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::livekit::ParticipantPermission* permission);
  ::livekit::ParticipantPermission* unsafe_arena_release_permission();

  // int64 joined_at = 6;
  void clear_joined_at();
  int64_t joined_at() const;
  void set_joined_at(int64_t value);
  private:
  int64_t _internal_joined_at() const;
  void _internal_set_joined_at(int64_t value);
  public:

  // .livekit.ParticipantInfo.State state = 3;
  void clear_state();
  ::livekit::ParticipantInfo_State state() const;
  void set_state(::livekit::ParticipantInfo_State value);
  private:
  ::livekit::ParticipantInfo_State _internal_state() const;
  void _internal_set_state(::livekit::ParticipantInfo_State value);
  public:

  // uint32 version = 10;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // bool is_publisher = 13;
  void clear_is_publisher();
  bool is_publisher() const;
  void set_is_publisher(bool value);
  private:
  bool _internal_is_publisher() const;
  void _internal_set_is_publisher(bool value);
  public:

  // .livekit.ParticipantInfo.Kind kind = 14;
  void clear_kind();
  ::livekit::ParticipantInfo_Kind kind() const;
  void set_kind(::livekit::ParticipantInfo_Kind value);
  private:
  ::livekit::ParticipantInfo_Kind _internal_kind() const;
  void _internal_set_kind(::livekit::ParticipantInfo_Kind value);
  public:

  // int64 joined_at_ms = 17;
  void clear_joined_at_ms();
  int64_t joined_at_ms() const;
  void set_joined_at_ms(int64_t value);
  private:
  int64_t _internal_joined_at_ms() const;
  void _internal_set_joined_at_ms(int64_t value);
  public:

  // .livekit.DisconnectReason disconnect_reason = 16;
  void clear_disconnect_reason();
  ::livekit::DisconnectReason disconnect_reason() const;
  void set_disconnect_reason(::livekit::DisconnectReason value);
  private:
  ::livekit::DisconnectReason _internal_disconnect_reason() const;
  void _internal_set_disconnect_reason(::livekit::DisconnectReason value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo > tracks_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ParticipantInfo_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::livekit::ParticipantPermission* permission_;
    int64_t joined_at_;
    int state_;
    uint32_t version_;
    bool is_publisher_;
    int kind_;
    int64_t joined_at_ms_;
    int disconnect_reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class Encryption final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.Encryption) */ {
 public:
  inline Encryption() : Encryption(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Encryption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Encryption(const Encryption& from);
  Encryption(Encryption&& from) noexcept
    : Encryption() {
    *this = ::std::move(from);
  }

  inline Encryption& operator=(const Encryption& from) {
    CopyFrom(from);
    return *this;
  }
  inline Encryption& operator=(Encryption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Encryption& default_instance() {
    return *internal_default_instance();
  }
  static inline const Encryption* internal_default_instance() {
    return reinterpret_cast<const Encryption*>(
               &_Encryption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Encryption& a, Encryption& b) {
    a.Swap(&b);
  }
  inline void Swap(Encryption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Encryption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Encryption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Encryption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Encryption& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Encryption& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Encryption";
  }
  protected:
  explicit Encryption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Encryption_Type Type;
  static constexpr Type NONE =
    Encryption_Type_NONE;
  static constexpr Type GCM =
    Encryption_Type_GCM;
  static constexpr Type CUSTOM =
    Encryption_Type_CUSTOM;
  static inline bool Type_IsValid(int value) {
    return Encryption_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Encryption_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Encryption_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Encryption_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Encryption_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Encryption_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Encryption_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.Encryption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class SimulcastCodecInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SimulcastCodecInfo) */ {
 public:
  inline SimulcastCodecInfo() : SimulcastCodecInfo(nullptr) {}
  ~SimulcastCodecInfo() override;
  explicit PROTOBUF_CONSTEXPR SimulcastCodecInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulcastCodecInfo(const SimulcastCodecInfo& from);
  SimulcastCodecInfo(SimulcastCodecInfo&& from) noexcept
    : SimulcastCodecInfo() {
    *this = ::std::move(from);
  }

  inline SimulcastCodecInfo& operator=(const SimulcastCodecInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulcastCodecInfo& operator=(SimulcastCodecInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulcastCodecInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimulcastCodecInfo* internal_default_instance() {
    return reinterpret_cast<const SimulcastCodecInfo*>(
               &_SimulcastCodecInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SimulcastCodecInfo& a, SimulcastCodecInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulcastCodecInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulcastCodecInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulcastCodecInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulcastCodecInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulcastCodecInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimulcastCodecInfo& from) {
    SimulcastCodecInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulcastCodecInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SimulcastCodecInfo";
  }
  protected:
  explicit SimulcastCodecInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 4,
    kMimeTypeFieldNumber = 1,
    kMidFieldNumber = 2,
    kCidFieldNumber = 3,
  };
  // repeated .livekit.VideoLayer layers = 4;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // string mime_type = 1;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string mid = 2;
  void clear_mid();
  const std::string& mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mid();
  PROTOBUF_NODISCARD std::string* release_mid();
  void set_allocated_mid(std::string* mid);
  private:
  const std::string& _internal_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid(const std::string& value);
  std::string* _internal_mutable_mid();
  public:

  // string cid = 3;
  void clear_cid();
  const std::string& cid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cid();
  PROTOBUF_NODISCARD std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.SimulcastCodecInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class TrackInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TrackInfo) */ {
 public:
  inline TrackInfo() : TrackInfo(nullptr) {}
  ~TrackInfo() override;
  explicit PROTOBUF_CONSTEXPR TrackInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackInfo(const TrackInfo& from);
  TrackInfo(TrackInfo&& from) noexcept
    : TrackInfo() {
    *this = ::std::move(from);
  }

  inline TrackInfo& operator=(const TrackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackInfo& operator=(TrackInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackInfo* internal_default_instance() {
    return reinterpret_cast<const TrackInfo*>(
               &_TrackInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrackInfo& a, TrackInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackInfo& from) {
    TrackInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TrackInfo";
  }
  protected:
  explicit TrackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 10,
    kCodecsFieldNumber = 13,
    kAudioFeaturesFieldNumber = 19,
    kSidFieldNumber = 1,
    kNameFieldNumber = 3,
    kMimeTypeFieldNumber = 11,
    kMidFieldNumber = 12,
    kStreamFieldNumber = 17,
    kVersionFieldNumber = 18,
    kTypeFieldNumber = 2,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
    kMutedFieldNumber = 4,
    kSimulcastFieldNumber = 7,
    kDisableDtxFieldNumber = 8,
    kStereoFieldNumber = 14,
    kSourceFieldNumber = 9,
    kDisableRedFieldNumber = 15,
    kEncryptionFieldNumber = 16,
    kBackupCodecPolicyFieldNumber = 20,
  };
  // repeated .livekit.VideoLayer layers = 10;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // repeated .livekit.SimulcastCodecInfo codecs = 13;
  int codecs_size() const;
  private:
  int _internal_codecs_size() const;
  public:
  void clear_codecs();
  ::livekit::SimulcastCodecInfo* mutable_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodecInfo >*
      mutable_codecs();
  private:
  const ::livekit::SimulcastCodecInfo& _internal_codecs(int index) const;
  ::livekit::SimulcastCodecInfo* _internal_add_codecs();
  public:
  const ::livekit::SimulcastCodecInfo& codecs(int index) const;
  ::livekit::SimulcastCodecInfo* add_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodecInfo >&
      codecs() const;

  // repeated .livekit.AudioTrackFeature audio_features = 19;
  int audio_features_size() const;
  private:
  int _internal_audio_features_size() const;
  public:
  void clear_audio_features();
  private:
  ::livekit::AudioTrackFeature _internal_audio_features(int index) const;
  void _internal_add_audio_features(::livekit::AudioTrackFeature value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_audio_features();
  public:
  ::livekit::AudioTrackFeature audio_features(int index) const;
  void set_audio_features(int index, ::livekit::AudioTrackFeature value);
  void add_audio_features(::livekit::AudioTrackFeature value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& audio_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_audio_features();

  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mime_type = 11;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string mid = 12;
  void clear_mid();
  const std::string& mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mid();
  PROTOBUF_NODISCARD std::string* release_mid();
  void set_allocated_mid(std::string* mid);
  private:
  const std::string& _internal_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mid(const std::string& value);
  std::string* _internal_mutable_mid();
  public:

  // string stream = 17;
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // .livekit.TimedVersion version = 18;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::livekit::TimedVersion& version() const;
  PROTOBUF_NODISCARD ::livekit::TimedVersion* release_version();
  ::livekit::TimedVersion* mutable_version();
  void set_allocated_version(::livekit::TimedVersion* version);
  private:
  const ::livekit::TimedVersion& _internal_version() const;
  ::livekit::TimedVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::livekit::TimedVersion* version);
  ::livekit::TimedVersion* unsafe_arena_release_version();

  // .livekit.TrackType type = 2;
  void clear_type();
  ::livekit::TrackType type() const;
  void set_type(::livekit::TrackType value);
  private:
  ::livekit::TrackType _internal_type() const;
  void _internal_set_type(::livekit::TrackType value);
  public:

  // uint32 width = 5;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 6;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // bool muted = 4;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // bool simulcast = 7;
  void clear_simulcast();
  bool simulcast() const;
  void set_simulcast(bool value);
  private:
  bool _internal_simulcast() const;
  void _internal_set_simulcast(bool value);
  public:

  // bool disable_dtx = 8;
  void clear_disable_dtx();
  bool disable_dtx() const;
  void set_disable_dtx(bool value);
  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);
  public:

  // bool stereo = 14;
  void clear_stereo();
  bool stereo() const;
  void set_stereo(bool value);
  private:
  bool _internal_stereo() const;
  void _internal_set_stereo(bool value);
  public:

  // .livekit.TrackSource source = 9;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // bool disable_red = 15;
  void clear_disable_red();
  bool disable_red() const;
  void set_disable_red(bool value);
  private:
  bool _internal_disable_red() const;
  void _internal_set_disable_red(bool value);
  public:

  // .livekit.Encryption.Type encryption = 16;
  void clear_encryption();
  ::livekit::Encryption_Type encryption() const;
  void set_encryption(::livekit::Encryption_Type value);
  private:
  ::livekit::Encryption_Type _internal_encryption() const;
  void _internal_set_encryption(::livekit::Encryption_Type value);
  public:

  // .livekit.BackupCodecPolicy backup_codec_policy = 20;
  void clear_backup_codec_policy();
  ::livekit::BackupCodecPolicy backup_codec_policy() const;
  void set_backup_codec_policy(::livekit::BackupCodecPolicy value);
  private:
  ::livekit::BackupCodecPolicy _internal_backup_codec_policy() const;
  void _internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TrackInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodecInfo > codecs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> audio_features_;
    mutable std::atomic<int> _audio_features_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    ::livekit::TimedVersion* version_;
    int type_;
    uint32_t width_;
    uint32_t height_;
    bool muted_;
    bool simulcast_;
    bool disable_dtx_;
    bool stereo_;
    int source_;
    bool disable_red_;
    int encryption_;
    int backup_codec_policy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class VideoLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.VideoLayer) */ {
 public:
  inline VideoLayer() : VideoLayer(nullptr) {}
  ~VideoLayer() override;
  explicit PROTOBUF_CONSTEXPR VideoLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoLayer(const VideoLayer& from);
  VideoLayer(VideoLayer&& from) noexcept
    : VideoLayer() {
    *this = ::std::move(from);
  }

  inline VideoLayer& operator=(const VideoLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoLayer& operator=(VideoLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoLayer* internal_default_instance() {
    return reinterpret_cast<const VideoLayer*>(
               &_VideoLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VideoLayer& a, VideoLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoLayer& from) {
    VideoLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.VideoLayer";
  }
  protected:
  explicit VideoLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kBitrateFieldNumber = 4,
    kSsrcFieldNumber = 5,
  };
  // .livekit.VideoQuality quality = 1;
  void clear_quality();
  ::livekit::VideoQuality quality() const;
  void set_quality(::livekit::VideoQuality value);
  private:
  ::livekit::VideoQuality _internal_quality() const;
  void _internal_set_quality(::livekit::VideoQuality value);
  public:

  // uint32 width = 2;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 bitrate = 4;
  void clear_bitrate();
  uint32_t bitrate() const;
  void set_bitrate(uint32_t value);
  private:
  uint32_t _internal_bitrate() const;
  void _internal_set_bitrate(uint32_t value);
  public:

  // uint32 ssrc = 5;
  void clear_ssrc();
  uint32_t ssrc() const;
  void set_ssrc(uint32_t value);
  private:
  uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.VideoLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int quality_;
    uint32_t width_;
    uint32_t height_;
    uint32_t bitrate_;
    uint32_t ssrc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataPacket) */ {
 public:
  inline DataPacket() : DataPacket(nullptr) {}
  ~DataPacket() override;
  explicit PROTOBUF_CONSTEXPR DataPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataPacket(const DataPacket& from);
  DataPacket(DataPacket&& from) noexcept
    : DataPacket() {
    *this = ::std::move(from);
  }

  inline DataPacket& operator=(const DataPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPacket& operator=(DataPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPacket& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUser = 2,
    kSpeaker = 3,
    kSipDtmf = 6,
    kTranscription = 7,
    kMetrics = 8,
    kChatMessage = 9,
    kRpcRequest = 10,
    kRpcAck = 11,
    kRpcResponse = 12,
    kStreamHeader = 13,
    kStreamChunk = 14,
    kStreamTrailer = 15,
    VALUE_NOT_SET = 0,
  };

  static inline const DataPacket* internal_default_instance() {
    return reinterpret_cast<const DataPacket*>(
               &_DataPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DataPacket& a, DataPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataPacket& from) {
    DataPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataPacket";
  }
  protected:
  explicit DataPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataPacket_Kind Kind;
  static constexpr Kind RELIABLE =
    DataPacket_Kind_RELIABLE;
  static constexpr Kind LOSSY =
    DataPacket_Kind_LOSSY;
  static inline bool Kind_IsValid(int value) {
    return DataPacket_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    DataPacket_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    DataPacket_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    DataPacket_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return DataPacket_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return DataPacket_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return DataPacket_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 5,
    kParticipantIdentityFieldNumber = 4,
    kKindFieldNumber = 1,
    kUserFieldNumber = 2,
    kSpeakerFieldNumber = 3,
    kSipDtmfFieldNumber = 6,
    kTranscriptionFieldNumber = 7,
    kMetricsFieldNumber = 8,
    kChatMessageFieldNumber = 9,
    kRpcRequestFieldNumber = 10,
    kRpcAckFieldNumber = 11,
    kRpcResponseFieldNumber = 12,
    kStreamHeaderFieldNumber = 13,
    kStreamChunkFieldNumber = 14,
    kStreamTrailerFieldNumber = 15,
  };
  // repeated string destination_identities = 5;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // string participant_identity = 4;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // .livekit.DataPacket.Kind kind = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_kind();
  PROTOBUF_DEPRECATED ::livekit::DataPacket_Kind kind() const;
  PROTOBUF_DEPRECATED void set_kind(::livekit::DataPacket_Kind value);
  private:
  ::livekit::DataPacket_Kind _internal_kind() const;
  void _internal_set_kind(::livekit::DataPacket_Kind value);
  public:

  // .livekit.UserPacket user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::livekit::UserPacket& user() const;
  PROTOBUF_NODISCARD ::livekit::UserPacket* release_user();
  ::livekit::UserPacket* mutable_user();
  void set_allocated_user(::livekit::UserPacket* user);
  private:
  const ::livekit::UserPacket& _internal_user() const;
  ::livekit::UserPacket* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::livekit::UserPacket* user);
  ::livekit::UserPacket* unsafe_arena_release_user();

  // .livekit.ActiveSpeakerUpdate speaker = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_speaker() const;
  private:
  bool _internal_has_speaker() const;
  public:
  PROTOBUF_DEPRECATED void clear_speaker();
  PROTOBUF_DEPRECATED const ::livekit::ActiveSpeakerUpdate& speaker() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::livekit::ActiveSpeakerUpdate* release_speaker();
  PROTOBUF_DEPRECATED ::livekit::ActiveSpeakerUpdate* mutable_speaker();
  PROTOBUF_DEPRECATED void set_allocated_speaker(::livekit::ActiveSpeakerUpdate* speaker);
  private:
  const ::livekit::ActiveSpeakerUpdate& _internal_speaker() const;
  ::livekit::ActiveSpeakerUpdate* _internal_mutable_speaker();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_speaker(
      ::livekit::ActiveSpeakerUpdate* speaker);
  PROTOBUF_DEPRECATED ::livekit::ActiveSpeakerUpdate* unsafe_arena_release_speaker();

  // .livekit.SipDTMF sip_dtmf = 6;
  bool has_sip_dtmf() const;
  private:
  bool _internal_has_sip_dtmf() const;
  public:
  void clear_sip_dtmf();
  const ::livekit::SipDTMF& sip_dtmf() const;
  PROTOBUF_NODISCARD ::livekit::SipDTMF* release_sip_dtmf();
  ::livekit::SipDTMF* mutable_sip_dtmf();
  void set_allocated_sip_dtmf(::livekit::SipDTMF* sip_dtmf);
  private:
  const ::livekit::SipDTMF& _internal_sip_dtmf() const;
  ::livekit::SipDTMF* _internal_mutable_sip_dtmf();
  public:
  void unsafe_arena_set_allocated_sip_dtmf(
      ::livekit::SipDTMF* sip_dtmf);
  ::livekit::SipDTMF* unsafe_arena_release_sip_dtmf();

  // .livekit.Transcription transcription = 7;
  bool has_transcription() const;
  private:
  bool _internal_has_transcription() const;
  public:
  void clear_transcription();
  const ::livekit::Transcription& transcription() const;
  PROTOBUF_NODISCARD ::livekit::Transcription* release_transcription();
  ::livekit::Transcription* mutable_transcription();
  void set_allocated_transcription(::livekit::Transcription* transcription);
  private:
  const ::livekit::Transcription& _internal_transcription() const;
  ::livekit::Transcription* _internal_mutable_transcription();
  public:
  void unsafe_arena_set_allocated_transcription(
      ::livekit::Transcription* transcription);
  ::livekit::Transcription* unsafe_arena_release_transcription();

  // .livekit.MetricsBatch metrics = 8;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::livekit::MetricsBatch& metrics() const;
  PROTOBUF_NODISCARD ::livekit::MetricsBatch* release_metrics();
  ::livekit::MetricsBatch* mutable_metrics();
  void set_allocated_metrics(::livekit::MetricsBatch* metrics);
  private:
  const ::livekit::MetricsBatch& _internal_metrics() const;
  ::livekit::MetricsBatch* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::livekit::MetricsBatch* metrics);
  ::livekit::MetricsBatch* unsafe_arena_release_metrics();

  // .livekit.ChatMessage chat_message = 9;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;
  public:
  void clear_chat_message();
  const ::livekit::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::livekit::ChatMessage* release_chat_message();
  ::livekit::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::livekit::ChatMessage* chat_message);
  private:
  const ::livekit::ChatMessage& _internal_chat_message() const;
  ::livekit::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::livekit::ChatMessage* chat_message);
  ::livekit::ChatMessage* unsafe_arena_release_chat_message();

  // .livekit.RpcRequest rpc_request = 10;
  bool has_rpc_request() const;
  private:
  bool _internal_has_rpc_request() const;
  public:
  void clear_rpc_request();
  const ::livekit::RpcRequest& rpc_request() const;
  PROTOBUF_NODISCARD ::livekit::RpcRequest* release_rpc_request();
  ::livekit::RpcRequest* mutable_rpc_request();
  void set_allocated_rpc_request(::livekit::RpcRequest* rpc_request);
  private:
  const ::livekit::RpcRequest& _internal_rpc_request() const;
  ::livekit::RpcRequest* _internal_mutable_rpc_request();
  public:
  void unsafe_arena_set_allocated_rpc_request(
      ::livekit::RpcRequest* rpc_request);
  ::livekit::RpcRequest* unsafe_arena_release_rpc_request();

  // .livekit.RpcAck rpc_ack = 11;
  bool has_rpc_ack() const;
  private:
  bool _internal_has_rpc_ack() const;
  public:
  void clear_rpc_ack();
  const ::livekit::RpcAck& rpc_ack() const;
  PROTOBUF_NODISCARD ::livekit::RpcAck* release_rpc_ack();
  ::livekit::RpcAck* mutable_rpc_ack();
  void set_allocated_rpc_ack(::livekit::RpcAck* rpc_ack);
  private:
  const ::livekit::RpcAck& _internal_rpc_ack() const;
  ::livekit::RpcAck* _internal_mutable_rpc_ack();
  public:
  void unsafe_arena_set_allocated_rpc_ack(
      ::livekit::RpcAck* rpc_ack);
  ::livekit::RpcAck* unsafe_arena_release_rpc_ack();

  // .livekit.RpcResponse rpc_response = 12;
  bool has_rpc_response() const;
  private:
  bool _internal_has_rpc_response() const;
  public:
  void clear_rpc_response();
  const ::livekit::RpcResponse& rpc_response() const;
  PROTOBUF_NODISCARD ::livekit::RpcResponse* release_rpc_response();
  ::livekit::RpcResponse* mutable_rpc_response();
  void set_allocated_rpc_response(::livekit::RpcResponse* rpc_response);
  private:
  const ::livekit::RpcResponse& _internal_rpc_response() const;
  ::livekit::RpcResponse* _internal_mutable_rpc_response();
  public:
  void unsafe_arena_set_allocated_rpc_response(
      ::livekit::RpcResponse* rpc_response);
  ::livekit::RpcResponse* unsafe_arena_release_rpc_response();

  // .livekit.DataStream.Header stream_header = 13;
  bool has_stream_header() const;
  private:
  bool _internal_has_stream_header() const;
  public:
  void clear_stream_header();
  const ::livekit::DataStream_Header& stream_header() const;
  PROTOBUF_NODISCARD ::livekit::DataStream_Header* release_stream_header();
  ::livekit::DataStream_Header* mutable_stream_header();
  void set_allocated_stream_header(::livekit::DataStream_Header* stream_header);
  private:
  const ::livekit::DataStream_Header& _internal_stream_header() const;
  ::livekit::DataStream_Header* _internal_mutable_stream_header();
  public:
  void unsafe_arena_set_allocated_stream_header(
      ::livekit::DataStream_Header* stream_header);
  ::livekit::DataStream_Header* unsafe_arena_release_stream_header();

  // .livekit.DataStream.Chunk stream_chunk = 14;
  bool has_stream_chunk() const;
  private:
  bool _internal_has_stream_chunk() const;
  public:
  void clear_stream_chunk();
  const ::livekit::DataStream_Chunk& stream_chunk() const;
  PROTOBUF_NODISCARD ::livekit::DataStream_Chunk* release_stream_chunk();
  ::livekit::DataStream_Chunk* mutable_stream_chunk();
  void set_allocated_stream_chunk(::livekit::DataStream_Chunk* stream_chunk);
  private:
  const ::livekit::DataStream_Chunk& _internal_stream_chunk() const;
  ::livekit::DataStream_Chunk* _internal_mutable_stream_chunk();
  public:
  void unsafe_arena_set_allocated_stream_chunk(
      ::livekit::DataStream_Chunk* stream_chunk);
  ::livekit::DataStream_Chunk* unsafe_arena_release_stream_chunk();

  // .livekit.DataStream.Trailer stream_trailer = 15;
  bool has_stream_trailer() const;
  private:
  bool _internal_has_stream_trailer() const;
  public:
  void clear_stream_trailer();
  const ::livekit::DataStream_Trailer& stream_trailer() const;
  PROTOBUF_NODISCARD ::livekit::DataStream_Trailer* release_stream_trailer();
  ::livekit::DataStream_Trailer* mutable_stream_trailer();
  void set_allocated_stream_trailer(::livekit::DataStream_Trailer* stream_trailer);
  private:
  const ::livekit::DataStream_Trailer& _internal_stream_trailer() const;
  ::livekit::DataStream_Trailer* _internal_mutable_stream_trailer();
  public:
  void unsafe_arena_set_allocated_stream_trailer(
      ::livekit::DataStream_Trailer* stream_trailer);
  ::livekit::DataStream_Trailer* unsafe_arena_release_stream_trailer();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:livekit.DataPacket)
 private:
  class _Internal;
  void set_has_user();
  void set_has_speaker();
  void set_has_sip_dtmf();
  void set_has_transcription();
  void set_has_metrics();
  void set_has_chat_message();
  void set_has_rpc_request();
  void set_has_rpc_ack();
  void set_has_rpc_response();
  void set_has_stream_header();
  void set_has_stream_chunk();
  void set_has_stream_trailer();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int kind_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::UserPacket* user_;
      ::livekit::ActiveSpeakerUpdate* speaker_;
      ::livekit::SipDTMF* sip_dtmf_;
      ::livekit::Transcription* transcription_;
      ::livekit::MetricsBatch* metrics_;
      ::livekit::ChatMessage* chat_message_;
      ::livekit::RpcRequest* rpc_request_;
      ::livekit::RpcAck* rpc_ack_;
      ::livekit::RpcResponse* rpc_response_;
      ::livekit::DataStream_Header* stream_header_;
      ::livekit::DataStream_Chunk* stream_chunk_;
      ::livekit::DataStream_Trailer* stream_trailer_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ActiveSpeakerUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ActiveSpeakerUpdate) */ {
 public:
  inline ActiveSpeakerUpdate() : ActiveSpeakerUpdate(nullptr) {}
  ~ActiveSpeakerUpdate() override;
  explicit PROTOBUF_CONSTEXPR ActiveSpeakerUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSpeakerUpdate(const ActiveSpeakerUpdate& from);
  ActiveSpeakerUpdate(ActiveSpeakerUpdate&& from) noexcept
    : ActiveSpeakerUpdate() {
    *this = ::std::move(from);
  }

  inline ActiveSpeakerUpdate& operator=(const ActiveSpeakerUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSpeakerUpdate& operator=(ActiveSpeakerUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSpeakerUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSpeakerUpdate* internal_default_instance() {
    return reinterpret_cast<const ActiveSpeakerUpdate*>(
               &_ActiveSpeakerUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ActiveSpeakerUpdate& a, ActiveSpeakerUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSpeakerUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSpeakerUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSpeakerUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSpeakerUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSpeakerUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSpeakerUpdate& from) {
    ActiveSpeakerUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSpeakerUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ActiveSpeakerUpdate";
  }
  protected:
  explicit ActiveSpeakerUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakersFieldNumber = 1,
  };
  // repeated .livekit.SpeakerInfo speakers = 1;
  int speakers_size() const;
  private:
  int _internal_speakers_size() const;
  public:
  void clear_speakers();
  ::livekit::SpeakerInfo* mutable_speakers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
      mutable_speakers();
  private:
  const ::livekit::SpeakerInfo& _internal_speakers(int index) const;
  ::livekit::SpeakerInfo* _internal_add_speakers();
  public:
  const ::livekit::SpeakerInfo& speakers(int index) const;
  ::livekit::SpeakerInfo* add_speakers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
      speakers() const;

  // @@protoc_insertion_point(class_scope:livekit.ActiveSpeakerUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo > speakers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class SpeakerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SpeakerInfo) */ {
 public:
  inline SpeakerInfo() : SpeakerInfo(nullptr) {}
  ~SpeakerInfo() override;
  explicit PROTOBUF_CONSTEXPR SpeakerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeakerInfo(const SpeakerInfo& from);
  SpeakerInfo(SpeakerInfo&& from) noexcept
    : SpeakerInfo() {
    *this = ::std::move(from);
  }

  inline SpeakerInfo& operator=(const SpeakerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeakerInfo& operator=(SpeakerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeakerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpeakerInfo* internal_default_instance() {
    return reinterpret_cast<const SpeakerInfo*>(
               &_SpeakerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SpeakerInfo& a, SpeakerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeakerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeakerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeakerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeakerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeakerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeakerInfo& from) {
    SpeakerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeakerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SpeakerInfo";
  }
  protected:
  explicit SpeakerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kLevelFieldNumber = 2,
    kActiveFieldNumber = 3,
  };
  // string sid = 1;
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // float level = 2;
  void clear_level();
  float level() const;
  void set_level(float value);
  private:
  float _internal_level() const;
  void _internal_set_level(float value);
  public:

  // bool active = 3;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SpeakerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    float level_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class UserPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UserPacket) */ {
 public:
  inline UserPacket() : UserPacket(nullptr) {}
  ~UserPacket() override;
  explicit PROTOBUF_CONSTEXPR UserPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPacket(const UserPacket& from);
  UserPacket(UserPacket&& from) noexcept
    : UserPacket() {
    *this = ::std::move(from);
  }

  inline UserPacket& operator=(const UserPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPacket& operator=(UserPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPacket* internal_default_instance() {
    return reinterpret_cast<const UserPacket*>(
               &_UserPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UserPacket& a, UserPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserPacket& from) {
    UserPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UserPacket";
  }
  protected:
  explicit UserPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationSidsFieldNumber = 3,
    kDestinationIdentitiesFieldNumber = 6,
    kParticipantSidFieldNumber = 1,
    kPayloadFieldNumber = 2,
    kTopicFieldNumber = 4,
    kParticipantIdentityFieldNumber = 5,
    kIdFieldNumber = 8,
    kNonceFieldNumber = 11,
    kStartTimeFieldNumber = 9,
    kEndTimeFieldNumber = 10,
  };
  // repeated string destination_sids = 3 [deprecated = true];
  PROTOBUF_DEPRECATED int destination_sids_size() const;
  private:
  int _internal_destination_sids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_destination_sids();
  PROTOBUF_DEPRECATED const std::string& destination_sids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_destination_sids(int index);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_destination_sids();
  PROTOBUF_DEPRECATED void add_destination_sids(const std::string& value);
  PROTOBUF_DEPRECATED void add_destination_sids(std::string&& value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_sids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_sids();
  private:
  const std::string& _internal_destination_sids(int index) const;
  std::string* _internal_add_destination_sids();
  public:

  // repeated string destination_identities = 6 [deprecated = true];
  PROTOBUF_DEPRECATED int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_destination_identities();
  PROTOBUF_DEPRECATED const std::string& destination_identities(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_destination_identities(int index);
  PROTOBUF_DEPRECATED void set_destination_identities(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_destination_identities(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_destination_identities(int index, const char* value);
  PROTOBUF_DEPRECATED void set_destination_identities(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_destination_identities();
  PROTOBUF_DEPRECATED void add_destination_identities(const std::string& value);
  PROTOBUF_DEPRECATED void add_destination_identities(std::string&& value);
  PROTOBUF_DEPRECATED void add_destination_identities(const char* value);
  PROTOBUF_DEPRECATED void add_destination_identities(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // string participant_sid = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_participant_sid();
  PROTOBUF_DEPRECATED const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_participant_sid(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_participant_sid();
  PROTOBUF_DEPRECATED void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string topic = 4;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string participant_identity = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_participant_identity();
  PROTOBUF_DEPRECATED const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_participant_identity(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_participant_identity();
  PROTOBUF_DEPRECATED void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // optional string id = 8;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes nonce = 11;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // optional uint64 start_time = 9;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint64_t start_time() const;
  void set_start_time(uint64_t value);
  private:
  uint64_t _internal_start_time() const;
  void _internal_set_start_time(uint64_t value);
  public:

  // optional uint64 end_time = 10;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  uint64_t end_time() const;
  void set_end_time(uint64_t value);
  private:
  uint64_t _internal_end_time() const;
  void _internal_set_end_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UserPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_sids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    uint64_t start_time_;
    uint64_t end_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class SipDTMF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SipDTMF) */ {
 public:
  inline SipDTMF() : SipDTMF(nullptr) {}
  ~SipDTMF() override;
  explicit PROTOBUF_CONSTEXPR SipDTMF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SipDTMF(const SipDTMF& from);
  SipDTMF(SipDTMF&& from) noexcept
    : SipDTMF() {
    *this = ::std::move(from);
  }

  inline SipDTMF& operator=(const SipDTMF& from) {
    CopyFrom(from);
    return *this;
  }
  inline SipDTMF& operator=(SipDTMF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SipDTMF& default_instance() {
    return *internal_default_instance();
  }
  static inline const SipDTMF* internal_default_instance() {
    return reinterpret_cast<const SipDTMF*>(
               &_SipDTMF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SipDTMF& a, SipDTMF& b) {
    a.Swap(&b);
  }
  inline void Swap(SipDTMF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SipDTMF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SipDTMF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SipDTMF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SipDTMF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SipDTMF& from) {
    SipDTMF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipDTMF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SipDTMF";
  }
  protected:
  explicit SipDTMF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigitFieldNumber = 4,
    kCodeFieldNumber = 3,
  };
  // string digit = 4;
  void clear_digit();
  const std::string& digit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digit();
  PROTOBUF_NODISCARD std::string* release_digit();
  void set_allocated_digit(std::string* digit);
  private:
  const std::string& _internal_digit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digit(const std::string& value);
  std::string* _internal_mutable_digit();
  public:

  // uint32 code = 3;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SipDTMF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digit_;
    uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class Transcription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Transcription) */ {
 public:
  inline Transcription() : Transcription(nullptr) {}
  ~Transcription() override;
  explicit PROTOBUF_CONSTEXPR Transcription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transcription(const Transcription& from);
  Transcription(Transcription&& from) noexcept
    : Transcription() {
    *this = ::std::move(from);
  }

  inline Transcription& operator=(const Transcription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transcription& operator=(Transcription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transcription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transcription* internal_default_instance() {
    return reinterpret_cast<const Transcription*>(
               &_Transcription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Transcription& a, Transcription& b) {
    a.Swap(&b);
  }
  inline void Swap(Transcription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transcription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transcription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transcription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transcription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Transcription& from) {
    Transcription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transcription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Transcription";
  }
  protected:
  explicit Transcription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 4,
    kTranscribedParticipantIdentityFieldNumber = 2,
    kTrackIdFieldNumber = 3,
  };
  // repeated .livekit.TranscriptionSegment segments = 4;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::livekit::TranscriptionSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TranscriptionSegment >*
      mutable_segments();
  private:
  const ::livekit::TranscriptionSegment& _internal_segments(int index) const;
  ::livekit::TranscriptionSegment* _internal_add_segments();
  public:
  const ::livekit::TranscriptionSegment& segments(int index) const;
  ::livekit::TranscriptionSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TranscriptionSegment >&
      segments() const;

  // string transcribed_participant_identity = 2;
  void clear_transcribed_participant_identity();
  const std::string& transcribed_participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transcribed_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transcribed_participant_identity();
  PROTOBUF_NODISCARD std::string* release_transcribed_participant_identity();
  void set_allocated_transcribed_participant_identity(std::string* transcribed_participant_identity);
  private:
  const std::string& _internal_transcribed_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transcribed_participant_identity(const std::string& value);
  std::string* _internal_mutable_transcribed_participant_identity();
  public:

  // string track_id = 3;
  void clear_track_id();
  const std::string& track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_id();
  PROTOBUF_NODISCARD std::string* release_track_id();
  void set_allocated_track_id(std::string* track_id);
  private:
  const std::string& _internal_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(const std::string& value);
  std::string* _internal_mutable_track_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.Transcription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TranscriptionSegment > segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcribed_participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class TranscriptionSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TranscriptionSegment) */ {
 public:
  inline TranscriptionSegment() : TranscriptionSegment(nullptr) {}
  ~TranscriptionSegment() override;
  explicit PROTOBUF_CONSTEXPR TranscriptionSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscriptionSegment(const TranscriptionSegment& from);
  TranscriptionSegment(TranscriptionSegment&& from) noexcept
    : TranscriptionSegment() {
    *this = ::std::move(from);
  }

  inline TranscriptionSegment& operator=(const TranscriptionSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscriptionSegment& operator=(TranscriptionSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscriptionSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscriptionSegment* internal_default_instance() {
    return reinterpret_cast<const TranscriptionSegment*>(
               &_TranscriptionSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TranscriptionSegment& a, TranscriptionSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscriptionSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscriptionSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranscriptionSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranscriptionSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscriptionSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranscriptionSegment& from) {
    TranscriptionSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptionSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TranscriptionSegment";
  }
  protected:
  explicit TranscriptionSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kLanguageFieldNumber = 6,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kFinalFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string language = 6;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // uint64 start_time = 3;
  void clear_start_time();
  uint64_t start_time() const;
  void set_start_time(uint64_t value);
  private:
  uint64_t _internal_start_time() const;
  void _internal_set_start_time(uint64_t value);
  public:

  // uint64 end_time = 4;
  void clear_end_time();
  uint64_t end_time() const;
  void set_end_time(uint64_t value);
  private:
  uint64_t _internal_end_time() const;
  void _internal_set_end_time(uint64_t value);
  public:

  // bool final = 5;
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TranscriptionSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    uint64_t start_time_;
    uint64_t end_time_;
    bool final_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kEditTimestampFieldNumber = 3,
    kDeletedFieldNumber = 5,
    kGeneratedFieldNumber = 6,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int64 edit_timestamp = 3;
  bool has_edit_timestamp() const;
  private:
  bool _internal_has_edit_timestamp() const;
  public:
  void clear_edit_timestamp();
  int64_t edit_timestamp() const;
  void set_edit_timestamp(int64_t value);
  private:
  int64_t _internal_edit_timestamp() const;
  void _internal_set_edit_timestamp(int64_t value);
  public:

  // bool deleted = 5;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // bool generated = 6;
  void clear_generated();
  bool generated() const;
  void set_generated(bool value);
  private:
  bool _internal_generated() const;
  void _internal_set_generated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t timestamp_;
    int64_t edit_timestamp_;
    bool deleted_;
    bool generated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RpcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RpcRequest) */ {
 public:
  inline RpcRequest() : RpcRequest(nullptr) {}
  ~RpcRequest() override;
  explicit PROTOBUF_CONSTEXPR RpcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcRequest(const RpcRequest& from);
  RpcRequest(RpcRequest&& from) noexcept
    : RpcRequest() {
    *this = ::std::move(from);
  }

  inline RpcRequest& operator=(const RpcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcRequest& operator=(RpcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcRequest* internal_default_instance() {
    return reinterpret_cast<const RpcRequest*>(
               &_RpcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RpcRequest& a, RpcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcRequest& from) {
    RpcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RpcRequest";
  }
  protected:
  explicit RpcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMethodFieldNumber = 2,
    kPayloadFieldNumber = 3,
    kResponseTimeoutMsFieldNumber = 4,
    kVersionFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string method = 2;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // uint32 response_timeout_ms = 4;
  void clear_response_timeout_ms();
  uint32_t response_timeout_ms() const;
  void set_response_timeout_ms(uint32_t value);
  private:
  uint32_t _internal_response_timeout_ms() const;
  void _internal_set_response_timeout_ms(uint32_t value);
  public:

  // uint32 version = 5;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RpcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    uint32_t response_timeout_ms_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RpcAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RpcAck) */ {
 public:
  inline RpcAck() : RpcAck(nullptr) {}
  ~RpcAck() override;
  explicit PROTOBUF_CONSTEXPR RpcAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcAck(const RpcAck& from);
  RpcAck(RpcAck&& from) noexcept
    : RpcAck() {
    *this = ::std::move(from);
  }

  inline RpcAck& operator=(const RpcAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcAck& operator=(RpcAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcAck* internal_default_instance() {
    return reinterpret_cast<const RpcAck*>(
               &_RpcAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RpcAck& a, RpcAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcAck& from) {
    RpcAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RpcAck";
  }
  protected:
  explicit RpcAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.RpcAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RpcResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RpcResponse) */ {
 public:
  inline RpcResponse() : RpcResponse(nullptr) {}
  ~RpcResponse() override;
  explicit PROTOBUF_CONSTEXPR RpcResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcResponse(const RpcResponse& from);
  RpcResponse(RpcResponse&& from) noexcept
    : RpcResponse() {
    *this = ::std::move(from);
  }

  inline RpcResponse& operator=(const RpcResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcResponse& operator=(RpcResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kPayload = 2,
    kError = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const RpcResponse* internal_default_instance() {
    return reinterpret_cast<const RpcResponse*>(
               &_RpcResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RpcResponse& a, RpcResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcResponse& from) {
    RpcResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RpcResponse";
  }
  protected:
  explicit RpcResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kPayloadFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // string request_id = 1;
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // string payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .livekit.RpcError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::livekit::RpcError& error() const;
  PROTOBUF_NODISCARD ::livekit::RpcError* release_error();
  ::livekit::RpcError* mutable_error();
  void set_allocated_error(::livekit::RpcError* error);
  private:
  const ::livekit::RpcError& _internal_error() const;
  ::livekit::RpcError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::livekit::RpcError* error);
  ::livekit::RpcError* unsafe_arena_release_error();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:livekit.RpcResponse)
 private:
  class _Internal;
  void set_has_payload();
  void set_has_error();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
      ::livekit::RpcError* error_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RpcError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RpcError) */ {
 public:
  inline RpcError() : RpcError(nullptr) {}
  ~RpcError() override;
  explicit PROTOBUF_CONSTEXPR RpcError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcError(const RpcError& from);
  RpcError(RpcError&& from) noexcept
    : RpcError() {
    *this = ::std::move(from);
  }

  inline RpcError& operator=(const RpcError& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcError& operator=(RpcError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcError& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcError* internal_default_instance() {
    return reinterpret_cast<const RpcError*>(
               &_RpcError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RpcError& a, RpcError& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcError& from) {
    RpcError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RpcError";
  }
  protected:
  explicit RpcError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kDataFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RpcError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    uint32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ParticipantTracks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ParticipantTracks) */ {
 public:
  inline ParticipantTracks() : ParticipantTracks(nullptr) {}
  ~ParticipantTracks() override;
  explicit PROTOBUF_CONSTEXPR ParticipantTracks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantTracks(const ParticipantTracks& from);
  ParticipantTracks(ParticipantTracks&& from) noexcept
    : ParticipantTracks() {
    *this = ::std::move(from);
  }

  inline ParticipantTracks& operator=(const ParticipantTracks& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantTracks& operator=(ParticipantTracks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantTracks& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantTracks* internal_default_instance() {
    return reinterpret_cast<const ParticipantTracks*>(
               &_ParticipantTracks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ParticipantTracks& a, ParticipantTracks& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantTracks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantTracks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantTracks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantTracks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantTracks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantTracks& from) {
    ParticipantTracks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantTracks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ParticipantTracks";
  }
  protected:
  explicit ParticipantTracks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 2,
    kParticipantSidFieldNumber = 1,
  };
  // repeated string track_sids = 2;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // string participant_sid = 1;
  void clear_participant_sid();
  const std::string& participant_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_sid();
  PROTOBUF_NODISCARD std::string* release_participant_sid();
  void set_allocated_participant_sid(std::string* participant_sid);
  private:
  const std::string& _internal_participant_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_sid(const std::string& value);
  std::string* _internal_mutable_participant_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ParticipantTracks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_sid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerInfo& from) {
    ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerInfo_Edition Edition;
  static constexpr Edition Standard =
    ServerInfo_Edition_Standard;
  static constexpr Edition Cloud =
    ServerInfo_Edition_Cloud;
  static inline bool Edition_IsValid(int value) {
    return ServerInfo_Edition_IsValid(value);
  }
  static constexpr Edition Edition_MIN =
    ServerInfo_Edition_Edition_MIN;
  static constexpr Edition Edition_MAX =
    ServerInfo_Edition_Edition_MAX;
  static constexpr int Edition_ARRAYSIZE =
    ServerInfo_Edition_Edition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Edition_descriptor() {
    return ServerInfo_Edition_descriptor();
  }
  template<typename T>
  static inline const std::string& Edition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Edition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Edition_Name.");
    return ServerInfo_Edition_Name(enum_t_value);
  }
  static inline bool Edition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Edition* value) {
    return ServerInfo_Edition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kRegionFieldNumber = 4,
    kNodeIdFieldNumber = 5,
    kDebugInfoFieldNumber = 6,
    kEditionFieldNumber = 1,
    kProtocolFieldNumber = 3,
    kAgentProtocolFieldNumber = 7,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string region = 4;
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // string node_id = 5;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string debug_info = 6;
  void clear_debug_info();
  const std::string& debug_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_info();
  PROTOBUF_NODISCARD std::string* release_debug_info();
  void set_allocated_debug_info(std::string* debug_info);
  private:
  const std::string& _internal_debug_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_info(const std::string& value);
  std::string* _internal_mutable_debug_info();
  public:

  // .livekit.ServerInfo.Edition edition = 1;
  void clear_edition();
  ::livekit::ServerInfo_Edition edition() const;
  void set_edition(::livekit::ServerInfo_Edition value);
  private:
  ::livekit::ServerInfo_Edition _internal_edition() const;
  void _internal_set_edition(::livekit::ServerInfo_Edition value);
  public:

  // int32 protocol = 3;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // int32 agent_protocol = 7;
  void clear_agent_protocol();
  int32_t agent_protocol() const;
  void set_agent_protocol(int32_t value);
  private:
  int32_t _internal_agent_protocol() const;
  void _internal_set_agent_protocol(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_info_;
    int edition_;
    int32_t protocol_;
    int32_t agent_protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ClientInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ClientInfo) */ {
 public:
  inline ClientInfo() : ClientInfo(nullptr) {}
  ~ClientInfo() override;
  explicit PROTOBUF_CONSTEXPR ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientInfo(const ClientInfo& from);
  ClientInfo(ClientInfo&& from) noexcept
    : ClientInfo() {
    *this = ::std::move(from);
  }

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientInfo& operator=(ClientInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientInfo* internal_default_instance() {
    return reinterpret_cast<const ClientInfo*>(
               &_ClientInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ClientInfo& a, ClientInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientInfo& from) {
    ClientInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ClientInfo";
  }
  protected:
  explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientInfo_SDK SDK;
  static constexpr SDK UNKNOWN =
    ClientInfo_SDK_UNKNOWN;
  static constexpr SDK JS =
    ClientInfo_SDK_JS;
  static constexpr SDK SWIFT =
    ClientInfo_SDK_SWIFT;
  static constexpr SDK ANDROID =
    ClientInfo_SDK_ANDROID;
  static constexpr SDK FLUTTER =
    ClientInfo_SDK_FLUTTER;
  static constexpr SDK GO =
    ClientInfo_SDK_GO;
  static constexpr SDK UNITY =
    ClientInfo_SDK_UNITY;
  static constexpr SDK REACT_NATIVE =
    ClientInfo_SDK_REACT_NATIVE;
  static constexpr SDK RUST =
    ClientInfo_SDK_RUST;
  static constexpr SDK PYTHON =
    ClientInfo_SDK_PYTHON;
  static constexpr SDK CPP =
    ClientInfo_SDK_CPP;
  static constexpr SDK UNITY_WEB =
    ClientInfo_SDK_UNITY_WEB;
  static constexpr SDK NODE =
    ClientInfo_SDK_NODE;
  static inline bool SDK_IsValid(int value) {
    return ClientInfo_SDK_IsValid(value);
  }
  static constexpr SDK SDK_MIN =
    ClientInfo_SDK_SDK_MIN;
  static constexpr SDK SDK_MAX =
    ClientInfo_SDK_SDK_MAX;
  static constexpr int SDK_ARRAYSIZE =
    ClientInfo_SDK_SDK_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SDK_descriptor() {
    return ClientInfo_SDK_descriptor();
  }
  template<typename T>
  static inline const std::string& SDK_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SDK>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SDK_Name.");
    return ClientInfo_SDK_Name(enum_t_value);
  }
  static inline bool SDK_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SDK* value) {
    return ClientInfo_SDK_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kOsFieldNumber = 4,
    kOsVersionFieldNumber = 5,
    kDeviceModelFieldNumber = 6,
    kBrowserFieldNumber = 7,
    kBrowserVersionFieldNumber = 8,
    kAddressFieldNumber = 9,
    kNetworkFieldNumber = 10,
    kOtherSdksFieldNumber = 11,
    kSdkFieldNumber = 1,
    kProtocolFieldNumber = 3,
  };
  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string os = 4;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string os_version = 5;
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // string device_model = 6;
  void clear_device_model();
  const std::string& device_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_model();
  PROTOBUF_NODISCARD std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // string browser = 7;
  void clear_browser();
  const std::string& browser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser();
  PROTOBUF_NODISCARD std::string* release_browser();
  void set_allocated_browser(std::string* browser);
  private:
  const std::string& _internal_browser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser(const std::string& value);
  std::string* _internal_mutable_browser();
  public:

  // string browser_version = 8;
  void clear_browser_version();
  const std::string& browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_version();
  PROTOBUF_NODISCARD std::string* release_browser_version();
  void set_allocated_browser_version(std::string* browser_version);
  private:
  const std::string& _internal_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_version(const std::string& value);
  std::string* _internal_mutable_browser_version();
  public:

  // string address = 9;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string network = 10;
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // string other_sdks = 11;
  void clear_other_sdks();
  const std::string& other_sdks() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_other_sdks(ArgT0&& arg0, ArgT... args);
  std::string* mutable_other_sdks();
  PROTOBUF_NODISCARD std::string* release_other_sdks();
  void set_allocated_other_sdks(std::string* other_sdks);
  private:
  const std::string& _internal_other_sdks() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_other_sdks(const std::string& value);
  std::string* _internal_mutable_other_sdks();
  public:

  // .livekit.ClientInfo.SDK sdk = 1;
  void clear_sdk();
  ::livekit::ClientInfo_SDK sdk() const;
  void set_sdk(::livekit::ClientInfo_SDK value);
  private:
  ::livekit::ClientInfo_SDK _internal_sdk() const;
  void _internal_set_sdk(::livekit::ClientInfo_SDK value);
  public:

  // int32 protocol = 3;
  void clear_protocol();
  int32_t protocol() const;
  void set_protocol(int32_t value);
  private:
  int32_t _internal_protocol() const;
  void _internal_set_protocol(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ClientInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr other_sdks_;
    int sdk_;
    int32_t protocol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class ClientConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ClientConfiguration) */ {
 public:
  inline ClientConfiguration() : ClientConfiguration(nullptr) {}
  ~ClientConfiguration() override;
  explicit PROTOBUF_CONSTEXPR ClientConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfiguration(const ClientConfiguration& from);
  ClientConfiguration(ClientConfiguration&& from) noexcept
    : ClientConfiguration() {
    *this = ::std::move(from);
  }

  inline ClientConfiguration& operator=(const ClientConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfiguration& operator=(ClientConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfiguration* internal_default_instance() {
    return reinterpret_cast<const ClientConfiguration*>(
               &_ClientConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ClientConfiguration& a, ClientConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientConfiguration& from) {
    ClientConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ClientConfiguration";
  }
  protected:
  explicit ClientConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoFieldNumber = 1,
    kScreenFieldNumber = 2,
    kDisabledCodecsFieldNumber = 4,
    kResumeConnectionFieldNumber = 3,
    kForceRelayFieldNumber = 5,
  };
  // .livekit.VideoConfiguration video = 1;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::VideoConfiguration& video() const;
  PROTOBUF_NODISCARD ::livekit::VideoConfiguration* release_video();
  ::livekit::VideoConfiguration* mutable_video();
  void set_allocated_video(::livekit::VideoConfiguration* video);
  private:
  const ::livekit::VideoConfiguration& _internal_video() const;
  ::livekit::VideoConfiguration* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::VideoConfiguration* video);
  ::livekit::VideoConfiguration* unsafe_arena_release_video();

  // .livekit.VideoConfiguration screen = 2;
  bool has_screen() const;
  private:
  bool _internal_has_screen() const;
  public:
  void clear_screen();
  const ::livekit::VideoConfiguration& screen() const;
  PROTOBUF_NODISCARD ::livekit::VideoConfiguration* release_screen();
  ::livekit::VideoConfiguration* mutable_screen();
  void set_allocated_screen(::livekit::VideoConfiguration* screen);
  private:
  const ::livekit::VideoConfiguration& _internal_screen() const;
  ::livekit::VideoConfiguration* _internal_mutable_screen();
  public:
  void unsafe_arena_set_allocated_screen(
      ::livekit::VideoConfiguration* screen);
  ::livekit::VideoConfiguration* unsafe_arena_release_screen();

  // .livekit.DisabledCodecs disabled_codecs = 4;
  bool has_disabled_codecs() const;
  private:
  bool _internal_has_disabled_codecs() const;
  public:
  void clear_disabled_codecs();
  const ::livekit::DisabledCodecs& disabled_codecs() const;
  PROTOBUF_NODISCARD ::livekit::DisabledCodecs* release_disabled_codecs();
  ::livekit::DisabledCodecs* mutable_disabled_codecs();
  void set_allocated_disabled_codecs(::livekit::DisabledCodecs* disabled_codecs);
  private:
  const ::livekit::DisabledCodecs& _internal_disabled_codecs() const;
  ::livekit::DisabledCodecs* _internal_mutable_disabled_codecs();
  public:
  void unsafe_arena_set_allocated_disabled_codecs(
      ::livekit::DisabledCodecs* disabled_codecs);
  ::livekit::DisabledCodecs* unsafe_arena_release_disabled_codecs();

  // .livekit.ClientConfigSetting resume_connection = 3;
  void clear_resume_connection();
  ::livekit::ClientConfigSetting resume_connection() const;
  void set_resume_connection(::livekit::ClientConfigSetting value);
  private:
  ::livekit::ClientConfigSetting _internal_resume_connection() const;
  void _internal_set_resume_connection(::livekit::ClientConfigSetting value);
  public:

  // .livekit.ClientConfigSetting force_relay = 5;
  void clear_force_relay();
  ::livekit::ClientConfigSetting force_relay() const;
  void set_force_relay(::livekit::ClientConfigSetting value);
  private:
  ::livekit::ClientConfigSetting _internal_force_relay() const;
  void _internal_set_force_relay(::livekit::ClientConfigSetting value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.ClientConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::VideoConfiguration* video_;
    ::livekit::VideoConfiguration* screen_;
    ::livekit::DisabledCodecs* disabled_codecs_;
    int resume_connection_;
    int force_relay_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class VideoConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.VideoConfiguration) */ {
 public:
  inline VideoConfiguration() : VideoConfiguration(nullptr) {}
  ~VideoConfiguration() override;
  explicit PROTOBUF_CONSTEXPR VideoConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoConfiguration(const VideoConfiguration& from);
  VideoConfiguration(VideoConfiguration&& from) noexcept
    : VideoConfiguration() {
    *this = ::std::move(from);
  }

  inline VideoConfiguration& operator=(const VideoConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoConfiguration& operator=(VideoConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoConfiguration* internal_default_instance() {
    return reinterpret_cast<const VideoConfiguration*>(
               &_VideoConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(VideoConfiguration& a, VideoConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoConfiguration& from) {
    VideoConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.VideoConfiguration";
  }
  protected:
  explicit VideoConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardwareEncoderFieldNumber = 1,
  };
  // .livekit.ClientConfigSetting hardware_encoder = 1;
  void clear_hardware_encoder();
  ::livekit::ClientConfigSetting hardware_encoder() const;
  void set_hardware_encoder(::livekit::ClientConfigSetting value);
  private:
  ::livekit::ClientConfigSetting _internal_hardware_encoder() const;
  void _internal_set_hardware_encoder(::livekit::ClientConfigSetting value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.VideoConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int hardware_encoder_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DisabledCodecs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DisabledCodecs) */ {
 public:
  inline DisabledCodecs() : DisabledCodecs(nullptr) {}
  ~DisabledCodecs() override;
  explicit PROTOBUF_CONSTEXPR DisabledCodecs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisabledCodecs(const DisabledCodecs& from);
  DisabledCodecs(DisabledCodecs&& from) noexcept
    : DisabledCodecs() {
    *this = ::std::move(from);
  }

  inline DisabledCodecs& operator=(const DisabledCodecs& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisabledCodecs& operator=(DisabledCodecs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisabledCodecs& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisabledCodecs* internal_default_instance() {
    return reinterpret_cast<const DisabledCodecs*>(
               &_DisabledCodecs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DisabledCodecs& a, DisabledCodecs& b) {
    a.Swap(&b);
  }
  inline void Swap(DisabledCodecs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisabledCodecs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisabledCodecs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisabledCodecs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisabledCodecs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisabledCodecs& from) {
    DisabledCodecs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisabledCodecs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DisabledCodecs";
  }
  protected:
  explicit DisabledCodecs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecsFieldNumber = 1,
    kPublishFieldNumber = 2,
  };
  // repeated .livekit.Codec codecs = 1;
  int codecs_size() const;
  private:
  int _internal_codecs_size() const;
  public:
  void clear_codecs();
  ::livekit::Codec* mutable_codecs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
      mutable_codecs();
  private:
  const ::livekit::Codec& _internal_codecs(int index) const;
  ::livekit::Codec* _internal_add_codecs();
  public:
  const ::livekit::Codec& codecs(int index) const;
  ::livekit::Codec* add_codecs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
      codecs() const;

  // repeated .livekit.Codec publish = 2;
  int publish_size() const;
  private:
  int _internal_publish_size() const;
  public:
  void clear_publish();
  ::livekit::Codec* mutable_publish(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
      mutable_publish();
  private:
  const ::livekit::Codec& _internal_publish(int index) const;
  ::livekit::Codec* _internal_add_publish();
  public:
  const ::livekit::Codec& publish(int index) const;
  ::livekit::Codec* add_publish();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
      publish() const;

  // @@protoc_insertion_point(class_scope:livekit.DisabledCodecs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec > codecs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec > publish_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTPDrift final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTPDrift) */ {
 public:
  inline RTPDrift() : RTPDrift(nullptr) {}
  ~RTPDrift() override;
  explicit PROTOBUF_CONSTEXPR RTPDrift(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTPDrift(const RTPDrift& from);
  RTPDrift(RTPDrift&& from) noexcept
    : RTPDrift() {
    *this = ::std::move(from);
  }

  inline RTPDrift& operator=(const RTPDrift& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTPDrift& operator=(RTPDrift&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTPDrift& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTPDrift* internal_default_instance() {
    return reinterpret_cast<const RTPDrift*>(
               &_RTPDrift_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RTPDrift& a, RTPDrift& b) {
    a.Swap(&b);
  }
  inline void Swap(RTPDrift* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTPDrift* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTPDrift* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTPDrift>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTPDrift& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTPDrift& from) {
    RTPDrift::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTPDrift* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTPDrift";
  }
  protected:
  explicit RTPDrift(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kDurationFieldNumber = 3,
    kStartTimestampFieldNumber = 4,
    kEndTimestampFieldNumber = 5,
    kRtpClockTicksFieldNumber = 6,
    kDriftSamplesFieldNumber = 7,
    kDriftMsFieldNumber = 8,
    kClockRateFieldNumber = 9,
  };
  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // double duration = 3;
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // uint64 start_timestamp = 4;
  void clear_start_timestamp();
  uint64_t start_timestamp() const;
  void set_start_timestamp(uint64_t value);
  private:
  uint64_t _internal_start_timestamp() const;
  void _internal_set_start_timestamp(uint64_t value);
  public:

  // uint64 end_timestamp = 5;
  void clear_end_timestamp();
  uint64_t end_timestamp() const;
  void set_end_timestamp(uint64_t value);
  private:
  uint64_t _internal_end_timestamp() const;
  void _internal_set_end_timestamp(uint64_t value);
  public:

  // uint64 rtp_clock_ticks = 6;
  void clear_rtp_clock_ticks();
  uint64_t rtp_clock_ticks() const;
  void set_rtp_clock_ticks(uint64_t value);
  private:
  uint64_t _internal_rtp_clock_ticks() const;
  void _internal_set_rtp_clock_ticks(uint64_t value);
  public:

  // int64 drift_samples = 7;
  void clear_drift_samples();
  int64_t drift_samples() const;
  void set_drift_samples(int64_t value);
  private:
  int64_t _internal_drift_samples() const;
  void _internal_set_drift_samples(int64_t value);
  public:

  // double drift_ms = 8;
  void clear_drift_ms();
  double drift_ms() const;
  void set_drift_ms(double value);
  private:
  double _internal_drift_ms() const;
  void _internal_set_drift_ms(double value);
  public:

  // double clock_rate = 9;
  void clear_clock_rate();
  double clock_rate() const;
  void set_clock_rate(double value);
  private:
  double _internal_clock_rate() const;
  void _internal_set_clock_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RTPDrift)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    double duration_;
    uint64_t start_timestamp_;
    uint64_t end_timestamp_;
    uint64_t rtp_clock_ticks_;
    int64_t drift_samples_;
    double drift_ms_;
    double clock_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTPStats_GapHistogramEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTPStats_GapHistogramEntry_DoNotUse, 
    int32_t, uint32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RTPStats_GapHistogramEntry_DoNotUse, 
    int32_t, uint32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> SuperType;
  RTPStats_GapHistogramEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RTPStats_GapHistogramEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RTPStats_GapHistogramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RTPStats_GapHistogramEntry_DoNotUse& other);
  static const RTPStats_GapHistogramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RTPStats_GapHistogramEntry_DoNotUse*>(&_RTPStats_GapHistogramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};

// -------------------------------------------------------------------

class RTPStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTPStats) */ {
 public:
  inline RTPStats() : RTPStats(nullptr) {}
  ~RTPStats() override;
  explicit PROTOBUF_CONSTEXPR RTPStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTPStats(const RTPStats& from);
  RTPStats(RTPStats&& from) noexcept
    : RTPStats() {
    *this = ::std::move(from);
  }

  inline RTPStats& operator=(const RTPStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTPStats& operator=(RTPStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTPStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTPStats* internal_default_instance() {
    return reinterpret_cast<const RTPStats*>(
               &_RTPStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RTPStats& a, RTPStats& b) {
    a.Swap(&b);
  }
  inline void Swap(RTPStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTPStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTPStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTPStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTPStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTPStats& from) {
    RTPStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTPStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTPStats";
  }
  protected:
  explicit RTPStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kGapHistogramFieldNumber = 24,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kLastPliFieldNumber = 28,
    kLastFirFieldNumber = 30,
    kLastKeyFrameFieldNumber = 34,
    kLastLayerLockPliFieldNumber = 36,
    kPacketDriftFieldNumber = 44,
    kNtpReportDriftFieldNumber = 45,
    kRebasedReportDriftFieldNumber = 46,
    kReceivedReportDriftFieldNumber = 47,
    kDurationFieldNumber = 3,
    kPacketRateFieldNumber = 5,
    kBytesFieldNumber = 6,
    kPacketsFieldNumber = 4,
    kPacketsLostFieldNumber = 8,
    kBitrateFieldNumber = 7,
    kPacketLossRateFieldNumber = 9,
    kPacketLossPercentageFieldNumber = 10,
    kPacketsDuplicateFieldNumber = 11,
    kPacketDuplicateRateFieldNumber = 12,
    kBytesDuplicateFieldNumber = 13,
    kBitrateDuplicateFieldNumber = 14,
    kPacketPaddingRateFieldNumber = 16,
    kBytesPaddingFieldNumber = 17,
    kPacketsPaddingFieldNumber = 15,
    kPacketsOutOfOrderFieldNumber = 19,
    kBitratePaddingFieldNumber = 18,
    kFrameRateFieldNumber = 21,
    kJitterCurrentFieldNumber = 22,
    kFramesFieldNumber = 20,
    kNacksFieldNumber = 25,
    kJitterMaxFieldNumber = 23,
    kNackMissesFieldNumber = 26,
    kPlisFieldNumber = 27,
    kFirsFieldNumber = 29,
    kRttCurrentFieldNumber = 31,
    kRttMaxFieldNumber = 32,
    kKeyFramesFieldNumber = 33,
    kLayerLockPlisFieldNumber = 35,
    kNackAcksFieldNumber = 37,
    kHeaderBytesFieldNumber = 39,
    kHeaderBytesDuplicateFieldNumber = 40,
    kHeaderBytesPaddingFieldNumber = 41,
    kNackRepeatedFieldNumber = 38,
  };
  // map<int32, uint32> gap_histogram = 24;
  int gap_histogram_size() const;
  private:
  int _internal_gap_histogram_size() const;
  public:
  void clear_gap_histogram();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
      _internal_gap_histogram() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
      _internal_mutable_gap_histogram();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
      gap_histogram() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
      mutable_gap_histogram();

  // .google.protobuf.Timestamp start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start_time();
  void set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start_time();

  // .google.protobuf.Timestamp end_time = 2;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_time();
  void set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_time();
  public:
  void unsafe_arena_set_allocated_end_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_time();

  // .google.protobuf.Timestamp last_pli = 28;
  bool has_last_pli() const;
  private:
  bool _internal_has_last_pli() const;
  public:
  void clear_last_pli();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_pli() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_pli();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_pli();
  void set_allocated_last_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_pli() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_pli();
  public:
  void unsafe_arena_set_allocated_last_pli(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_pli();

  // .google.protobuf.Timestamp last_fir = 30;
  bool has_last_fir() const;
  private:
  bool _internal_has_last_fir() const;
  public:
  void clear_last_fir();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_fir() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_fir();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_fir();
  void set_allocated_last_fir(::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_fir() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_fir();
  public:
  void unsafe_arena_set_allocated_last_fir(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_fir();

  // .google.protobuf.Timestamp last_key_frame = 34;
  bool has_last_key_frame() const;
  private:
  bool _internal_has_last_key_frame() const;
  public:
  void clear_last_key_frame();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_key_frame() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_key_frame();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_key_frame();
  void set_allocated_last_key_frame(::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_key_frame() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_key_frame();
  public:
  void unsafe_arena_set_allocated_last_key_frame(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_key_frame();

  // .google.protobuf.Timestamp last_layer_lock_pli = 36;
  bool has_last_layer_lock_pli() const;
  private:
  bool _internal_has_last_layer_lock_pli() const;
  public:
  void clear_last_layer_lock_pli();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_layer_lock_pli() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_layer_lock_pli();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_layer_lock_pli();
  void set_allocated_last_layer_lock_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_layer_lock_pli() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_layer_lock_pli();
  public:
  void unsafe_arena_set_allocated_last_layer_lock_pli(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_layer_lock_pli();

  // .livekit.RTPDrift packet_drift = 44;
  bool has_packet_drift() const;
  private:
  bool _internal_has_packet_drift() const;
  public:
  void clear_packet_drift();
  const ::livekit::RTPDrift& packet_drift() const;
  PROTOBUF_NODISCARD ::livekit::RTPDrift* release_packet_drift();
  ::livekit::RTPDrift* mutable_packet_drift();
  void set_allocated_packet_drift(::livekit::RTPDrift* packet_drift);
  private:
  const ::livekit::RTPDrift& _internal_packet_drift() const;
  ::livekit::RTPDrift* _internal_mutable_packet_drift();
  public:
  void unsafe_arena_set_allocated_packet_drift(
      ::livekit::RTPDrift* packet_drift);
  ::livekit::RTPDrift* unsafe_arena_release_packet_drift();

  // .livekit.RTPDrift ntp_report_drift = 45;
  bool has_ntp_report_drift() const;
  private:
  bool _internal_has_ntp_report_drift() const;
  public:
  void clear_ntp_report_drift();
  const ::livekit::RTPDrift& ntp_report_drift() const;
  PROTOBUF_NODISCARD ::livekit::RTPDrift* release_ntp_report_drift();
  ::livekit::RTPDrift* mutable_ntp_report_drift();
  void set_allocated_ntp_report_drift(::livekit::RTPDrift* ntp_report_drift);
  private:
  const ::livekit::RTPDrift& _internal_ntp_report_drift() const;
  ::livekit::RTPDrift* _internal_mutable_ntp_report_drift();
  public:
  void unsafe_arena_set_allocated_ntp_report_drift(
      ::livekit::RTPDrift* ntp_report_drift);
  ::livekit::RTPDrift* unsafe_arena_release_ntp_report_drift();

  // .livekit.RTPDrift rebased_report_drift = 46;
  bool has_rebased_report_drift() const;
  private:
  bool _internal_has_rebased_report_drift() const;
  public:
  void clear_rebased_report_drift();
  const ::livekit::RTPDrift& rebased_report_drift() const;
  PROTOBUF_NODISCARD ::livekit::RTPDrift* release_rebased_report_drift();
  ::livekit::RTPDrift* mutable_rebased_report_drift();
  void set_allocated_rebased_report_drift(::livekit::RTPDrift* rebased_report_drift);
  private:
  const ::livekit::RTPDrift& _internal_rebased_report_drift() const;
  ::livekit::RTPDrift* _internal_mutable_rebased_report_drift();
  public:
  void unsafe_arena_set_allocated_rebased_report_drift(
      ::livekit::RTPDrift* rebased_report_drift);
  ::livekit::RTPDrift* unsafe_arena_release_rebased_report_drift();

  // .livekit.RTPDrift received_report_drift = 47;
  bool has_received_report_drift() const;
  private:
  bool _internal_has_received_report_drift() const;
  public:
  void clear_received_report_drift();
  const ::livekit::RTPDrift& received_report_drift() const;
  PROTOBUF_NODISCARD ::livekit::RTPDrift* release_received_report_drift();
  ::livekit::RTPDrift* mutable_received_report_drift();
  void set_allocated_received_report_drift(::livekit::RTPDrift* received_report_drift);
  private:
  const ::livekit::RTPDrift& _internal_received_report_drift() const;
  ::livekit::RTPDrift* _internal_mutable_received_report_drift();
  public:
  void unsafe_arena_set_allocated_received_report_drift(
      ::livekit::RTPDrift* received_report_drift);
  ::livekit::RTPDrift* unsafe_arena_release_received_report_drift();

  // double duration = 3;
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // double packet_rate = 5;
  void clear_packet_rate();
  double packet_rate() const;
  void set_packet_rate(double value);
  private:
  double _internal_packet_rate() const;
  void _internal_set_packet_rate(double value);
  public:

  // uint64 bytes = 6;
  void clear_bytes();
  uint64_t bytes() const;
  void set_bytes(uint64_t value);
  private:
  uint64_t _internal_bytes() const;
  void _internal_set_bytes(uint64_t value);
  public:

  // uint32 packets = 4;
  void clear_packets();
  uint32_t packets() const;
  void set_packets(uint32_t value);
  private:
  uint32_t _internal_packets() const;
  void _internal_set_packets(uint32_t value);
  public:

  // uint32 packets_lost = 8;
  void clear_packets_lost();
  uint32_t packets_lost() const;
  void set_packets_lost(uint32_t value);
  private:
  uint32_t _internal_packets_lost() const;
  void _internal_set_packets_lost(uint32_t value);
  public:

  // double bitrate = 7;
  void clear_bitrate();
  double bitrate() const;
  void set_bitrate(double value);
  private:
  double _internal_bitrate() const;
  void _internal_set_bitrate(double value);
  public:

  // double packet_loss_rate = 9;
  void clear_packet_loss_rate();
  double packet_loss_rate() const;
  void set_packet_loss_rate(double value);
  private:
  double _internal_packet_loss_rate() const;
  void _internal_set_packet_loss_rate(double value);
  public:

  // float packet_loss_percentage = 10;
  void clear_packet_loss_percentage();
  float packet_loss_percentage() const;
  void set_packet_loss_percentage(float value);
  private:
  float _internal_packet_loss_percentage() const;
  void _internal_set_packet_loss_percentage(float value);
  public:

  // uint32 packets_duplicate = 11;
  void clear_packets_duplicate();
  uint32_t packets_duplicate() const;
  void set_packets_duplicate(uint32_t value);
  private:
  uint32_t _internal_packets_duplicate() const;
  void _internal_set_packets_duplicate(uint32_t value);
  public:

  // double packet_duplicate_rate = 12;
  void clear_packet_duplicate_rate();
  double packet_duplicate_rate() const;
  void set_packet_duplicate_rate(double value);
  private:
  double _internal_packet_duplicate_rate() const;
  void _internal_set_packet_duplicate_rate(double value);
  public:

  // uint64 bytes_duplicate = 13;
  void clear_bytes_duplicate();
  uint64_t bytes_duplicate() const;
  void set_bytes_duplicate(uint64_t value);
  private:
  uint64_t _internal_bytes_duplicate() const;
  void _internal_set_bytes_duplicate(uint64_t value);
  public:

  // double bitrate_duplicate = 14;
  void clear_bitrate_duplicate();
  double bitrate_duplicate() const;
  void set_bitrate_duplicate(double value);
  private:
  double _internal_bitrate_duplicate() const;
  void _internal_set_bitrate_duplicate(double value);
  public:

  // double packet_padding_rate = 16;
  void clear_packet_padding_rate();
  double packet_padding_rate() const;
  void set_packet_padding_rate(double value);
  private:
  double _internal_packet_padding_rate() const;
  void _internal_set_packet_padding_rate(double value);
  public:

  // uint64 bytes_padding = 17;
  void clear_bytes_padding();
  uint64_t bytes_padding() const;
  void set_bytes_padding(uint64_t value);
  private:
  uint64_t _internal_bytes_padding() const;
  void _internal_set_bytes_padding(uint64_t value);
  public:

  // uint32 packets_padding = 15;
  void clear_packets_padding();
  uint32_t packets_padding() const;
  void set_packets_padding(uint32_t value);
  private:
  uint32_t _internal_packets_padding() const;
  void _internal_set_packets_padding(uint32_t value);
  public:

  // uint32 packets_out_of_order = 19;
  void clear_packets_out_of_order();
  uint32_t packets_out_of_order() const;
  void set_packets_out_of_order(uint32_t value);
  private:
  uint32_t _internal_packets_out_of_order() const;
  void _internal_set_packets_out_of_order(uint32_t value);
  public:

  // double bitrate_padding = 18;
  void clear_bitrate_padding();
  double bitrate_padding() const;
  void set_bitrate_padding(double value);
  private:
  double _internal_bitrate_padding() const;
  void _internal_set_bitrate_padding(double value);
  public:

  // double frame_rate = 21;
  void clear_frame_rate();
  double frame_rate() const;
  void set_frame_rate(double value);
  private:
  double _internal_frame_rate() const;
  void _internal_set_frame_rate(double value);
  public:

  // double jitter_current = 22;
  void clear_jitter_current();
  double jitter_current() const;
  void set_jitter_current(double value);
  private:
  double _internal_jitter_current() const;
  void _internal_set_jitter_current(double value);
  public:

  // uint32 frames = 20;
  void clear_frames();
  uint32_t frames() const;
  void set_frames(uint32_t value);
  private:
  uint32_t _internal_frames() const;
  void _internal_set_frames(uint32_t value);
  public:

  // uint32 nacks = 25;
  void clear_nacks();
  uint32_t nacks() const;
  void set_nacks(uint32_t value);
  private:
  uint32_t _internal_nacks() const;
  void _internal_set_nacks(uint32_t value);
  public:

  // double jitter_max = 23;
  void clear_jitter_max();
  double jitter_max() const;
  void set_jitter_max(double value);
  private:
  double _internal_jitter_max() const;
  void _internal_set_jitter_max(double value);
  public:

  // uint32 nack_misses = 26;
  void clear_nack_misses();
  uint32_t nack_misses() const;
  void set_nack_misses(uint32_t value);
  private:
  uint32_t _internal_nack_misses() const;
  void _internal_set_nack_misses(uint32_t value);
  public:

  // uint32 plis = 27;
  void clear_plis();
  uint32_t plis() const;
  void set_plis(uint32_t value);
  private:
  uint32_t _internal_plis() const;
  void _internal_set_plis(uint32_t value);
  public:

  // uint32 firs = 29;
  void clear_firs();
  uint32_t firs() const;
  void set_firs(uint32_t value);
  private:
  uint32_t _internal_firs() const;
  void _internal_set_firs(uint32_t value);
  public:

  // uint32 rtt_current = 31;
  void clear_rtt_current();
  uint32_t rtt_current() const;
  void set_rtt_current(uint32_t value);
  private:
  uint32_t _internal_rtt_current() const;
  void _internal_set_rtt_current(uint32_t value);
  public:

  // uint32 rtt_max = 32;
  void clear_rtt_max();
  uint32_t rtt_max() const;
  void set_rtt_max(uint32_t value);
  private:
  uint32_t _internal_rtt_max() const;
  void _internal_set_rtt_max(uint32_t value);
  public:

  // uint32 key_frames = 33;
  void clear_key_frames();
  uint32_t key_frames() const;
  void set_key_frames(uint32_t value);
  private:
  uint32_t _internal_key_frames() const;
  void _internal_set_key_frames(uint32_t value);
  public:

  // uint32 layer_lock_plis = 35;
  void clear_layer_lock_plis();
  uint32_t layer_lock_plis() const;
  void set_layer_lock_plis(uint32_t value);
  private:
  uint32_t _internal_layer_lock_plis() const;
  void _internal_set_layer_lock_plis(uint32_t value);
  public:

  // uint32 nack_acks = 37;
  void clear_nack_acks();
  uint32_t nack_acks() const;
  void set_nack_acks(uint32_t value);
  private:
  uint32_t _internal_nack_acks() const;
  void _internal_set_nack_acks(uint32_t value);
  public:

  // uint64 header_bytes = 39;
  void clear_header_bytes();
  uint64_t header_bytes() const;
  void set_header_bytes(uint64_t value);
  private:
  uint64_t _internal_header_bytes() const;
  void _internal_set_header_bytes(uint64_t value);
  public:

  // uint64 header_bytes_duplicate = 40;
  void clear_header_bytes_duplicate();
  uint64_t header_bytes_duplicate() const;
  void set_header_bytes_duplicate(uint64_t value);
  private:
  uint64_t _internal_header_bytes_duplicate() const;
  void _internal_set_header_bytes_duplicate(uint64_t value);
  public:

  // uint64 header_bytes_padding = 41;
  void clear_header_bytes_padding();
  uint64_t header_bytes_padding() const;
  void set_header_bytes_padding(uint64_t value);
  private:
  uint64_t _internal_header_bytes_padding() const;
  void _internal_set_header_bytes_padding(uint64_t value);
  public:

  // uint32 nack_repeated = 38;
  void clear_nack_repeated();
  uint32_t nack_repeated() const;
  void set_nack_repeated(uint32_t value);
  private:
  uint32_t _internal_nack_repeated() const;
  void _internal_set_nack_repeated(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RTPStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RTPStats_GapHistogramEntry_DoNotUse,
        int32_t, uint32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> gap_histogram_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli_;
    ::livekit::RTPDrift* packet_drift_;
    ::livekit::RTPDrift* ntp_report_drift_;
    ::livekit::RTPDrift* rebased_report_drift_;
    ::livekit::RTPDrift* received_report_drift_;
    double duration_;
    double packet_rate_;
    uint64_t bytes_;
    uint32_t packets_;
    uint32_t packets_lost_;
    double bitrate_;
    double packet_loss_rate_;
    float packet_loss_percentage_;
    uint32_t packets_duplicate_;
    double packet_duplicate_rate_;
    uint64_t bytes_duplicate_;
    double bitrate_duplicate_;
    double packet_padding_rate_;
    uint64_t bytes_padding_;
    uint32_t packets_padding_;
    uint32_t packets_out_of_order_;
    double bitrate_padding_;
    double frame_rate_;
    double jitter_current_;
    uint32_t frames_;
    uint32_t nacks_;
    double jitter_max_;
    uint32_t nack_misses_;
    uint32_t plis_;
    uint32_t firs_;
    uint32_t rtt_current_;
    uint32_t rtt_max_;
    uint32_t key_frames_;
    uint32_t layer_lock_plis_;
    uint32_t nack_acks_;
    uint64_t header_bytes_;
    uint64_t header_bytes_duplicate_;
    uint64_t header_bytes_padding_;
    uint32_t nack_repeated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTCPSenderReportState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTCPSenderReportState) */ {
 public:
  inline RTCPSenderReportState() : RTCPSenderReportState(nullptr) {}
  ~RTCPSenderReportState() override;
  explicit PROTOBUF_CONSTEXPR RTCPSenderReportState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTCPSenderReportState(const RTCPSenderReportState& from);
  RTCPSenderReportState(RTCPSenderReportState&& from) noexcept
    : RTCPSenderReportState() {
    *this = ::std::move(from);
  }

  inline RTCPSenderReportState& operator=(const RTCPSenderReportState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTCPSenderReportState& operator=(RTCPSenderReportState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTCPSenderReportState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTCPSenderReportState* internal_default_instance() {
    return reinterpret_cast<const RTCPSenderReportState*>(
               &_RTCPSenderReportState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RTCPSenderReportState& a, RTCPSenderReportState& b) {
    a.Swap(&b);
  }
  inline void Swap(RTCPSenderReportState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTCPSenderReportState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTCPSenderReportState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTCPSenderReportState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTCPSenderReportState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTCPSenderReportState& from) {
    RTCPSenderReportState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTCPSenderReportState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTCPSenderReportState";
  }
  protected:
  explicit RTCPSenderReportState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRtpTimestampExtFieldNumber = 2,
    kNtpTimestampFieldNumber = 3,
    kRtpTimestampFieldNumber = 1,
    kPacketsFieldNumber = 6,
    kAtFieldNumber = 4,
    kAtAdjustedFieldNumber = 5,
    kOctetsFieldNumber = 7,
  };
  // uint64 rtp_timestamp_ext = 2;
  void clear_rtp_timestamp_ext();
  uint64_t rtp_timestamp_ext() const;
  void set_rtp_timestamp_ext(uint64_t value);
  private:
  uint64_t _internal_rtp_timestamp_ext() const;
  void _internal_set_rtp_timestamp_ext(uint64_t value);
  public:

  // uint64 ntp_timestamp = 3;
  void clear_ntp_timestamp();
  uint64_t ntp_timestamp() const;
  void set_ntp_timestamp(uint64_t value);
  private:
  uint64_t _internal_ntp_timestamp() const;
  void _internal_set_ntp_timestamp(uint64_t value);
  public:

  // uint32 rtp_timestamp = 1;
  void clear_rtp_timestamp();
  uint32_t rtp_timestamp() const;
  void set_rtp_timestamp(uint32_t value);
  private:
  uint32_t _internal_rtp_timestamp() const;
  void _internal_set_rtp_timestamp(uint32_t value);
  public:

  // uint32 packets = 6;
  void clear_packets();
  uint32_t packets() const;
  void set_packets(uint32_t value);
  private:
  uint32_t _internal_packets() const;
  void _internal_set_packets(uint32_t value);
  public:

  // int64 at = 4;
  void clear_at();
  int64_t at() const;
  void set_at(int64_t value);
  private:
  int64_t _internal_at() const;
  void _internal_set_at(int64_t value);
  public:

  // int64 at_adjusted = 5;
  void clear_at_adjusted();
  int64_t at_adjusted() const;
  void set_at_adjusted(int64_t value);
  private:
  int64_t _internal_at_adjusted() const;
  void _internal_set_at_adjusted(int64_t value);
  public:

  // uint64 octets = 7;
  void clear_octets();
  uint64_t octets() const;
  void set_octets(uint64_t value);
  private:
  uint64_t _internal_octets() const;
  void _internal_set_octets(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RTCPSenderReportState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t rtp_timestamp_ext_;
    uint64_t ntp_timestamp_;
    uint32_t rtp_timestamp_;
    uint32_t packets_;
    int64_t at_;
    int64_t at_adjusted_;
    uint64_t octets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTPForwarderState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTPForwarderState) */ {
 public:
  inline RTPForwarderState() : RTPForwarderState(nullptr) {}
  ~RTPForwarderState() override;
  explicit PROTOBUF_CONSTEXPR RTPForwarderState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTPForwarderState(const RTPForwarderState& from);
  RTPForwarderState(RTPForwarderState&& from) noexcept
    : RTPForwarderState() {
    *this = ::std::move(from);
  }

  inline RTPForwarderState& operator=(const RTPForwarderState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTPForwarderState& operator=(RTPForwarderState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTPForwarderState& default_instance() {
    return *internal_default_instance();
  }
  enum CodecMungerCase {
    kVp8Munger = 7,
    CODEC_MUNGER_NOT_SET = 0,
  };

  static inline const RTPForwarderState* internal_default_instance() {
    return reinterpret_cast<const RTPForwarderState*>(
               &_RTPForwarderState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RTPForwarderState& a, RTPForwarderState& b) {
    a.Swap(&b);
  }
  inline void Swap(RTPForwarderState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTPForwarderState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTPForwarderState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTPForwarderState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTPForwarderState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTPForwarderState& from) {
    RTPForwarderState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTPForwarderState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTPForwarderState";
  }
  protected:
  explicit RTPForwarderState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderReportStateFieldNumber = 8,
    kRtpMungerFieldNumber = 6,
    kStartedFieldNumber = 1,
    kReferenceLayerSpatialFieldNumber = 2,
    kPreStartTimeFieldNumber = 3,
    kExtFirstTimestampFieldNumber = 4,
    kDummyStartTimestampOffsetFieldNumber = 5,
    kVp8MungerFieldNumber = 7,
  };
  // repeated .livekit.RTCPSenderReportState sender_report_state = 8;
  int sender_report_state_size() const;
  private:
  int _internal_sender_report_state_size() const;
  public:
  void clear_sender_report_state();
  ::livekit::RTCPSenderReportState* mutable_sender_report_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RTCPSenderReportState >*
      mutable_sender_report_state();
  private:
  const ::livekit::RTCPSenderReportState& _internal_sender_report_state(int index) const;
  ::livekit::RTCPSenderReportState* _internal_add_sender_report_state();
  public:
  const ::livekit::RTCPSenderReportState& sender_report_state(int index) const;
  ::livekit::RTCPSenderReportState* add_sender_report_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RTCPSenderReportState >&
      sender_report_state() const;

  // .livekit.RTPMungerState rtp_munger = 6;
  bool has_rtp_munger() const;
  private:
  bool _internal_has_rtp_munger() const;
  public:
  void clear_rtp_munger();
  const ::livekit::RTPMungerState& rtp_munger() const;
  PROTOBUF_NODISCARD ::livekit::RTPMungerState* release_rtp_munger();
  ::livekit::RTPMungerState* mutable_rtp_munger();
  void set_allocated_rtp_munger(::livekit::RTPMungerState* rtp_munger);
  private:
  const ::livekit::RTPMungerState& _internal_rtp_munger() const;
  ::livekit::RTPMungerState* _internal_mutable_rtp_munger();
  public:
  void unsafe_arena_set_allocated_rtp_munger(
      ::livekit::RTPMungerState* rtp_munger);
  ::livekit::RTPMungerState* unsafe_arena_release_rtp_munger();

  // bool started = 1;
  void clear_started();
  bool started() const;
  void set_started(bool value);
  private:
  bool _internal_started() const;
  void _internal_set_started(bool value);
  public:

  // int32 reference_layer_spatial = 2;
  void clear_reference_layer_spatial();
  int32_t reference_layer_spatial() const;
  void set_reference_layer_spatial(int32_t value);
  private:
  int32_t _internal_reference_layer_spatial() const;
  void _internal_set_reference_layer_spatial(int32_t value);
  public:

  // int64 pre_start_time = 3;
  void clear_pre_start_time();
  int64_t pre_start_time() const;
  void set_pre_start_time(int64_t value);
  private:
  int64_t _internal_pre_start_time() const;
  void _internal_set_pre_start_time(int64_t value);
  public:

  // uint64 ext_first_timestamp = 4;
  void clear_ext_first_timestamp();
  uint64_t ext_first_timestamp() const;
  void set_ext_first_timestamp(uint64_t value);
  private:
  uint64_t _internal_ext_first_timestamp() const;
  void _internal_set_ext_first_timestamp(uint64_t value);
  public:

  // uint64 dummy_start_timestamp_offset = 5;
  void clear_dummy_start_timestamp_offset();
  uint64_t dummy_start_timestamp_offset() const;
  void set_dummy_start_timestamp_offset(uint64_t value);
  private:
  uint64_t _internal_dummy_start_timestamp_offset() const;
  void _internal_set_dummy_start_timestamp_offset(uint64_t value);
  public:

  // .livekit.VP8MungerState vp8_munger = 7;
  bool has_vp8_munger() const;
  private:
  bool _internal_has_vp8_munger() const;
  public:
  void clear_vp8_munger();
  const ::livekit::VP8MungerState& vp8_munger() const;
  PROTOBUF_NODISCARD ::livekit::VP8MungerState* release_vp8_munger();
  ::livekit::VP8MungerState* mutable_vp8_munger();
  void set_allocated_vp8_munger(::livekit::VP8MungerState* vp8_munger);
  private:
  const ::livekit::VP8MungerState& _internal_vp8_munger() const;
  ::livekit::VP8MungerState* _internal_mutable_vp8_munger();
  public:
  void unsafe_arena_set_allocated_vp8_munger(
      ::livekit::VP8MungerState* vp8_munger);
  ::livekit::VP8MungerState* unsafe_arena_release_vp8_munger();

  void clear_codec_munger();
  CodecMungerCase codec_munger_case() const;
  // @@protoc_insertion_point(class_scope:livekit.RTPForwarderState)
 private:
  class _Internal;
  void set_has_vp8_munger();

  inline bool has_codec_munger() const;
  inline void clear_has_codec_munger();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RTCPSenderReportState > sender_report_state_;
    ::livekit::RTPMungerState* rtp_munger_;
    bool started_;
    int32_t reference_layer_spatial_;
    int64_t pre_start_time_;
    uint64_t ext_first_timestamp_;
    uint64_t dummy_start_timestamp_offset_;
    union CodecMungerUnion {
      constexpr CodecMungerUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::VP8MungerState* vp8_munger_;
    } codec_munger_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class RTPMungerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RTPMungerState) */ {
 public:
  inline RTPMungerState() : RTPMungerState(nullptr) {}
  ~RTPMungerState() override;
  explicit PROTOBUF_CONSTEXPR RTPMungerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RTPMungerState(const RTPMungerState& from);
  RTPMungerState(RTPMungerState&& from) noexcept
    : RTPMungerState() {
    *this = ::std::move(from);
  }

  inline RTPMungerState& operator=(const RTPMungerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RTPMungerState& operator=(RTPMungerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RTPMungerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RTPMungerState* internal_default_instance() {
    return reinterpret_cast<const RTPMungerState*>(
               &_RTPMungerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RTPMungerState& a, RTPMungerState& b) {
    a.Swap(&b);
  }
  inline void Swap(RTPMungerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RTPMungerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RTPMungerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RTPMungerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RTPMungerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RTPMungerState& from) {
    RTPMungerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTPMungerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RTPMungerState";
  }
  protected:
  explicit RTPMungerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtLastSequenceNumberFieldNumber = 1,
    kExtSecondLastSequenceNumberFieldNumber = 2,
    kExtLastTimestampFieldNumber = 3,
    kExtSecondLastTimestampFieldNumber = 4,
    kLastMarkerFieldNumber = 5,
    kSecondLastMarkerFieldNumber = 6,
  };
  // uint64 ext_last_sequence_number = 1;
  void clear_ext_last_sequence_number();
  uint64_t ext_last_sequence_number() const;
  void set_ext_last_sequence_number(uint64_t value);
  private:
  uint64_t _internal_ext_last_sequence_number() const;
  void _internal_set_ext_last_sequence_number(uint64_t value);
  public:

  // uint64 ext_second_last_sequence_number = 2;
  void clear_ext_second_last_sequence_number();
  uint64_t ext_second_last_sequence_number() const;
  void set_ext_second_last_sequence_number(uint64_t value);
  private:
  uint64_t _internal_ext_second_last_sequence_number() const;
  void _internal_set_ext_second_last_sequence_number(uint64_t value);
  public:

  // uint64 ext_last_timestamp = 3;
  void clear_ext_last_timestamp();
  uint64_t ext_last_timestamp() const;
  void set_ext_last_timestamp(uint64_t value);
  private:
  uint64_t _internal_ext_last_timestamp() const;
  void _internal_set_ext_last_timestamp(uint64_t value);
  public:

  // uint64 ext_second_last_timestamp = 4;
  void clear_ext_second_last_timestamp();
  uint64_t ext_second_last_timestamp() const;
  void set_ext_second_last_timestamp(uint64_t value);
  private:
  uint64_t _internal_ext_second_last_timestamp() const;
  void _internal_set_ext_second_last_timestamp(uint64_t value);
  public:

  // bool last_marker = 5;
  void clear_last_marker();
  bool last_marker() const;
  void set_last_marker(bool value);
  private:
  bool _internal_last_marker() const;
  void _internal_set_last_marker(bool value);
  public:

  // bool second_last_marker = 6;
  void clear_second_last_marker();
  bool second_last_marker() const;
  void set_second_last_marker(bool value);
  private:
  bool _internal_second_last_marker() const;
  void _internal_set_second_last_marker(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RTPMungerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t ext_last_sequence_number_;
    uint64_t ext_second_last_sequence_number_;
    uint64_t ext_last_timestamp_;
    uint64_t ext_second_last_timestamp_;
    bool last_marker_;
    bool second_last_marker_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class VP8MungerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.VP8MungerState) */ {
 public:
  inline VP8MungerState() : VP8MungerState(nullptr) {}
  ~VP8MungerState() override;
  explicit PROTOBUF_CONSTEXPR VP8MungerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VP8MungerState(const VP8MungerState& from);
  VP8MungerState(VP8MungerState&& from) noexcept
    : VP8MungerState() {
    *this = ::std::move(from);
  }

  inline VP8MungerState& operator=(const VP8MungerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VP8MungerState& operator=(VP8MungerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VP8MungerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VP8MungerState* internal_default_instance() {
    return reinterpret_cast<const VP8MungerState*>(
               &_VP8MungerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(VP8MungerState& a, VP8MungerState& b) {
    a.Swap(&b);
  }
  inline void Swap(VP8MungerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VP8MungerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VP8MungerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VP8MungerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VP8MungerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VP8MungerState& from) {
    VP8MungerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VP8MungerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.VP8MungerState";
  }
  protected:
  explicit VP8MungerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtLastPictureIdFieldNumber = 1,
    kLastTl0PicIdxFieldNumber = 3,
    kPictureIdUsedFieldNumber = 2,
    kTl0PicIdxUsedFieldNumber = 4,
    kTidUsedFieldNumber = 5,
    kKeyIdxUsedFieldNumber = 7,
    kLastKeyIdxFieldNumber = 6,
  };
  // int32 ext_last_picture_id = 1;
  void clear_ext_last_picture_id();
  int32_t ext_last_picture_id() const;
  void set_ext_last_picture_id(int32_t value);
  private:
  int32_t _internal_ext_last_picture_id() const;
  void _internal_set_ext_last_picture_id(int32_t value);
  public:

  // uint32 last_tl0_pic_idx = 3;
  void clear_last_tl0_pic_idx();
  uint32_t last_tl0_pic_idx() const;
  void set_last_tl0_pic_idx(uint32_t value);
  private:
  uint32_t _internal_last_tl0_pic_idx() const;
  void _internal_set_last_tl0_pic_idx(uint32_t value);
  public:

  // bool picture_id_used = 2;
  void clear_picture_id_used();
  bool picture_id_used() const;
  void set_picture_id_used(bool value);
  private:
  bool _internal_picture_id_used() const;
  void _internal_set_picture_id_used(bool value);
  public:

  // bool tl0_pic_idx_used = 4;
  void clear_tl0_pic_idx_used();
  bool tl0_pic_idx_used() const;
  void set_tl0_pic_idx_used(bool value);
  private:
  bool _internal_tl0_pic_idx_used() const;
  void _internal_set_tl0_pic_idx_used(bool value);
  public:

  // bool tid_used = 5;
  void clear_tid_used();
  bool tid_used() const;
  void set_tid_used(bool value);
  private:
  bool _internal_tid_used() const;
  void _internal_set_tid_used(bool value);
  public:

  // bool key_idx_used = 7;
  void clear_key_idx_used();
  bool key_idx_used() const;
  void set_key_idx_used(bool value);
  private:
  bool _internal_key_idx_used() const;
  void _internal_set_key_idx_used(bool value);
  public:

  // uint32 last_key_idx = 6;
  void clear_last_key_idx();
  uint32_t last_key_idx() const;
  void set_last_key_idx(uint32_t value);
  private:
  uint32_t _internal_last_key_idx() const;
  void _internal_set_last_key_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.VP8MungerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t ext_last_picture_id_;
    uint32_t last_tl0_pic_idx_;
    bool picture_id_used_;
    bool tl0_pic_idx_used_;
    bool tid_used_;
    bool key_idx_used_;
    uint32_t last_key_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class TimedVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.TimedVersion) */ {
 public:
  inline TimedVersion() : TimedVersion(nullptr) {}
  ~TimedVersion() override;
  explicit PROTOBUF_CONSTEXPR TimedVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimedVersion(const TimedVersion& from);
  TimedVersion(TimedVersion&& from) noexcept
    : TimedVersion() {
    *this = ::std::move(from);
  }

  inline TimedVersion& operator=(const TimedVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimedVersion& operator=(TimedVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimedVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimedVersion* internal_default_instance() {
    return reinterpret_cast<const TimedVersion*>(
               &_TimedVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(TimedVersion& a, TimedVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(TimedVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimedVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimedVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimedVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimedVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimedVersion& from) {
    TimedVersion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimedVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.TimedVersion";
  }
  protected:
  explicit TimedVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnixMicroFieldNumber = 1,
    kTicksFieldNumber = 2,
  };
  // int64 unix_micro = 1;
  void clear_unix_micro();
  int64_t unix_micro() const;
  void set_unix_micro(int64_t value);
  private:
  int64_t _internal_unix_micro() const;
  void _internal_set_unix_micro(int64_t value);
  public:

  // int32 ticks = 2;
  void clear_ticks();
  int32_t ticks() const;
  void set_ticks(int32_t value);
  private:
  int32_t _internal_ticks() const;
  void _internal_set_ticks(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.TimedVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t unix_micro_;
    int32_t ticks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream_TextHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataStream.TextHeader) */ {
 public:
  inline DataStream_TextHeader() : DataStream_TextHeader(nullptr) {}
  ~DataStream_TextHeader() override;
  explicit PROTOBUF_CONSTEXPR DataStream_TextHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_TextHeader(const DataStream_TextHeader& from);
  DataStream_TextHeader(DataStream_TextHeader&& from) noexcept
    : DataStream_TextHeader() {
    *this = ::std::move(from);
  }

  inline DataStream_TextHeader& operator=(const DataStream_TextHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_TextHeader& operator=(DataStream_TextHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_TextHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_TextHeader* internal_default_instance() {
    return reinterpret_cast<const DataStream_TextHeader*>(
               &_DataStream_TextHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DataStream_TextHeader& a, DataStream_TextHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_TextHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_TextHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_TextHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_TextHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_TextHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_TextHeader& from) {
    DataStream_TextHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_TextHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream.TextHeader";
  }
  protected:
  explicit DataStream_TextHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedStreamIdsFieldNumber = 4,
    kReplyToStreamIdFieldNumber = 3,
    kOperationTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kGeneratedFieldNumber = 5,
  };
  // repeated string attached_stream_ids = 4;
  int attached_stream_ids_size() const;
  private:
  int _internal_attached_stream_ids_size() const;
  public:
  void clear_attached_stream_ids();
  const std::string& attached_stream_ids(int index) const;
  std::string* mutable_attached_stream_ids(int index);
  void set_attached_stream_ids(int index, const std::string& value);
  void set_attached_stream_ids(int index, std::string&& value);
  void set_attached_stream_ids(int index, const char* value);
  void set_attached_stream_ids(int index, const char* value, size_t size);
  std::string* add_attached_stream_ids();
  void add_attached_stream_ids(const std::string& value);
  void add_attached_stream_ids(std::string&& value);
  void add_attached_stream_ids(const char* value);
  void add_attached_stream_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attached_stream_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attached_stream_ids();
  private:
  const std::string& _internal_attached_stream_ids(int index) const;
  std::string* _internal_add_attached_stream_ids();
  public:

  // string reply_to_stream_id = 3;
  void clear_reply_to_stream_id();
  const std::string& reply_to_stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to_stream_id();
  PROTOBUF_NODISCARD std::string* release_reply_to_stream_id();
  void set_allocated_reply_to_stream_id(std::string* reply_to_stream_id);
  private:
  const std::string& _internal_reply_to_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to_stream_id(const std::string& value);
  std::string* _internal_mutable_reply_to_stream_id();
  public:

  // .livekit.DataStream.OperationType operation_type = 1;
  void clear_operation_type();
  ::livekit::DataStream_OperationType operation_type() const;
  void set_operation_type(::livekit::DataStream_OperationType value);
  private:
  ::livekit::DataStream_OperationType _internal_operation_type() const;
  void _internal_set_operation_type(::livekit::DataStream_OperationType value);
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // bool generated = 5;
  void clear_generated();
  bool generated() const;
  void set_generated(bool value);
  private:
  bool _internal_generated() const;
  void _internal_set_generated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataStream.TextHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attached_stream_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_stream_id_;
    int operation_type_;
    int32_t version_;
    bool generated_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream_ByteHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataStream.ByteHeader) */ {
 public:
  inline DataStream_ByteHeader() : DataStream_ByteHeader(nullptr) {}
  ~DataStream_ByteHeader() override;
  explicit PROTOBUF_CONSTEXPR DataStream_ByteHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_ByteHeader(const DataStream_ByteHeader& from);
  DataStream_ByteHeader(DataStream_ByteHeader&& from) noexcept
    : DataStream_ByteHeader() {
    *this = ::std::move(from);
  }

  inline DataStream_ByteHeader& operator=(const DataStream_ByteHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_ByteHeader& operator=(DataStream_ByteHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_ByteHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_ByteHeader* internal_default_instance() {
    return reinterpret_cast<const DataStream_ByteHeader*>(
               &_DataStream_ByteHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DataStream_ByteHeader& a, DataStream_ByteHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_ByteHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_ByteHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_ByteHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_ByteHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_ByteHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_ByteHeader& from) {
    DataStream_ByteHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_ByteHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream.ByteHeader";
  }
  protected:
  explicit DataStream_ByteHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataStream.ByteHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Header_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Header_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Header_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DataStream_Header_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataStream_Header_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataStream_Header_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataStream_Header_AttributesEntry_DoNotUse& other);
  static const DataStream_Header_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataStream_Header_AttributesEntry_DoNotUse*>(&_DataStream_Header_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.DataStream.Header.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.DataStream.Header.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};

// -------------------------------------------------------------------

class DataStream_Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataStream.Header) */ {
 public:
  inline DataStream_Header() : DataStream_Header(nullptr) {}
  ~DataStream_Header() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Header(const DataStream_Header& from);
  DataStream_Header(DataStream_Header&& from) noexcept
    : DataStream_Header() {
    *this = ::std::move(from);
  }

  inline DataStream_Header& operator=(const DataStream_Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Header& operator=(DataStream_Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Header& default_instance() {
    return *internal_default_instance();
  }
  enum ContentHeaderCase {
    kTextHeader = 9,
    kByteHeader = 10,
    CONTENT_HEADER_NOT_SET = 0,
  };

  static inline const DataStream_Header* internal_default_instance() {
    return reinterpret_cast<const DataStream_Header*>(
               &_DataStream_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DataStream_Header& a, DataStream_Header& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Header& from) {
    DataStream_Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream.Header";
  }
  protected:
  explicit DataStream_Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 8,
    kStreamIdFieldNumber = 1,
    kTopicFieldNumber = 3,
    kMimeTypeFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kTotalLengthFieldNumber = 5,
    kEncryptionTypeFieldNumber = 7,
    kTextHeaderFieldNumber = 9,
    kByteHeaderFieldNumber = 10,
  };
  // map<string, string> attributes = 8;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // string topic = 3;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // string mime_type = 4;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional uint64 total_length = 5;
  bool has_total_length() const;
  private:
  bool _internal_has_total_length() const;
  public:
  void clear_total_length();
  uint64_t total_length() const;
  void set_total_length(uint64_t value);
  private:
  uint64_t _internal_total_length() const;
  void _internal_set_total_length(uint64_t value);
  public:

  // .livekit.Encryption.Type encryption_type = 7;
  void clear_encryption_type();
  ::livekit::Encryption_Type encryption_type() const;
  void set_encryption_type(::livekit::Encryption_Type value);
  private:
  ::livekit::Encryption_Type _internal_encryption_type() const;
  void _internal_set_encryption_type(::livekit::Encryption_Type value);
  public:

  // .livekit.DataStream.TextHeader text_header = 9;
  bool has_text_header() const;
  private:
  bool _internal_has_text_header() const;
  public:
  void clear_text_header();
  const ::livekit::DataStream_TextHeader& text_header() const;
  PROTOBUF_NODISCARD ::livekit::DataStream_TextHeader* release_text_header();
  ::livekit::DataStream_TextHeader* mutable_text_header();
  void set_allocated_text_header(::livekit::DataStream_TextHeader* text_header);
  private:
  const ::livekit::DataStream_TextHeader& _internal_text_header() const;
  ::livekit::DataStream_TextHeader* _internal_mutable_text_header();
  public:
  void unsafe_arena_set_allocated_text_header(
      ::livekit::DataStream_TextHeader* text_header);
  ::livekit::DataStream_TextHeader* unsafe_arena_release_text_header();

  // .livekit.DataStream.ByteHeader byte_header = 10;
  bool has_byte_header() const;
  private:
  bool _internal_has_byte_header() const;
  public:
  void clear_byte_header();
  const ::livekit::DataStream_ByteHeader& byte_header() const;
  PROTOBUF_NODISCARD ::livekit::DataStream_ByteHeader* release_byte_header();
  ::livekit::DataStream_ByteHeader* mutable_byte_header();
  void set_allocated_byte_header(::livekit::DataStream_ByteHeader* byte_header);
  private:
  const ::livekit::DataStream_ByteHeader& _internal_byte_header() const;
  ::livekit::DataStream_ByteHeader* _internal_mutable_byte_header();
  public:
  void unsafe_arena_set_allocated_byte_header(
      ::livekit::DataStream_ByteHeader* byte_header);
  ::livekit::DataStream_ByteHeader* unsafe_arena_release_byte_header();

  void clear_content_header();
  ContentHeaderCase content_header_case() const;
  // @@protoc_insertion_point(class_scope:livekit.DataStream.Header)
 private:
  class _Internal;
  void set_has_text_header();
  void set_has_byte_header();

  inline bool has_content_header() const;
  inline void clear_has_content_header();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DataStream_Header_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    int64_t timestamp_;
    uint64_t total_length_;
    int encryption_type_;
    union ContentHeaderUnion {
      constexpr ContentHeaderUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::DataStream_TextHeader* text_header_;
      ::livekit::DataStream_ByteHeader* byte_header_;
    } content_header_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataStream.Chunk) */ {
 public:
  inline DataStream_Chunk() : DataStream_Chunk(nullptr) {}
  ~DataStream_Chunk() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Chunk(const DataStream_Chunk& from);
  DataStream_Chunk(DataStream_Chunk&& from) noexcept
    : DataStream_Chunk() {
    *this = ::std::move(from);
  }

  inline DataStream_Chunk& operator=(const DataStream_Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Chunk& operator=(DataStream_Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Chunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_Chunk* internal_default_instance() {
    return reinterpret_cast<const DataStream_Chunk*>(
               &_DataStream_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DataStream_Chunk& a, DataStream_Chunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Chunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Chunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Chunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Chunk& from) {
    DataStream_Chunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Chunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream.Chunk";
  }
  protected:
  explicit DataStream_Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kContentFieldNumber = 3,
    kIvFieldNumber = 5,
    kChunkIndexFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional bytes iv = 5;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // uint64 chunk_index = 2;
  void clear_chunk_index();
  uint64_t chunk_index() const;
  void set_chunk_index(uint64_t value);
  private:
  uint64_t _internal_chunk_index() const;
  void _internal_set_chunk_index(uint64_t value);
  public:

  // int32 version = 4;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataStream.Chunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    uint64_t chunk_index_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Trailer_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Trailer_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Trailer_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DataStream_Trailer_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataStream_Trailer_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataStream_Trailer_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataStream_Trailer_AttributesEntry_DoNotUse& other);
  static const DataStream_Trailer_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataStream_Trailer_AttributesEntry_DoNotUse*>(&_DataStream_Trailer_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.DataStream.Trailer.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.DataStream.Trailer.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};

// -------------------------------------------------------------------

class DataStream_Trailer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DataStream.Trailer) */ {
 public:
  inline DataStream_Trailer() : DataStream_Trailer(nullptr) {}
  ~DataStream_Trailer() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Trailer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Trailer(const DataStream_Trailer& from);
  DataStream_Trailer(DataStream_Trailer&& from) noexcept
    : DataStream_Trailer() {
    *this = ::std::move(from);
  }

  inline DataStream_Trailer& operator=(const DataStream_Trailer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Trailer& operator=(DataStream_Trailer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Trailer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_Trailer* internal_default_instance() {
    return reinterpret_cast<const DataStream_Trailer*>(
               &_DataStream_Trailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DataStream_Trailer& a, DataStream_Trailer& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Trailer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Trailer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Trailer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Trailer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Trailer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Trailer& from) {
    DataStream_Trailer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Trailer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream.Trailer";
  }
  protected:
  explicit DataStream_Trailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kStreamIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // map<string, string> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:livekit.DataStream.Trailer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DataStream_Trailer_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// -------------------------------------------------------------------

class DataStream final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.DataStream) */ {
 public:
  inline DataStream() : DataStream(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream(const DataStream& from);
  DataStream(DataStream&& from) noexcept
    : DataStream() {
    *this = ::std::move(from);
  }

  inline DataStream& operator=(const DataStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream& operator=(DataStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream* internal_default_instance() {
    return reinterpret_cast<const DataStream*>(
               &_DataStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(DataStream& a, DataStream& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataStream& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataStream& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DataStream";
  }
  protected:
  explicit DataStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataStream_TextHeader TextHeader;
  typedef DataStream_ByteHeader ByteHeader;
  typedef DataStream_Header Header;
  typedef DataStream_Chunk Chunk;
  typedef DataStream_Trailer Trailer;

  typedef DataStream_OperationType OperationType;
  static constexpr OperationType CREATE =
    DataStream_OperationType_CREATE;
  static constexpr OperationType UPDATE =
    DataStream_OperationType_UPDATE;
  static constexpr OperationType DELETE =
    DataStream_OperationType_DELETE;
  static constexpr OperationType REACTION =
    DataStream_OperationType_REACTION;
  static inline bool OperationType_IsValid(int value) {
    return DataStream_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN =
    DataStream_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX =
    DataStream_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE =
    DataStream_OperationType_OperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperationType_descriptor() {
    return DataStream_OperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& OperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperationType_Name.");
    return DataStream_OperationType_Name(enum_t_value);
  }
  static inline bool OperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperationType* value) {
    return DataStream_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.DataStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5fmodels_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pagination

// string after_id = 1;
inline void Pagination::clear_after_id() {
  _impl_.after_id_.ClearToEmpty();
}
inline const std::string& Pagination::after_id() const {
  // @@protoc_insertion_point(field_get:livekit.Pagination.after_id)
  return _internal_after_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Pagination::set_after_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.after_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Pagination.after_id)
}
inline std::string* Pagination::mutable_after_id() {
  std::string* _s = _internal_mutable_after_id();
  // @@protoc_insertion_point(field_mutable:livekit.Pagination.after_id)
  return _s;
}
inline const std::string& Pagination::_internal_after_id() const {
  return _impl_.after_id_.Get();
}
inline void Pagination::_internal_set_after_id(const std::string& value) {
  
  _impl_.after_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Pagination::_internal_mutable_after_id() {
  
  return _impl_.after_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Pagination::release_after_id() {
  // @@protoc_insertion_point(field_release:livekit.Pagination.after_id)
  return _impl_.after_id_.Release();
}
inline void Pagination::set_allocated_after_id(std::string* after_id) {
  if (after_id != nullptr) {
    
  } else {
    
  }
  _impl_.after_id_.SetAllocated(after_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.after_id_.IsDefault()) {
    _impl_.after_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Pagination.after_id)
}

// int32 limit = 2;
inline void Pagination::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t Pagination::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t Pagination::limit() const {
  // @@protoc_insertion_point(field_get:livekit.Pagination.limit)
  return _internal_limit();
}
inline void Pagination::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void Pagination::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:livekit.Pagination.limit)
}

// -------------------------------------------------------------------

// Room

// string sid = 1;
inline void Room::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& Room::sid() const {
  // @@protoc_insertion_point(field_get:livekit.Room.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.sid)
}
inline std::string* Room::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.Room.sid)
  return _s;
}
inline const std::string& Room::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void Room::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* Room::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.Room.sid)
  return _impl_.sid_.Release();
}
inline void Room::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.sid)
}

// string name = 2;
inline void Room::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Room::name() const {
  // @@protoc_insertion_point(field_get:livekit.Room.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.name)
}
inline std::string* Room::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.Room.name)
  return _s;
}
inline const std::string& Room::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Room::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Room::release_name() {
  // @@protoc_insertion_point(field_release:livekit.Room.name)
  return _impl_.name_.Release();
}
inline void Room::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.name)
}

// uint32 empty_timeout = 3;
inline void Room::clear_empty_timeout() {
  _impl_.empty_timeout_ = 0u;
}
inline uint32_t Room::_internal_empty_timeout() const {
  return _impl_.empty_timeout_;
}
inline uint32_t Room::empty_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.Room.empty_timeout)
  return _internal_empty_timeout();
}
inline void Room::_internal_set_empty_timeout(uint32_t value) {
  
  _impl_.empty_timeout_ = value;
}
inline void Room::set_empty_timeout(uint32_t value) {
  _internal_set_empty_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.Room.empty_timeout)
}

// uint32 departure_timeout = 14;
inline void Room::clear_departure_timeout() {
  _impl_.departure_timeout_ = 0u;
}
inline uint32_t Room::_internal_departure_timeout() const {
  return _impl_.departure_timeout_;
}
inline uint32_t Room::departure_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.Room.departure_timeout)
  return _internal_departure_timeout();
}
inline void Room::_internal_set_departure_timeout(uint32_t value) {
  
  _impl_.departure_timeout_ = value;
}
inline void Room::set_departure_timeout(uint32_t value) {
  _internal_set_departure_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.Room.departure_timeout)
}

// uint32 max_participants = 4;
inline void Room::clear_max_participants() {
  _impl_.max_participants_ = 0u;
}
inline uint32_t Room::_internal_max_participants() const {
  return _impl_.max_participants_;
}
inline uint32_t Room::max_participants() const {
  // @@protoc_insertion_point(field_get:livekit.Room.max_participants)
  return _internal_max_participants();
}
inline void Room::_internal_set_max_participants(uint32_t value) {
  
  _impl_.max_participants_ = value;
}
inline void Room::set_max_participants(uint32_t value) {
  _internal_set_max_participants(value);
  // @@protoc_insertion_point(field_set:livekit.Room.max_participants)
}

// int64 creation_time = 5;
inline void Room::clear_creation_time() {
  _impl_.creation_time_ = int64_t{0};
}
inline int64_t Room::_internal_creation_time() const {
  return _impl_.creation_time_;
}
inline int64_t Room::creation_time() const {
  // @@protoc_insertion_point(field_get:livekit.Room.creation_time)
  return _internal_creation_time();
}
inline void Room::_internal_set_creation_time(int64_t value) {
  
  _impl_.creation_time_ = value;
}
inline void Room::set_creation_time(int64_t value) {
  _internal_set_creation_time(value);
  // @@protoc_insertion_point(field_set:livekit.Room.creation_time)
}

// int64 creation_time_ms = 15;
inline void Room::clear_creation_time_ms() {
  _impl_.creation_time_ms_ = int64_t{0};
}
inline int64_t Room::_internal_creation_time_ms() const {
  return _impl_.creation_time_ms_;
}
inline int64_t Room::creation_time_ms() const {
  // @@protoc_insertion_point(field_get:livekit.Room.creation_time_ms)
  return _internal_creation_time_ms();
}
inline void Room::_internal_set_creation_time_ms(int64_t value) {
  
  _impl_.creation_time_ms_ = value;
}
inline void Room::set_creation_time_ms(int64_t value) {
  _internal_set_creation_time_ms(value);
  // @@protoc_insertion_point(field_set:livekit.Room.creation_time_ms)
}

// string turn_password = 6;
inline void Room::clear_turn_password() {
  _impl_.turn_password_.ClearToEmpty();
}
inline const std::string& Room::turn_password() const {
  // @@protoc_insertion_point(field_get:livekit.Room.turn_password)
  return _internal_turn_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_turn_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.turn_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.turn_password)
}
inline std::string* Room::mutable_turn_password() {
  std::string* _s = _internal_mutable_turn_password();
  // @@protoc_insertion_point(field_mutable:livekit.Room.turn_password)
  return _s;
}
inline const std::string& Room::_internal_turn_password() const {
  return _impl_.turn_password_.Get();
}
inline void Room::_internal_set_turn_password(const std::string& value) {
  
  _impl_.turn_password_.Set(value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_turn_password() {
  
  return _impl_.turn_password_.Mutable(GetArenaForAllocation());
}
inline std::string* Room::release_turn_password() {
  // @@protoc_insertion_point(field_release:livekit.Room.turn_password)
  return _impl_.turn_password_.Release();
}
inline void Room::set_allocated_turn_password(std::string* turn_password) {
  if (turn_password != nullptr) {
    
  } else {
    
  }
  _impl_.turn_password_.SetAllocated(turn_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.turn_password_.IsDefault()) {
    _impl_.turn_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.turn_password)
}

// repeated .livekit.Codec enabled_codecs = 7;
inline int Room::_internal_enabled_codecs_size() const {
  return _impl_.enabled_codecs_.size();
}
inline int Room::enabled_codecs_size() const {
  return _internal_enabled_codecs_size();
}
inline void Room::clear_enabled_codecs() {
  _impl_.enabled_codecs_.Clear();
}
inline ::livekit::Codec* Room::mutable_enabled_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.Room.enabled_codecs)
  return _impl_.enabled_codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
Room::mutable_enabled_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.Room.enabled_codecs)
  return &_impl_.enabled_codecs_;
}
inline const ::livekit::Codec& Room::_internal_enabled_codecs(int index) const {
  return _impl_.enabled_codecs_.Get(index);
}
inline const ::livekit::Codec& Room::enabled_codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.Room.enabled_codecs)
  return _internal_enabled_codecs(index);
}
inline ::livekit::Codec* Room::_internal_add_enabled_codecs() {
  return _impl_.enabled_codecs_.Add();
}
inline ::livekit::Codec* Room::add_enabled_codecs() {
  ::livekit::Codec* _add = _internal_add_enabled_codecs();
  // @@protoc_insertion_point(field_add:livekit.Room.enabled_codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
Room::enabled_codecs() const {
  // @@protoc_insertion_point(field_list:livekit.Room.enabled_codecs)
  return _impl_.enabled_codecs_;
}

// string metadata = 8;
inline void Room::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& Room::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.Room.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Room.metadata)
}
inline std::string* Room::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.Room.metadata)
  return _s;
}
inline const std::string& Room::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void Room::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* Room::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* Room::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.Room.metadata)
  return _impl_.metadata_.Release();
}
inline void Room::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.metadata)
}

// uint32 num_participants = 9;
inline void Room::clear_num_participants() {
  _impl_.num_participants_ = 0u;
}
inline uint32_t Room::_internal_num_participants() const {
  return _impl_.num_participants_;
}
inline uint32_t Room::num_participants() const {
  // @@protoc_insertion_point(field_get:livekit.Room.num_participants)
  return _internal_num_participants();
}
inline void Room::_internal_set_num_participants(uint32_t value) {
  
  _impl_.num_participants_ = value;
}
inline void Room::set_num_participants(uint32_t value) {
  _internal_set_num_participants(value);
  // @@protoc_insertion_point(field_set:livekit.Room.num_participants)
}

// uint32 num_publishers = 11;
inline void Room::clear_num_publishers() {
  _impl_.num_publishers_ = 0u;
}
inline uint32_t Room::_internal_num_publishers() const {
  return _impl_.num_publishers_;
}
inline uint32_t Room::num_publishers() const {
  // @@protoc_insertion_point(field_get:livekit.Room.num_publishers)
  return _internal_num_publishers();
}
inline void Room::_internal_set_num_publishers(uint32_t value) {
  
  _impl_.num_publishers_ = value;
}
inline void Room::set_num_publishers(uint32_t value) {
  _internal_set_num_publishers(value);
  // @@protoc_insertion_point(field_set:livekit.Room.num_publishers)
}

// bool active_recording = 10;
inline void Room::clear_active_recording() {
  _impl_.active_recording_ = false;
}
inline bool Room::_internal_active_recording() const {
  return _impl_.active_recording_;
}
inline bool Room::active_recording() const {
  // @@protoc_insertion_point(field_get:livekit.Room.active_recording)
  return _internal_active_recording();
}
inline void Room::_internal_set_active_recording(bool value) {
  
  _impl_.active_recording_ = value;
}
inline void Room::set_active_recording(bool value) {
  _internal_set_active_recording(value);
  // @@protoc_insertion_point(field_set:livekit.Room.active_recording)
}

// .livekit.TimedVersion version = 13;
inline bool Room::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool Room::has_version() const {
  return _internal_has_version();
}
inline void Room::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::livekit::TimedVersion& Room::_internal_version() const {
  const ::livekit::TimedVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TimedVersion&>(
      ::livekit::_TimedVersion_default_instance_);
}
inline const ::livekit::TimedVersion& Room::version() const {
  // @@protoc_insertion_point(field_get:livekit.Room.version)
  return _internal_version();
}
inline void Room::unsafe_arena_set_allocated_version(
    ::livekit::TimedVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Room.version)
}
inline ::livekit::TimedVersion* Room::release_version() {
  
  ::livekit::TimedVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::TimedVersion* Room::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:livekit.Room.version)
  
  ::livekit::TimedVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::livekit::TimedVersion* Room::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::TimedVersion>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::livekit::TimedVersion* Room::mutable_version() {
  ::livekit::TimedVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.Room.version)
  return _msg;
}
inline void Room::set_allocated_version(::livekit::TimedVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:livekit.Room.version)
}

// -------------------------------------------------------------------

// Codec

// string mime = 1;
inline void Codec::clear_mime() {
  _impl_.mime_.ClearToEmpty();
}
inline const std::string& Codec::mime() const {
  // @@protoc_insertion_point(field_get:livekit.Codec.mime)
  return _internal_mime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Codec::set_mime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Codec.mime)
}
inline std::string* Codec::mutable_mime() {
  std::string* _s = _internal_mutable_mime();
  // @@protoc_insertion_point(field_mutable:livekit.Codec.mime)
  return _s;
}
inline const std::string& Codec::_internal_mime() const {
  return _impl_.mime_.Get();
}
inline void Codec::_internal_set_mime(const std::string& value) {
  
  _impl_.mime_.Set(value, GetArenaForAllocation());
}
inline std::string* Codec::_internal_mutable_mime() {
  
  return _impl_.mime_.Mutable(GetArenaForAllocation());
}
inline std::string* Codec::release_mime() {
  // @@protoc_insertion_point(field_release:livekit.Codec.mime)
  return _impl_.mime_.Release();
}
inline void Codec::set_allocated_mime(std::string* mime) {
  if (mime != nullptr) {
    
  } else {
    
  }
  _impl_.mime_.SetAllocated(mime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_.IsDefault()) {
    _impl_.mime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Codec.mime)
}

// string fmtp_line = 2;
inline void Codec::clear_fmtp_line() {
  _impl_.fmtp_line_.ClearToEmpty();
}
inline const std::string& Codec::fmtp_line() const {
  // @@protoc_insertion_point(field_get:livekit.Codec.fmtp_line)
  return _internal_fmtp_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Codec::set_fmtp_line(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fmtp_line_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Codec.fmtp_line)
}
inline std::string* Codec::mutable_fmtp_line() {
  std::string* _s = _internal_mutable_fmtp_line();
  // @@protoc_insertion_point(field_mutable:livekit.Codec.fmtp_line)
  return _s;
}
inline const std::string& Codec::_internal_fmtp_line() const {
  return _impl_.fmtp_line_.Get();
}
inline void Codec::_internal_set_fmtp_line(const std::string& value) {
  
  _impl_.fmtp_line_.Set(value, GetArenaForAllocation());
}
inline std::string* Codec::_internal_mutable_fmtp_line() {
  
  return _impl_.fmtp_line_.Mutable(GetArenaForAllocation());
}
inline std::string* Codec::release_fmtp_line() {
  // @@protoc_insertion_point(field_release:livekit.Codec.fmtp_line)
  return _impl_.fmtp_line_.Release();
}
inline void Codec::set_allocated_fmtp_line(std::string* fmtp_line) {
  if (fmtp_line != nullptr) {
    
  } else {
    
  }
  _impl_.fmtp_line_.SetAllocated(fmtp_line, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fmtp_line_.IsDefault()) {
    _impl_.fmtp_line_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Codec.fmtp_line)
}

// -------------------------------------------------------------------

// PlayoutDelay

// bool enabled = 1;
inline void PlayoutDelay::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool PlayoutDelay::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool PlayoutDelay::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.PlayoutDelay.enabled)
  return _internal_enabled();
}
inline void PlayoutDelay::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void PlayoutDelay::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.PlayoutDelay.enabled)
}

// uint32 min = 2;
inline void PlayoutDelay::clear_min() {
  _impl_.min_ = 0u;
}
inline uint32_t PlayoutDelay::_internal_min() const {
  return _impl_.min_;
}
inline uint32_t PlayoutDelay::min() const {
  // @@protoc_insertion_point(field_get:livekit.PlayoutDelay.min)
  return _internal_min();
}
inline void PlayoutDelay::_internal_set_min(uint32_t value) {
  
  _impl_.min_ = value;
}
inline void PlayoutDelay::set_min(uint32_t value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:livekit.PlayoutDelay.min)
}

// uint32 max = 3;
inline void PlayoutDelay::clear_max() {
  _impl_.max_ = 0u;
}
inline uint32_t PlayoutDelay::_internal_max() const {
  return _impl_.max_;
}
inline uint32_t PlayoutDelay::max() const {
  // @@protoc_insertion_point(field_get:livekit.PlayoutDelay.max)
  return _internal_max();
}
inline void PlayoutDelay::_internal_set_max(uint32_t value) {
  
  _impl_.max_ = value;
}
inline void PlayoutDelay::set_max(uint32_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:livekit.PlayoutDelay.max)
}

// -------------------------------------------------------------------

// ParticipantPermission

// bool can_subscribe = 1;
inline void ParticipantPermission::clear_can_subscribe() {
  _impl_.can_subscribe_ = false;
}
inline bool ParticipantPermission::_internal_can_subscribe() const {
  return _impl_.can_subscribe_;
}
inline bool ParticipantPermission::can_subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_subscribe)
  return _internal_can_subscribe();
}
inline void ParticipantPermission::_internal_set_can_subscribe(bool value) {
  
  _impl_.can_subscribe_ = value;
}
inline void ParticipantPermission::set_can_subscribe(bool value) {
  _internal_set_can_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_subscribe)
}

// bool can_publish = 2;
inline void ParticipantPermission::clear_can_publish() {
  _impl_.can_publish_ = false;
}
inline bool ParticipantPermission::_internal_can_publish() const {
  return _impl_.can_publish_;
}
inline bool ParticipantPermission::can_publish() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_publish)
  return _internal_can_publish();
}
inline void ParticipantPermission::_internal_set_can_publish(bool value) {
  
  _impl_.can_publish_ = value;
}
inline void ParticipantPermission::set_can_publish(bool value) {
  _internal_set_can_publish(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_publish)
}

// bool can_publish_data = 3;
inline void ParticipantPermission::clear_can_publish_data() {
  _impl_.can_publish_data_ = false;
}
inline bool ParticipantPermission::_internal_can_publish_data() const {
  return _impl_.can_publish_data_;
}
inline bool ParticipantPermission::can_publish_data() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_publish_data)
  return _internal_can_publish_data();
}
inline void ParticipantPermission::_internal_set_can_publish_data(bool value) {
  
  _impl_.can_publish_data_ = value;
}
inline void ParticipantPermission::set_can_publish_data(bool value) {
  _internal_set_can_publish_data(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_publish_data)
}

// repeated .livekit.TrackSource can_publish_sources = 9;
inline int ParticipantPermission::_internal_can_publish_sources_size() const {
  return _impl_.can_publish_sources_.size();
}
inline int ParticipantPermission::can_publish_sources_size() const {
  return _internal_can_publish_sources_size();
}
inline void ParticipantPermission::clear_can_publish_sources() {
  _impl_.can_publish_sources_.Clear();
}
inline ::livekit::TrackSource ParticipantPermission::_internal_can_publish_sources(int index) const {
  return static_cast< ::livekit::TrackSource >(_impl_.can_publish_sources_.Get(index));
}
inline ::livekit::TrackSource ParticipantPermission::can_publish_sources(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_publish_sources)
  return _internal_can_publish_sources(index);
}
inline void ParticipantPermission::set_can_publish_sources(int index, ::livekit::TrackSource value) {
  _impl_.can_publish_sources_.Set(index, value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_publish_sources)
}
inline void ParticipantPermission::_internal_add_can_publish_sources(::livekit::TrackSource value) {
  _impl_.can_publish_sources_.Add(value);
}
inline void ParticipantPermission::add_can_publish_sources(::livekit::TrackSource value) {
  _internal_add_can_publish_sources(value);
  // @@protoc_insertion_point(field_add:livekit.ParticipantPermission.can_publish_sources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ParticipantPermission::can_publish_sources() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantPermission.can_publish_sources)
  return _impl_.can_publish_sources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParticipantPermission::_internal_mutable_can_publish_sources() {
  return &_impl_.can_publish_sources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ParticipantPermission::mutable_can_publish_sources() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantPermission.can_publish_sources)
  return _internal_mutable_can_publish_sources();
}

// bool hidden = 7;
inline void ParticipantPermission::clear_hidden() {
  _impl_.hidden_ = false;
}
inline bool ParticipantPermission::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool ParticipantPermission::hidden() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.hidden)
  return _internal_hidden();
}
inline void ParticipantPermission::_internal_set_hidden(bool value) {
  
  _impl_.hidden_ = value;
}
inline void ParticipantPermission::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.hidden)
}

// bool recorder = 8 [deprecated = true];
inline void ParticipantPermission::clear_recorder() {
  _impl_.recorder_ = false;
}
inline bool ParticipantPermission::_internal_recorder() const {
  return _impl_.recorder_;
}
inline bool ParticipantPermission::recorder() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.recorder)
  return _internal_recorder();
}
inline void ParticipantPermission::_internal_set_recorder(bool value) {
  
  _impl_.recorder_ = value;
}
inline void ParticipantPermission::set_recorder(bool value) {
  _internal_set_recorder(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.recorder)
}

// bool can_update_metadata = 10;
inline void ParticipantPermission::clear_can_update_metadata() {
  _impl_.can_update_metadata_ = false;
}
inline bool ParticipantPermission::_internal_can_update_metadata() const {
  return _impl_.can_update_metadata_;
}
inline bool ParticipantPermission::can_update_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_update_metadata)
  return _internal_can_update_metadata();
}
inline void ParticipantPermission::_internal_set_can_update_metadata(bool value) {
  
  _impl_.can_update_metadata_ = value;
}
inline void ParticipantPermission::set_can_update_metadata(bool value) {
  _internal_set_can_update_metadata(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_update_metadata)
}

// bool agent = 11 [deprecated = true];
inline void ParticipantPermission::clear_agent() {
  _impl_.agent_ = false;
}
inline bool ParticipantPermission::_internal_agent() const {
  return _impl_.agent_;
}
inline bool ParticipantPermission::agent() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.agent)
  return _internal_agent();
}
inline void ParticipantPermission::_internal_set_agent(bool value) {
  
  _impl_.agent_ = value;
}
inline void ParticipantPermission::set_agent(bool value) {
  _internal_set_agent(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.agent)
}

// bool can_subscribe_metrics = 12;
inline void ParticipantPermission::clear_can_subscribe_metrics() {
  _impl_.can_subscribe_metrics_ = false;
}
inline bool ParticipantPermission::_internal_can_subscribe_metrics() const {
  return _impl_.can_subscribe_metrics_;
}
inline bool ParticipantPermission::can_subscribe_metrics() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantPermission.can_subscribe_metrics)
  return _internal_can_subscribe_metrics();
}
inline void ParticipantPermission::_internal_set_can_subscribe_metrics(bool value) {
  
  _impl_.can_subscribe_metrics_ = value;
}
inline void ParticipantPermission::set_can_subscribe_metrics(bool value) {
  _internal_set_can_subscribe_metrics(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantPermission.can_subscribe_metrics)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ParticipantInfo

// string sid = 1;
inline void ParticipantInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.sid)
}
inline std::string* ParticipantInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.sid)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void ParticipantInfo::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.sid)
  return _impl_.sid_.Release();
}
inline void ParticipantInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.sid)
}

// string identity = 2;
inline void ParticipantInfo::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::identity() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.identity)
}
inline std::string* ParticipantInfo::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.identity)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void ParticipantInfo::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.identity)
  return _impl_.identity_.Release();
}
inline void ParticipantInfo::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.identity)
}

// .livekit.ParticipantInfo.State state = 3;
inline void ParticipantInfo::clear_state() {
  _impl_.state_ = 0;
}
inline ::livekit::ParticipantInfo_State ParticipantInfo::_internal_state() const {
  return static_cast< ::livekit::ParticipantInfo_State >(_impl_.state_);
}
inline ::livekit::ParticipantInfo_State ParticipantInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.state)
  return _internal_state();
}
inline void ParticipantInfo::_internal_set_state(::livekit::ParticipantInfo_State value) {
  
  _impl_.state_ = value;
}
inline void ParticipantInfo::set_state(::livekit::ParticipantInfo_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.state)
}

// repeated .livekit.TrackInfo tracks = 4;
inline int ParticipantInfo::_internal_tracks_size() const {
  return _impl_.tracks_.size();
}
inline int ParticipantInfo::tracks_size() const {
  return _internal_tracks_size();
}
inline void ParticipantInfo::clear_tracks() {
  _impl_.tracks_.Clear();
}
inline ::livekit::TrackInfo* ParticipantInfo::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.tracks)
  return _impl_.tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
ParticipantInfo::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantInfo.tracks)
  return &_impl_.tracks_;
}
inline const ::livekit::TrackInfo& ParticipantInfo::_internal_tracks(int index) const {
  return _impl_.tracks_.Get(index);
}
inline const ::livekit::TrackInfo& ParticipantInfo::tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.tracks)
  return _internal_tracks(index);
}
inline ::livekit::TrackInfo* ParticipantInfo::_internal_add_tracks() {
  return _impl_.tracks_.Add();
}
inline ::livekit::TrackInfo* ParticipantInfo::add_tracks() {
  ::livekit::TrackInfo* _add = _internal_add_tracks();
  // @@protoc_insertion_point(field_add:livekit.ParticipantInfo.tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
ParticipantInfo::tracks() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantInfo.tracks)
  return _impl_.tracks_;
}

// string metadata = 5;
inline void ParticipantInfo::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.metadata)
}
inline std::string* ParticipantInfo::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.metadata)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void ParticipantInfo::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.metadata)
  return _impl_.metadata_.Release();
}
inline void ParticipantInfo::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.metadata)
}

// int64 joined_at = 6;
inline void ParticipantInfo::clear_joined_at() {
  _impl_.joined_at_ = int64_t{0};
}
inline int64_t ParticipantInfo::_internal_joined_at() const {
  return _impl_.joined_at_;
}
inline int64_t ParticipantInfo::joined_at() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.joined_at)
  return _internal_joined_at();
}
inline void ParticipantInfo::_internal_set_joined_at(int64_t value) {
  
  _impl_.joined_at_ = value;
}
inline void ParticipantInfo::set_joined_at(int64_t value) {
  _internal_set_joined_at(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.joined_at)
}

// int64 joined_at_ms = 17;
inline void ParticipantInfo::clear_joined_at_ms() {
  _impl_.joined_at_ms_ = int64_t{0};
}
inline int64_t ParticipantInfo::_internal_joined_at_ms() const {
  return _impl_.joined_at_ms_;
}
inline int64_t ParticipantInfo::joined_at_ms() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.joined_at_ms)
  return _internal_joined_at_ms();
}
inline void ParticipantInfo::_internal_set_joined_at_ms(int64_t value) {
  
  _impl_.joined_at_ms_ = value;
}
inline void ParticipantInfo::set_joined_at_ms(int64_t value) {
  _internal_set_joined_at_ms(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.joined_at_ms)
}

// string name = 9;
inline void ParticipantInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.name)
}
inline std::string* ParticipantInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.name)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ParticipantInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.name)
  return _impl_.name_.Release();
}
inline void ParticipantInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.name)
}

// uint32 version = 10;
inline void ParticipantInfo::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t ParticipantInfo::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t ParticipantInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.version)
  return _internal_version();
}
inline void ParticipantInfo::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void ParticipantInfo::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.version)
}

// .livekit.ParticipantPermission permission = 11;
inline bool ParticipantInfo::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool ParticipantInfo::has_permission() const {
  return _internal_has_permission();
}
inline void ParticipantInfo::clear_permission() {
  if (GetArenaForAllocation() == nullptr && _impl_.permission_ != nullptr) {
    delete _impl_.permission_;
  }
  _impl_.permission_ = nullptr;
}
inline const ::livekit::ParticipantPermission& ParticipantInfo::_internal_permission() const {
  const ::livekit::ParticipantPermission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantPermission&>(
      ::livekit::_ParticipantPermission_default_instance_);
}
inline const ::livekit::ParticipantPermission& ParticipantInfo::permission() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.permission)
  return _internal_permission();
}
inline void ParticipantInfo::unsafe_arena_set_allocated_permission(
    ::livekit::ParticipantPermission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ParticipantInfo.permission)
}
inline ::livekit::ParticipantPermission* ParticipantInfo::release_permission() {
  
  ::livekit::ParticipantPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.permission)
  
  ::livekit::ParticipantPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantPermission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::livekit::ParticipantPermission* ParticipantInfo::mutable_permission() {
  ::livekit::ParticipantPermission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.permission)
  return _msg;
}
inline void ParticipantInfo::set_allocated_permission(::livekit::ParticipantPermission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission);
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.permission)
}

// string region = 12;
inline void ParticipantInfo::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& ParticipantInfo::region() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantInfo::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.region)
}
inline std::string* ParticipantInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantInfo.region)
  return _s;
}
inline const std::string& ParticipantInfo::_internal_region() const {
  return _impl_.region_.Get();
}
inline void ParticipantInfo::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantInfo::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantInfo::release_region() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantInfo.region)
  return _impl_.region_.Release();
}
inline void ParticipantInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantInfo.region)
}

// bool is_publisher = 13;
inline void ParticipantInfo::clear_is_publisher() {
  _impl_.is_publisher_ = false;
}
inline bool ParticipantInfo::_internal_is_publisher() const {
  return _impl_.is_publisher_;
}
inline bool ParticipantInfo::is_publisher() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.is_publisher)
  return _internal_is_publisher();
}
inline void ParticipantInfo::_internal_set_is_publisher(bool value) {
  
  _impl_.is_publisher_ = value;
}
inline void ParticipantInfo::set_is_publisher(bool value) {
  _internal_set_is_publisher(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.is_publisher)
}

// .livekit.ParticipantInfo.Kind kind = 14;
inline void ParticipantInfo::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::livekit::ParticipantInfo_Kind ParticipantInfo::_internal_kind() const {
  return static_cast< ::livekit::ParticipantInfo_Kind >(_impl_.kind_);
}
inline ::livekit::ParticipantInfo_Kind ParticipantInfo::kind() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.kind)
  return _internal_kind();
}
inline void ParticipantInfo::_internal_set_kind(::livekit::ParticipantInfo_Kind value) {
  
  _impl_.kind_ = value;
}
inline void ParticipantInfo::set_kind(::livekit::ParticipantInfo_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.kind)
}

// map<string, string> attributes = 15;
inline int ParticipantInfo::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int ParticipantInfo::attributes_size() const {
  return _internal_attributes_size();
}
inline void ParticipantInfo::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ParticipantInfo::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ParticipantInfo::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.ParticipantInfo.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ParticipantInfo::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ParticipantInfo::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.ParticipantInfo.attributes)
  return _internal_mutable_attributes();
}

// .livekit.DisconnectReason disconnect_reason = 16;
inline void ParticipantInfo::clear_disconnect_reason() {
  _impl_.disconnect_reason_ = 0;
}
inline ::livekit::DisconnectReason ParticipantInfo::_internal_disconnect_reason() const {
  return static_cast< ::livekit::DisconnectReason >(_impl_.disconnect_reason_);
}
inline ::livekit::DisconnectReason ParticipantInfo::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantInfo.disconnect_reason)
  return _internal_disconnect_reason();
}
inline void ParticipantInfo::_internal_set_disconnect_reason(::livekit::DisconnectReason value) {
  
  _impl_.disconnect_reason_ = value;
}
inline void ParticipantInfo::set_disconnect_reason(::livekit::DisconnectReason value) {
  _internal_set_disconnect_reason(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantInfo.disconnect_reason)
}

// -------------------------------------------------------------------

// Encryption

// -------------------------------------------------------------------

// SimulcastCodecInfo

// string mime_type = 1;
inline void SimulcastCodecInfo::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& SimulcastCodecInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodecInfo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulcastCodecInfo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodecInfo.mime_type)
}
inline std::string* SimulcastCodecInfo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodecInfo.mime_type)
  return _s;
}
inline const std::string& SimulcastCodecInfo::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void SimulcastCodecInfo::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodecInfo.mime_type)
  return _impl_.mime_type_.Release();
}
inline void SimulcastCodecInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodecInfo.mime_type)
}

// string mid = 2;
inline void SimulcastCodecInfo::clear_mid() {
  _impl_.mid_.ClearToEmpty();
}
inline const std::string& SimulcastCodecInfo::mid() const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodecInfo.mid)
  return _internal_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulcastCodecInfo::set_mid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodecInfo.mid)
}
inline std::string* SimulcastCodecInfo::mutable_mid() {
  std::string* _s = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodecInfo.mid)
  return _s;
}
inline const std::string& SimulcastCodecInfo::_internal_mid() const {
  return _impl_.mid_.Get();
}
inline void SimulcastCodecInfo::_internal_set_mid(const std::string& value) {
  
  _impl_.mid_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::_internal_mutable_mid() {
  
  return _impl_.mid_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::release_mid() {
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodecInfo.mid)
  return _impl_.mid_.Release();
}
inline void SimulcastCodecInfo::set_allocated_mid(std::string* mid) {
  if (mid != nullptr) {
    
  } else {
    
  }
  _impl_.mid_.SetAllocated(mid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mid_.IsDefault()) {
    _impl_.mid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodecInfo.mid)
}

// string cid = 3;
inline void SimulcastCodecInfo::clear_cid() {
  _impl_.cid_.ClearToEmpty();
}
inline const std::string& SimulcastCodecInfo::cid() const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodecInfo.cid)
  return _internal_cid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SimulcastCodecInfo::set_cid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SimulcastCodecInfo.cid)
}
inline std::string* SimulcastCodecInfo::mutable_cid() {
  std::string* _s = _internal_mutable_cid();
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodecInfo.cid)
  return _s;
}
inline const std::string& SimulcastCodecInfo::_internal_cid() const {
  return _impl_.cid_.Get();
}
inline void SimulcastCodecInfo::_internal_set_cid(const std::string& value) {
  
  _impl_.cid_.Set(value, GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::_internal_mutable_cid() {
  
  return _impl_.cid_.Mutable(GetArenaForAllocation());
}
inline std::string* SimulcastCodecInfo::release_cid() {
  // @@protoc_insertion_point(field_release:livekit.SimulcastCodecInfo.cid)
  return _impl_.cid_.Release();
}
inline void SimulcastCodecInfo::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  _impl_.cid_.SetAllocated(cid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cid_.IsDefault()) {
    _impl_.cid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulcastCodecInfo.cid)
}

// repeated .livekit.VideoLayer layers = 4;
inline int SimulcastCodecInfo::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int SimulcastCodecInfo::layers_size() const {
  return _internal_layers_size();
}
inline void SimulcastCodecInfo::clear_layers() {
  _impl_.layers_.Clear();
}
inline ::livekit::VideoLayer* SimulcastCodecInfo::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SimulcastCodecInfo.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
SimulcastCodecInfo::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SimulcastCodecInfo.layers)
  return &_impl_.layers_;
}
inline const ::livekit::VideoLayer& SimulcastCodecInfo::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::livekit::VideoLayer& SimulcastCodecInfo::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SimulcastCodecInfo.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* SimulcastCodecInfo::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::livekit::VideoLayer* SimulcastCodecInfo::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.SimulcastCodecInfo.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
SimulcastCodecInfo::layers() const {
  // @@protoc_insertion_point(field_list:livekit.SimulcastCodecInfo.layers)
  return _impl_.layers_;
}

// -------------------------------------------------------------------

// TrackInfo

// string sid = 1;
inline void TrackInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& TrackInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.sid)
}
inline std::string* TrackInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.sid)
  return _s;
}
inline const std::string& TrackInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void TrackInfo::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.sid)
  return _impl_.sid_.Release();
}
inline void TrackInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.sid)
}

// .livekit.TrackType type = 2;
inline void TrackInfo::clear_type() {
  _impl_.type_ = 0;
}
inline ::livekit::TrackType TrackInfo::_internal_type() const {
  return static_cast< ::livekit::TrackType >(_impl_.type_);
}
inline ::livekit::TrackType TrackInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.type)
  return _internal_type();
}
inline void TrackInfo::_internal_set_type(::livekit::TrackType value) {
  
  _impl_.type_ = value;
}
inline void TrackInfo::set_type(::livekit::TrackType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.type)
}

// string name = 3;
inline void TrackInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TrackInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.name)
}
inline std::string* TrackInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.name)
  return _s;
}
inline const std::string& TrackInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TrackInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.name)
  return _impl_.name_.Release();
}
inline void TrackInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.name)
}

// bool muted = 4;
inline void TrackInfo::clear_muted() {
  _impl_.muted_ = false;
}
inline bool TrackInfo::_internal_muted() const {
  return _impl_.muted_;
}
inline bool TrackInfo::muted() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.muted)
  return _internal_muted();
}
inline void TrackInfo::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void TrackInfo::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.muted)
}

// uint32 width = 5;
inline void TrackInfo::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t TrackInfo::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t TrackInfo::width() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.width)
  return _internal_width();
}
inline void TrackInfo::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void TrackInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.width)
}

// uint32 height = 6;
inline void TrackInfo::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t TrackInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t TrackInfo::height() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.height)
  return _internal_height();
}
inline void TrackInfo::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void TrackInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.height)
}

// bool simulcast = 7;
inline void TrackInfo::clear_simulcast() {
  _impl_.simulcast_ = false;
}
inline bool TrackInfo::_internal_simulcast() const {
  return _impl_.simulcast_;
}
inline bool TrackInfo::simulcast() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.simulcast)
  return _internal_simulcast();
}
inline void TrackInfo::_internal_set_simulcast(bool value) {
  
  _impl_.simulcast_ = value;
}
inline void TrackInfo::set_simulcast(bool value) {
  _internal_set_simulcast(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.simulcast)
}

// bool disable_dtx = 8;
inline void TrackInfo::clear_disable_dtx() {
  _impl_.disable_dtx_ = false;
}
inline bool TrackInfo::_internal_disable_dtx() const {
  return _impl_.disable_dtx_;
}
inline bool TrackInfo::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.disable_dtx)
  return _internal_disable_dtx();
}
inline void TrackInfo::_internal_set_disable_dtx(bool value) {
  
  _impl_.disable_dtx_ = value;
}
inline void TrackInfo::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.disable_dtx)
}

// .livekit.TrackSource source = 9;
inline void TrackInfo::clear_source() {
  _impl_.source_ = 0;
}
inline ::livekit::TrackSource TrackInfo::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(_impl_.source_);
}
inline ::livekit::TrackSource TrackInfo::source() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.source)
  return _internal_source();
}
inline void TrackInfo::_internal_set_source(::livekit::TrackSource value) {
  
  _impl_.source_ = value;
}
inline void TrackInfo::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.source)
}

// repeated .livekit.VideoLayer layers = 10;
inline int TrackInfo::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int TrackInfo::layers_size() const {
  return _internal_layers_size();
}
inline void TrackInfo::clear_layers() {
  _impl_.layers_.Clear();
}
inline ::livekit::VideoLayer* TrackInfo::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
TrackInfo::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackInfo.layers)
  return &_impl_.layers_;
}
inline const ::livekit::VideoLayer& TrackInfo::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::livekit::VideoLayer& TrackInfo::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* TrackInfo::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::livekit::VideoLayer* TrackInfo::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.TrackInfo.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
TrackInfo::layers() const {
  // @@protoc_insertion_point(field_list:livekit.TrackInfo.layers)
  return _impl_.layers_;
}

// string mime_type = 11;
inline void TrackInfo::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& TrackInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.mime_type)
}
inline std::string* TrackInfo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.mime_type)
  return _s;
}
inline const std::string& TrackInfo::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void TrackInfo::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.mime_type)
  return _impl_.mime_type_.Release();
}
inline void TrackInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.mime_type)
}

// string mid = 12;
inline void TrackInfo::clear_mid() {
  _impl_.mid_.ClearToEmpty();
}
inline const std::string& TrackInfo::mid() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.mid)
  return _internal_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_mid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.mid)
}
inline std::string* TrackInfo::mutable_mid() {
  std::string* _s = _internal_mutable_mid();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.mid)
  return _s;
}
inline const std::string& TrackInfo::_internal_mid() const {
  return _impl_.mid_.Get();
}
inline void TrackInfo::_internal_set_mid(const std::string& value) {
  
  _impl_.mid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_mid() {
  
  return _impl_.mid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_mid() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.mid)
  return _impl_.mid_.Release();
}
inline void TrackInfo::set_allocated_mid(std::string* mid) {
  if (mid != nullptr) {
    
  } else {
    
  }
  _impl_.mid_.SetAllocated(mid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mid_.IsDefault()) {
    _impl_.mid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.mid)
}

// repeated .livekit.SimulcastCodecInfo codecs = 13;
inline int TrackInfo::_internal_codecs_size() const {
  return _impl_.codecs_.size();
}
inline int TrackInfo::codecs_size() const {
  return _internal_codecs_size();
}
inline void TrackInfo::clear_codecs() {
  _impl_.codecs_.Clear();
}
inline ::livekit::SimulcastCodecInfo* TrackInfo::mutable_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.codecs)
  return _impl_.codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodecInfo >*
TrackInfo::mutable_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackInfo.codecs)
  return &_impl_.codecs_;
}
inline const ::livekit::SimulcastCodecInfo& TrackInfo::_internal_codecs(int index) const {
  return _impl_.codecs_.Get(index);
}
inline const ::livekit::SimulcastCodecInfo& TrackInfo::codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.codecs)
  return _internal_codecs(index);
}
inline ::livekit::SimulcastCodecInfo* TrackInfo::_internal_add_codecs() {
  return _impl_.codecs_.Add();
}
inline ::livekit::SimulcastCodecInfo* TrackInfo::add_codecs() {
  ::livekit::SimulcastCodecInfo* _add = _internal_add_codecs();
  // @@protoc_insertion_point(field_add:livekit.TrackInfo.codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SimulcastCodecInfo >&
TrackInfo::codecs() const {
  // @@protoc_insertion_point(field_list:livekit.TrackInfo.codecs)
  return _impl_.codecs_;
}

// bool stereo = 14;
inline void TrackInfo::clear_stereo() {
  _impl_.stereo_ = false;
}
inline bool TrackInfo::_internal_stereo() const {
  return _impl_.stereo_;
}
inline bool TrackInfo::stereo() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.stereo)
  return _internal_stereo();
}
inline void TrackInfo::_internal_set_stereo(bool value) {
  
  _impl_.stereo_ = value;
}
inline void TrackInfo::set_stereo(bool value) {
  _internal_set_stereo(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.stereo)
}

// bool disable_red = 15;
inline void TrackInfo::clear_disable_red() {
  _impl_.disable_red_ = false;
}
inline bool TrackInfo::_internal_disable_red() const {
  return _impl_.disable_red_;
}
inline bool TrackInfo::disable_red() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.disable_red)
  return _internal_disable_red();
}
inline void TrackInfo::_internal_set_disable_red(bool value) {
  
  _impl_.disable_red_ = value;
}
inline void TrackInfo::set_disable_red(bool value) {
  _internal_set_disable_red(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.disable_red)
}

// .livekit.Encryption.Type encryption = 16;
inline void TrackInfo::clear_encryption() {
  _impl_.encryption_ = 0;
}
inline ::livekit::Encryption_Type TrackInfo::_internal_encryption() const {
  return static_cast< ::livekit::Encryption_Type >(_impl_.encryption_);
}
inline ::livekit::Encryption_Type TrackInfo::encryption() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.encryption)
  return _internal_encryption();
}
inline void TrackInfo::_internal_set_encryption(::livekit::Encryption_Type value) {
  
  _impl_.encryption_ = value;
}
inline void TrackInfo::set_encryption(::livekit::Encryption_Type value) {
  _internal_set_encryption(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.encryption)
}

// string stream = 17;
inline void TrackInfo::clear_stream() {
  _impl_.stream_.ClearToEmpty();
}
inline const std::string& TrackInfo::stream() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_stream(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.stream)
}
inline std::string* TrackInfo::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.stream)
  return _s;
}
inline const std::string& TrackInfo::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void TrackInfo::_internal_set_stream(const std::string& value) {
  
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_stream() {
  
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.stream)
  return _impl_.stream_.Release();
}
inline void TrackInfo::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.stream)
}

// .livekit.TimedVersion version = 18;
inline bool TrackInfo::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool TrackInfo::has_version() const {
  return _internal_has_version();
}
inline void TrackInfo::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::livekit::TimedVersion& TrackInfo::_internal_version() const {
  const ::livekit::TimedVersion* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TimedVersion&>(
      ::livekit::_TimedVersion_default_instance_);
}
inline const ::livekit::TimedVersion& TrackInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.version)
  return _internal_version();
}
inline void TrackInfo::unsafe_arena_set_allocated_version(
    ::livekit::TimedVersion* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.TrackInfo.version)
}
inline ::livekit::TimedVersion* TrackInfo::release_version() {
  
  ::livekit::TimedVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::TimedVersion* TrackInfo::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:livekit.TrackInfo.version)
  
  ::livekit::TimedVersion* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::livekit::TimedVersion* TrackInfo::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::TimedVersion>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::livekit::TimedVersion* TrackInfo::mutable_version() {
  ::livekit::TimedVersion* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.TrackInfo.version)
  return _msg;
}
inline void TrackInfo::set_allocated_version(::livekit::TimedVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:livekit.TrackInfo.version)
}

// repeated .livekit.AudioTrackFeature audio_features = 19;
inline int TrackInfo::_internal_audio_features_size() const {
  return _impl_.audio_features_.size();
}
inline int TrackInfo::audio_features_size() const {
  return _internal_audio_features_size();
}
inline void TrackInfo::clear_audio_features() {
  _impl_.audio_features_.Clear();
}
inline ::livekit::AudioTrackFeature TrackInfo::_internal_audio_features(int index) const {
  return static_cast< ::livekit::AudioTrackFeature >(_impl_.audio_features_.Get(index));
}
inline ::livekit::AudioTrackFeature TrackInfo::audio_features(int index) const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.audio_features)
  return _internal_audio_features(index);
}
inline void TrackInfo::set_audio_features(int index, ::livekit::AudioTrackFeature value) {
  _impl_.audio_features_.Set(index, value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.audio_features)
}
inline void TrackInfo::_internal_add_audio_features(::livekit::AudioTrackFeature value) {
  _impl_.audio_features_.Add(value);
}
inline void TrackInfo::add_audio_features(::livekit::AudioTrackFeature value) {
  _internal_add_audio_features(value);
  // @@protoc_insertion_point(field_add:livekit.TrackInfo.audio_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TrackInfo::audio_features() const {
  // @@protoc_insertion_point(field_list:livekit.TrackInfo.audio_features)
  return _impl_.audio_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrackInfo::_internal_mutable_audio_features() {
  return &_impl_.audio_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TrackInfo::mutable_audio_features() {
  // @@protoc_insertion_point(field_mutable_list:livekit.TrackInfo.audio_features)
  return _internal_mutable_audio_features();
}

// .livekit.BackupCodecPolicy backup_codec_policy = 20;
inline void TrackInfo::clear_backup_codec_policy() {
  _impl_.backup_codec_policy_ = 0;
}
inline ::livekit::BackupCodecPolicy TrackInfo::_internal_backup_codec_policy() const {
  return static_cast< ::livekit::BackupCodecPolicy >(_impl_.backup_codec_policy_);
}
inline ::livekit::BackupCodecPolicy TrackInfo::backup_codec_policy() const {
  // @@protoc_insertion_point(field_get:livekit.TrackInfo.backup_codec_policy)
  return _internal_backup_codec_policy();
}
inline void TrackInfo::_internal_set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  
  _impl_.backup_codec_policy_ = value;
}
inline void TrackInfo::set_backup_codec_policy(::livekit::BackupCodecPolicy value) {
  _internal_set_backup_codec_policy(value);
  // @@protoc_insertion_point(field_set:livekit.TrackInfo.backup_codec_policy)
}

// -------------------------------------------------------------------

// VideoLayer

// .livekit.VideoQuality quality = 1;
inline void VideoLayer::clear_quality() {
  _impl_.quality_ = 0;
}
inline ::livekit::VideoQuality VideoLayer::_internal_quality() const {
  return static_cast< ::livekit::VideoQuality >(_impl_.quality_);
}
inline ::livekit::VideoQuality VideoLayer::quality() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.quality)
  return _internal_quality();
}
inline void VideoLayer::_internal_set_quality(::livekit::VideoQuality value) {
  
  _impl_.quality_ = value;
}
inline void VideoLayer::set_quality(::livekit::VideoQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.quality)
}

// uint32 width = 2;
inline void VideoLayer::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t VideoLayer::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t VideoLayer::width() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.width)
  return _internal_width();
}
inline void VideoLayer::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void VideoLayer::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.width)
}

// uint32 height = 3;
inline void VideoLayer::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t VideoLayer::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t VideoLayer::height() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.height)
  return _internal_height();
}
inline void VideoLayer::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void VideoLayer::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.height)
}

// uint32 bitrate = 4;
inline void VideoLayer::clear_bitrate() {
  _impl_.bitrate_ = 0u;
}
inline uint32_t VideoLayer::_internal_bitrate() const {
  return _impl_.bitrate_;
}
inline uint32_t VideoLayer::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.bitrate)
  return _internal_bitrate();
}
inline void VideoLayer::_internal_set_bitrate(uint32_t value) {
  
  _impl_.bitrate_ = value;
}
inline void VideoLayer::set_bitrate(uint32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.bitrate)
}

// uint32 ssrc = 5;
inline void VideoLayer::clear_ssrc() {
  _impl_.ssrc_ = 0u;
}
inline uint32_t VideoLayer::_internal_ssrc() const {
  return _impl_.ssrc_;
}
inline uint32_t VideoLayer::ssrc() const {
  // @@protoc_insertion_point(field_get:livekit.VideoLayer.ssrc)
  return _internal_ssrc();
}
inline void VideoLayer::_internal_set_ssrc(uint32_t value) {
  
  _impl_.ssrc_ = value;
}
inline void VideoLayer::set_ssrc(uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:livekit.VideoLayer.ssrc)
}

// -------------------------------------------------------------------

// DataPacket

// .livekit.DataPacket.Kind kind = 1 [deprecated = true];
inline void DataPacket::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::livekit::DataPacket_Kind DataPacket::_internal_kind() const {
  return static_cast< ::livekit::DataPacket_Kind >(_impl_.kind_);
}
inline ::livekit::DataPacket_Kind DataPacket::kind() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.kind)
  return _internal_kind();
}
inline void DataPacket::_internal_set_kind(::livekit::DataPacket_Kind value) {
  
  _impl_.kind_ = value;
}
inline void DataPacket::set_kind(::livekit::DataPacket_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.DataPacket.kind)
}

// string participant_identity = 4;
inline void DataPacket::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& DataPacket::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataPacket::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataPacket.participant_identity)
}
inline std::string* DataPacket::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.participant_identity)
  return _s;
}
inline const std::string& DataPacket::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void DataPacket::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* DataPacket::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* DataPacket::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void DataPacket::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataPacket.participant_identity)
}

// repeated string destination_identities = 5;
inline int DataPacket::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int DataPacket::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void DataPacket::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* DataPacket::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.DataPacket.destination_identities)
  return _s;
}
inline const std::string& DataPacket::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& DataPacket::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* DataPacket::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void DataPacket::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.DataPacket.destination_identities)
}
inline void DataPacket::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.DataPacket.destination_identities)
}
inline void DataPacket::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.DataPacket.destination_identities)
}
inline void DataPacket::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.DataPacket.destination_identities)
}
inline std::string* DataPacket::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void DataPacket::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.DataPacket.destination_identities)
}
inline void DataPacket::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.DataPacket.destination_identities)
}
inline void DataPacket::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.DataPacket.destination_identities)
}
inline void DataPacket::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.DataPacket.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataPacket::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.DataPacket.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataPacket::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.DataPacket.destination_identities)
  return &_impl_.destination_identities_;
}

// .livekit.UserPacket user = 2;
inline bool DataPacket::_internal_has_user() const {
  return value_case() == kUser;
}
inline bool DataPacket::has_user() const {
  return _internal_has_user();
}
inline void DataPacket::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void DataPacket::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.user_;
    }
    clear_has_value();
  }
}
inline ::livekit::UserPacket* DataPacket::release_user() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.user)
  if (_internal_has_user()) {
    clear_has_value();
    ::livekit::UserPacket* temp = _impl_.value_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UserPacket& DataPacket::_internal_user() const {
  return _internal_has_user()
      ? *_impl_.value_.user_
      : reinterpret_cast< ::livekit::UserPacket&>(::livekit::_UserPacket_default_instance_);
}
inline const ::livekit::UserPacket& DataPacket::user() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.user)
  return _internal_user();
}
inline ::livekit::UserPacket* DataPacket::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.user)
  if (_internal_has_user()) {
    clear_has_value();
    ::livekit::UserPacket* temp = _impl_.value_.user_;
    _impl_.value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_user(::livekit::UserPacket* user) {
  clear_value();
  if (user) {
    set_has_user();
    _impl_.value_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.user)
}
inline ::livekit::UserPacket* DataPacket::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_value();
    set_has_user();
    _impl_.value_.user_ = CreateMaybeMessage< ::livekit::UserPacket >(GetArenaForAllocation());
  }
  return _impl_.value_.user_;
}
inline ::livekit::UserPacket* DataPacket::mutable_user() {
  ::livekit::UserPacket* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.user)
  return _msg;
}

// .livekit.ActiveSpeakerUpdate speaker = 3 [deprecated = true];
inline bool DataPacket::_internal_has_speaker() const {
  return value_case() == kSpeaker;
}
inline bool DataPacket::has_speaker() const {
  return _internal_has_speaker();
}
inline void DataPacket::set_has_speaker() {
  _impl_._oneof_case_[0] = kSpeaker;
}
inline void DataPacket::clear_speaker() {
  if (_internal_has_speaker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.speaker_;
    }
    clear_has_value();
  }
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::release_speaker() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.speaker)
  if (_internal_has_speaker()) {
    clear_has_value();
    ::livekit::ActiveSpeakerUpdate* temp = _impl_.value_.speaker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.speaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ActiveSpeakerUpdate& DataPacket::_internal_speaker() const {
  return _internal_has_speaker()
      ? *_impl_.value_.speaker_
      : reinterpret_cast< ::livekit::ActiveSpeakerUpdate&>(::livekit::_ActiveSpeakerUpdate_default_instance_);
}
inline const ::livekit::ActiveSpeakerUpdate& DataPacket::speaker() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.speaker)
  return _internal_speaker();
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::unsafe_arena_release_speaker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.speaker)
  if (_internal_has_speaker()) {
    clear_has_value();
    ::livekit::ActiveSpeakerUpdate* temp = _impl_.value_.speaker_;
    _impl_.value_.speaker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_speaker(::livekit::ActiveSpeakerUpdate* speaker) {
  clear_value();
  if (speaker) {
    set_has_speaker();
    _impl_.value_.speaker_ = speaker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.speaker)
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::_internal_mutable_speaker() {
  if (!_internal_has_speaker()) {
    clear_value();
    set_has_speaker();
    _impl_.value_.speaker_ = CreateMaybeMessage< ::livekit::ActiveSpeakerUpdate >(GetArenaForAllocation());
  }
  return _impl_.value_.speaker_;
}
inline ::livekit::ActiveSpeakerUpdate* DataPacket::mutable_speaker() {
  ::livekit::ActiveSpeakerUpdate* _msg = _internal_mutable_speaker();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.speaker)
  return _msg;
}

// .livekit.SipDTMF sip_dtmf = 6;
inline bool DataPacket::_internal_has_sip_dtmf() const {
  return value_case() == kSipDtmf;
}
inline bool DataPacket::has_sip_dtmf() const {
  return _internal_has_sip_dtmf();
}
inline void DataPacket::set_has_sip_dtmf() {
  _impl_._oneof_case_[0] = kSipDtmf;
}
inline void DataPacket::clear_sip_dtmf() {
  if (_internal_has_sip_dtmf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sip_dtmf_;
    }
    clear_has_value();
  }
}
inline ::livekit::SipDTMF* DataPacket::release_sip_dtmf() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.sip_dtmf)
  if (_internal_has_sip_dtmf()) {
    clear_has_value();
    ::livekit::SipDTMF* temp = _impl_.value_.sip_dtmf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sip_dtmf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SipDTMF& DataPacket::_internal_sip_dtmf() const {
  return _internal_has_sip_dtmf()
      ? *_impl_.value_.sip_dtmf_
      : reinterpret_cast< ::livekit::SipDTMF&>(::livekit::_SipDTMF_default_instance_);
}
inline const ::livekit::SipDTMF& DataPacket::sip_dtmf() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.sip_dtmf)
  return _internal_sip_dtmf();
}
inline ::livekit::SipDTMF* DataPacket::unsafe_arena_release_sip_dtmf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.sip_dtmf)
  if (_internal_has_sip_dtmf()) {
    clear_has_value();
    ::livekit::SipDTMF* temp = _impl_.value_.sip_dtmf_;
    _impl_.value_.sip_dtmf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_sip_dtmf(::livekit::SipDTMF* sip_dtmf) {
  clear_value();
  if (sip_dtmf) {
    set_has_sip_dtmf();
    _impl_.value_.sip_dtmf_ = sip_dtmf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.sip_dtmf)
}
inline ::livekit::SipDTMF* DataPacket::_internal_mutable_sip_dtmf() {
  if (!_internal_has_sip_dtmf()) {
    clear_value();
    set_has_sip_dtmf();
    _impl_.value_.sip_dtmf_ = CreateMaybeMessage< ::livekit::SipDTMF >(GetArenaForAllocation());
  }
  return _impl_.value_.sip_dtmf_;
}
inline ::livekit::SipDTMF* DataPacket::mutable_sip_dtmf() {
  ::livekit::SipDTMF* _msg = _internal_mutable_sip_dtmf();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.sip_dtmf)
  return _msg;
}

// .livekit.Transcription transcription = 7;
inline bool DataPacket::_internal_has_transcription() const {
  return value_case() == kTranscription;
}
inline bool DataPacket::has_transcription() const {
  return _internal_has_transcription();
}
inline void DataPacket::set_has_transcription() {
  _impl_._oneof_case_[0] = kTranscription;
}
inline void DataPacket::clear_transcription() {
  if (_internal_has_transcription()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.transcription_;
    }
    clear_has_value();
  }
}
inline ::livekit::Transcription* DataPacket::release_transcription() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.transcription)
  if (_internal_has_transcription()) {
    clear_has_value();
    ::livekit::Transcription* temp = _impl_.value_.transcription_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.transcription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::Transcription& DataPacket::_internal_transcription() const {
  return _internal_has_transcription()
      ? *_impl_.value_.transcription_
      : reinterpret_cast< ::livekit::Transcription&>(::livekit::_Transcription_default_instance_);
}
inline const ::livekit::Transcription& DataPacket::transcription() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.transcription)
  return _internal_transcription();
}
inline ::livekit::Transcription* DataPacket::unsafe_arena_release_transcription() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.transcription)
  if (_internal_has_transcription()) {
    clear_has_value();
    ::livekit::Transcription* temp = _impl_.value_.transcription_;
    _impl_.value_.transcription_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_transcription(::livekit::Transcription* transcription) {
  clear_value();
  if (transcription) {
    set_has_transcription();
    _impl_.value_.transcription_ = transcription;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.transcription)
}
inline ::livekit::Transcription* DataPacket::_internal_mutable_transcription() {
  if (!_internal_has_transcription()) {
    clear_value();
    set_has_transcription();
    _impl_.value_.transcription_ = CreateMaybeMessage< ::livekit::Transcription >(GetArenaForAllocation());
  }
  return _impl_.value_.transcription_;
}
inline ::livekit::Transcription* DataPacket::mutable_transcription() {
  ::livekit::Transcription* _msg = _internal_mutable_transcription();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.transcription)
  return _msg;
}

// .livekit.MetricsBatch metrics = 8;
inline bool DataPacket::_internal_has_metrics() const {
  return value_case() == kMetrics;
}
inline bool DataPacket::has_metrics() const {
  return _internal_has_metrics();
}
inline void DataPacket::set_has_metrics() {
  _impl_._oneof_case_[0] = kMetrics;
}
inline ::livekit::MetricsBatch* DataPacket::release_metrics() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.metrics)
  if (_internal_has_metrics()) {
    clear_has_value();
    ::livekit::MetricsBatch* temp = _impl_.value_.metrics_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.metrics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MetricsBatch& DataPacket::_internal_metrics() const {
  return _internal_has_metrics()
      ? *_impl_.value_.metrics_
      : reinterpret_cast< ::livekit::MetricsBatch&>(::livekit::_MetricsBatch_default_instance_);
}
inline const ::livekit::MetricsBatch& DataPacket::metrics() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.metrics)
  return _internal_metrics();
}
inline ::livekit::MetricsBatch* DataPacket::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.metrics)
  if (_internal_has_metrics()) {
    clear_has_value();
    ::livekit::MetricsBatch* temp = _impl_.value_.metrics_;
    _impl_.value_.metrics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_metrics(::livekit::MetricsBatch* metrics) {
  clear_value();
  if (metrics) {
    set_has_metrics();
    _impl_.value_.metrics_ = metrics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.metrics)
}
inline ::livekit::MetricsBatch* DataPacket::_internal_mutable_metrics() {
  if (!_internal_has_metrics()) {
    clear_value();
    set_has_metrics();
    _impl_.value_.metrics_ = CreateMaybeMessage< ::livekit::MetricsBatch >(GetArenaForAllocation());
  }
  return _impl_.value_.metrics_;
}
inline ::livekit::MetricsBatch* DataPacket::mutable_metrics() {
  ::livekit::MetricsBatch* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.metrics)
  return _msg;
}

// .livekit.ChatMessage chat_message = 9;
inline bool DataPacket::_internal_has_chat_message() const {
  return value_case() == kChatMessage;
}
inline bool DataPacket::has_chat_message() const {
  return _internal_has_chat_message();
}
inline void DataPacket::set_has_chat_message() {
  _impl_._oneof_case_[0] = kChatMessage;
}
inline void DataPacket::clear_chat_message() {
  if (_internal_has_chat_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.chat_message_;
    }
    clear_has_value();
  }
}
inline ::livekit::ChatMessage* DataPacket::release_chat_message() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_value();
    ::livekit::ChatMessage* temp = _impl_.value_.chat_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::ChatMessage& DataPacket::_internal_chat_message() const {
  return _internal_has_chat_message()
      ? *_impl_.value_.chat_message_
      : reinterpret_cast< ::livekit::ChatMessage&>(::livekit::_ChatMessage_default_instance_);
}
inline const ::livekit::ChatMessage& DataPacket::chat_message() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.chat_message)
  return _internal_chat_message();
}
inline ::livekit::ChatMessage* DataPacket::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_value();
    ::livekit::ChatMessage* temp = _impl_.value_.chat_message_;
    _impl_.value_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_chat_message(::livekit::ChatMessage* chat_message) {
  clear_value();
  if (chat_message) {
    set_has_chat_message();
    _impl_.value_.chat_message_ = chat_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.chat_message)
}
inline ::livekit::ChatMessage* DataPacket::_internal_mutable_chat_message() {
  if (!_internal_has_chat_message()) {
    clear_value();
    set_has_chat_message();
    _impl_.value_.chat_message_ = CreateMaybeMessage< ::livekit::ChatMessage >(GetArenaForAllocation());
  }
  return _impl_.value_.chat_message_;
}
inline ::livekit::ChatMessage* DataPacket::mutable_chat_message() {
  ::livekit::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.chat_message)
  return _msg;
}

// .livekit.RpcRequest rpc_request = 10;
inline bool DataPacket::_internal_has_rpc_request() const {
  return value_case() == kRpcRequest;
}
inline bool DataPacket::has_rpc_request() const {
  return _internal_has_rpc_request();
}
inline void DataPacket::set_has_rpc_request() {
  _impl_._oneof_case_[0] = kRpcRequest;
}
inline void DataPacket::clear_rpc_request() {
  if (_internal_has_rpc_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.rpc_request_;
    }
    clear_has_value();
  }
}
inline ::livekit::RpcRequest* DataPacket::release_rpc_request() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.rpc_request)
  if (_internal_has_rpc_request()) {
    clear_has_value();
    ::livekit::RpcRequest* temp = _impl_.value_.rpc_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rpc_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RpcRequest& DataPacket::_internal_rpc_request() const {
  return _internal_has_rpc_request()
      ? *_impl_.value_.rpc_request_
      : reinterpret_cast< ::livekit::RpcRequest&>(::livekit::_RpcRequest_default_instance_);
}
inline const ::livekit::RpcRequest& DataPacket::rpc_request() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.rpc_request)
  return _internal_rpc_request();
}
inline ::livekit::RpcRequest* DataPacket::unsafe_arena_release_rpc_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.rpc_request)
  if (_internal_has_rpc_request()) {
    clear_has_value();
    ::livekit::RpcRequest* temp = _impl_.value_.rpc_request_;
    _impl_.value_.rpc_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_rpc_request(::livekit::RpcRequest* rpc_request) {
  clear_value();
  if (rpc_request) {
    set_has_rpc_request();
    _impl_.value_.rpc_request_ = rpc_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.rpc_request)
}
inline ::livekit::RpcRequest* DataPacket::_internal_mutable_rpc_request() {
  if (!_internal_has_rpc_request()) {
    clear_value();
    set_has_rpc_request();
    _impl_.value_.rpc_request_ = CreateMaybeMessage< ::livekit::RpcRequest >(GetArenaForAllocation());
  }
  return _impl_.value_.rpc_request_;
}
inline ::livekit::RpcRequest* DataPacket::mutable_rpc_request() {
  ::livekit::RpcRequest* _msg = _internal_mutable_rpc_request();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.rpc_request)
  return _msg;
}

// .livekit.RpcAck rpc_ack = 11;
inline bool DataPacket::_internal_has_rpc_ack() const {
  return value_case() == kRpcAck;
}
inline bool DataPacket::has_rpc_ack() const {
  return _internal_has_rpc_ack();
}
inline void DataPacket::set_has_rpc_ack() {
  _impl_._oneof_case_[0] = kRpcAck;
}
inline void DataPacket::clear_rpc_ack() {
  if (_internal_has_rpc_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.rpc_ack_;
    }
    clear_has_value();
  }
}
inline ::livekit::RpcAck* DataPacket::release_rpc_ack() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.rpc_ack)
  if (_internal_has_rpc_ack()) {
    clear_has_value();
    ::livekit::RpcAck* temp = _impl_.value_.rpc_ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rpc_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RpcAck& DataPacket::_internal_rpc_ack() const {
  return _internal_has_rpc_ack()
      ? *_impl_.value_.rpc_ack_
      : reinterpret_cast< ::livekit::RpcAck&>(::livekit::_RpcAck_default_instance_);
}
inline const ::livekit::RpcAck& DataPacket::rpc_ack() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.rpc_ack)
  return _internal_rpc_ack();
}
inline ::livekit::RpcAck* DataPacket::unsafe_arena_release_rpc_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.rpc_ack)
  if (_internal_has_rpc_ack()) {
    clear_has_value();
    ::livekit::RpcAck* temp = _impl_.value_.rpc_ack_;
    _impl_.value_.rpc_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_rpc_ack(::livekit::RpcAck* rpc_ack) {
  clear_value();
  if (rpc_ack) {
    set_has_rpc_ack();
    _impl_.value_.rpc_ack_ = rpc_ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.rpc_ack)
}
inline ::livekit::RpcAck* DataPacket::_internal_mutable_rpc_ack() {
  if (!_internal_has_rpc_ack()) {
    clear_value();
    set_has_rpc_ack();
    _impl_.value_.rpc_ack_ = CreateMaybeMessage< ::livekit::RpcAck >(GetArenaForAllocation());
  }
  return _impl_.value_.rpc_ack_;
}
inline ::livekit::RpcAck* DataPacket::mutable_rpc_ack() {
  ::livekit::RpcAck* _msg = _internal_mutable_rpc_ack();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.rpc_ack)
  return _msg;
}

// .livekit.RpcResponse rpc_response = 12;
inline bool DataPacket::_internal_has_rpc_response() const {
  return value_case() == kRpcResponse;
}
inline bool DataPacket::has_rpc_response() const {
  return _internal_has_rpc_response();
}
inline void DataPacket::set_has_rpc_response() {
  _impl_._oneof_case_[0] = kRpcResponse;
}
inline void DataPacket::clear_rpc_response() {
  if (_internal_has_rpc_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.rpc_response_;
    }
    clear_has_value();
  }
}
inline ::livekit::RpcResponse* DataPacket::release_rpc_response() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.rpc_response)
  if (_internal_has_rpc_response()) {
    clear_has_value();
    ::livekit::RpcResponse* temp = _impl_.value_.rpc_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.rpc_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RpcResponse& DataPacket::_internal_rpc_response() const {
  return _internal_has_rpc_response()
      ? *_impl_.value_.rpc_response_
      : reinterpret_cast< ::livekit::RpcResponse&>(::livekit::_RpcResponse_default_instance_);
}
inline const ::livekit::RpcResponse& DataPacket::rpc_response() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.rpc_response)
  return _internal_rpc_response();
}
inline ::livekit::RpcResponse* DataPacket::unsafe_arena_release_rpc_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.rpc_response)
  if (_internal_has_rpc_response()) {
    clear_has_value();
    ::livekit::RpcResponse* temp = _impl_.value_.rpc_response_;
    _impl_.value_.rpc_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_rpc_response(::livekit::RpcResponse* rpc_response) {
  clear_value();
  if (rpc_response) {
    set_has_rpc_response();
    _impl_.value_.rpc_response_ = rpc_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.rpc_response)
}
inline ::livekit::RpcResponse* DataPacket::_internal_mutable_rpc_response() {
  if (!_internal_has_rpc_response()) {
    clear_value();
    set_has_rpc_response();
    _impl_.value_.rpc_response_ = CreateMaybeMessage< ::livekit::RpcResponse >(GetArenaForAllocation());
  }
  return _impl_.value_.rpc_response_;
}
inline ::livekit::RpcResponse* DataPacket::mutable_rpc_response() {
  ::livekit::RpcResponse* _msg = _internal_mutable_rpc_response();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.rpc_response)
  return _msg;
}

// .livekit.DataStream.Header stream_header = 13;
inline bool DataPacket::_internal_has_stream_header() const {
  return value_case() == kStreamHeader;
}
inline bool DataPacket::has_stream_header() const {
  return _internal_has_stream_header();
}
inline void DataPacket::set_has_stream_header() {
  _impl_._oneof_case_[0] = kStreamHeader;
}
inline void DataPacket::clear_stream_header() {
  if (_internal_has_stream_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.stream_header_;
    }
    clear_has_value();
  }
}
inline ::livekit::DataStream_Header* DataPacket::release_stream_header() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.stream_header)
  if (_internal_has_stream_header()) {
    clear_has_value();
    ::livekit::DataStream_Header* temp = _impl_.value_.stream_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.stream_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DataStream_Header& DataPacket::_internal_stream_header() const {
  return _internal_has_stream_header()
      ? *_impl_.value_.stream_header_
      : reinterpret_cast< ::livekit::DataStream_Header&>(::livekit::_DataStream_Header_default_instance_);
}
inline const ::livekit::DataStream_Header& DataPacket::stream_header() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.stream_header)
  return _internal_stream_header();
}
inline ::livekit::DataStream_Header* DataPacket::unsafe_arena_release_stream_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.stream_header)
  if (_internal_has_stream_header()) {
    clear_has_value();
    ::livekit::DataStream_Header* temp = _impl_.value_.stream_header_;
    _impl_.value_.stream_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_stream_header(::livekit::DataStream_Header* stream_header) {
  clear_value();
  if (stream_header) {
    set_has_stream_header();
    _impl_.value_.stream_header_ = stream_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.stream_header)
}
inline ::livekit::DataStream_Header* DataPacket::_internal_mutable_stream_header() {
  if (!_internal_has_stream_header()) {
    clear_value();
    set_has_stream_header();
    _impl_.value_.stream_header_ = CreateMaybeMessage< ::livekit::DataStream_Header >(GetArenaForAllocation());
  }
  return _impl_.value_.stream_header_;
}
inline ::livekit::DataStream_Header* DataPacket::mutable_stream_header() {
  ::livekit::DataStream_Header* _msg = _internal_mutable_stream_header();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.stream_header)
  return _msg;
}

// .livekit.DataStream.Chunk stream_chunk = 14;
inline bool DataPacket::_internal_has_stream_chunk() const {
  return value_case() == kStreamChunk;
}
inline bool DataPacket::has_stream_chunk() const {
  return _internal_has_stream_chunk();
}
inline void DataPacket::set_has_stream_chunk() {
  _impl_._oneof_case_[0] = kStreamChunk;
}
inline void DataPacket::clear_stream_chunk() {
  if (_internal_has_stream_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.stream_chunk_;
    }
    clear_has_value();
  }
}
inline ::livekit::DataStream_Chunk* DataPacket::release_stream_chunk() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.stream_chunk)
  if (_internal_has_stream_chunk()) {
    clear_has_value();
    ::livekit::DataStream_Chunk* temp = _impl_.value_.stream_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.stream_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DataStream_Chunk& DataPacket::_internal_stream_chunk() const {
  return _internal_has_stream_chunk()
      ? *_impl_.value_.stream_chunk_
      : reinterpret_cast< ::livekit::DataStream_Chunk&>(::livekit::_DataStream_Chunk_default_instance_);
}
inline const ::livekit::DataStream_Chunk& DataPacket::stream_chunk() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.stream_chunk)
  return _internal_stream_chunk();
}
inline ::livekit::DataStream_Chunk* DataPacket::unsafe_arena_release_stream_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.stream_chunk)
  if (_internal_has_stream_chunk()) {
    clear_has_value();
    ::livekit::DataStream_Chunk* temp = _impl_.value_.stream_chunk_;
    _impl_.value_.stream_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_stream_chunk(::livekit::DataStream_Chunk* stream_chunk) {
  clear_value();
  if (stream_chunk) {
    set_has_stream_chunk();
    _impl_.value_.stream_chunk_ = stream_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.stream_chunk)
}
inline ::livekit::DataStream_Chunk* DataPacket::_internal_mutable_stream_chunk() {
  if (!_internal_has_stream_chunk()) {
    clear_value();
    set_has_stream_chunk();
    _impl_.value_.stream_chunk_ = CreateMaybeMessage< ::livekit::DataStream_Chunk >(GetArenaForAllocation());
  }
  return _impl_.value_.stream_chunk_;
}
inline ::livekit::DataStream_Chunk* DataPacket::mutable_stream_chunk() {
  ::livekit::DataStream_Chunk* _msg = _internal_mutable_stream_chunk();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.stream_chunk)
  return _msg;
}

// .livekit.DataStream.Trailer stream_trailer = 15;
inline bool DataPacket::_internal_has_stream_trailer() const {
  return value_case() == kStreamTrailer;
}
inline bool DataPacket::has_stream_trailer() const {
  return _internal_has_stream_trailer();
}
inline void DataPacket::set_has_stream_trailer() {
  _impl_._oneof_case_[0] = kStreamTrailer;
}
inline void DataPacket::clear_stream_trailer() {
  if (_internal_has_stream_trailer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.stream_trailer_;
    }
    clear_has_value();
  }
}
inline ::livekit::DataStream_Trailer* DataPacket::release_stream_trailer() {
  // @@protoc_insertion_point(field_release:livekit.DataPacket.stream_trailer)
  if (_internal_has_stream_trailer()) {
    clear_has_value();
    ::livekit::DataStream_Trailer* temp = _impl_.value_.stream_trailer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.stream_trailer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DataStream_Trailer& DataPacket::_internal_stream_trailer() const {
  return _internal_has_stream_trailer()
      ? *_impl_.value_.stream_trailer_
      : reinterpret_cast< ::livekit::DataStream_Trailer&>(::livekit::_DataStream_Trailer_default_instance_);
}
inline const ::livekit::DataStream_Trailer& DataPacket::stream_trailer() const {
  // @@protoc_insertion_point(field_get:livekit.DataPacket.stream_trailer)
  return _internal_stream_trailer();
}
inline ::livekit::DataStream_Trailer* DataPacket::unsafe_arena_release_stream_trailer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataPacket.stream_trailer)
  if (_internal_has_stream_trailer()) {
    clear_has_value();
    ::livekit::DataStream_Trailer* temp = _impl_.value_.stream_trailer_;
    _impl_.value_.stream_trailer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacket::unsafe_arena_set_allocated_stream_trailer(::livekit::DataStream_Trailer* stream_trailer) {
  clear_value();
  if (stream_trailer) {
    set_has_stream_trailer();
    _impl_.value_.stream_trailer_ = stream_trailer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataPacket.stream_trailer)
}
inline ::livekit::DataStream_Trailer* DataPacket::_internal_mutable_stream_trailer() {
  if (!_internal_has_stream_trailer()) {
    clear_value();
    set_has_stream_trailer();
    _impl_.value_.stream_trailer_ = CreateMaybeMessage< ::livekit::DataStream_Trailer >(GetArenaForAllocation());
  }
  return _impl_.value_.stream_trailer_;
}
inline ::livekit::DataStream_Trailer* DataPacket::mutable_stream_trailer() {
  ::livekit::DataStream_Trailer* _msg = _internal_mutable_stream_trailer();
  // @@protoc_insertion_point(field_mutable:livekit.DataPacket.stream_trailer)
  return _msg;
}

inline bool DataPacket::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataPacket::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataPacket::ValueCase DataPacket::value_case() const {
  return DataPacket::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActiveSpeakerUpdate

// repeated .livekit.SpeakerInfo speakers = 1;
inline int ActiveSpeakerUpdate::_internal_speakers_size() const {
  return _impl_.speakers_.size();
}
inline int ActiveSpeakerUpdate::speakers_size() const {
  return _internal_speakers_size();
}
inline void ActiveSpeakerUpdate::clear_speakers() {
  _impl_.speakers_.Clear();
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::mutable_speakers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ActiveSpeakerUpdate.speakers)
  return _impl_.speakers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >*
ActiveSpeakerUpdate::mutable_speakers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ActiveSpeakerUpdate.speakers)
  return &_impl_.speakers_;
}
inline const ::livekit::SpeakerInfo& ActiveSpeakerUpdate::_internal_speakers(int index) const {
  return _impl_.speakers_.Get(index);
}
inline const ::livekit::SpeakerInfo& ActiveSpeakerUpdate::speakers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ActiveSpeakerUpdate.speakers)
  return _internal_speakers(index);
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::_internal_add_speakers() {
  return _impl_.speakers_.Add();
}
inline ::livekit::SpeakerInfo* ActiveSpeakerUpdate::add_speakers() {
  ::livekit::SpeakerInfo* _add = _internal_add_speakers();
  // @@protoc_insertion_point(field_add:livekit.ActiveSpeakerUpdate.speakers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::SpeakerInfo >&
ActiveSpeakerUpdate::speakers() const {
  // @@protoc_insertion_point(field_list:livekit.ActiveSpeakerUpdate.speakers)
  return _impl_.speakers_;
}

// -------------------------------------------------------------------

// SpeakerInfo

// string sid = 1;
inline void SpeakerInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
}
inline const std::string& SpeakerInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SpeakerInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.sid)
}
inline std::string* SpeakerInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.SpeakerInfo.sid)
  return _s;
}
inline const std::string& SpeakerInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void SpeakerInfo::_internal_set_sid(const std::string& value) {
  
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* SpeakerInfo::_internal_mutable_sid() {
  
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* SpeakerInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.SpeakerInfo.sid)
  return _impl_.sid_.Release();
}
inline void SpeakerInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SpeakerInfo.sid)
}

// float level = 2;
inline void SpeakerInfo::clear_level() {
  _impl_.level_ = 0;
}
inline float SpeakerInfo::_internal_level() const {
  return _impl_.level_;
}
inline float SpeakerInfo::level() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.level)
  return _internal_level();
}
inline void SpeakerInfo::_internal_set_level(float value) {
  
  _impl_.level_ = value;
}
inline void SpeakerInfo::set_level(float value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.level)
}

// bool active = 3;
inline void SpeakerInfo::clear_active() {
  _impl_.active_ = false;
}
inline bool SpeakerInfo::_internal_active() const {
  return _impl_.active_;
}
inline bool SpeakerInfo::active() const {
  // @@protoc_insertion_point(field_get:livekit.SpeakerInfo.active)
  return _internal_active();
}
inline void SpeakerInfo::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void SpeakerInfo::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:livekit.SpeakerInfo.active)
}

// -------------------------------------------------------------------

// UserPacket

// string participant_sid = 1 [deprecated = true];
inline void UserPacket::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& UserPacket::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.participant_sid)
}
inline std::string* UserPacket::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.participant_sid)
  return _s;
}
inline const std::string& UserPacket::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void UserPacket::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void UserPacket::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.participant_sid)
}

// string participant_identity = 5 [deprecated = true];
inline void UserPacket::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& UserPacket::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.participant_identity)
}
inline std::string* UserPacket::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.participant_identity)
  return _s;
}
inline const std::string& UserPacket::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void UserPacket::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void UserPacket::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.participant_identity)
}

// bytes payload = 2;
inline void UserPacket::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& UserPacket::payload() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.payload)
}
inline std::string* UserPacket::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.payload)
  return _s;
}
inline const std::string& UserPacket::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void UserPacket::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_payload() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.payload)
  return _impl_.payload_.Release();
}
inline void UserPacket::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.payload)
}

// repeated string destination_sids = 3 [deprecated = true];
inline int UserPacket::_internal_destination_sids_size() const {
  return _impl_.destination_sids_.size();
}
inline int UserPacket::destination_sids_size() const {
  return _internal_destination_sids_size();
}
inline void UserPacket::clear_destination_sids() {
  _impl_.destination_sids_.Clear();
}
inline std::string* UserPacket::add_destination_sids() {
  std::string* _s = _internal_add_destination_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UserPacket.destination_sids)
  return _s;
}
inline const std::string& UserPacket::_internal_destination_sids(int index) const {
  return _impl_.destination_sids_.Get(index);
}
inline const std::string& UserPacket::destination_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.destination_sids)
  return _internal_destination_sids(index);
}
inline std::string* UserPacket::mutable_destination_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.destination_sids)
  return _impl_.destination_sids_.Mutable(index);
}
inline void UserPacket::set_destination_sids(int index, const std::string& value) {
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, std::string&& value) {
  _impl_.destination_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UserPacket.destination_sids)
}
inline void UserPacket::set_destination_sids(int index, const char* value, size_t size) {
  _impl_.destination_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UserPacket.destination_sids)
}
inline std::string* UserPacket::_internal_add_destination_sids() {
  return _impl_.destination_sids_.Add();
}
inline void UserPacket::add_destination_sids(const std::string& value) {
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(std::string&& value) {
  _impl_.destination_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UserPacket.destination_sids)
}
inline void UserPacket::add_destination_sids(const char* value, size_t size) {
  _impl_.destination_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UserPacket.destination_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserPacket::destination_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UserPacket.destination_sids)
  return _impl_.destination_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserPacket::mutable_destination_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UserPacket.destination_sids)
  return &_impl_.destination_sids_;
}

// repeated string destination_identities = 6 [deprecated = true];
inline int UserPacket::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int UserPacket::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void UserPacket::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* UserPacket::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.UserPacket.destination_identities)
  return _s;
}
inline const std::string& UserPacket::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& UserPacket::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* UserPacket::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void UserPacket::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_identities)
}
inline void UserPacket::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UserPacket.destination_identities)
}
inline void UserPacket::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UserPacket.destination_identities)
}
inline void UserPacket::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UserPacket.destination_identities)
}
inline std::string* UserPacket::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void UserPacket::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_identities)
}
inline void UserPacket::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UserPacket.destination_identities)
}
inline void UserPacket::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UserPacket.destination_identities)
}
inline void UserPacket::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UserPacket.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserPacket::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.UserPacket.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserPacket::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UserPacket.destination_identities)
  return &_impl_.destination_identities_;
}

// optional string topic = 4;
inline bool UserPacket::_internal_has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserPacket::has_topic() const {
  return _internal_has_topic();
}
inline void UserPacket::clear_topic() {
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserPacket::topic() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.topic)
}
inline std::string* UserPacket::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.topic)
  return _s;
}
inline const std::string& UserPacket::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void UserPacket::_internal_set_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserPacket::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.topic)
}

// optional string id = 8;
inline bool UserPacket::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserPacket::has_id() const {
  return _internal_has_id();
}
inline void UserPacket::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserPacket::id() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.id)
}
inline std::string* UserPacket::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.id)
  return _s;
}
inline const std::string& UserPacket::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UserPacket::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_id() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserPacket::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.id)
}

// optional uint64 start_time = 9;
inline bool UserPacket::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserPacket::has_start_time() const {
  return _internal_has_start_time();
}
inline void UserPacket::clear_start_time() {
  _impl_.start_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t UserPacket::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint64_t UserPacket::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.start_time)
  return _internal_start_time();
}
inline void UserPacket::_internal_set_start_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_ = value;
}
inline void UserPacket::set_start_time(uint64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:livekit.UserPacket.start_time)
}

// optional uint64 end_time = 10;
inline bool UserPacket::_internal_has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserPacket::has_end_time() const {
  return _internal_has_end_time();
}
inline void UserPacket::clear_end_time() {
  _impl_.end_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t UserPacket::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint64_t UserPacket::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.end_time)
  return _internal_end_time();
}
inline void UserPacket::_internal_set_end_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.end_time_ = value;
}
inline void UserPacket::set_end_time(uint64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:livekit.UserPacket.end_time)
}

// bytes nonce = 11;
inline void UserPacket::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& UserPacket::nonce() const {
  // @@protoc_insertion_point(field_get:livekit.UserPacket.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UserPacket.nonce)
}
inline std::string* UserPacket::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:livekit.UserPacket.nonce)
  return _s;
}
inline const std::string& UserPacket::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void UserPacket::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_nonce() {
  // @@protoc_insertion_point(field_release:livekit.UserPacket.nonce)
  return _impl_.nonce_.Release();
}
inline void UserPacket::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UserPacket.nonce)
}

// -------------------------------------------------------------------

// SipDTMF

// uint32 code = 3;
inline void SipDTMF::clear_code() {
  _impl_.code_ = 0u;
}
inline uint32_t SipDTMF::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t SipDTMF::code() const {
  // @@protoc_insertion_point(field_get:livekit.SipDTMF.code)
  return _internal_code();
}
inline void SipDTMF::_internal_set_code(uint32_t value) {
  
  _impl_.code_ = value;
}
inline void SipDTMF::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:livekit.SipDTMF.code)
}

// string digit = 4;
inline void SipDTMF::clear_digit() {
  _impl_.digit_.ClearToEmpty();
}
inline const std::string& SipDTMF::digit() const {
  // @@protoc_insertion_point(field_get:livekit.SipDTMF.digit)
  return _internal_digit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipDTMF::set_digit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.digit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SipDTMF.digit)
}
inline std::string* SipDTMF::mutable_digit() {
  std::string* _s = _internal_mutable_digit();
  // @@protoc_insertion_point(field_mutable:livekit.SipDTMF.digit)
  return _s;
}
inline const std::string& SipDTMF::_internal_digit() const {
  return _impl_.digit_.Get();
}
inline void SipDTMF::_internal_set_digit(const std::string& value) {
  
  _impl_.digit_.Set(value, GetArenaForAllocation());
}
inline std::string* SipDTMF::_internal_mutable_digit() {
  
  return _impl_.digit_.Mutable(GetArenaForAllocation());
}
inline std::string* SipDTMF::release_digit() {
  // @@protoc_insertion_point(field_release:livekit.SipDTMF.digit)
  return _impl_.digit_.Release();
}
inline void SipDTMF::set_allocated_digit(std::string* digit) {
  if (digit != nullptr) {
    
  } else {
    
  }
  _impl_.digit_.SetAllocated(digit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digit_.IsDefault()) {
    _impl_.digit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SipDTMF.digit)
}

// -------------------------------------------------------------------

// Transcription

// string transcribed_participant_identity = 2;
inline void Transcription::clear_transcribed_participant_identity() {
  _impl_.transcribed_participant_identity_.ClearToEmpty();
}
inline const std::string& Transcription::transcribed_participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.Transcription.transcribed_participant_identity)
  return _internal_transcribed_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transcription::set_transcribed_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transcribed_participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Transcription.transcribed_participant_identity)
}
inline std::string* Transcription::mutable_transcribed_participant_identity() {
  std::string* _s = _internal_mutable_transcribed_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.Transcription.transcribed_participant_identity)
  return _s;
}
inline const std::string& Transcription::_internal_transcribed_participant_identity() const {
  return _impl_.transcribed_participant_identity_.Get();
}
inline void Transcription::_internal_set_transcribed_participant_identity(const std::string& value) {
  
  _impl_.transcribed_participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* Transcription::_internal_mutable_transcribed_participant_identity() {
  
  return _impl_.transcribed_participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* Transcription::release_transcribed_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.Transcription.transcribed_participant_identity)
  return _impl_.transcribed_participant_identity_.Release();
}
inline void Transcription::set_allocated_transcribed_participant_identity(std::string* transcribed_participant_identity) {
  if (transcribed_participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.transcribed_participant_identity_.SetAllocated(transcribed_participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transcribed_participant_identity_.IsDefault()) {
    _impl_.transcribed_participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Transcription.transcribed_participant_identity)
}

// string track_id = 3;
inline void Transcription::clear_track_id() {
  _impl_.track_id_.ClearToEmpty();
}
inline const std::string& Transcription::track_id() const {
  // @@protoc_insertion_point(field_get:livekit.Transcription.track_id)
  return _internal_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transcription::set_track_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Transcription.track_id)
}
inline std::string* Transcription::mutable_track_id() {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.Transcription.track_id)
  return _s;
}
inline const std::string& Transcription::_internal_track_id() const {
  return _impl_.track_id_.Get();
}
inline void Transcription::_internal_set_track_id(const std::string& value) {
  
  _impl_.track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Transcription::_internal_mutable_track_id() {
  
  return _impl_.track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Transcription::release_track_id() {
  // @@protoc_insertion_point(field_release:livekit.Transcription.track_id)
  return _impl_.track_id_.Release();
}
inline void Transcription::set_allocated_track_id(std::string* track_id) {
  if (track_id != nullptr) {
    
  } else {
    
  }
  _impl_.track_id_.SetAllocated(track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Transcription.track_id)
}

// repeated .livekit.TranscriptionSegment segments = 4;
inline int Transcription::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int Transcription::segments_size() const {
  return _internal_segments_size();
}
inline void Transcription::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::livekit::TranscriptionSegment* Transcription::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.Transcription.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TranscriptionSegment >*
Transcription::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:livekit.Transcription.segments)
  return &_impl_.segments_;
}
inline const ::livekit::TranscriptionSegment& Transcription::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::livekit::TranscriptionSegment& Transcription::segments(int index) const {
  // @@protoc_insertion_point(field_get:livekit.Transcription.segments)
  return _internal_segments(index);
}
inline ::livekit::TranscriptionSegment* Transcription::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::livekit::TranscriptionSegment* Transcription::add_segments() {
  ::livekit::TranscriptionSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:livekit.Transcription.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TranscriptionSegment >&
Transcription::segments() const {
  // @@protoc_insertion_point(field_list:livekit.Transcription.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// TranscriptionSegment

// string id = 1;
inline void TranscriptionSegment::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TranscriptionSegment::id() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.id)
}
inline std::string* TranscriptionSegment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.TranscriptionSegment.id)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TranscriptionSegment::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_id() {
  // @@protoc_insertion_point(field_release:livekit.TranscriptionSegment.id)
  return _impl_.id_.Release();
}
inline void TranscriptionSegment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TranscriptionSegment.id)
}

// string text = 2;
inline void TranscriptionSegment::clear_text() {
  _impl_.text_.ClearToEmpty();
}
inline const std::string& TranscriptionSegment::text() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.text)
}
inline std::string* TranscriptionSegment::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:livekit.TranscriptionSegment.text)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranscriptionSegment::_internal_set_text(const std::string& value) {
  
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_text() {
  
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_text() {
  // @@protoc_insertion_point(field_release:livekit.TranscriptionSegment.text)
  return _impl_.text_.Release();
}
inline void TranscriptionSegment::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TranscriptionSegment.text)
}

// uint64 start_time = 3;
inline void TranscriptionSegment::clear_start_time() {
  _impl_.start_time_ = uint64_t{0u};
}
inline uint64_t TranscriptionSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint64_t TranscriptionSegment::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.start_time)
  return _internal_start_time();
}
inline void TranscriptionSegment::_internal_set_start_time(uint64_t value) {
  
  _impl_.start_time_ = value;
}
inline void TranscriptionSegment::set_start_time(uint64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.start_time)
}

// uint64 end_time = 4;
inline void TranscriptionSegment::clear_end_time() {
  _impl_.end_time_ = uint64_t{0u};
}
inline uint64_t TranscriptionSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint64_t TranscriptionSegment::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.end_time)
  return _internal_end_time();
}
inline void TranscriptionSegment::_internal_set_end_time(uint64_t value) {
  
  _impl_.end_time_ = value;
}
inline void TranscriptionSegment::set_end_time(uint64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.end_time)
}

// bool final = 5;
inline void TranscriptionSegment::clear_final() {
  _impl_.final_ = false;
}
inline bool TranscriptionSegment::_internal_final() const {
  return _impl_.final_;
}
inline bool TranscriptionSegment::final() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.final)
  return _internal_final();
}
inline void TranscriptionSegment::_internal_set_final(bool value) {
  
  _impl_.final_ = value;
}
inline void TranscriptionSegment::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.final)
}

// string language = 6;
inline void TranscriptionSegment::clear_language() {
  _impl_.language_.ClearToEmpty();
}
inline const std::string& TranscriptionSegment::language() const {
  // @@protoc_insertion_point(field_get:livekit.TranscriptionSegment.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_language(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.TranscriptionSegment.language)
}
inline std::string* TranscriptionSegment::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:livekit.TranscriptionSegment.language)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranscriptionSegment::_internal_set_language(const std::string& value) {
  
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_language() {
  
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_language() {
  // @@protoc_insertion_point(field_release:livekit.TranscriptionSegment.language)
  return _impl_.language_.Release();
}
inline void TranscriptionSegment::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.TranscriptionSegment.language)
}

// -------------------------------------------------------------------

// ChatMessage

// string id = 1;
inline void ChatMessage::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChatMessage::id() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.id)
}
inline std::string* ChatMessage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.ChatMessage.id)
  return _s;
}
inline const std::string& ChatMessage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChatMessage::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_id() {
  // @@protoc_insertion_point(field_release:livekit.ChatMessage.id)
  return _impl_.id_.Release();
}
inline void ChatMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ChatMessage.id)
}

// int64 timestamp = 2;
inline void ChatMessage::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t ChatMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ChatMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.timestamp)
  return _internal_timestamp();
}
inline void ChatMessage::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void ChatMessage::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.timestamp)
}

// optional int64 edit_timestamp = 3;
inline bool ChatMessage::_internal_has_edit_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatMessage::has_edit_timestamp() const {
  return _internal_has_edit_timestamp();
}
inline void ChatMessage::clear_edit_timestamp() {
  _impl_.edit_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ChatMessage::_internal_edit_timestamp() const {
  return _impl_.edit_timestamp_;
}
inline int64_t ChatMessage::edit_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.edit_timestamp)
  return _internal_edit_timestamp();
}
inline void ChatMessage::_internal_set_edit_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.edit_timestamp_ = value;
}
inline void ChatMessage::set_edit_timestamp(int64_t value) {
  _internal_set_edit_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.edit_timestamp)
}

// string message = 4;
inline void ChatMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatMessage::message() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.message)
}
inline std::string* ChatMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.ChatMessage.message)
  return _s;
}
inline const std::string& ChatMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatMessage::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_message() {
  // @@protoc_insertion_point(field_release:livekit.ChatMessage.message)
  return _impl_.message_.Release();
}
inline void ChatMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ChatMessage.message)
}

// bool deleted = 5;
inline void ChatMessage::clear_deleted() {
  _impl_.deleted_ = false;
}
inline bool ChatMessage::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool ChatMessage::deleted() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.deleted)
  return _internal_deleted();
}
inline void ChatMessage::_internal_set_deleted(bool value) {
  
  _impl_.deleted_ = value;
}
inline void ChatMessage::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.deleted)
}

// bool generated = 6;
inline void ChatMessage::clear_generated() {
  _impl_.generated_ = false;
}
inline bool ChatMessage::_internal_generated() const {
  return _impl_.generated_;
}
inline bool ChatMessage::generated() const {
  // @@protoc_insertion_point(field_get:livekit.ChatMessage.generated)
  return _internal_generated();
}
inline void ChatMessage::_internal_set_generated(bool value) {
  
  _impl_.generated_ = value;
}
inline void ChatMessage::set_generated(bool value) {
  _internal_set_generated(value);
  // @@protoc_insertion_point(field_set:livekit.ChatMessage.generated)
}

// -------------------------------------------------------------------

// RpcRequest

// string id = 1;
inline void RpcRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& RpcRequest::id() const {
  // @@protoc_insertion_point(field_get:livekit.RpcRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcRequest.id)
}
inline std::string* RpcRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.RpcRequest.id)
  return _s;
}
inline const std::string& RpcRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void RpcRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcRequest::release_id() {
  // @@protoc_insertion_point(field_release:livekit.RpcRequest.id)
  return _impl_.id_.Release();
}
inline void RpcRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcRequest.id)
}

// string method = 2;
inline void RpcRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& RpcRequest::method() const {
  // @@protoc_insertion_point(field_get:livekit.RpcRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcRequest.method)
}
inline std::string* RpcRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:livekit.RpcRequest.method)
  return _s;
}
inline const std::string& RpcRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void RpcRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcRequest::release_method() {
  // @@protoc_insertion_point(field_release:livekit.RpcRequest.method)
  return _impl_.method_.Release();
}
inline void RpcRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcRequest.method)
}

// string payload = 3;
inline void RpcRequest::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& RpcRequest::payload() const {
  // @@protoc_insertion_point(field_get:livekit.RpcRequest.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcRequest::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcRequest.payload)
}
inline std::string* RpcRequest::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:livekit.RpcRequest.payload)
  return _s;
}
inline const std::string& RpcRequest::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void RpcRequest::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcRequest::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcRequest::release_payload() {
  // @@protoc_insertion_point(field_release:livekit.RpcRequest.payload)
  return _impl_.payload_.Release();
}
inline void RpcRequest::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcRequest.payload)
}

// uint32 response_timeout_ms = 4;
inline void RpcRequest::clear_response_timeout_ms() {
  _impl_.response_timeout_ms_ = 0u;
}
inline uint32_t RpcRequest::_internal_response_timeout_ms() const {
  return _impl_.response_timeout_ms_;
}
inline uint32_t RpcRequest::response_timeout_ms() const {
  // @@protoc_insertion_point(field_get:livekit.RpcRequest.response_timeout_ms)
  return _internal_response_timeout_ms();
}
inline void RpcRequest::_internal_set_response_timeout_ms(uint32_t value) {
  
  _impl_.response_timeout_ms_ = value;
}
inline void RpcRequest::set_response_timeout_ms(uint32_t value) {
  _internal_set_response_timeout_ms(value);
  // @@protoc_insertion_point(field_set:livekit.RpcRequest.response_timeout_ms)
}

// uint32 version = 5;
inline void RpcRequest::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t RpcRequest::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t RpcRequest::version() const {
  // @@protoc_insertion_point(field_get:livekit.RpcRequest.version)
  return _internal_version();
}
inline void RpcRequest::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void RpcRequest::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.RpcRequest.version)
}

// -------------------------------------------------------------------

// RpcAck

// string request_id = 1;
inline void RpcAck::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& RpcAck::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.RpcAck.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcAck::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcAck.request_id)
}
inline std::string* RpcAck::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:livekit.RpcAck.request_id)
  return _s;
}
inline const std::string& RpcAck::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void RpcAck::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcAck::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcAck::release_request_id() {
  // @@protoc_insertion_point(field_release:livekit.RpcAck.request_id)
  return _impl_.request_id_.Release();
}
inline void RpcAck::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcAck.request_id)
}

// -------------------------------------------------------------------

// RpcResponse

// string request_id = 1;
inline void RpcResponse::clear_request_id() {
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& RpcResponse::request_id() const {
  // @@protoc_insertion_point(field_get:livekit.RpcResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcResponse.request_id)
}
inline std::string* RpcResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:livekit.RpcResponse.request_id)
  return _s;
}
inline const std::string& RpcResponse::_internal_request_id() const {
  return _impl_.request_id_.Get();
}
inline void RpcResponse::_internal_set_request_id(const std::string& value) {
  
  _impl_.request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcResponse::_internal_mutable_request_id() {
  
  return _impl_.request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:livekit.RpcResponse.request_id)
  return _impl_.request_id_.Release();
}
inline void RpcResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  _impl_.request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcResponse.request_id)
}

// string payload = 2;
inline bool RpcResponse::_internal_has_payload() const {
  return value_case() == kPayload;
}
inline bool RpcResponse::has_payload() const {
  return _internal_has_payload();
}
inline void RpcResponse::set_has_payload() {
  _impl_._oneof_case_[0] = kPayload;
}
inline void RpcResponse::clear_payload() {
  if (_internal_has_payload()) {
    _impl_.value_.payload_.Destroy();
    clear_has_value();
  }
}
inline const std::string& RpcResponse::payload() const {
  // @@protoc_insertion_point(field_get:livekit.RpcResponse.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline void RpcResponse::set_payload(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_payload()) {
    clear_value();
    set_has_payload();
    _impl_.value_.payload_.InitDefault();
  }
  _impl_.value_.payload_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcResponse.payload)
}
inline std::string* RpcResponse::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:livekit.RpcResponse.payload)
  return _s;
}
inline const std::string& RpcResponse::_internal_payload() const {
  if (_internal_has_payload()) {
    return _impl_.value_.payload_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RpcResponse::_internal_set_payload(const std::string& value) {
  if (!_internal_has_payload()) {
    clear_value();
    set_has_payload();
    _impl_.value_.payload_.InitDefault();
  }
  _impl_.value_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcResponse::_internal_mutable_payload() {
  if (!_internal_has_payload()) {
    clear_value();
    set_has_payload();
    _impl_.value_.payload_.InitDefault();
  }
  return _impl_.value_.payload_.Mutable(      GetArenaForAllocation());
}
inline std::string* RpcResponse::release_payload() {
  // @@protoc_insertion_point(field_release:livekit.RpcResponse.payload)
  if (_internal_has_payload()) {
    clear_has_value();
    return _impl_.value_.payload_.Release();
  } else {
    return nullptr;
  }
}
inline void RpcResponse::set_allocated_payload(std::string* payload) {
  if (has_value()) {
    clear_value();
  }
  if (payload != nullptr) {
    set_has_payload();
    _impl_.value_.payload_.InitAllocated(payload, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcResponse.payload)
}

// .livekit.RpcError error = 3;
inline bool RpcResponse::_internal_has_error() const {
  return value_case() == kError;
}
inline bool RpcResponse::has_error() const {
  return _internal_has_error();
}
inline void RpcResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void RpcResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.error_;
    }
    clear_has_value();
  }
}
inline ::livekit::RpcError* RpcResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.RpcResponse.error)
  if (_internal_has_error()) {
    clear_has_value();
    ::livekit::RpcError* temp = _impl_.value_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RpcError& RpcResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.value_.error_
      : reinterpret_cast< ::livekit::RpcError&>(::livekit::_RpcError_default_instance_);
}
inline const ::livekit::RpcError& RpcResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.RpcResponse.error)
  return _internal_error();
}
inline ::livekit::RpcError* RpcResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RpcResponse.error)
  if (_internal_has_error()) {
    clear_has_value();
    ::livekit::RpcError* temp = _impl_.value_.error_;
    _impl_.value_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcResponse::unsafe_arena_set_allocated_error(::livekit::RpcError* error) {
  clear_value();
  if (error) {
    set_has_error();
    _impl_.value_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RpcResponse.error)
}
inline ::livekit::RpcError* RpcResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_value();
    set_has_error();
    _impl_.value_.error_ = CreateMaybeMessage< ::livekit::RpcError >(GetArenaForAllocation());
  }
  return _impl_.value_.error_;
}
inline ::livekit::RpcError* RpcResponse::mutable_error() {
  ::livekit::RpcError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.RpcResponse.error)
  return _msg;
}

inline bool RpcResponse::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void RpcResponse::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline RpcResponse::ValueCase RpcResponse::value_case() const {
  return RpcResponse::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RpcError

// uint32 code = 1;
inline void RpcError::clear_code() {
  _impl_.code_ = 0u;
}
inline uint32_t RpcError::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t RpcError::code() const {
  // @@protoc_insertion_point(field_get:livekit.RpcError.code)
  return _internal_code();
}
inline void RpcError::_internal_set_code(uint32_t value) {
  
  _impl_.code_ = value;
}
inline void RpcError::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:livekit.RpcError.code)
}

// string message = 2;
inline void RpcError::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RpcError::message() const {
  // @@protoc_insertion_point(field_get:livekit.RpcError.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcError::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcError.message)
}
inline std::string* RpcError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.RpcError.message)
  return _s;
}
inline const std::string& RpcError::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RpcError::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcError::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcError::release_message() {
  // @@protoc_insertion_point(field_release:livekit.RpcError.message)
  return _impl_.message_.Release();
}
inline void RpcError::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcError.message)
}

// string data = 3;
inline void RpcError::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RpcError::data() const {
  // @@protoc_insertion_point(field_get:livekit.RpcError.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RpcError::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RpcError.data)
}
inline std::string* RpcError::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:livekit.RpcError.data)
  return _s;
}
inline const std::string& RpcError::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RpcError::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcError::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* RpcError::release_data() {
  // @@protoc_insertion_point(field_release:livekit.RpcError.data)
  return _impl_.data_.Release();
}
inline void RpcError::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RpcError.data)
}

// -------------------------------------------------------------------

// ParticipantTracks

// string participant_sid = 1;
inline void ParticipantTracks::clear_participant_sid() {
  _impl_.participant_sid_.ClearToEmpty();
}
inline const std::string& ParticipantTracks::participant_sid() const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantTracks.participant_sid)
  return _internal_participant_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantTracks::set_participant_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.participant_sid)
}
inline std::string* ParticipantTracks::mutable_participant_sid() {
  std::string* _s = _internal_mutable_participant_sid();
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantTracks.participant_sid)
  return _s;
}
inline const std::string& ParticipantTracks::_internal_participant_sid() const {
  return _impl_.participant_sid_.Get();
}
inline void ParticipantTracks::_internal_set_participant_sid(const std::string& value) {
  
  _impl_.participant_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantTracks::_internal_mutable_participant_sid() {
  
  return _impl_.participant_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantTracks::release_participant_sid() {
  // @@protoc_insertion_point(field_release:livekit.ParticipantTracks.participant_sid)
  return _impl_.participant_sid_.Release();
}
inline void ParticipantTracks::set_allocated_participant_sid(std::string* participant_sid) {
  if (participant_sid != nullptr) {
    
  } else {
    
  }
  _impl_.participant_sid_.SetAllocated(participant_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_sid_.IsDefault()) {
    _impl_.participant_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ParticipantTracks.participant_sid)
}

// repeated string track_sids = 2;
inline int ParticipantTracks::_internal_track_sids_size() const {
  return _impl_.track_sids_.size();
}
inline int ParticipantTracks::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void ParticipantTracks::clear_track_sids() {
  _impl_.track_sids_.Clear();
}
inline std::string* ParticipantTracks::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.ParticipantTracks.track_sids)
  return _s;
}
inline const std::string& ParticipantTracks::_internal_track_sids(int index) const {
  return _impl_.track_sids_.Get(index);
}
inline const std::string& ParticipantTracks::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ParticipantTracks.track_sids)
  return _internal_track_sids(index);
}
inline std::string* ParticipantTracks::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ParticipantTracks.track_sids)
  return _impl_.track_sids_.Mutable(index);
}
inline void ParticipantTracks::set_track_sids(int index, const std::string& value) {
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, std::string&& value) {
  _impl_.track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::set_track_sids(int index, const char* value, size_t size) {
  _impl_.track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.ParticipantTracks.track_sids)
}
inline std::string* ParticipantTracks::_internal_add_track_sids() {
  return _impl_.track_sids_.Add();
}
inline void ParticipantTracks::add_track_sids(const std::string& value) {
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(std::string&& value) {
  _impl_.track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.ParticipantTracks.track_sids)
}
inline void ParticipantTracks::add_track_sids(const char* value, size_t size) {
  _impl_.track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.ParticipantTracks.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParticipantTracks::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.ParticipantTracks.track_sids)
  return _impl_.track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParticipantTracks::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ParticipantTracks.track_sids)
  return &_impl_.track_sids_;
}

// -------------------------------------------------------------------

// ServerInfo

// .livekit.ServerInfo.Edition edition = 1;
inline void ServerInfo::clear_edition() {
  _impl_.edition_ = 0;
}
inline ::livekit::ServerInfo_Edition ServerInfo::_internal_edition() const {
  return static_cast< ::livekit::ServerInfo_Edition >(_impl_.edition_);
}
inline ::livekit::ServerInfo_Edition ServerInfo::edition() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.edition)
  return _internal_edition();
}
inline void ServerInfo::_internal_set_edition(::livekit::ServerInfo_Edition value) {
  
  _impl_.edition_ = value;
}
inline void ServerInfo::set_edition(::livekit::ServerInfo_Edition value) {
  _internal_set_edition(value);
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.edition)
}

// string version = 2;
inline void ServerInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ServerInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.version)
}
inline std::string* ServerInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.ServerInfo.version)
  return _s;
}
inline const std::string& ServerInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ServerInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_version() {
  // @@protoc_insertion_point(field_release:livekit.ServerInfo.version)
  return _impl_.version_.Release();
}
inline void ServerInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ServerInfo.version)
}

// int32 protocol = 3;
inline void ServerInfo::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t ServerInfo::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t ServerInfo::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.protocol)
  return _internal_protocol();
}
inline void ServerInfo::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void ServerInfo::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.protocol)
}

// string region = 4;
inline void ServerInfo::clear_region() {
  _impl_.region_.ClearToEmpty();
}
inline const std::string& ServerInfo::region() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_region(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.region)
}
inline std::string* ServerInfo::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:livekit.ServerInfo.region)
  return _s;
}
inline const std::string& ServerInfo::_internal_region() const {
  return _impl_.region_.Get();
}
inline void ServerInfo::_internal_set_region(const std::string& value) {
  
  _impl_.region_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_region() {
  
  return _impl_.region_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_region() {
  // @@protoc_insertion_point(field_release:livekit.ServerInfo.region)
  return _impl_.region_.Release();
}
inline void ServerInfo::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    
  } else {
    
  }
  _impl_.region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ServerInfo.region)
}

// string node_id = 5;
inline void ServerInfo::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& ServerInfo::node_id() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.node_id)
}
inline std::string* ServerInfo::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:livekit.ServerInfo.node_id)
  return _s;
}
inline const std::string& ServerInfo::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void ServerInfo::_internal_set_node_id(const std::string& value) {
  
  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_node_id() {
  
  return _impl_.node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_node_id() {
  // @@protoc_insertion_point(field_release:livekit.ServerInfo.node_id)
  return _impl_.node_id_.Release();
}
inline void ServerInfo::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  _impl_.node_id_.SetAllocated(node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ServerInfo.node_id)
}

// string debug_info = 6;
inline void ServerInfo::clear_debug_info() {
  _impl_.debug_info_.ClearToEmpty();
}
inline const std::string& ServerInfo::debug_info() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.debug_info)
  return _internal_debug_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_debug_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.debug_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.debug_info)
}
inline std::string* ServerInfo::mutable_debug_info() {
  std::string* _s = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:livekit.ServerInfo.debug_info)
  return _s;
}
inline const std::string& ServerInfo::_internal_debug_info() const {
  return _impl_.debug_info_.Get();
}
inline void ServerInfo::_internal_set_debug_info(const std::string& value) {
  
  _impl_.debug_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_debug_info() {
  
  return _impl_.debug_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerInfo::release_debug_info() {
  // @@protoc_insertion_point(field_release:livekit.ServerInfo.debug_info)
  return _impl_.debug_info_.Release();
}
inline void ServerInfo::set_allocated_debug_info(std::string* debug_info) {
  if (debug_info != nullptr) {
    
  } else {
    
  }
  _impl_.debug_info_.SetAllocated(debug_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.debug_info_.IsDefault()) {
    _impl_.debug_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ServerInfo.debug_info)
}

// int32 agent_protocol = 7;
inline void ServerInfo::clear_agent_protocol() {
  _impl_.agent_protocol_ = 0;
}
inline int32_t ServerInfo::_internal_agent_protocol() const {
  return _impl_.agent_protocol_;
}
inline int32_t ServerInfo::agent_protocol() const {
  // @@protoc_insertion_point(field_get:livekit.ServerInfo.agent_protocol)
  return _internal_agent_protocol();
}
inline void ServerInfo::_internal_set_agent_protocol(int32_t value) {
  
  _impl_.agent_protocol_ = value;
}
inline void ServerInfo::set_agent_protocol(int32_t value) {
  _internal_set_agent_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.ServerInfo.agent_protocol)
}

// -------------------------------------------------------------------

// ClientInfo

// .livekit.ClientInfo.SDK sdk = 1;
inline void ClientInfo::clear_sdk() {
  _impl_.sdk_ = 0;
}
inline ::livekit::ClientInfo_SDK ClientInfo::_internal_sdk() const {
  return static_cast< ::livekit::ClientInfo_SDK >(_impl_.sdk_);
}
inline ::livekit::ClientInfo_SDK ClientInfo::sdk() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.sdk)
  return _internal_sdk();
}
inline void ClientInfo::_internal_set_sdk(::livekit::ClientInfo_SDK value) {
  
  _impl_.sdk_ = value;
}
inline void ClientInfo::set_sdk(::livekit::ClientInfo_SDK value) {
  _internal_set_sdk(value);
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.sdk)
}

// string version = 2;
inline void ClientInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ClientInfo::version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.version)
}
inline std::string* ClientInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.version)
  return _s;
}
inline const std::string& ClientInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ClientInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.version)
  return _impl_.version_.Release();
}
inline void ClientInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.version)
}

// int32 protocol = 3;
inline void ClientInfo::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline int32_t ClientInfo::_internal_protocol() const {
  return _impl_.protocol_;
}
inline int32_t ClientInfo::protocol() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.protocol)
  return _internal_protocol();
}
inline void ClientInfo::_internal_set_protocol(int32_t value) {
  
  _impl_.protocol_ = value;
}
inline void ClientInfo::set_protocol(int32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.protocol)
}

// string os = 4;
inline void ClientInfo::clear_os() {
  _impl_.os_.ClearToEmpty();
}
inline const std::string& ClientInfo::os() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_os(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.os)
}
inline std::string* ClientInfo::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.os)
  return _s;
}
inline const std::string& ClientInfo::_internal_os() const {
  return _impl_.os_.Get();
}
inline void ClientInfo::_internal_set_os(const std::string& value) {
  
  _impl_.os_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_os() {
  
  return _impl_.os_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_os() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.os)
  return _impl_.os_.Release();
}
inline void ClientInfo::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  _impl_.os_.SetAllocated(os, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_.IsDefault()) {
    _impl_.os_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.os)
}

// string os_version = 5;
inline void ClientInfo::clear_os_version() {
  _impl_.os_version_.ClearToEmpty();
}
inline const std::string& ClientInfo::os_version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_os_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.os_version)
}
inline std::string* ClientInfo::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.os_version)
  return _s;
}
inline const std::string& ClientInfo::_internal_os_version() const {
  return _impl_.os_version_.Get();
}
inline void ClientInfo::_internal_set_os_version(const std::string& value) {
  
  _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_os_version() {
  
  return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_os_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.os_version)
  return _impl_.os_version_.Release();
}
inline void ClientInfo::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    
  } else {
    
  }
  _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.os_version)
}

// string device_model = 6;
inline void ClientInfo::clear_device_model() {
  _impl_.device_model_.ClearToEmpty();
}
inline const std::string& ClientInfo::device_model() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.device_model)
  return _internal_device_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_device_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.device_model)
}
inline std::string* ClientInfo::mutable_device_model() {
  std::string* _s = _internal_mutable_device_model();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.device_model)
  return _s;
}
inline const std::string& ClientInfo::_internal_device_model() const {
  return _impl_.device_model_.Get();
}
inline void ClientInfo::_internal_set_device_model(const std::string& value) {
  
  _impl_.device_model_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_device_model() {
  
  return _impl_.device_model_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_device_model() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.device_model)
  return _impl_.device_model_.Release();
}
inline void ClientInfo::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    
  } else {
    
  }
  _impl_.device_model_.SetAllocated(device_model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_model_.IsDefault()) {
    _impl_.device_model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.device_model)
}

// string browser = 7;
inline void ClientInfo::clear_browser() {
  _impl_.browser_.ClearToEmpty();
}
inline const std::string& ClientInfo::browser() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.browser)
  return _internal_browser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_browser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.browser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.browser)
}
inline std::string* ClientInfo::mutable_browser() {
  std::string* _s = _internal_mutable_browser();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.browser)
  return _s;
}
inline const std::string& ClientInfo::_internal_browser() const {
  return _impl_.browser_.Get();
}
inline void ClientInfo::_internal_set_browser(const std::string& value) {
  
  _impl_.browser_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_browser() {
  
  return _impl_.browser_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_browser() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.browser)
  return _impl_.browser_.Release();
}
inline void ClientInfo::set_allocated_browser(std::string* browser) {
  if (browser != nullptr) {
    
  } else {
    
  }
  _impl_.browser_.SetAllocated(browser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_.IsDefault()) {
    _impl_.browser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.browser)
}

// string browser_version = 8;
inline void ClientInfo::clear_browser_version() {
  _impl_.browser_version_.ClearToEmpty();
}
inline const std::string& ClientInfo::browser_version() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.browser_version)
  return _internal_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_browser_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.browser_version)
}
inline std::string* ClientInfo::mutable_browser_version() {
  std::string* _s = _internal_mutable_browser_version();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.browser_version)
  return _s;
}
inline const std::string& ClientInfo::_internal_browser_version() const {
  return _impl_.browser_version_.Get();
}
inline void ClientInfo::_internal_set_browser_version(const std::string& value) {
  
  _impl_.browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_browser_version() {
  
  return _impl_.browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_browser_version() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.browser_version)
  return _impl_.browser_version_.Release();
}
inline void ClientInfo::set_allocated_browser_version(std::string* browser_version) {
  if (browser_version != nullptr) {
    
  } else {
    
  }
  _impl_.browser_version_.SetAllocated(browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.browser_version)
}

// string address = 9;
inline void ClientInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ClientInfo::address() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.address)
}
inline std::string* ClientInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.address)
  return _s;
}
inline const std::string& ClientInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ClientInfo::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_address() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.address)
  return _impl_.address_.Release();
}
inline void ClientInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.address)
}

// string network = 10;
inline void ClientInfo::clear_network() {
  _impl_.network_.ClearToEmpty();
}
inline const std::string& ClientInfo::network() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.network)
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_network(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.network)
}
inline std::string* ClientInfo::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.network)
  return _s;
}
inline const std::string& ClientInfo::_internal_network() const {
  return _impl_.network_.Get();
}
inline void ClientInfo::_internal_set_network(const std::string& value) {
  
  _impl_.network_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_network() {
  
  return _impl_.network_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_network() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.network)
  return _impl_.network_.Release();
}
inline void ClientInfo::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    
  } else {
    
  }
  _impl_.network_.SetAllocated(network, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_.IsDefault()) {
    _impl_.network_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.network)
}

// string other_sdks = 11;
inline void ClientInfo::clear_other_sdks() {
  _impl_.other_sdks_.ClearToEmpty();
}
inline const std::string& ClientInfo::other_sdks() const {
  // @@protoc_insertion_point(field_get:livekit.ClientInfo.other_sdks)
  return _internal_other_sdks();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientInfo::set_other_sdks(ArgT0&& arg0, ArgT... args) {
 
 _impl_.other_sdks_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ClientInfo.other_sdks)
}
inline std::string* ClientInfo::mutable_other_sdks() {
  std::string* _s = _internal_mutable_other_sdks();
  // @@protoc_insertion_point(field_mutable:livekit.ClientInfo.other_sdks)
  return _s;
}
inline const std::string& ClientInfo::_internal_other_sdks() const {
  return _impl_.other_sdks_.Get();
}
inline void ClientInfo::_internal_set_other_sdks(const std::string& value) {
  
  _impl_.other_sdks_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientInfo::_internal_mutable_other_sdks() {
  
  return _impl_.other_sdks_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientInfo::release_other_sdks() {
  // @@protoc_insertion_point(field_release:livekit.ClientInfo.other_sdks)
  return _impl_.other_sdks_.Release();
}
inline void ClientInfo::set_allocated_other_sdks(std::string* other_sdks) {
  if (other_sdks != nullptr) {
    
  } else {
    
  }
  _impl_.other_sdks_.SetAllocated(other_sdks, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.other_sdks_.IsDefault()) {
    _impl_.other_sdks_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientInfo.other_sdks)
}

// -------------------------------------------------------------------

// ClientConfiguration

// .livekit.VideoConfiguration video = 1;
inline bool ClientConfiguration::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool ClientConfiguration::has_video() const {
  return _internal_has_video();
}
inline void ClientConfiguration::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::_internal_video() const {
  const ::livekit::VideoConfiguration* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::VideoConfiguration&>(
      ::livekit::_VideoConfiguration_default_instance_);
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::video() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.video)
  return _internal_video();
}
inline void ClientConfiguration::unsafe_arena_set_allocated_video(
    ::livekit::VideoConfiguration* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ClientConfiguration.video)
}
inline ::livekit::VideoConfiguration* ClientConfiguration::release_video() {
  
  ::livekit::VideoConfiguration* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.ClientConfiguration.video)
  
  ::livekit::VideoConfiguration* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::VideoConfiguration>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::mutable_video() {
  ::livekit::VideoConfiguration* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.ClientConfiguration.video)
  return _msg;
}
inline void ClientConfiguration::set_allocated_video(::livekit::VideoConfiguration* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientConfiguration.video)
}

// .livekit.VideoConfiguration screen = 2;
inline bool ClientConfiguration::_internal_has_screen() const {
  return this != internal_default_instance() && _impl_.screen_ != nullptr;
}
inline bool ClientConfiguration::has_screen() const {
  return _internal_has_screen();
}
inline void ClientConfiguration::clear_screen() {
  if (GetArenaForAllocation() == nullptr && _impl_.screen_ != nullptr) {
    delete _impl_.screen_;
  }
  _impl_.screen_ = nullptr;
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::_internal_screen() const {
  const ::livekit::VideoConfiguration* p = _impl_.screen_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::VideoConfiguration&>(
      ::livekit::_VideoConfiguration_default_instance_);
}
inline const ::livekit::VideoConfiguration& ClientConfiguration::screen() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.screen)
  return _internal_screen();
}
inline void ClientConfiguration::unsafe_arena_set_allocated_screen(
    ::livekit::VideoConfiguration* screen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_);
  }
  _impl_.screen_ = screen;
  if (screen) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ClientConfiguration.screen)
}
inline ::livekit::VideoConfiguration* ClientConfiguration::release_screen() {
  
  ::livekit::VideoConfiguration* temp = _impl_.screen_;
  _impl_.screen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::unsafe_arena_release_screen() {
  // @@protoc_insertion_point(field_release:livekit.ClientConfiguration.screen)
  
  ::livekit::VideoConfiguration* temp = _impl_.screen_;
  _impl_.screen_ = nullptr;
  return temp;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::_internal_mutable_screen() {
  
  if (_impl_.screen_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::VideoConfiguration>(GetArenaForAllocation());
    _impl_.screen_ = p;
  }
  return _impl_.screen_;
}
inline ::livekit::VideoConfiguration* ClientConfiguration::mutable_screen() {
  ::livekit::VideoConfiguration* _msg = _internal_mutable_screen();
  // @@protoc_insertion_point(field_mutable:livekit.ClientConfiguration.screen)
  return _msg;
}
inline void ClientConfiguration::set_allocated_screen(::livekit::VideoConfiguration* screen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.screen_;
  }
  if (screen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screen);
    if (message_arena != submessage_arena) {
      screen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.screen_ = screen;
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientConfiguration.screen)
}

// .livekit.ClientConfigSetting resume_connection = 3;
inline void ClientConfiguration::clear_resume_connection() {
  _impl_.resume_connection_ = 0;
}
inline ::livekit::ClientConfigSetting ClientConfiguration::_internal_resume_connection() const {
  return static_cast< ::livekit::ClientConfigSetting >(_impl_.resume_connection_);
}
inline ::livekit::ClientConfigSetting ClientConfiguration::resume_connection() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.resume_connection)
  return _internal_resume_connection();
}
inline void ClientConfiguration::_internal_set_resume_connection(::livekit::ClientConfigSetting value) {
  
  _impl_.resume_connection_ = value;
}
inline void ClientConfiguration::set_resume_connection(::livekit::ClientConfigSetting value) {
  _internal_set_resume_connection(value);
  // @@protoc_insertion_point(field_set:livekit.ClientConfiguration.resume_connection)
}

// .livekit.DisabledCodecs disabled_codecs = 4;
inline bool ClientConfiguration::_internal_has_disabled_codecs() const {
  return this != internal_default_instance() && _impl_.disabled_codecs_ != nullptr;
}
inline bool ClientConfiguration::has_disabled_codecs() const {
  return _internal_has_disabled_codecs();
}
inline void ClientConfiguration::clear_disabled_codecs() {
  if (GetArenaForAllocation() == nullptr && _impl_.disabled_codecs_ != nullptr) {
    delete _impl_.disabled_codecs_;
  }
  _impl_.disabled_codecs_ = nullptr;
}
inline const ::livekit::DisabledCodecs& ClientConfiguration::_internal_disabled_codecs() const {
  const ::livekit::DisabledCodecs* p = _impl_.disabled_codecs_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::DisabledCodecs&>(
      ::livekit::_DisabledCodecs_default_instance_);
}
inline const ::livekit::DisabledCodecs& ClientConfiguration::disabled_codecs() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.disabled_codecs)
  return _internal_disabled_codecs();
}
inline void ClientConfiguration::unsafe_arena_set_allocated_disabled_codecs(
    ::livekit::DisabledCodecs* disabled_codecs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disabled_codecs_);
  }
  _impl_.disabled_codecs_ = disabled_codecs;
  if (disabled_codecs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ClientConfiguration.disabled_codecs)
}
inline ::livekit::DisabledCodecs* ClientConfiguration::release_disabled_codecs() {
  
  ::livekit::DisabledCodecs* temp = _impl_.disabled_codecs_;
  _impl_.disabled_codecs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::DisabledCodecs* ClientConfiguration::unsafe_arena_release_disabled_codecs() {
  // @@protoc_insertion_point(field_release:livekit.ClientConfiguration.disabled_codecs)
  
  ::livekit::DisabledCodecs* temp = _impl_.disabled_codecs_;
  _impl_.disabled_codecs_ = nullptr;
  return temp;
}
inline ::livekit::DisabledCodecs* ClientConfiguration::_internal_mutable_disabled_codecs() {
  
  if (_impl_.disabled_codecs_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::DisabledCodecs>(GetArenaForAllocation());
    _impl_.disabled_codecs_ = p;
  }
  return _impl_.disabled_codecs_;
}
inline ::livekit::DisabledCodecs* ClientConfiguration::mutable_disabled_codecs() {
  ::livekit::DisabledCodecs* _msg = _internal_mutable_disabled_codecs();
  // @@protoc_insertion_point(field_mutable:livekit.ClientConfiguration.disabled_codecs)
  return _msg;
}
inline void ClientConfiguration::set_allocated_disabled_codecs(::livekit::DisabledCodecs* disabled_codecs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disabled_codecs_;
  }
  if (disabled_codecs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disabled_codecs);
    if (message_arena != submessage_arena) {
      disabled_codecs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled_codecs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.disabled_codecs_ = disabled_codecs;
  // @@protoc_insertion_point(field_set_allocated:livekit.ClientConfiguration.disabled_codecs)
}

// .livekit.ClientConfigSetting force_relay = 5;
inline void ClientConfiguration::clear_force_relay() {
  _impl_.force_relay_ = 0;
}
inline ::livekit::ClientConfigSetting ClientConfiguration::_internal_force_relay() const {
  return static_cast< ::livekit::ClientConfigSetting >(_impl_.force_relay_);
}
inline ::livekit::ClientConfigSetting ClientConfiguration::force_relay() const {
  // @@protoc_insertion_point(field_get:livekit.ClientConfiguration.force_relay)
  return _internal_force_relay();
}
inline void ClientConfiguration::_internal_set_force_relay(::livekit::ClientConfigSetting value) {
  
  _impl_.force_relay_ = value;
}
inline void ClientConfiguration::set_force_relay(::livekit::ClientConfigSetting value) {
  _internal_set_force_relay(value);
  // @@protoc_insertion_point(field_set:livekit.ClientConfiguration.force_relay)
}

// -------------------------------------------------------------------

// VideoConfiguration

// .livekit.ClientConfigSetting hardware_encoder = 1;
inline void VideoConfiguration::clear_hardware_encoder() {
  _impl_.hardware_encoder_ = 0;
}
inline ::livekit::ClientConfigSetting VideoConfiguration::_internal_hardware_encoder() const {
  return static_cast< ::livekit::ClientConfigSetting >(_impl_.hardware_encoder_);
}
inline ::livekit::ClientConfigSetting VideoConfiguration::hardware_encoder() const {
  // @@protoc_insertion_point(field_get:livekit.VideoConfiguration.hardware_encoder)
  return _internal_hardware_encoder();
}
inline void VideoConfiguration::_internal_set_hardware_encoder(::livekit::ClientConfigSetting value) {
  
  _impl_.hardware_encoder_ = value;
}
inline void VideoConfiguration::set_hardware_encoder(::livekit::ClientConfigSetting value) {
  _internal_set_hardware_encoder(value);
  // @@protoc_insertion_point(field_set:livekit.VideoConfiguration.hardware_encoder)
}

// -------------------------------------------------------------------

// DisabledCodecs

// repeated .livekit.Codec codecs = 1;
inline int DisabledCodecs::_internal_codecs_size() const {
  return _impl_.codecs_.size();
}
inline int DisabledCodecs::codecs_size() const {
  return _internal_codecs_size();
}
inline void DisabledCodecs::clear_codecs() {
  _impl_.codecs_.Clear();
}
inline ::livekit::Codec* DisabledCodecs::mutable_codecs(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.DisabledCodecs.codecs)
  return _impl_.codecs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
DisabledCodecs::mutable_codecs() {
  // @@protoc_insertion_point(field_mutable_list:livekit.DisabledCodecs.codecs)
  return &_impl_.codecs_;
}
inline const ::livekit::Codec& DisabledCodecs::_internal_codecs(int index) const {
  return _impl_.codecs_.Get(index);
}
inline const ::livekit::Codec& DisabledCodecs::codecs(int index) const {
  // @@protoc_insertion_point(field_get:livekit.DisabledCodecs.codecs)
  return _internal_codecs(index);
}
inline ::livekit::Codec* DisabledCodecs::_internal_add_codecs() {
  return _impl_.codecs_.Add();
}
inline ::livekit::Codec* DisabledCodecs::add_codecs() {
  ::livekit::Codec* _add = _internal_add_codecs();
  // @@protoc_insertion_point(field_add:livekit.DisabledCodecs.codecs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
DisabledCodecs::codecs() const {
  // @@protoc_insertion_point(field_list:livekit.DisabledCodecs.codecs)
  return _impl_.codecs_;
}

// repeated .livekit.Codec publish = 2;
inline int DisabledCodecs::_internal_publish_size() const {
  return _impl_.publish_.size();
}
inline int DisabledCodecs::publish_size() const {
  return _internal_publish_size();
}
inline void DisabledCodecs::clear_publish() {
  _impl_.publish_.Clear();
}
inline ::livekit::Codec* DisabledCodecs::mutable_publish(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.DisabledCodecs.publish)
  return _impl_.publish_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >*
DisabledCodecs::mutable_publish() {
  // @@protoc_insertion_point(field_mutable_list:livekit.DisabledCodecs.publish)
  return &_impl_.publish_;
}
inline const ::livekit::Codec& DisabledCodecs::_internal_publish(int index) const {
  return _impl_.publish_.Get(index);
}
inline const ::livekit::Codec& DisabledCodecs::publish(int index) const {
  // @@protoc_insertion_point(field_get:livekit.DisabledCodecs.publish)
  return _internal_publish(index);
}
inline ::livekit::Codec* DisabledCodecs::_internal_add_publish() {
  return _impl_.publish_.Add();
}
inline ::livekit::Codec* DisabledCodecs::add_publish() {
  ::livekit::Codec* _add = _internal_add_publish();
  // @@protoc_insertion_point(field_add:livekit.DisabledCodecs.publish)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Codec >&
DisabledCodecs::publish() const {
  // @@protoc_insertion_point(field_list:livekit.DisabledCodecs.publish)
  return _impl_.publish_;
}

// -------------------------------------------------------------------

// RTPDrift

// .google.protobuf.Timestamp start_time = 1;
inline bool RTPDrift::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool RTPDrift::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPDrift::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPDrift::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.start_time)
  return _internal_start_time();
}
inline void RTPDrift::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPDrift.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPDrift.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPDrift.start_time)
  return _msg;
}
inline void RTPDrift::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPDrift.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool RTPDrift::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool RTPDrift::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPDrift::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPDrift::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.end_time)
  return _internal_end_time();
}
inline void RTPDrift::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPDrift.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPDrift.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPDrift::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPDrift.end_time)
  return _msg;
}
inline void RTPDrift::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPDrift.end_time)
}

// double duration = 3;
inline void RTPDrift::clear_duration() {
  _impl_.duration_ = 0;
}
inline double RTPDrift::_internal_duration() const {
  return _impl_.duration_;
}
inline double RTPDrift::duration() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.duration)
  return _internal_duration();
}
inline void RTPDrift::_internal_set_duration(double value) {
  
  _impl_.duration_ = value;
}
inline void RTPDrift::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.duration)
}

// uint64 start_timestamp = 4;
inline void RTPDrift::clear_start_timestamp() {
  _impl_.start_timestamp_ = uint64_t{0u};
}
inline uint64_t RTPDrift::_internal_start_timestamp() const {
  return _impl_.start_timestamp_;
}
inline uint64_t RTPDrift::start_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.start_timestamp)
  return _internal_start_timestamp();
}
inline void RTPDrift::_internal_set_start_timestamp(uint64_t value) {
  
  _impl_.start_timestamp_ = value;
}
inline void RTPDrift::set_start_timestamp(uint64_t value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.start_timestamp)
}

// uint64 end_timestamp = 5;
inline void RTPDrift::clear_end_timestamp() {
  _impl_.end_timestamp_ = uint64_t{0u};
}
inline uint64_t RTPDrift::_internal_end_timestamp() const {
  return _impl_.end_timestamp_;
}
inline uint64_t RTPDrift::end_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.end_timestamp)
  return _internal_end_timestamp();
}
inline void RTPDrift::_internal_set_end_timestamp(uint64_t value) {
  
  _impl_.end_timestamp_ = value;
}
inline void RTPDrift::set_end_timestamp(uint64_t value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.end_timestamp)
}

// uint64 rtp_clock_ticks = 6;
inline void RTPDrift::clear_rtp_clock_ticks() {
  _impl_.rtp_clock_ticks_ = uint64_t{0u};
}
inline uint64_t RTPDrift::_internal_rtp_clock_ticks() const {
  return _impl_.rtp_clock_ticks_;
}
inline uint64_t RTPDrift::rtp_clock_ticks() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.rtp_clock_ticks)
  return _internal_rtp_clock_ticks();
}
inline void RTPDrift::_internal_set_rtp_clock_ticks(uint64_t value) {
  
  _impl_.rtp_clock_ticks_ = value;
}
inline void RTPDrift::set_rtp_clock_ticks(uint64_t value) {
  _internal_set_rtp_clock_ticks(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.rtp_clock_ticks)
}

// int64 drift_samples = 7;
inline void RTPDrift::clear_drift_samples() {
  _impl_.drift_samples_ = int64_t{0};
}
inline int64_t RTPDrift::_internal_drift_samples() const {
  return _impl_.drift_samples_;
}
inline int64_t RTPDrift::drift_samples() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.drift_samples)
  return _internal_drift_samples();
}
inline void RTPDrift::_internal_set_drift_samples(int64_t value) {
  
  _impl_.drift_samples_ = value;
}
inline void RTPDrift::set_drift_samples(int64_t value) {
  _internal_set_drift_samples(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.drift_samples)
}

// double drift_ms = 8;
inline void RTPDrift::clear_drift_ms() {
  _impl_.drift_ms_ = 0;
}
inline double RTPDrift::_internal_drift_ms() const {
  return _impl_.drift_ms_;
}
inline double RTPDrift::drift_ms() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.drift_ms)
  return _internal_drift_ms();
}
inline void RTPDrift::_internal_set_drift_ms(double value) {
  
  _impl_.drift_ms_ = value;
}
inline void RTPDrift::set_drift_ms(double value) {
  _internal_set_drift_ms(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.drift_ms)
}

// double clock_rate = 9;
inline void RTPDrift::clear_clock_rate() {
  _impl_.clock_rate_ = 0;
}
inline double RTPDrift::_internal_clock_rate() const {
  return _impl_.clock_rate_;
}
inline double RTPDrift::clock_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPDrift.clock_rate)
  return _internal_clock_rate();
}
inline void RTPDrift::_internal_set_clock_rate(double value) {
  
  _impl_.clock_rate_ = value;
}
inline void RTPDrift::set_clock_rate(double value) {
  _internal_set_clock_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPDrift.clock_rate)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RTPStats

// .google.protobuf.Timestamp start_time = 1;
inline bool RTPStats::_internal_has_start_time() const {
  return this != internal_default_instance() && _impl_.start_time_ != nullptr;
}
inline bool RTPStats::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_start_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.start_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.start_time)
  return _internal_start_time();
}
inline void RTPStats::unsafe_arena_set_allocated_start_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  _impl_.start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.start_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_start_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.start_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.start_time_;
  _impl_.start_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_start_time() {
  
  if (_impl_.start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.start_time_ = p;
  }
  return _impl_.start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_start_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.start_time)
  return _msg;
}
inline void RTPStats::set_allocated_start_time(::PROTOBUF_NAMESPACE_ID::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time));
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.start_time)
}

// .google.protobuf.Timestamp end_time = 2;
inline bool RTPStats::_internal_has_end_time() const {
  return this != internal_default_instance() && _impl_.end_time_ != nullptr;
}
inline bool RTPStats::has_end_time() const {
  return _internal_has_end_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_end_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.end_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.end_time)
  return _internal_end_time();
}
inline void RTPStats::unsafe_arena_set_allocated_end_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  _impl_.end_time_ = end_time;
  if (end_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.end_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_end_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_end_time() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.end_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.end_time_;
  _impl_.end_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_end_time() {
  
  if (_impl_.end_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.end_time_ = p;
  }
  return _impl_.end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_end_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.end_time)
  return _msg;
}
inline void RTPStats::set_allocated_end_time(::PROTOBUF_NAMESPACE_ID::Timestamp* end_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_time_);
  }
  if (end_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_time));
    if (message_arena != submessage_arena) {
      end_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_time_ = end_time;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.end_time)
}

// double duration = 3;
inline void RTPStats::clear_duration() {
  _impl_.duration_ = 0;
}
inline double RTPStats::_internal_duration() const {
  return _impl_.duration_;
}
inline double RTPStats::duration() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.duration)
  return _internal_duration();
}
inline void RTPStats::_internal_set_duration(double value) {
  
  _impl_.duration_ = value;
}
inline void RTPStats::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.duration)
}

// uint32 packets = 4;
inline void RTPStats::clear_packets() {
  _impl_.packets_ = 0u;
}
inline uint32_t RTPStats::_internal_packets() const {
  return _impl_.packets_;
}
inline uint32_t RTPStats::packets() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets)
  return _internal_packets();
}
inline void RTPStats::_internal_set_packets(uint32_t value) {
  
  _impl_.packets_ = value;
}
inline void RTPStats::set_packets(uint32_t value) {
  _internal_set_packets(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets)
}

// double packet_rate = 5;
inline void RTPStats::clear_packet_rate() {
  _impl_.packet_rate_ = 0;
}
inline double RTPStats::_internal_packet_rate() const {
  return _impl_.packet_rate_;
}
inline double RTPStats::packet_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_rate)
  return _internal_packet_rate();
}
inline void RTPStats::_internal_set_packet_rate(double value) {
  
  _impl_.packet_rate_ = value;
}
inline void RTPStats::set_packet_rate(double value) {
  _internal_set_packet_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_rate)
}

// uint64 bytes = 6;
inline void RTPStats::clear_bytes() {
  _impl_.bytes_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes() const {
  return _impl_.bytes_;
}
inline uint64_t RTPStats::bytes() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes)
  return _internal_bytes();
}
inline void RTPStats::_internal_set_bytes(uint64_t value) {
  
  _impl_.bytes_ = value;
}
inline void RTPStats::set_bytes(uint64_t value) {
  _internal_set_bytes(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes)
}

// uint64 header_bytes = 39;
inline void RTPStats::clear_header_bytes() {
  _impl_.header_bytes_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_header_bytes() const {
  return _impl_.header_bytes_;
}
inline uint64_t RTPStats::header_bytes() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.header_bytes)
  return _internal_header_bytes();
}
inline void RTPStats::_internal_set_header_bytes(uint64_t value) {
  
  _impl_.header_bytes_ = value;
}
inline void RTPStats::set_header_bytes(uint64_t value) {
  _internal_set_header_bytes(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.header_bytes)
}

// double bitrate = 7;
inline void RTPStats::clear_bitrate() {
  _impl_.bitrate_ = 0;
}
inline double RTPStats::_internal_bitrate() const {
  return _impl_.bitrate_;
}
inline double RTPStats::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate)
  return _internal_bitrate();
}
inline void RTPStats::_internal_set_bitrate(double value) {
  
  _impl_.bitrate_ = value;
}
inline void RTPStats::set_bitrate(double value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate)
}

// uint32 packets_lost = 8;
inline void RTPStats::clear_packets_lost() {
  _impl_.packets_lost_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_lost() const {
  return _impl_.packets_lost_;
}
inline uint32_t RTPStats::packets_lost() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_lost)
  return _internal_packets_lost();
}
inline void RTPStats::_internal_set_packets_lost(uint32_t value) {
  
  _impl_.packets_lost_ = value;
}
inline void RTPStats::set_packets_lost(uint32_t value) {
  _internal_set_packets_lost(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_lost)
}

// double packet_loss_rate = 9;
inline void RTPStats::clear_packet_loss_rate() {
  _impl_.packet_loss_rate_ = 0;
}
inline double RTPStats::_internal_packet_loss_rate() const {
  return _impl_.packet_loss_rate_;
}
inline double RTPStats::packet_loss_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_loss_rate)
  return _internal_packet_loss_rate();
}
inline void RTPStats::_internal_set_packet_loss_rate(double value) {
  
  _impl_.packet_loss_rate_ = value;
}
inline void RTPStats::set_packet_loss_rate(double value) {
  _internal_set_packet_loss_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_loss_rate)
}

// float packet_loss_percentage = 10;
inline void RTPStats::clear_packet_loss_percentage() {
  _impl_.packet_loss_percentage_ = 0;
}
inline float RTPStats::_internal_packet_loss_percentage() const {
  return _impl_.packet_loss_percentage_;
}
inline float RTPStats::packet_loss_percentage() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_loss_percentage)
  return _internal_packet_loss_percentage();
}
inline void RTPStats::_internal_set_packet_loss_percentage(float value) {
  
  _impl_.packet_loss_percentage_ = value;
}
inline void RTPStats::set_packet_loss_percentage(float value) {
  _internal_set_packet_loss_percentage(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_loss_percentage)
}

// uint32 packets_duplicate = 11;
inline void RTPStats::clear_packets_duplicate() {
  _impl_.packets_duplicate_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_duplicate() const {
  return _impl_.packets_duplicate_;
}
inline uint32_t RTPStats::packets_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_duplicate)
  return _internal_packets_duplicate();
}
inline void RTPStats::_internal_set_packets_duplicate(uint32_t value) {
  
  _impl_.packets_duplicate_ = value;
}
inline void RTPStats::set_packets_duplicate(uint32_t value) {
  _internal_set_packets_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_duplicate)
}

// double packet_duplicate_rate = 12;
inline void RTPStats::clear_packet_duplicate_rate() {
  _impl_.packet_duplicate_rate_ = 0;
}
inline double RTPStats::_internal_packet_duplicate_rate() const {
  return _impl_.packet_duplicate_rate_;
}
inline double RTPStats::packet_duplicate_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_duplicate_rate)
  return _internal_packet_duplicate_rate();
}
inline void RTPStats::_internal_set_packet_duplicate_rate(double value) {
  
  _impl_.packet_duplicate_rate_ = value;
}
inline void RTPStats::set_packet_duplicate_rate(double value) {
  _internal_set_packet_duplicate_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_duplicate_rate)
}

// uint64 bytes_duplicate = 13;
inline void RTPStats::clear_bytes_duplicate() {
  _impl_.bytes_duplicate_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes_duplicate() const {
  return _impl_.bytes_duplicate_;
}
inline uint64_t RTPStats::bytes_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes_duplicate)
  return _internal_bytes_duplicate();
}
inline void RTPStats::_internal_set_bytes_duplicate(uint64_t value) {
  
  _impl_.bytes_duplicate_ = value;
}
inline void RTPStats::set_bytes_duplicate(uint64_t value) {
  _internal_set_bytes_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes_duplicate)
}

// uint64 header_bytes_duplicate = 40;
inline void RTPStats::clear_header_bytes_duplicate() {
  _impl_.header_bytes_duplicate_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_header_bytes_duplicate() const {
  return _impl_.header_bytes_duplicate_;
}
inline uint64_t RTPStats::header_bytes_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.header_bytes_duplicate)
  return _internal_header_bytes_duplicate();
}
inline void RTPStats::_internal_set_header_bytes_duplicate(uint64_t value) {
  
  _impl_.header_bytes_duplicate_ = value;
}
inline void RTPStats::set_header_bytes_duplicate(uint64_t value) {
  _internal_set_header_bytes_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.header_bytes_duplicate)
}

// double bitrate_duplicate = 14;
inline void RTPStats::clear_bitrate_duplicate() {
  _impl_.bitrate_duplicate_ = 0;
}
inline double RTPStats::_internal_bitrate_duplicate() const {
  return _impl_.bitrate_duplicate_;
}
inline double RTPStats::bitrate_duplicate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate_duplicate)
  return _internal_bitrate_duplicate();
}
inline void RTPStats::_internal_set_bitrate_duplicate(double value) {
  
  _impl_.bitrate_duplicate_ = value;
}
inline void RTPStats::set_bitrate_duplicate(double value) {
  _internal_set_bitrate_duplicate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate_duplicate)
}

// uint32 packets_padding = 15;
inline void RTPStats::clear_packets_padding() {
  _impl_.packets_padding_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_padding() const {
  return _impl_.packets_padding_;
}
inline uint32_t RTPStats::packets_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_padding)
  return _internal_packets_padding();
}
inline void RTPStats::_internal_set_packets_padding(uint32_t value) {
  
  _impl_.packets_padding_ = value;
}
inline void RTPStats::set_packets_padding(uint32_t value) {
  _internal_set_packets_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_padding)
}

// double packet_padding_rate = 16;
inline void RTPStats::clear_packet_padding_rate() {
  _impl_.packet_padding_rate_ = 0;
}
inline double RTPStats::_internal_packet_padding_rate() const {
  return _impl_.packet_padding_rate_;
}
inline double RTPStats::packet_padding_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_padding_rate)
  return _internal_packet_padding_rate();
}
inline void RTPStats::_internal_set_packet_padding_rate(double value) {
  
  _impl_.packet_padding_rate_ = value;
}
inline void RTPStats::set_packet_padding_rate(double value) {
  _internal_set_packet_padding_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packet_padding_rate)
}

// uint64 bytes_padding = 17;
inline void RTPStats::clear_bytes_padding() {
  _impl_.bytes_padding_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_bytes_padding() const {
  return _impl_.bytes_padding_;
}
inline uint64_t RTPStats::bytes_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bytes_padding)
  return _internal_bytes_padding();
}
inline void RTPStats::_internal_set_bytes_padding(uint64_t value) {
  
  _impl_.bytes_padding_ = value;
}
inline void RTPStats::set_bytes_padding(uint64_t value) {
  _internal_set_bytes_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bytes_padding)
}

// uint64 header_bytes_padding = 41;
inline void RTPStats::clear_header_bytes_padding() {
  _impl_.header_bytes_padding_ = uint64_t{0u};
}
inline uint64_t RTPStats::_internal_header_bytes_padding() const {
  return _impl_.header_bytes_padding_;
}
inline uint64_t RTPStats::header_bytes_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.header_bytes_padding)
  return _internal_header_bytes_padding();
}
inline void RTPStats::_internal_set_header_bytes_padding(uint64_t value) {
  
  _impl_.header_bytes_padding_ = value;
}
inline void RTPStats::set_header_bytes_padding(uint64_t value) {
  _internal_set_header_bytes_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.header_bytes_padding)
}

// double bitrate_padding = 18;
inline void RTPStats::clear_bitrate_padding() {
  _impl_.bitrate_padding_ = 0;
}
inline double RTPStats::_internal_bitrate_padding() const {
  return _impl_.bitrate_padding_;
}
inline double RTPStats::bitrate_padding() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.bitrate_padding)
  return _internal_bitrate_padding();
}
inline void RTPStats::_internal_set_bitrate_padding(double value) {
  
  _impl_.bitrate_padding_ = value;
}
inline void RTPStats::set_bitrate_padding(double value) {
  _internal_set_bitrate_padding(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.bitrate_padding)
}

// uint32 packets_out_of_order = 19;
inline void RTPStats::clear_packets_out_of_order() {
  _impl_.packets_out_of_order_ = 0u;
}
inline uint32_t RTPStats::_internal_packets_out_of_order() const {
  return _impl_.packets_out_of_order_;
}
inline uint32_t RTPStats::packets_out_of_order() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packets_out_of_order)
  return _internal_packets_out_of_order();
}
inline void RTPStats::_internal_set_packets_out_of_order(uint32_t value) {
  
  _impl_.packets_out_of_order_ = value;
}
inline void RTPStats::set_packets_out_of_order(uint32_t value) {
  _internal_set_packets_out_of_order(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.packets_out_of_order)
}

// uint32 frames = 20;
inline void RTPStats::clear_frames() {
  _impl_.frames_ = 0u;
}
inline uint32_t RTPStats::_internal_frames() const {
  return _impl_.frames_;
}
inline uint32_t RTPStats::frames() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.frames)
  return _internal_frames();
}
inline void RTPStats::_internal_set_frames(uint32_t value) {
  
  _impl_.frames_ = value;
}
inline void RTPStats::set_frames(uint32_t value) {
  _internal_set_frames(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.frames)
}

// double frame_rate = 21;
inline void RTPStats::clear_frame_rate() {
  _impl_.frame_rate_ = 0;
}
inline double RTPStats::_internal_frame_rate() const {
  return _impl_.frame_rate_;
}
inline double RTPStats::frame_rate() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.frame_rate)
  return _internal_frame_rate();
}
inline void RTPStats::_internal_set_frame_rate(double value) {
  
  _impl_.frame_rate_ = value;
}
inline void RTPStats::set_frame_rate(double value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.frame_rate)
}

// double jitter_current = 22;
inline void RTPStats::clear_jitter_current() {
  _impl_.jitter_current_ = 0;
}
inline double RTPStats::_internal_jitter_current() const {
  return _impl_.jitter_current_;
}
inline double RTPStats::jitter_current() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.jitter_current)
  return _internal_jitter_current();
}
inline void RTPStats::_internal_set_jitter_current(double value) {
  
  _impl_.jitter_current_ = value;
}
inline void RTPStats::set_jitter_current(double value) {
  _internal_set_jitter_current(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.jitter_current)
}

// double jitter_max = 23;
inline void RTPStats::clear_jitter_max() {
  _impl_.jitter_max_ = 0;
}
inline double RTPStats::_internal_jitter_max() const {
  return _impl_.jitter_max_;
}
inline double RTPStats::jitter_max() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.jitter_max)
  return _internal_jitter_max();
}
inline void RTPStats::_internal_set_jitter_max(double value) {
  
  _impl_.jitter_max_ = value;
}
inline void RTPStats::set_jitter_max(double value) {
  _internal_set_jitter_max(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.jitter_max)
}

// map<int32, uint32> gap_histogram = 24;
inline int RTPStats::_internal_gap_histogram_size() const {
  return _impl_.gap_histogram_.size();
}
inline int RTPStats::gap_histogram_size() const {
  return _internal_gap_histogram_size();
}
inline void RTPStats::clear_gap_histogram() {
  _impl_.gap_histogram_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
RTPStats::_internal_gap_histogram() const {
  return _impl_.gap_histogram_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >&
RTPStats::gap_histogram() const {
  // @@protoc_insertion_point(field_map:livekit.RTPStats.gap_histogram)
  return _internal_gap_histogram();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
RTPStats::_internal_mutable_gap_histogram() {
  return _impl_.gap_histogram_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, uint32_t >*
RTPStats::mutable_gap_histogram() {
  // @@protoc_insertion_point(field_mutable_map:livekit.RTPStats.gap_histogram)
  return _internal_mutable_gap_histogram();
}

// uint32 nacks = 25;
inline void RTPStats::clear_nacks() {
  _impl_.nacks_ = 0u;
}
inline uint32_t RTPStats::_internal_nacks() const {
  return _impl_.nacks_;
}
inline uint32_t RTPStats::nacks() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nacks)
  return _internal_nacks();
}
inline void RTPStats::_internal_set_nacks(uint32_t value) {
  
  _impl_.nacks_ = value;
}
inline void RTPStats::set_nacks(uint32_t value) {
  _internal_set_nacks(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nacks)
}

// uint32 nack_acks = 37;
inline void RTPStats::clear_nack_acks() {
  _impl_.nack_acks_ = 0u;
}
inline uint32_t RTPStats::_internal_nack_acks() const {
  return _impl_.nack_acks_;
}
inline uint32_t RTPStats::nack_acks() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nack_acks)
  return _internal_nack_acks();
}
inline void RTPStats::_internal_set_nack_acks(uint32_t value) {
  
  _impl_.nack_acks_ = value;
}
inline void RTPStats::set_nack_acks(uint32_t value) {
  _internal_set_nack_acks(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nack_acks)
}

// uint32 nack_misses = 26;
inline void RTPStats::clear_nack_misses() {
  _impl_.nack_misses_ = 0u;
}
inline uint32_t RTPStats::_internal_nack_misses() const {
  return _impl_.nack_misses_;
}
inline uint32_t RTPStats::nack_misses() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nack_misses)
  return _internal_nack_misses();
}
inline void RTPStats::_internal_set_nack_misses(uint32_t value) {
  
  _impl_.nack_misses_ = value;
}
inline void RTPStats::set_nack_misses(uint32_t value) {
  _internal_set_nack_misses(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nack_misses)
}

// uint32 nack_repeated = 38;
inline void RTPStats::clear_nack_repeated() {
  _impl_.nack_repeated_ = 0u;
}
inline uint32_t RTPStats::_internal_nack_repeated() const {
  return _impl_.nack_repeated_;
}
inline uint32_t RTPStats::nack_repeated() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.nack_repeated)
  return _internal_nack_repeated();
}
inline void RTPStats::_internal_set_nack_repeated(uint32_t value) {
  
  _impl_.nack_repeated_ = value;
}
inline void RTPStats::set_nack_repeated(uint32_t value) {
  _internal_set_nack_repeated(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.nack_repeated)
}

// uint32 plis = 27;
inline void RTPStats::clear_plis() {
  _impl_.plis_ = 0u;
}
inline uint32_t RTPStats::_internal_plis() const {
  return _impl_.plis_;
}
inline uint32_t RTPStats::plis() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.plis)
  return _internal_plis();
}
inline void RTPStats::_internal_set_plis(uint32_t value) {
  
  _impl_.plis_ = value;
}
inline void RTPStats::set_plis(uint32_t value) {
  _internal_set_plis(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.plis)
}

// .google.protobuf.Timestamp last_pli = 28;
inline bool RTPStats::_internal_has_last_pli() const {
  return this != internal_default_instance() && _impl_.last_pli_ != nullptr;
}
inline bool RTPStats::has_last_pli() const {
  return _internal_has_last_pli();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_pli() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_pli_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_pli() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_pli)
  return _internal_last_pli();
}
inline void RTPStats::unsafe_arena_set_allocated_last_pli(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_pli_);
  }
  _impl_.last_pli_ = last_pli;
  if (last_pli) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_pli)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_pli() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_pli_;
  _impl_.last_pli_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_pli() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_pli)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_pli_;
  _impl_.last_pli_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_pli() {
  
  if (_impl_.last_pli_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_pli_ = p;
  }
  return _impl_.last_pli_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_pli() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_pli();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_pli)
  return _msg;
}
inline void RTPStats::set_allocated_last_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_pli) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_pli_);
  }
  if (last_pli) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_pli));
    if (message_arena != submessage_arena) {
      last_pli = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_pli, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_pli_ = last_pli;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_pli)
}

// uint32 firs = 29;
inline void RTPStats::clear_firs() {
  _impl_.firs_ = 0u;
}
inline uint32_t RTPStats::_internal_firs() const {
  return _impl_.firs_;
}
inline uint32_t RTPStats::firs() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.firs)
  return _internal_firs();
}
inline void RTPStats::_internal_set_firs(uint32_t value) {
  
  _impl_.firs_ = value;
}
inline void RTPStats::set_firs(uint32_t value) {
  _internal_set_firs(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.firs)
}

// .google.protobuf.Timestamp last_fir = 30;
inline bool RTPStats::_internal_has_last_fir() const {
  return this != internal_default_instance() && _impl_.last_fir_ != nullptr;
}
inline bool RTPStats::has_last_fir() const {
  return _internal_has_last_fir();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_fir() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_fir_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_fir() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_fir)
  return _internal_last_fir();
}
inline void RTPStats::unsafe_arena_set_allocated_last_fir(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_fir_);
  }
  _impl_.last_fir_ = last_fir;
  if (last_fir) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_fir)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_fir() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_fir_;
  _impl_.last_fir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_fir() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_fir)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_fir_;
  _impl_.last_fir_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_fir() {
  
  if (_impl_.last_fir_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_fir_ = p;
  }
  return _impl_.last_fir_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_fir() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_fir();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_fir)
  return _msg;
}
inline void RTPStats::set_allocated_last_fir(::PROTOBUF_NAMESPACE_ID::Timestamp* last_fir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_fir_);
  }
  if (last_fir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_fir));
    if (message_arena != submessage_arena) {
      last_fir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_fir, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_fir_ = last_fir;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_fir)
}

// uint32 rtt_current = 31;
inline void RTPStats::clear_rtt_current() {
  _impl_.rtt_current_ = 0u;
}
inline uint32_t RTPStats::_internal_rtt_current() const {
  return _impl_.rtt_current_;
}
inline uint32_t RTPStats::rtt_current() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.rtt_current)
  return _internal_rtt_current();
}
inline void RTPStats::_internal_set_rtt_current(uint32_t value) {
  
  _impl_.rtt_current_ = value;
}
inline void RTPStats::set_rtt_current(uint32_t value) {
  _internal_set_rtt_current(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.rtt_current)
}

// uint32 rtt_max = 32;
inline void RTPStats::clear_rtt_max() {
  _impl_.rtt_max_ = 0u;
}
inline uint32_t RTPStats::_internal_rtt_max() const {
  return _impl_.rtt_max_;
}
inline uint32_t RTPStats::rtt_max() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.rtt_max)
  return _internal_rtt_max();
}
inline void RTPStats::_internal_set_rtt_max(uint32_t value) {
  
  _impl_.rtt_max_ = value;
}
inline void RTPStats::set_rtt_max(uint32_t value) {
  _internal_set_rtt_max(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.rtt_max)
}

// uint32 key_frames = 33;
inline void RTPStats::clear_key_frames() {
  _impl_.key_frames_ = 0u;
}
inline uint32_t RTPStats::_internal_key_frames() const {
  return _impl_.key_frames_;
}
inline uint32_t RTPStats::key_frames() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.key_frames)
  return _internal_key_frames();
}
inline void RTPStats::_internal_set_key_frames(uint32_t value) {
  
  _impl_.key_frames_ = value;
}
inline void RTPStats::set_key_frames(uint32_t value) {
  _internal_set_key_frames(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.key_frames)
}

// .google.protobuf.Timestamp last_key_frame = 34;
inline bool RTPStats::_internal_has_last_key_frame() const {
  return this != internal_default_instance() && _impl_.last_key_frame_ != nullptr;
}
inline bool RTPStats::has_last_key_frame() const {
  return _internal_has_last_key_frame();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_key_frame() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_key_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_key_frame() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_key_frame)
  return _internal_last_key_frame();
}
inline void RTPStats::unsafe_arena_set_allocated_last_key_frame(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_key_frame_);
  }
  _impl_.last_key_frame_ = last_key_frame;
  if (last_key_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_key_frame)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_key_frame() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_key_frame_;
  _impl_.last_key_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_key_frame() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_key_frame)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_key_frame_;
  _impl_.last_key_frame_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_key_frame() {
  
  if (_impl_.last_key_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_key_frame_ = p;
  }
  return _impl_.last_key_frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_key_frame() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_key_frame();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_key_frame)
  return _msg;
}
inline void RTPStats::set_allocated_last_key_frame(::PROTOBUF_NAMESPACE_ID::Timestamp* last_key_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_key_frame_);
  }
  if (last_key_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_key_frame));
    if (message_arena != submessage_arena) {
      last_key_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_key_frame, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_key_frame_ = last_key_frame;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_key_frame)
}

// uint32 layer_lock_plis = 35;
inline void RTPStats::clear_layer_lock_plis() {
  _impl_.layer_lock_plis_ = 0u;
}
inline uint32_t RTPStats::_internal_layer_lock_plis() const {
  return _impl_.layer_lock_plis_;
}
inline uint32_t RTPStats::layer_lock_plis() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.layer_lock_plis)
  return _internal_layer_lock_plis();
}
inline void RTPStats::_internal_set_layer_lock_plis(uint32_t value) {
  
  _impl_.layer_lock_plis_ = value;
}
inline void RTPStats::set_layer_lock_plis(uint32_t value) {
  _internal_set_layer_lock_plis(value);
  // @@protoc_insertion_point(field_set:livekit.RTPStats.layer_lock_plis)
}

// .google.protobuf.Timestamp last_layer_lock_pli = 36;
inline bool RTPStats::_internal_has_last_layer_lock_pli() const {
  return this != internal_default_instance() && _impl_.last_layer_lock_pli_ != nullptr;
}
inline bool RTPStats::has_last_layer_lock_pli() const {
  return _internal_has_last_layer_lock_pli();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::_internal_last_layer_lock_pli() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_layer_lock_pli_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RTPStats::last_layer_lock_pli() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.last_layer_lock_pli)
  return _internal_last_layer_lock_pli();
}
inline void RTPStats::unsafe_arena_set_allocated_last_layer_lock_pli(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_layer_lock_pli_);
  }
  _impl_.last_layer_lock_pli_ = last_layer_lock_pli;
  if (last_layer_lock_pli) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.last_layer_lock_pli)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::release_last_layer_lock_pli() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_layer_lock_pli_;
  _impl_.last_layer_lock_pli_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::unsafe_arena_release_last_layer_lock_pli() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.last_layer_lock_pli)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_layer_lock_pli_;
  _impl_.last_layer_lock_pli_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::_internal_mutable_last_layer_lock_pli() {
  
  if (_impl_.last_layer_lock_pli_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_layer_lock_pli_ = p;
  }
  return _impl_.last_layer_lock_pli_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RTPStats::mutable_last_layer_lock_pli() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_layer_lock_pli();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.last_layer_lock_pli)
  return _msg;
}
inline void RTPStats::set_allocated_last_layer_lock_pli(::PROTOBUF_NAMESPACE_ID::Timestamp* last_layer_lock_pli) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_layer_lock_pli_);
  }
  if (last_layer_lock_pli) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_layer_lock_pli));
    if (message_arena != submessage_arena) {
      last_layer_lock_pli = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_layer_lock_pli, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_layer_lock_pli_ = last_layer_lock_pli;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.last_layer_lock_pli)
}

// .livekit.RTPDrift packet_drift = 44;
inline bool RTPStats::_internal_has_packet_drift() const {
  return this != internal_default_instance() && _impl_.packet_drift_ != nullptr;
}
inline bool RTPStats::has_packet_drift() const {
  return _internal_has_packet_drift();
}
inline void RTPStats::clear_packet_drift() {
  if (GetArenaForAllocation() == nullptr && _impl_.packet_drift_ != nullptr) {
    delete _impl_.packet_drift_;
  }
  _impl_.packet_drift_ = nullptr;
}
inline const ::livekit::RTPDrift& RTPStats::_internal_packet_drift() const {
  const ::livekit::RTPDrift* p = _impl_.packet_drift_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RTPDrift&>(
      ::livekit::_RTPDrift_default_instance_);
}
inline const ::livekit::RTPDrift& RTPStats::packet_drift() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.packet_drift)
  return _internal_packet_drift();
}
inline void RTPStats::unsafe_arena_set_allocated_packet_drift(
    ::livekit::RTPDrift* packet_drift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.packet_drift_);
  }
  _impl_.packet_drift_ = packet_drift;
  if (packet_drift) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.packet_drift)
}
inline ::livekit::RTPDrift* RTPStats::release_packet_drift() {
  
  ::livekit::RTPDrift* temp = _impl_.packet_drift_;
  _impl_.packet_drift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::unsafe_arena_release_packet_drift() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.packet_drift)
  
  ::livekit::RTPDrift* temp = _impl_.packet_drift_;
  _impl_.packet_drift_ = nullptr;
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::_internal_mutable_packet_drift() {
  
  if (_impl_.packet_drift_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RTPDrift>(GetArenaForAllocation());
    _impl_.packet_drift_ = p;
  }
  return _impl_.packet_drift_;
}
inline ::livekit::RTPDrift* RTPStats::mutable_packet_drift() {
  ::livekit::RTPDrift* _msg = _internal_mutable_packet_drift();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.packet_drift)
  return _msg;
}
inline void RTPStats::set_allocated_packet_drift(::livekit::RTPDrift* packet_drift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.packet_drift_;
  }
  if (packet_drift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(packet_drift);
    if (message_arena != submessage_arena) {
      packet_drift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_drift, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.packet_drift_ = packet_drift;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.packet_drift)
}

// .livekit.RTPDrift ntp_report_drift = 45;
inline bool RTPStats::_internal_has_ntp_report_drift() const {
  return this != internal_default_instance() && _impl_.ntp_report_drift_ != nullptr;
}
inline bool RTPStats::has_ntp_report_drift() const {
  return _internal_has_ntp_report_drift();
}
inline void RTPStats::clear_ntp_report_drift() {
  if (GetArenaForAllocation() == nullptr && _impl_.ntp_report_drift_ != nullptr) {
    delete _impl_.ntp_report_drift_;
  }
  _impl_.ntp_report_drift_ = nullptr;
}
inline const ::livekit::RTPDrift& RTPStats::_internal_ntp_report_drift() const {
  const ::livekit::RTPDrift* p = _impl_.ntp_report_drift_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RTPDrift&>(
      ::livekit::_RTPDrift_default_instance_);
}
inline const ::livekit::RTPDrift& RTPStats::ntp_report_drift() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.ntp_report_drift)
  return _internal_ntp_report_drift();
}
inline void RTPStats::unsafe_arena_set_allocated_ntp_report_drift(
    ::livekit::RTPDrift* ntp_report_drift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ntp_report_drift_);
  }
  _impl_.ntp_report_drift_ = ntp_report_drift;
  if (ntp_report_drift) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.ntp_report_drift)
}
inline ::livekit::RTPDrift* RTPStats::release_ntp_report_drift() {
  
  ::livekit::RTPDrift* temp = _impl_.ntp_report_drift_;
  _impl_.ntp_report_drift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::unsafe_arena_release_ntp_report_drift() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.ntp_report_drift)
  
  ::livekit::RTPDrift* temp = _impl_.ntp_report_drift_;
  _impl_.ntp_report_drift_ = nullptr;
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::_internal_mutable_ntp_report_drift() {
  
  if (_impl_.ntp_report_drift_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RTPDrift>(GetArenaForAllocation());
    _impl_.ntp_report_drift_ = p;
  }
  return _impl_.ntp_report_drift_;
}
inline ::livekit::RTPDrift* RTPStats::mutable_ntp_report_drift() {
  ::livekit::RTPDrift* _msg = _internal_mutable_ntp_report_drift();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.ntp_report_drift)
  return _msg;
}
inline void RTPStats::set_allocated_ntp_report_drift(::livekit::RTPDrift* ntp_report_drift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ntp_report_drift_;
  }
  if (ntp_report_drift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ntp_report_drift);
    if (message_arena != submessage_arena) {
      ntp_report_drift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ntp_report_drift, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ntp_report_drift_ = ntp_report_drift;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.ntp_report_drift)
}

// .livekit.RTPDrift rebased_report_drift = 46;
inline bool RTPStats::_internal_has_rebased_report_drift() const {
  return this != internal_default_instance() && _impl_.rebased_report_drift_ != nullptr;
}
inline bool RTPStats::has_rebased_report_drift() const {
  return _internal_has_rebased_report_drift();
}
inline void RTPStats::clear_rebased_report_drift() {
  if (GetArenaForAllocation() == nullptr && _impl_.rebased_report_drift_ != nullptr) {
    delete _impl_.rebased_report_drift_;
  }
  _impl_.rebased_report_drift_ = nullptr;
}
inline const ::livekit::RTPDrift& RTPStats::_internal_rebased_report_drift() const {
  const ::livekit::RTPDrift* p = _impl_.rebased_report_drift_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RTPDrift&>(
      ::livekit::_RTPDrift_default_instance_);
}
inline const ::livekit::RTPDrift& RTPStats::rebased_report_drift() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.rebased_report_drift)
  return _internal_rebased_report_drift();
}
inline void RTPStats::unsafe_arena_set_allocated_rebased_report_drift(
    ::livekit::RTPDrift* rebased_report_drift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rebased_report_drift_);
  }
  _impl_.rebased_report_drift_ = rebased_report_drift;
  if (rebased_report_drift) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.rebased_report_drift)
}
inline ::livekit::RTPDrift* RTPStats::release_rebased_report_drift() {
  
  ::livekit::RTPDrift* temp = _impl_.rebased_report_drift_;
  _impl_.rebased_report_drift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::unsafe_arena_release_rebased_report_drift() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.rebased_report_drift)
  
  ::livekit::RTPDrift* temp = _impl_.rebased_report_drift_;
  _impl_.rebased_report_drift_ = nullptr;
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::_internal_mutable_rebased_report_drift() {
  
  if (_impl_.rebased_report_drift_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RTPDrift>(GetArenaForAllocation());
    _impl_.rebased_report_drift_ = p;
  }
  return _impl_.rebased_report_drift_;
}
inline ::livekit::RTPDrift* RTPStats::mutable_rebased_report_drift() {
  ::livekit::RTPDrift* _msg = _internal_mutable_rebased_report_drift();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.rebased_report_drift)
  return _msg;
}
inline void RTPStats::set_allocated_rebased_report_drift(::livekit::RTPDrift* rebased_report_drift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rebased_report_drift_;
  }
  if (rebased_report_drift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rebased_report_drift);
    if (message_arena != submessage_arena) {
      rebased_report_drift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rebased_report_drift, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rebased_report_drift_ = rebased_report_drift;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.rebased_report_drift)
}

// .livekit.RTPDrift received_report_drift = 47;
inline bool RTPStats::_internal_has_received_report_drift() const {
  return this != internal_default_instance() && _impl_.received_report_drift_ != nullptr;
}
inline bool RTPStats::has_received_report_drift() const {
  return _internal_has_received_report_drift();
}
inline void RTPStats::clear_received_report_drift() {
  if (GetArenaForAllocation() == nullptr && _impl_.received_report_drift_ != nullptr) {
    delete _impl_.received_report_drift_;
  }
  _impl_.received_report_drift_ = nullptr;
}
inline const ::livekit::RTPDrift& RTPStats::_internal_received_report_drift() const {
  const ::livekit::RTPDrift* p = _impl_.received_report_drift_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RTPDrift&>(
      ::livekit::_RTPDrift_default_instance_);
}
inline const ::livekit::RTPDrift& RTPStats::received_report_drift() const {
  // @@protoc_insertion_point(field_get:livekit.RTPStats.received_report_drift)
  return _internal_received_report_drift();
}
inline void RTPStats::unsafe_arena_set_allocated_received_report_drift(
    ::livekit::RTPDrift* received_report_drift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.received_report_drift_);
  }
  _impl_.received_report_drift_ = received_report_drift;
  if (received_report_drift) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPStats.received_report_drift)
}
inline ::livekit::RTPDrift* RTPStats::release_received_report_drift() {
  
  ::livekit::RTPDrift* temp = _impl_.received_report_drift_;
  _impl_.received_report_drift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::unsafe_arena_release_received_report_drift() {
  // @@protoc_insertion_point(field_release:livekit.RTPStats.received_report_drift)
  
  ::livekit::RTPDrift* temp = _impl_.received_report_drift_;
  _impl_.received_report_drift_ = nullptr;
  return temp;
}
inline ::livekit::RTPDrift* RTPStats::_internal_mutable_received_report_drift() {
  
  if (_impl_.received_report_drift_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RTPDrift>(GetArenaForAllocation());
    _impl_.received_report_drift_ = p;
  }
  return _impl_.received_report_drift_;
}
inline ::livekit::RTPDrift* RTPStats::mutable_received_report_drift() {
  ::livekit::RTPDrift* _msg = _internal_mutable_received_report_drift();
  // @@protoc_insertion_point(field_mutable:livekit.RTPStats.received_report_drift)
  return _msg;
}
inline void RTPStats::set_allocated_received_report_drift(::livekit::RTPDrift* received_report_drift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.received_report_drift_;
  }
  if (received_report_drift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(received_report_drift);
    if (message_arena != submessage_arena) {
      received_report_drift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, received_report_drift, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.received_report_drift_ = received_report_drift;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPStats.received_report_drift)
}

// -------------------------------------------------------------------

// RTCPSenderReportState

// uint32 rtp_timestamp = 1;
inline void RTCPSenderReportState::clear_rtp_timestamp() {
  _impl_.rtp_timestamp_ = 0u;
}
inline uint32_t RTCPSenderReportState::_internal_rtp_timestamp() const {
  return _impl_.rtp_timestamp_;
}
inline uint32_t RTCPSenderReportState::rtp_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.rtp_timestamp)
  return _internal_rtp_timestamp();
}
inline void RTCPSenderReportState::_internal_set_rtp_timestamp(uint32_t value) {
  
  _impl_.rtp_timestamp_ = value;
}
inline void RTCPSenderReportState::set_rtp_timestamp(uint32_t value) {
  _internal_set_rtp_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.rtp_timestamp)
}

// uint64 rtp_timestamp_ext = 2;
inline void RTCPSenderReportState::clear_rtp_timestamp_ext() {
  _impl_.rtp_timestamp_ext_ = uint64_t{0u};
}
inline uint64_t RTCPSenderReportState::_internal_rtp_timestamp_ext() const {
  return _impl_.rtp_timestamp_ext_;
}
inline uint64_t RTCPSenderReportState::rtp_timestamp_ext() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.rtp_timestamp_ext)
  return _internal_rtp_timestamp_ext();
}
inline void RTCPSenderReportState::_internal_set_rtp_timestamp_ext(uint64_t value) {
  
  _impl_.rtp_timestamp_ext_ = value;
}
inline void RTCPSenderReportState::set_rtp_timestamp_ext(uint64_t value) {
  _internal_set_rtp_timestamp_ext(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.rtp_timestamp_ext)
}

// uint64 ntp_timestamp = 3;
inline void RTCPSenderReportState::clear_ntp_timestamp() {
  _impl_.ntp_timestamp_ = uint64_t{0u};
}
inline uint64_t RTCPSenderReportState::_internal_ntp_timestamp() const {
  return _impl_.ntp_timestamp_;
}
inline uint64_t RTCPSenderReportState::ntp_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.ntp_timestamp)
  return _internal_ntp_timestamp();
}
inline void RTCPSenderReportState::_internal_set_ntp_timestamp(uint64_t value) {
  
  _impl_.ntp_timestamp_ = value;
}
inline void RTCPSenderReportState::set_ntp_timestamp(uint64_t value) {
  _internal_set_ntp_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.ntp_timestamp)
}

// int64 at = 4;
inline void RTCPSenderReportState::clear_at() {
  _impl_.at_ = int64_t{0};
}
inline int64_t RTCPSenderReportState::_internal_at() const {
  return _impl_.at_;
}
inline int64_t RTCPSenderReportState::at() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.at)
  return _internal_at();
}
inline void RTCPSenderReportState::_internal_set_at(int64_t value) {
  
  _impl_.at_ = value;
}
inline void RTCPSenderReportState::set_at(int64_t value) {
  _internal_set_at(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.at)
}

// int64 at_adjusted = 5;
inline void RTCPSenderReportState::clear_at_adjusted() {
  _impl_.at_adjusted_ = int64_t{0};
}
inline int64_t RTCPSenderReportState::_internal_at_adjusted() const {
  return _impl_.at_adjusted_;
}
inline int64_t RTCPSenderReportState::at_adjusted() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.at_adjusted)
  return _internal_at_adjusted();
}
inline void RTCPSenderReportState::_internal_set_at_adjusted(int64_t value) {
  
  _impl_.at_adjusted_ = value;
}
inline void RTCPSenderReportState::set_at_adjusted(int64_t value) {
  _internal_set_at_adjusted(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.at_adjusted)
}

// uint32 packets = 6;
inline void RTCPSenderReportState::clear_packets() {
  _impl_.packets_ = 0u;
}
inline uint32_t RTCPSenderReportState::_internal_packets() const {
  return _impl_.packets_;
}
inline uint32_t RTCPSenderReportState::packets() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.packets)
  return _internal_packets();
}
inline void RTCPSenderReportState::_internal_set_packets(uint32_t value) {
  
  _impl_.packets_ = value;
}
inline void RTCPSenderReportState::set_packets(uint32_t value) {
  _internal_set_packets(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.packets)
}

// uint64 octets = 7;
inline void RTCPSenderReportState::clear_octets() {
  _impl_.octets_ = uint64_t{0u};
}
inline uint64_t RTCPSenderReportState::_internal_octets() const {
  return _impl_.octets_;
}
inline uint64_t RTCPSenderReportState::octets() const {
  // @@protoc_insertion_point(field_get:livekit.RTCPSenderReportState.octets)
  return _internal_octets();
}
inline void RTCPSenderReportState::_internal_set_octets(uint64_t value) {
  
  _impl_.octets_ = value;
}
inline void RTCPSenderReportState::set_octets(uint64_t value) {
  _internal_set_octets(value);
  // @@protoc_insertion_point(field_set:livekit.RTCPSenderReportState.octets)
}

// -------------------------------------------------------------------

// RTPForwarderState

// bool started = 1;
inline void RTPForwarderState::clear_started() {
  _impl_.started_ = false;
}
inline bool RTPForwarderState::_internal_started() const {
  return _impl_.started_;
}
inline bool RTPForwarderState::started() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.started)
  return _internal_started();
}
inline void RTPForwarderState::_internal_set_started(bool value) {
  
  _impl_.started_ = value;
}
inline void RTPForwarderState::set_started(bool value) {
  _internal_set_started(value);
  // @@protoc_insertion_point(field_set:livekit.RTPForwarderState.started)
}

// int32 reference_layer_spatial = 2;
inline void RTPForwarderState::clear_reference_layer_spatial() {
  _impl_.reference_layer_spatial_ = 0;
}
inline int32_t RTPForwarderState::_internal_reference_layer_spatial() const {
  return _impl_.reference_layer_spatial_;
}
inline int32_t RTPForwarderState::reference_layer_spatial() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.reference_layer_spatial)
  return _internal_reference_layer_spatial();
}
inline void RTPForwarderState::_internal_set_reference_layer_spatial(int32_t value) {
  
  _impl_.reference_layer_spatial_ = value;
}
inline void RTPForwarderState::set_reference_layer_spatial(int32_t value) {
  _internal_set_reference_layer_spatial(value);
  // @@protoc_insertion_point(field_set:livekit.RTPForwarderState.reference_layer_spatial)
}

// int64 pre_start_time = 3;
inline void RTPForwarderState::clear_pre_start_time() {
  _impl_.pre_start_time_ = int64_t{0};
}
inline int64_t RTPForwarderState::_internal_pre_start_time() const {
  return _impl_.pre_start_time_;
}
inline int64_t RTPForwarderState::pre_start_time() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.pre_start_time)
  return _internal_pre_start_time();
}
inline void RTPForwarderState::_internal_set_pre_start_time(int64_t value) {
  
  _impl_.pre_start_time_ = value;
}
inline void RTPForwarderState::set_pre_start_time(int64_t value) {
  _internal_set_pre_start_time(value);
  // @@protoc_insertion_point(field_set:livekit.RTPForwarderState.pre_start_time)
}

// uint64 ext_first_timestamp = 4;
inline void RTPForwarderState::clear_ext_first_timestamp() {
  _impl_.ext_first_timestamp_ = uint64_t{0u};
}
inline uint64_t RTPForwarderState::_internal_ext_first_timestamp() const {
  return _impl_.ext_first_timestamp_;
}
inline uint64_t RTPForwarderState::ext_first_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.ext_first_timestamp)
  return _internal_ext_first_timestamp();
}
inline void RTPForwarderState::_internal_set_ext_first_timestamp(uint64_t value) {
  
  _impl_.ext_first_timestamp_ = value;
}
inline void RTPForwarderState::set_ext_first_timestamp(uint64_t value) {
  _internal_set_ext_first_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTPForwarderState.ext_first_timestamp)
}

// uint64 dummy_start_timestamp_offset = 5;
inline void RTPForwarderState::clear_dummy_start_timestamp_offset() {
  _impl_.dummy_start_timestamp_offset_ = uint64_t{0u};
}
inline uint64_t RTPForwarderState::_internal_dummy_start_timestamp_offset() const {
  return _impl_.dummy_start_timestamp_offset_;
}
inline uint64_t RTPForwarderState::dummy_start_timestamp_offset() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.dummy_start_timestamp_offset)
  return _internal_dummy_start_timestamp_offset();
}
inline void RTPForwarderState::_internal_set_dummy_start_timestamp_offset(uint64_t value) {
  
  _impl_.dummy_start_timestamp_offset_ = value;
}
inline void RTPForwarderState::set_dummy_start_timestamp_offset(uint64_t value) {
  _internal_set_dummy_start_timestamp_offset(value);
  // @@protoc_insertion_point(field_set:livekit.RTPForwarderState.dummy_start_timestamp_offset)
}

// .livekit.RTPMungerState rtp_munger = 6;
inline bool RTPForwarderState::_internal_has_rtp_munger() const {
  return this != internal_default_instance() && _impl_.rtp_munger_ != nullptr;
}
inline bool RTPForwarderState::has_rtp_munger() const {
  return _internal_has_rtp_munger();
}
inline void RTPForwarderState::clear_rtp_munger() {
  if (GetArenaForAllocation() == nullptr && _impl_.rtp_munger_ != nullptr) {
    delete _impl_.rtp_munger_;
  }
  _impl_.rtp_munger_ = nullptr;
}
inline const ::livekit::RTPMungerState& RTPForwarderState::_internal_rtp_munger() const {
  const ::livekit::RTPMungerState* p = _impl_.rtp_munger_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RTPMungerState&>(
      ::livekit::_RTPMungerState_default_instance_);
}
inline const ::livekit::RTPMungerState& RTPForwarderState::rtp_munger() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.rtp_munger)
  return _internal_rtp_munger();
}
inline void RTPForwarderState::unsafe_arena_set_allocated_rtp_munger(
    ::livekit::RTPMungerState* rtp_munger) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtp_munger_);
  }
  _impl_.rtp_munger_ = rtp_munger;
  if (rtp_munger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPForwarderState.rtp_munger)
}
inline ::livekit::RTPMungerState* RTPForwarderState::release_rtp_munger() {
  
  ::livekit::RTPMungerState* temp = _impl_.rtp_munger_;
  _impl_.rtp_munger_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RTPMungerState* RTPForwarderState::unsafe_arena_release_rtp_munger() {
  // @@protoc_insertion_point(field_release:livekit.RTPForwarderState.rtp_munger)
  
  ::livekit::RTPMungerState* temp = _impl_.rtp_munger_;
  _impl_.rtp_munger_ = nullptr;
  return temp;
}
inline ::livekit::RTPMungerState* RTPForwarderState::_internal_mutable_rtp_munger() {
  
  if (_impl_.rtp_munger_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RTPMungerState>(GetArenaForAllocation());
    _impl_.rtp_munger_ = p;
  }
  return _impl_.rtp_munger_;
}
inline ::livekit::RTPMungerState* RTPForwarderState::mutable_rtp_munger() {
  ::livekit::RTPMungerState* _msg = _internal_mutable_rtp_munger();
  // @@protoc_insertion_point(field_mutable:livekit.RTPForwarderState.rtp_munger)
  return _msg;
}
inline void RTPForwarderState::set_allocated_rtp_munger(::livekit::RTPMungerState* rtp_munger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtp_munger_;
  }
  if (rtp_munger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtp_munger);
    if (message_arena != submessage_arena) {
      rtp_munger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtp_munger, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rtp_munger_ = rtp_munger;
  // @@protoc_insertion_point(field_set_allocated:livekit.RTPForwarderState.rtp_munger)
}

// .livekit.VP8MungerState vp8_munger = 7;
inline bool RTPForwarderState::_internal_has_vp8_munger() const {
  return codec_munger_case() == kVp8Munger;
}
inline bool RTPForwarderState::has_vp8_munger() const {
  return _internal_has_vp8_munger();
}
inline void RTPForwarderState::set_has_vp8_munger() {
  _impl_._oneof_case_[0] = kVp8Munger;
}
inline void RTPForwarderState::clear_vp8_munger() {
  if (_internal_has_vp8_munger()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.codec_munger_.vp8_munger_;
    }
    clear_has_codec_munger();
  }
}
inline ::livekit::VP8MungerState* RTPForwarderState::release_vp8_munger() {
  // @@protoc_insertion_point(field_release:livekit.RTPForwarderState.vp8_munger)
  if (_internal_has_vp8_munger()) {
    clear_has_codec_munger();
    ::livekit::VP8MungerState* temp = _impl_.codec_munger_.vp8_munger_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.codec_munger_.vp8_munger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::VP8MungerState& RTPForwarderState::_internal_vp8_munger() const {
  return _internal_has_vp8_munger()
      ? *_impl_.codec_munger_.vp8_munger_
      : reinterpret_cast< ::livekit::VP8MungerState&>(::livekit::_VP8MungerState_default_instance_);
}
inline const ::livekit::VP8MungerState& RTPForwarderState::vp8_munger() const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.vp8_munger)
  return _internal_vp8_munger();
}
inline ::livekit::VP8MungerState* RTPForwarderState::unsafe_arena_release_vp8_munger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.RTPForwarderState.vp8_munger)
  if (_internal_has_vp8_munger()) {
    clear_has_codec_munger();
    ::livekit::VP8MungerState* temp = _impl_.codec_munger_.vp8_munger_;
    _impl_.codec_munger_.vp8_munger_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RTPForwarderState::unsafe_arena_set_allocated_vp8_munger(::livekit::VP8MungerState* vp8_munger) {
  clear_codec_munger();
  if (vp8_munger) {
    set_has_vp8_munger();
    _impl_.codec_munger_.vp8_munger_ = vp8_munger;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RTPForwarderState.vp8_munger)
}
inline ::livekit::VP8MungerState* RTPForwarderState::_internal_mutable_vp8_munger() {
  if (!_internal_has_vp8_munger()) {
    clear_codec_munger();
    set_has_vp8_munger();
    _impl_.codec_munger_.vp8_munger_ = CreateMaybeMessage< ::livekit::VP8MungerState >(GetArenaForAllocation());
  }
  return _impl_.codec_munger_.vp8_munger_;
}
inline ::livekit::VP8MungerState* RTPForwarderState::mutable_vp8_munger() {
  ::livekit::VP8MungerState* _msg = _internal_mutable_vp8_munger();
  // @@protoc_insertion_point(field_mutable:livekit.RTPForwarderState.vp8_munger)
  return _msg;
}

// repeated .livekit.RTCPSenderReportState sender_report_state = 8;
inline int RTPForwarderState::_internal_sender_report_state_size() const {
  return _impl_.sender_report_state_.size();
}
inline int RTPForwarderState::sender_report_state_size() const {
  return _internal_sender_report_state_size();
}
inline void RTPForwarderState::clear_sender_report_state() {
  _impl_.sender_report_state_.Clear();
}
inline ::livekit::RTCPSenderReportState* RTPForwarderState::mutable_sender_report_state(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RTPForwarderState.sender_report_state)
  return _impl_.sender_report_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RTCPSenderReportState >*
RTPForwarderState::mutable_sender_report_state() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RTPForwarderState.sender_report_state)
  return &_impl_.sender_report_state_;
}
inline const ::livekit::RTCPSenderReportState& RTPForwarderState::_internal_sender_report_state(int index) const {
  return _impl_.sender_report_state_.Get(index);
}
inline const ::livekit::RTCPSenderReportState& RTPForwarderState::sender_report_state(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RTPForwarderState.sender_report_state)
  return _internal_sender_report_state(index);
}
inline ::livekit::RTCPSenderReportState* RTPForwarderState::_internal_add_sender_report_state() {
  return _impl_.sender_report_state_.Add();
}
inline ::livekit::RTCPSenderReportState* RTPForwarderState::add_sender_report_state() {
  ::livekit::RTCPSenderReportState* _add = _internal_add_sender_report_state();
  // @@protoc_insertion_point(field_add:livekit.RTPForwarderState.sender_report_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RTCPSenderReportState >&
RTPForwarderState::sender_report_state() const {
  // @@protoc_insertion_point(field_list:livekit.RTPForwarderState.sender_report_state)
  return _impl_.sender_report_state_;
}

inline bool RTPForwarderState::has_codec_munger() const {
  return codec_munger_case() != CODEC_MUNGER_NOT_SET;
}
inline void RTPForwarderState::clear_has_codec_munger() {
  _impl_._oneof_case_[0] = CODEC_MUNGER_NOT_SET;
}
inline RTPForwarderState::CodecMungerCase RTPForwarderState::codec_munger_case() const {
  return RTPForwarderState::CodecMungerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RTPMungerState

// uint64 ext_last_sequence_number = 1;
inline void RTPMungerState::clear_ext_last_sequence_number() {
  _impl_.ext_last_sequence_number_ = uint64_t{0u};
}
inline uint64_t RTPMungerState::_internal_ext_last_sequence_number() const {
  return _impl_.ext_last_sequence_number_;
}
inline uint64_t RTPMungerState::ext_last_sequence_number() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.ext_last_sequence_number)
  return _internal_ext_last_sequence_number();
}
inline void RTPMungerState::_internal_set_ext_last_sequence_number(uint64_t value) {
  
  _impl_.ext_last_sequence_number_ = value;
}
inline void RTPMungerState::set_ext_last_sequence_number(uint64_t value) {
  _internal_set_ext_last_sequence_number(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.ext_last_sequence_number)
}

// uint64 ext_second_last_sequence_number = 2;
inline void RTPMungerState::clear_ext_second_last_sequence_number() {
  _impl_.ext_second_last_sequence_number_ = uint64_t{0u};
}
inline uint64_t RTPMungerState::_internal_ext_second_last_sequence_number() const {
  return _impl_.ext_second_last_sequence_number_;
}
inline uint64_t RTPMungerState::ext_second_last_sequence_number() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.ext_second_last_sequence_number)
  return _internal_ext_second_last_sequence_number();
}
inline void RTPMungerState::_internal_set_ext_second_last_sequence_number(uint64_t value) {
  
  _impl_.ext_second_last_sequence_number_ = value;
}
inline void RTPMungerState::set_ext_second_last_sequence_number(uint64_t value) {
  _internal_set_ext_second_last_sequence_number(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.ext_second_last_sequence_number)
}

// uint64 ext_last_timestamp = 3;
inline void RTPMungerState::clear_ext_last_timestamp() {
  _impl_.ext_last_timestamp_ = uint64_t{0u};
}
inline uint64_t RTPMungerState::_internal_ext_last_timestamp() const {
  return _impl_.ext_last_timestamp_;
}
inline uint64_t RTPMungerState::ext_last_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.ext_last_timestamp)
  return _internal_ext_last_timestamp();
}
inline void RTPMungerState::_internal_set_ext_last_timestamp(uint64_t value) {
  
  _impl_.ext_last_timestamp_ = value;
}
inline void RTPMungerState::set_ext_last_timestamp(uint64_t value) {
  _internal_set_ext_last_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.ext_last_timestamp)
}

// uint64 ext_second_last_timestamp = 4;
inline void RTPMungerState::clear_ext_second_last_timestamp() {
  _impl_.ext_second_last_timestamp_ = uint64_t{0u};
}
inline uint64_t RTPMungerState::_internal_ext_second_last_timestamp() const {
  return _impl_.ext_second_last_timestamp_;
}
inline uint64_t RTPMungerState::ext_second_last_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.ext_second_last_timestamp)
  return _internal_ext_second_last_timestamp();
}
inline void RTPMungerState::_internal_set_ext_second_last_timestamp(uint64_t value) {
  
  _impl_.ext_second_last_timestamp_ = value;
}
inline void RTPMungerState::set_ext_second_last_timestamp(uint64_t value) {
  _internal_set_ext_second_last_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.ext_second_last_timestamp)
}

// bool last_marker = 5;
inline void RTPMungerState::clear_last_marker() {
  _impl_.last_marker_ = false;
}
inline bool RTPMungerState::_internal_last_marker() const {
  return _impl_.last_marker_;
}
inline bool RTPMungerState::last_marker() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.last_marker)
  return _internal_last_marker();
}
inline void RTPMungerState::_internal_set_last_marker(bool value) {
  
  _impl_.last_marker_ = value;
}
inline void RTPMungerState::set_last_marker(bool value) {
  _internal_set_last_marker(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.last_marker)
}

// bool second_last_marker = 6;
inline void RTPMungerState::clear_second_last_marker() {
  _impl_.second_last_marker_ = false;
}
inline bool RTPMungerState::_internal_second_last_marker() const {
  return _impl_.second_last_marker_;
}
inline bool RTPMungerState::second_last_marker() const {
  // @@protoc_insertion_point(field_get:livekit.RTPMungerState.second_last_marker)
  return _internal_second_last_marker();
}
inline void RTPMungerState::_internal_set_second_last_marker(bool value) {
  
  _impl_.second_last_marker_ = value;
}
inline void RTPMungerState::set_second_last_marker(bool value) {
  _internal_set_second_last_marker(value);
  // @@protoc_insertion_point(field_set:livekit.RTPMungerState.second_last_marker)
}

// -------------------------------------------------------------------

// VP8MungerState

// int32 ext_last_picture_id = 1;
inline void VP8MungerState::clear_ext_last_picture_id() {
  _impl_.ext_last_picture_id_ = 0;
}
inline int32_t VP8MungerState::_internal_ext_last_picture_id() const {
  return _impl_.ext_last_picture_id_;
}
inline int32_t VP8MungerState::ext_last_picture_id() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.ext_last_picture_id)
  return _internal_ext_last_picture_id();
}
inline void VP8MungerState::_internal_set_ext_last_picture_id(int32_t value) {
  
  _impl_.ext_last_picture_id_ = value;
}
inline void VP8MungerState::set_ext_last_picture_id(int32_t value) {
  _internal_set_ext_last_picture_id(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.ext_last_picture_id)
}

// bool picture_id_used = 2;
inline void VP8MungerState::clear_picture_id_used() {
  _impl_.picture_id_used_ = false;
}
inline bool VP8MungerState::_internal_picture_id_used() const {
  return _impl_.picture_id_used_;
}
inline bool VP8MungerState::picture_id_used() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.picture_id_used)
  return _internal_picture_id_used();
}
inline void VP8MungerState::_internal_set_picture_id_used(bool value) {
  
  _impl_.picture_id_used_ = value;
}
inline void VP8MungerState::set_picture_id_used(bool value) {
  _internal_set_picture_id_used(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.picture_id_used)
}

// uint32 last_tl0_pic_idx = 3;
inline void VP8MungerState::clear_last_tl0_pic_idx() {
  _impl_.last_tl0_pic_idx_ = 0u;
}
inline uint32_t VP8MungerState::_internal_last_tl0_pic_idx() const {
  return _impl_.last_tl0_pic_idx_;
}
inline uint32_t VP8MungerState::last_tl0_pic_idx() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.last_tl0_pic_idx)
  return _internal_last_tl0_pic_idx();
}
inline void VP8MungerState::_internal_set_last_tl0_pic_idx(uint32_t value) {
  
  _impl_.last_tl0_pic_idx_ = value;
}
inline void VP8MungerState::set_last_tl0_pic_idx(uint32_t value) {
  _internal_set_last_tl0_pic_idx(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.last_tl0_pic_idx)
}

// bool tl0_pic_idx_used = 4;
inline void VP8MungerState::clear_tl0_pic_idx_used() {
  _impl_.tl0_pic_idx_used_ = false;
}
inline bool VP8MungerState::_internal_tl0_pic_idx_used() const {
  return _impl_.tl0_pic_idx_used_;
}
inline bool VP8MungerState::tl0_pic_idx_used() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.tl0_pic_idx_used)
  return _internal_tl0_pic_idx_used();
}
inline void VP8MungerState::_internal_set_tl0_pic_idx_used(bool value) {
  
  _impl_.tl0_pic_idx_used_ = value;
}
inline void VP8MungerState::set_tl0_pic_idx_used(bool value) {
  _internal_set_tl0_pic_idx_used(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.tl0_pic_idx_used)
}

// bool tid_used = 5;
inline void VP8MungerState::clear_tid_used() {
  _impl_.tid_used_ = false;
}
inline bool VP8MungerState::_internal_tid_used() const {
  return _impl_.tid_used_;
}
inline bool VP8MungerState::tid_used() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.tid_used)
  return _internal_tid_used();
}
inline void VP8MungerState::_internal_set_tid_used(bool value) {
  
  _impl_.tid_used_ = value;
}
inline void VP8MungerState::set_tid_used(bool value) {
  _internal_set_tid_used(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.tid_used)
}

// uint32 last_key_idx = 6;
inline void VP8MungerState::clear_last_key_idx() {
  _impl_.last_key_idx_ = 0u;
}
inline uint32_t VP8MungerState::_internal_last_key_idx() const {
  return _impl_.last_key_idx_;
}
inline uint32_t VP8MungerState::last_key_idx() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.last_key_idx)
  return _internal_last_key_idx();
}
inline void VP8MungerState::_internal_set_last_key_idx(uint32_t value) {
  
  _impl_.last_key_idx_ = value;
}
inline void VP8MungerState::set_last_key_idx(uint32_t value) {
  _internal_set_last_key_idx(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.last_key_idx)
}

// bool key_idx_used = 7;
inline void VP8MungerState::clear_key_idx_used() {
  _impl_.key_idx_used_ = false;
}
inline bool VP8MungerState::_internal_key_idx_used() const {
  return _impl_.key_idx_used_;
}
inline bool VP8MungerState::key_idx_used() const {
  // @@protoc_insertion_point(field_get:livekit.VP8MungerState.key_idx_used)
  return _internal_key_idx_used();
}
inline void VP8MungerState::_internal_set_key_idx_used(bool value) {
  
  _impl_.key_idx_used_ = value;
}
inline void VP8MungerState::set_key_idx_used(bool value) {
  _internal_set_key_idx_used(value);
  // @@protoc_insertion_point(field_set:livekit.VP8MungerState.key_idx_used)
}

// -------------------------------------------------------------------

// TimedVersion

// int64 unix_micro = 1;
inline void TimedVersion::clear_unix_micro() {
  _impl_.unix_micro_ = int64_t{0};
}
inline int64_t TimedVersion::_internal_unix_micro() const {
  return _impl_.unix_micro_;
}
inline int64_t TimedVersion::unix_micro() const {
  // @@protoc_insertion_point(field_get:livekit.TimedVersion.unix_micro)
  return _internal_unix_micro();
}
inline void TimedVersion::_internal_set_unix_micro(int64_t value) {
  
  _impl_.unix_micro_ = value;
}
inline void TimedVersion::set_unix_micro(int64_t value) {
  _internal_set_unix_micro(value);
  // @@protoc_insertion_point(field_set:livekit.TimedVersion.unix_micro)
}

// int32 ticks = 2;
inline void TimedVersion::clear_ticks() {
  _impl_.ticks_ = 0;
}
inline int32_t TimedVersion::_internal_ticks() const {
  return _impl_.ticks_;
}
inline int32_t TimedVersion::ticks() const {
  // @@protoc_insertion_point(field_get:livekit.TimedVersion.ticks)
  return _internal_ticks();
}
inline void TimedVersion::_internal_set_ticks(int32_t value) {
  
  _impl_.ticks_ = value;
}
inline void TimedVersion::set_ticks(int32_t value) {
  _internal_set_ticks(value);
  // @@protoc_insertion_point(field_set:livekit.TimedVersion.ticks)
}

// -------------------------------------------------------------------

// DataStream_TextHeader

// .livekit.DataStream.OperationType operation_type = 1;
inline void DataStream_TextHeader::clear_operation_type() {
  _impl_.operation_type_ = 0;
}
inline ::livekit::DataStream_OperationType DataStream_TextHeader::_internal_operation_type() const {
  return static_cast< ::livekit::DataStream_OperationType >(_impl_.operation_type_);
}
inline ::livekit::DataStream_OperationType DataStream_TextHeader::operation_type() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.TextHeader.operation_type)
  return _internal_operation_type();
}
inline void DataStream_TextHeader::_internal_set_operation_type(::livekit::DataStream_OperationType value) {
  
  _impl_.operation_type_ = value;
}
inline void DataStream_TextHeader::set_operation_type(::livekit::DataStream_OperationType value) {
  _internal_set_operation_type(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.operation_type)
}

// int32 version = 2;
inline void DataStream_TextHeader::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t DataStream_TextHeader::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DataStream_TextHeader::version() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.TextHeader.version)
  return _internal_version();
}
inline void DataStream_TextHeader::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void DataStream_TextHeader::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.version)
}

// string reply_to_stream_id = 3;
inline void DataStream_TextHeader::clear_reply_to_stream_id() {
  _impl_.reply_to_stream_id_.ClearToEmpty();
}
inline const std::string& DataStream_TextHeader::reply_to_stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.TextHeader.reply_to_stream_id)
  return _internal_reply_to_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_TextHeader::set_reply_to_stream_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_to_stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.reply_to_stream_id)
}
inline std::string* DataStream_TextHeader::mutable_reply_to_stream_id() {
  std::string* _s = _internal_mutable_reply_to_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.TextHeader.reply_to_stream_id)
  return _s;
}
inline const std::string& DataStream_TextHeader::_internal_reply_to_stream_id() const {
  return _impl_.reply_to_stream_id_.Get();
}
inline void DataStream_TextHeader::_internal_set_reply_to_stream_id(const std::string& value) {
  
  _impl_.reply_to_stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_TextHeader::_internal_mutable_reply_to_stream_id() {
  
  return _impl_.reply_to_stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_TextHeader::release_reply_to_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.TextHeader.reply_to_stream_id)
  return _impl_.reply_to_stream_id_.Release();
}
inline void DataStream_TextHeader::set_allocated_reply_to_stream_id(std::string* reply_to_stream_id) {
  if (reply_to_stream_id != nullptr) {
    
  } else {
    
  }
  _impl_.reply_to_stream_id_.SetAllocated(reply_to_stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_stream_id_.IsDefault()) {
    _impl_.reply_to_stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.TextHeader.reply_to_stream_id)
}

// repeated string attached_stream_ids = 4;
inline int DataStream_TextHeader::_internal_attached_stream_ids_size() const {
  return _impl_.attached_stream_ids_.size();
}
inline int DataStream_TextHeader::attached_stream_ids_size() const {
  return _internal_attached_stream_ids_size();
}
inline void DataStream_TextHeader::clear_attached_stream_ids() {
  _impl_.attached_stream_ids_.Clear();
}
inline std::string* DataStream_TextHeader::add_attached_stream_ids() {
  std::string* _s = _internal_add_attached_stream_ids();
  // @@protoc_insertion_point(field_add_mutable:livekit.DataStream.TextHeader.attached_stream_ids)
  return _s;
}
inline const std::string& DataStream_TextHeader::_internal_attached_stream_ids(int index) const {
  return _impl_.attached_stream_ids_.Get(index);
}
inline const std::string& DataStream_TextHeader::attached_stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.TextHeader.attached_stream_ids)
  return _internal_attached_stream_ids(index);
}
inline std::string* DataStream_TextHeader::mutable_attached_stream_ids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.TextHeader.attached_stream_ids)
  return _impl_.attached_stream_ids_.Mutable(index);
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const std::string& value) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, std::string&& value) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attached_stream_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const char* value, size_t size) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline std::string* DataStream_TextHeader::_internal_add_attached_stream_ids() {
  return _impl_.attached_stream_ids_.Add();
}
inline void DataStream_TextHeader::add_attached_stream_ids(const std::string& value) {
  _impl_.attached_stream_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(std::string&& value) {
  _impl_.attached_stream_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attached_stream_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(const char* value, size_t size) {
  _impl_.attached_stream_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.DataStream.TextHeader.attached_stream_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataStream_TextHeader::attached_stream_ids() const {
  // @@protoc_insertion_point(field_list:livekit.DataStream.TextHeader.attached_stream_ids)
  return _impl_.attached_stream_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataStream_TextHeader::mutable_attached_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.DataStream.TextHeader.attached_stream_ids)
  return &_impl_.attached_stream_ids_;
}

// bool generated = 5;
inline void DataStream_TextHeader::clear_generated() {
  _impl_.generated_ = false;
}
inline bool DataStream_TextHeader::_internal_generated() const {
  return _impl_.generated_;
}
inline bool DataStream_TextHeader::generated() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.TextHeader.generated)
  return _internal_generated();
}
inline void DataStream_TextHeader::_internal_set_generated(bool value) {
  
  _impl_.generated_ = value;
}
inline void DataStream_TextHeader::set_generated(bool value) {
  _internal_set_generated(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.TextHeader.generated)
}

// -------------------------------------------------------------------

// DataStream_ByteHeader

// string name = 1;
inline void DataStream_ByteHeader::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DataStream_ByteHeader::name() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.ByteHeader.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_ByteHeader::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.ByteHeader.name)
}
inline std::string* DataStream_ByteHeader::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.ByteHeader.name)
  return _s;
}
inline const std::string& DataStream_ByteHeader::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataStream_ByteHeader::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_ByteHeader::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_ByteHeader::release_name() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.ByteHeader.name)
  return _impl_.name_.Release();
}
inline void DataStream_ByteHeader::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.ByteHeader.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataStream_Header

// string stream_id = 1;
inline void DataStream_Header::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
}
inline const std::string& DataStream_Header::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.stream_id)
}
inline std::string* DataStream_Header::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Header.stream_id)
  return _s;
}
inline const std::string& DataStream_Header::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Header::_internal_set_stream_id(const std::string& value) {
  
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_stream_id() {
  
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Header.stream_id)
  return _impl_.stream_id_.Release();
}
inline void DataStream_Header::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Header.stream_id)
}

// int64 timestamp = 2;
inline void DataStream_Header::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t DataStream_Header::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t DataStream_Header::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.timestamp)
  return _internal_timestamp();
}
inline void DataStream_Header::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void DataStream_Header::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.timestamp)
}

// string topic = 3;
inline void DataStream_Header::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& DataStream_Header::topic() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.topic)
}
inline std::string* DataStream_Header::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Header.topic)
  return _s;
}
inline const std::string& DataStream_Header::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void DataStream_Header::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Header.topic)
  return _impl_.topic_.Release();
}
inline void DataStream_Header::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Header.topic)
}

// string mime_type = 4;
inline void DataStream_Header::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& DataStream_Header::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.mime_type)
}
inline std::string* DataStream_Header::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Header.mime_type)
  return _s;
}
inline const std::string& DataStream_Header::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void DataStream_Header::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Header.mime_type)
  return _impl_.mime_type_.Release();
}
inline void DataStream_Header::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Header.mime_type)
}

// optional uint64 total_length = 5;
inline bool DataStream_Header::_internal_has_total_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_Header::has_total_length() const {
  return _internal_has_total_length();
}
inline void DataStream_Header::clear_total_length() {
  _impl_.total_length_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DataStream_Header::_internal_total_length() const {
  return _impl_.total_length_;
}
inline uint64_t DataStream_Header::total_length() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.total_length)
  return _internal_total_length();
}
inline void DataStream_Header::_internal_set_total_length(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.total_length_ = value;
}
inline void DataStream_Header::set_total_length(uint64_t value) {
  _internal_set_total_length(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.total_length)
}

// .livekit.Encryption.Type encryption_type = 7;
inline void DataStream_Header::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
}
inline ::livekit::Encryption_Type DataStream_Header::_internal_encryption_type() const {
  return static_cast< ::livekit::Encryption_Type >(_impl_.encryption_type_);
}
inline ::livekit::Encryption_Type DataStream_Header::encryption_type() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.encryption_type)
  return _internal_encryption_type();
}
inline void DataStream_Header::_internal_set_encryption_type(::livekit::Encryption_Type value) {
  
  _impl_.encryption_type_ = value;
}
inline void DataStream_Header::set_encryption_type(::livekit::Encryption_Type value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.Header.encryption_type)
}

// map<string, string> attributes = 8;
inline int DataStream_Header::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int DataStream_Header::attributes_size() const {
  return _internal_attributes_size();
}
inline void DataStream_Header::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Header::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Header::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.DataStream.Header.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Header::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Header::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.DataStream.Header.attributes)
  return _internal_mutable_attributes();
}

// .livekit.DataStream.TextHeader text_header = 9;
inline bool DataStream_Header::_internal_has_text_header() const {
  return content_header_case() == kTextHeader;
}
inline bool DataStream_Header::has_text_header() const {
  return _internal_has_text_header();
}
inline void DataStream_Header::set_has_text_header() {
  _impl_._oneof_case_[0] = kTextHeader;
}
inline void DataStream_Header::clear_text_header() {
  if (_internal_has_text_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_header_.text_header_;
    }
    clear_has_content_header();
  }
}
inline ::livekit::DataStream_TextHeader* DataStream_Header::release_text_header() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Header.text_header)
  if (_internal_has_text_header()) {
    clear_has_content_header();
    ::livekit::DataStream_TextHeader* temp = _impl_.content_header_.text_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_header_.text_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DataStream_TextHeader& DataStream_Header::_internal_text_header() const {
  return _internal_has_text_header()
      ? *_impl_.content_header_.text_header_
      : reinterpret_cast< ::livekit::DataStream_TextHeader&>(::livekit::_DataStream_TextHeader_default_instance_);
}
inline const ::livekit::DataStream_TextHeader& DataStream_Header::text_header() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.text_header)
  return _internal_text_header();
}
inline ::livekit::DataStream_TextHeader* DataStream_Header::unsafe_arena_release_text_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataStream.Header.text_header)
  if (_internal_has_text_header()) {
    clear_has_content_header();
    ::livekit::DataStream_TextHeader* temp = _impl_.content_header_.text_header_;
    _impl_.content_header_.text_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataStream_Header::unsafe_arena_set_allocated_text_header(::livekit::DataStream_TextHeader* text_header) {
  clear_content_header();
  if (text_header) {
    set_has_text_header();
    _impl_.content_header_.text_header_ = text_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataStream.Header.text_header)
}
inline ::livekit::DataStream_TextHeader* DataStream_Header::_internal_mutable_text_header() {
  if (!_internal_has_text_header()) {
    clear_content_header();
    set_has_text_header();
    _impl_.content_header_.text_header_ = CreateMaybeMessage< ::livekit::DataStream_TextHeader >(GetArenaForAllocation());
  }
  return _impl_.content_header_.text_header_;
}
inline ::livekit::DataStream_TextHeader* DataStream_Header::mutable_text_header() {
  ::livekit::DataStream_TextHeader* _msg = _internal_mutable_text_header();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Header.text_header)
  return _msg;
}

// .livekit.DataStream.ByteHeader byte_header = 10;
inline bool DataStream_Header::_internal_has_byte_header() const {
  return content_header_case() == kByteHeader;
}
inline bool DataStream_Header::has_byte_header() const {
  return _internal_has_byte_header();
}
inline void DataStream_Header::set_has_byte_header() {
  _impl_._oneof_case_[0] = kByteHeader;
}
inline void DataStream_Header::clear_byte_header() {
  if (_internal_has_byte_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_header_.byte_header_;
    }
    clear_has_content_header();
  }
}
inline ::livekit::DataStream_ByteHeader* DataStream_Header::release_byte_header() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Header.byte_header)
  if (_internal_has_byte_header()) {
    clear_has_content_header();
    ::livekit::DataStream_ByteHeader* temp = _impl_.content_header_.byte_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_header_.byte_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::DataStream_ByteHeader& DataStream_Header::_internal_byte_header() const {
  return _internal_has_byte_header()
      ? *_impl_.content_header_.byte_header_
      : reinterpret_cast< ::livekit::DataStream_ByteHeader&>(::livekit::_DataStream_ByteHeader_default_instance_);
}
inline const ::livekit::DataStream_ByteHeader& DataStream_Header::byte_header() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Header.byte_header)
  return _internal_byte_header();
}
inline ::livekit::DataStream_ByteHeader* DataStream_Header::unsafe_arena_release_byte_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.DataStream.Header.byte_header)
  if (_internal_has_byte_header()) {
    clear_has_content_header();
    ::livekit::DataStream_ByteHeader* temp = _impl_.content_header_.byte_header_;
    _impl_.content_header_.byte_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataStream_Header::unsafe_arena_set_allocated_byte_header(::livekit::DataStream_ByteHeader* byte_header) {
  clear_content_header();
  if (byte_header) {
    set_has_byte_header();
    _impl_.content_header_.byte_header_ = byte_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.DataStream.Header.byte_header)
}
inline ::livekit::DataStream_ByteHeader* DataStream_Header::_internal_mutable_byte_header() {
  if (!_internal_has_byte_header()) {
    clear_content_header();
    set_has_byte_header();
    _impl_.content_header_.byte_header_ = CreateMaybeMessage< ::livekit::DataStream_ByteHeader >(GetArenaForAllocation());
  }
  return _impl_.content_header_.byte_header_;
}
inline ::livekit::DataStream_ByteHeader* DataStream_Header::mutable_byte_header() {
  ::livekit::DataStream_ByteHeader* _msg = _internal_mutable_byte_header();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Header.byte_header)
  return _msg;
}

inline bool DataStream_Header::has_content_header() const {
  return content_header_case() != CONTENT_HEADER_NOT_SET;
}
inline void DataStream_Header::clear_has_content_header() {
  _impl_._oneof_case_[0] = CONTENT_HEADER_NOT_SET;
}
inline DataStream_Header::ContentHeaderCase DataStream_Header::content_header_case() const {
  return DataStream_Header::ContentHeaderCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataStream_Chunk

// string stream_id = 1;
inline void DataStream_Chunk::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
}
inline const std::string& DataStream_Chunk::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Chunk.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Chunk.stream_id)
}
inline std::string* DataStream_Chunk::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Chunk.stream_id)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Chunk::_internal_set_stream_id(const std::string& value) {
  
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_stream_id() {
  
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Chunk.stream_id)
  return _impl_.stream_id_.Release();
}
inline void DataStream_Chunk::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Chunk.stream_id)
}

// uint64 chunk_index = 2;
inline void DataStream_Chunk::clear_chunk_index() {
  _impl_.chunk_index_ = uint64_t{0u};
}
inline uint64_t DataStream_Chunk::_internal_chunk_index() const {
  return _impl_.chunk_index_;
}
inline uint64_t DataStream_Chunk::chunk_index() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Chunk.chunk_index)
  return _internal_chunk_index();
}
inline void DataStream_Chunk::_internal_set_chunk_index(uint64_t value) {
  
  _impl_.chunk_index_ = value;
}
inline void DataStream_Chunk::set_chunk_index(uint64_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.Chunk.chunk_index)
}

// bytes content = 3;
inline void DataStream_Chunk::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& DataStream_Chunk::content() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Chunk.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Chunk.content)
}
inline std::string* DataStream_Chunk::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Chunk.content)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_content() const {
  return _impl_.content_.Get();
}
inline void DataStream_Chunk::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_content() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Chunk.content)
  return _impl_.content_.Release();
}
inline void DataStream_Chunk::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Chunk.content)
}

// int32 version = 4;
inline void DataStream_Chunk::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t DataStream_Chunk::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DataStream_Chunk::version() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Chunk.version)
  return _internal_version();
}
inline void DataStream_Chunk::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void DataStream_Chunk::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.DataStream.Chunk.version)
}

// optional bytes iv = 5;
inline bool DataStream_Chunk::_internal_has_iv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_iv() const {
  return _internal_has_iv();
}
inline void DataStream_Chunk::clear_iv() {
  _impl_.iv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_Chunk::iv() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Chunk.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_iv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Chunk.iv)
}
inline std::string* DataStream_Chunk::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Chunk.iv)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void DataStream_Chunk::_internal_set_iv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_iv() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_iv() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Chunk.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.iv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Chunk::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Chunk.iv)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataStream_Trailer

// string stream_id = 1;
inline void DataStream_Trailer::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
}
inline const std::string& DataStream_Trailer::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Trailer.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Trailer::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Trailer.stream_id)
}
inline std::string* DataStream_Trailer::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Trailer.stream_id)
  return _s;
}
inline const std::string& DataStream_Trailer::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Trailer::_internal_set_stream_id(const std::string& value) {
  
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::_internal_mutable_stream_id() {
  
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Trailer.stream_id)
  return _impl_.stream_id_.Release();
}
inline void DataStream_Trailer::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Trailer.stream_id)
}

// string reason = 2;
inline void DataStream_Trailer::clear_reason() {
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& DataStream_Trailer::reason() const {
  // @@protoc_insertion_point(field_get:livekit.DataStream.Trailer.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Trailer::set_reason(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DataStream.Trailer.reason)
}
inline std::string* DataStream_Trailer::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:livekit.DataStream.Trailer.reason)
  return _s;
}
inline const std::string& DataStream_Trailer::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void DataStream_Trailer::_internal_set_reason(const std::string& value) {
  
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::_internal_mutable_reason() {
  
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::release_reason() {
  // @@protoc_insertion_point(field_release:livekit.DataStream.Trailer.reason)
  return _impl_.reason_.Release();
}
inline void DataStream_Trailer::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DataStream.Trailer.reason)
}

// map<string, string> attributes = 3;
inline int DataStream_Trailer::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int DataStream_Trailer::attributes_size() const {
  return _internal_attributes_size();
}
inline void DataStream_Trailer::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Trailer::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Trailer::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.DataStream.Trailer.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Trailer::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Trailer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.DataStream.Trailer.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// DataStream

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::ParticipantInfo_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ParticipantInfo_State>() {
  return ::livekit::ParticipantInfo_State_descriptor();
}
template <> struct is_proto_enum< ::livekit::ParticipantInfo_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ParticipantInfo_Kind>() {
  return ::livekit::ParticipantInfo_Kind_descriptor();
}
template <> struct is_proto_enum< ::livekit::Encryption_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::Encryption_Type>() {
  return ::livekit::Encryption_Type_descriptor();
}
template <> struct is_proto_enum< ::livekit::DataPacket_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::DataPacket_Kind>() {
  return ::livekit::DataPacket_Kind_descriptor();
}
template <> struct is_proto_enum< ::livekit::ServerInfo_Edition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ServerInfo_Edition>() {
  return ::livekit::ServerInfo_Edition_descriptor();
}
template <> struct is_proto_enum< ::livekit::ClientInfo_SDK> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ClientInfo_SDK>() {
  return ::livekit::ClientInfo_SDK_descriptor();
}
template <> struct is_proto_enum< ::livekit::DataStream_OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::DataStream_OperationType>() {
  return ::livekit::DataStream_OperationType_descriptor();
}
template <> struct is_proto_enum< ::livekit::AudioCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::AudioCodec>() {
  return ::livekit::AudioCodec_descriptor();
}
template <> struct is_proto_enum< ::livekit::VideoCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::VideoCodec>() {
  return ::livekit::VideoCodec_descriptor();
}
template <> struct is_proto_enum< ::livekit::ImageCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ImageCodec>() {
  return ::livekit::ImageCodec_descriptor();
}
template <> struct is_proto_enum< ::livekit::BackupCodecPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::BackupCodecPolicy>() {
  return ::livekit::BackupCodecPolicy_descriptor();
}
template <> struct is_proto_enum< ::livekit::TrackType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::TrackType>() {
  return ::livekit::TrackType_descriptor();
}
template <> struct is_proto_enum< ::livekit::TrackSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::TrackSource>() {
  return ::livekit::TrackSource_descriptor();
}
template <> struct is_proto_enum< ::livekit::VideoQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::VideoQuality>() {
  return ::livekit::VideoQuality_descriptor();
}
template <> struct is_proto_enum< ::livekit::ConnectionQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ConnectionQuality>() {
  return ::livekit::ConnectionQuality_descriptor();
}
template <> struct is_proto_enum< ::livekit::ClientConfigSetting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ClientConfigSetting>() {
  return ::livekit::ClientConfigSetting_descriptor();
}
template <> struct is_proto_enum< ::livekit::DisconnectReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::DisconnectReason>() {
  return ::livekit::DisconnectReason_descriptor();
}
template <> struct is_proto_enum< ::livekit::ReconnectReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::ReconnectReason>() {
  return ::livekit::ReconnectReason_descriptor();
}
template <> struct is_proto_enum< ::livekit::SubscriptionError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::SubscriptionError>() {
  return ::livekit::SubscriptionError_descriptor();
}
template <> struct is_proto_enum< ::livekit::AudioTrackFeature> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::AudioTrackFeature>() {
  return ::livekit::AudioTrackFeature_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5fmodels_2eproto
