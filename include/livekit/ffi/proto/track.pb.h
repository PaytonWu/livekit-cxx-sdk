// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: track.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_track_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_track_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "e2ee.pb.h"
#include "handle.pb.h"
#include "stats.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_track_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_track_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_track_2eproto;
namespace livekit {
namespace proto {
class CreateAudioTrackRequest;
struct CreateAudioTrackRequestDefaultTypeInternal;
extern CreateAudioTrackRequestDefaultTypeInternal _CreateAudioTrackRequest_default_instance_;
class CreateAudioTrackResponse;
struct CreateAudioTrackResponseDefaultTypeInternal;
extern CreateAudioTrackResponseDefaultTypeInternal _CreateAudioTrackResponse_default_instance_;
class CreateVideoTrackRequest;
struct CreateVideoTrackRequestDefaultTypeInternal;
extern CreateVideoTrackRequestDefaultTypeInternal _CreateVideoTrackRequest_default_instance_;
class CreateVideoTrackResponse;
struct CreateVideoTrackResponseDefaultTypeInternal;
extern CreateVideoTrackResponseDefaultTypeInternal _CreateVideoTrackResponse_default_instance_;
class EnableRemoteTrackRequest;
struct EnableRemoteTrackRequestDefaultTypeInternal;
extern EnableRemoteTrackRequestDefaultTypeInternal _EnableRemoteTrackRequest_default_instance_;
class EnableRemoteTrackResponse;
struct EnableRemoteTrackResponseDefaultTypeInternal;
extern EnableRemoteTrackResponseDefaultTypeInternal _EnableRemoteTrackResponse_default_instance_;
class GetStatsCallback;
struct GetStatsCallbackDefaultTypeInternal;
extern GetStatsCallbackDefaultTypeInternal _GetStatsCallback_default_instance_;
class GetStatsRequest;
struct GetStatsRequestDefaultTypeInternal;
extern GetStatsRequestDefaultTypeInternal _GetStatsRequest_default_instance_;
class GetStatsResponse;
struct GetStatsResponseDefaultTypeInternal;
extern GetStatsResponseDefaultTypeInternal _GetStatsResponse_default_instance_;
class LocalTrackMuteRequest;
struct LocalTrackMuteRequestDefaultTypeInternal;
extern LocalTrackMuteRequestDefaultTypeInternal _LocalTrackMuteRequest_default_instance_;
class LocalTrackMuteResponse;
struct LocalTrackMuteResponseDefaultTypeInternal;
extern LocalTrackMuteResponseDefaultTypeInternal _LocalTrackMuteResponse_default_instance_;
class OwnedTrack;
struct OwnedTrackDefaultTypeInternal;
extern OwnedTrackDefaultTypeInternal _OwnedTrack_default_instance_;
class OwnedTrackPublication;
struct OwnedTrackPublicationDefaultTypeInternal;
extern OwnedTrackPublicationDefaultTypeInternal _OwnedTrackPublication_default_instance_;
class ParticipantTrackPermission;
struct ParticipantTrackPermissionDefaultTypeInternal;
extern ParticipantTrackPermissionDefaultTypeInternal _ParticipantTrackPermission_default_instance_;
class SetTrackSubscriptionPermissionsRequest;
struct SetTrackSubscriptionPermissionsRequestDefaultTypeInternal;
extern SetTrackSubscriptionPermissionsRequestDefaultTypeInternal _SetTrackSubscriptionPermissionsRequest_default_instance_;
class SetTrackSubscriptionPermissionsResponse;
struct SetTrackSubscriptionPermissionsResponseDefaultTypeInternal;
extern SetTrackSubscriptionPermissionsResponseDefaultTypeInternal _SetTrackSubscriptionPermissionsResponse_default_instance_;
class TrackEvent;
struct TrackEventDefaultTypeInternal;
extern TrackEventDefaultTypeInternal _TrackEvent_default_instance_;
class TrackInfo;
struct TrackInfoDefaultTypeInternal;
extern TrackInfoDefaultTypeInternal _TrackInfo_default_instance_;
class TrackPublicationInfo;
struct TrackPublicationInfoDefaultTypeInternal;
extern TrackPublicationInfoDefaultTypeInternal _TrackPublicationInfo_default_instance_;
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::proto::CreateAudioTrackRequest* Arena::CreateMaybeMessage<::livekit::proto::CreateAudioTrackRequest>(Arena*);
template<> ::livekit::proto::CreateAudioTrackResponse* Arena::CreateMaybeMessage<::livekit::proto::CreateAudioTrackResponse>(Arena*);
template<> ::livekit::proto::CreateVideoTrackRequest* Arena::CreateMaybeMessage<::livekit::proto::CreateVideoTrackRequest>(Arena*);
template<> ::livekit::proto::CreateVideoTrackResponse* Arena::CreateMaybeMessage<::livekit::proto::CreateVideoTrackResponse>(Arena*);
template<> ::livekit::proto::EnableRemoteTrackRequest* Arena::CreateMaybeMessage<::livekit::proto::EnableRemoteTrackRequest>(Arena*);
template<> ::livekit::proto::EnableRemoteTrackResponse* Arena::CreateMaybeMessage<::livekit::proto::EnableRemoteTrackResponse>(Arena*);
template<> ::livekit::proto::GetStatsCallback* Arena::CreateMaybeMessage<::livekit::proto::GetStatsCallback>(Arena*);
template<> ::livekit::proto::GetStatsRequest* Arena::CreateMaybeMessage<::livekit::proto::GetStatsRequest>(Arena*);
template<> ::livekit::proto::GetStatsResponse* Arena::CreateMaybeMessage<::livekit::proto::GetStatsResponse>(Arena*);
template<> ::livekit::proto::LocalTrackMuteRequest* Arena::CreateMaybeMessage<::livekit::proto::LocalTrackMuteRequest>(Arena*);
template<> ::livekit::proto::LocalTrackMuteResponse* Arena::CreateMaybeMessage<::livekit::proto::LocalTrackMuteResponse>(Arena*);
template<> ::livekit::proto::OwnedTrack* Arena::CreateMaybeMessage<::livekit::proto::OwnedTrack>(Arena*);
template<> ::livekit::proto::OwnedTrackPublication* Arena::CreateMaybeMessage<::livekit::proto::OwnedTrackPublication>(Arena*);
template<> ::livekit::proto::ParticipantTrackPermission* Arena::CreateMaybeMessage<::livekit::proto::ParticipantTrackPermission>(Arena*);
template<> ::livekit::proto::SetTrackSubscriptionPermissionsRequest* Arena::CreateMaybeMessage<::livekit::proto::SetTrackSubscriptionPermissionsRequest>(Arena*);
template<> ::livekit::proto::SetTrackSubscriptionPermissionsResponse* Arena::CreateMaybeMessage<::livekit::proto::SetTrackSubscriptionPermissionsResponse>(Arena*);
template<> ::livekit::proto::TrackEvent* Arena::CreateMaybeMessage<::livekit::proto::TrackEvent>(Arena*);
template<> ::livekit::proto::TrackInfo* Arena::CreateMaybeMessage<::livekit::proto::TrackInfo>(Arena*);
template<> ::livekit::proto::TrackPublicationInfo* Arena::CreateMaybeMessage<::livekit::proto::TrackPublicationInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {
namespace proto {

enum TrackKind : int {
  KIND_UNKNOWN = 0,
  KIND_AUDIO = 1,
  KIND_VIDEO = 2
};
bool TrackKind_IsValid(int value);
constexpr TrackKind TrackKind_MIN = KIND_UNKNOWN;
constexpr TrackKind TrackKind_MAX = KIND_VIDEO;
constexpr int TrackKind_ARRAYSIZE = TrackKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackKind_descriptor();
template<typename T>
inline const std::string& TrackKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackKind_descriptor(), enum_t_value);
}
inline bool TrackKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackKind>(
    TrackKind_descriptor(), name, value);
}
enum TrackSource : int {
  SOURCE_UNKNOWN = 0,
  SOURCE_CAMERA = 1,
  SOURCE_MICROPHONE = 2,
  SOURCE_SCREENSHARE = 3,
  SOURCE_SCREENSHARE_AUDIO = 4
};
bool TrackSource_IsValid(int value);
constexpr TrackSource TrackSource_MIN = SOURCE_UNKNOWN;
constexpr TrackSource TrackSource_MAX = SOURCE_SCREENSHARE_AUDIO;
constexpr int TrackSource_ARRAYSIZE = TrackSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSource_descriptor();
template<typename T>
inline const std::string& TrackSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackSource_descriptor(), enum_t_value);
}
inline bool TrackSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackSource>(
    TrackSource_descriptor(), name, value);
}
enum StreamState : int {
  STATE_UNKNOWN = 0,
  STATE_ACTIVE = 1,
  STATE_PAUSED = 2
};
bool StreamState_IsValid(int value);
constexpr StreamState StreamState_MIN = STATE_UNKNOWN;
constexpr StreamState StreamState_MAX = STATE_PAUSED;
constexpr int StreamState_ARRAYSIZE = StreamState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamState_descriptor();
template<typename T>
inline const std::string& StreamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamState_descriptor(), enum_t_value);
}
inline bool StreamState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamState>(
    StreamState_descriptor(), name, value);
}
// ===================================================================

class CreateVideoTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CreateVideoTrackRequest) */ {
 public:
  inline CreateVideoTrackRequest() : CreateVideoTrackRequest(nullptr) {}
  ~CreateVideoTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateVideoTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateVideoTrackRequest(const CreateVideoTrackRequest& from);
  CreateVideoTrackRequest(CreateVideoTrackRequest&& from) noexcept
    : CreateVideoTrackRequest() {
    *this = ::std::move(from);
  }

  inline CreateVideoTrackRequest& operator=(const CreateVideoTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVideoTrackRequest& operator=(CreateVideoTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVideoTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVideoTrackRequest* internal_default_instance() {
    return reinterpret_cast<const CreateVideoTrackRequest*>(
               &_CreateVideoTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateVideoTrackRequest& a, CreateVideoTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVideoTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVideoTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVideoTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVideoTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateVideoTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateVideoTrackRequest& from) {
    CreateVideoTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateVideoTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CreateVideoTrackRequest";
  }
  protected:
  explicit CreateVideoTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceHandleFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint64 source_handle = 2;
  bool has_source_handle() const;
  private:
  bool _internal_has_source_handle() const;
  public:
  void clear_source_handle();
  uint64_t source_handle() const;
  void set_source_handle(uint64_t value);
  private:
  uint64_t _internal_source_handle() const;
  void _internal_set_source_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CreateVideoTrackRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t source_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class CreateVideoTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CreateVideoTrackResponse) */ {
 public:
  inline CreateVideoTrackResponse() : CreateVideoTrackResponse(nullptr) {}
  ~CreateVideoTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateVideoTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateVideoTrackResponse(const CreateVideoTrackResponse& from);
  CreateVideoTrackResponse(CreateVideoTrackResponse&& from) noexcept
    : CreateVideoTrackResponse() {
    *this = ::std::move(from);
  }

  inline CreateVideoTrackResponse& operator=(const CreateVideoTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVideoTrackResponse& operator=(CreateVideoTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVideoTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVideoTrackResponse* internal_default_instance() {
    return reinterpret_cast<const CreateVideoTrackResponse*>(
               &_CreateVideoTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateVideoTrackResponse& a, CreateVideoTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVideoTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVideoTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVideoTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVideoTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateVideoTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateVideoTrackResponse& from) {
    CreateVideoTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateVideoTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CreateVideoTrackResponse";
  }
  protected:
  explicit CreateVideoTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackFieldNumber = 1,
  };
  // required .livekit.proto.OwnedTrack track = 1;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::proto::OwnedTrack& track() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedTrack* release_track();
  ::livekit::proto::OwnedTrack* mutable_track();
  void set_allocated_track(::livekit::proto::OwnedTrack* track);
  private:
  const ::livekit::proto::OwnedTrack& _internal_track() const;
  ::livekit::proto::OwnedTrack* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::proto::OwnedTrack* track);
  ::livekit::proto::OwnedTrack* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.proto.CreateVideoTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedTrack* track_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class CreateAudioTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CreateAudioTrackRequest) */ {
 public:
  inline CreateAudioTrackRequest() : CreateAudioTrackRequest(nullptr) {}
  ~CreateAudioTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateAudioTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAudioTrackRequest(const CreateAudioTrackRequest& from);
  CreateAudioTrackRequest(CreateAudioTrackRequest&& from) noexcept
    : CreateAudioTrackRequest() {
    *this = ::std::move(from);
  }

  inline CreateAudioTrackRequest& operator=(const CreateAudioTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAudioTrackRequest& operator=(CreateAudioTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAudioTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAudioTrackRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAudioTrackRequest*>(
               &_CreateAudioTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateAudioTrackRequest& a, CreateAudioTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAudioTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAudioTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAudioTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAudioTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAudioTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAudioTrackRequest& from) {
    CreateAudioTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAudioTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CreateAudioTrackRequest";
  }
  protected:
  explicit CreateAudioTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceHandleFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint64 source_handle = 2;
  bool has_source_handle() const;
  private:
  bool _internal_has_source_handle() const;
  public:
  void clear_source_handle();
  uint64_t source_handle() const;
  void set_source_handle(uint64_t value);
  private:
  uint64_t _internal_source_handle() const;
  void _internal_set_source_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CreateAudioTrackRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t source_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class CreateAudioTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CreateAudioTrackResponse) */ {
 public:
  inline CreateAudioTrackResponse() : CreateAudioTrackResponse(nullptr) {}
  ~CreateAudioTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateAudioTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAudioTrackResponse(const CreateAudioTrackResponse& from);
  CreateAudioTrackResponse(CreateAudioTrackResponse&& from) noexcept
    : CreateAudioTrackResponse() {
    *this = ::std::move(from);
  }

  inline CreateAudioTrackResponse& operator=(const CreateAudioTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAudioTrackResponse& operator=(CreateAudioTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAudioTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAudioTrackResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAudioTrackResponse*>(
               &_CreateAudioTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateAudioTrackResponse& a, CreateAudioTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAudioTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAudioTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAudioTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAudioTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAudioTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAudioTrackResponse& from) {
    CreateAudioTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAudioTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CreateAudioTrackResponse";
  }
  protected:
  explicit CreateAudioTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackFieldNumber = 1,
  };
  // required .livekit.proto.OwnedTrack track = 1;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::proto::OwnedTrack& track() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedTrack* release_track();
  ::livekit::proto::OwnedTrack* mutable_track();
  void set_allocated_track(::livekit::proto::OwnedTrack* track);
  private:
  const ::livekit::proto::OwnedTrack& _internal_track() const;
  ::livekit::proto::OwnedTrack* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::proto::OwnedTrack* track);
  ::livekit::proto::OwnedTrack* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.proto.CreateAudioTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedTrack* track_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class GetStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetStatsRequest) */ {
 public:
  inline GetStatsRequest() : GetStatsRequest(nullptr) {}
  ~GetStatsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatsRequest(const GetStatsRequest& from);
  GetStatsRequest(GetStatsRequest&& from) noexcept
    : GetStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetStatsRequest& operator=(const GetStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatsRequest& operator=(GetStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatsRequest*>(
               &_GetStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetStatsRequest& a, GetStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatsRequest& from) {
    GetStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetStatsRequest";
  }
  protected:
  explicit GetStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackHandleFieldNumber = 1,
  };
  // required uint64 track_handle = 1;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t track_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class GetStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetStatsResponse) */ {
 public:
  inline GetStatsResponse() : GetStatsResponse(nullptr) {}
  ~GetStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatsResponse(const GetStatsResponse& from);
  GetStatsResponse(GetStatsResponse&& from) noexcept
    : GetStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetStatsResponse& operator=(const GetStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatsResponse& operator=(GetStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatsResponse*>(
               &_GetStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetStatsResponse& a, GetStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatsResponse& from) {
    GetStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetStatsResponse";
  }
  protected:
  explicit GetStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class GetStatsCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetStatsCallback) */ {
 public:
  inline GetStatsCallback() : GetStatsCallback(nullptr) {}
  ~GetStatsCallback() override;
  explicit PROTOBUF_CONSTEXPR GetStatsCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStatsCallback(const GetStatsCallback& from);
  GetStatsCallback(GetStatsCallback&& from) noexcept
    : GetStatsCallback() {
    *this = ::std::move(from);
  }

  inline GetStatsCallback& operator=(const GetStatsCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatsCallback& operator=(GetStatsCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStatsCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStatsCallback* internal_default_instance() {
    return reinterpret_cast<const GetStatsCallback*>(
               &_GetStatsCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetStatsCallback& a, GetStatsCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatsCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatsCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStatsCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStatsCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStatsCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStatsCallback& from) {
    GetStatsCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatsCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetStatsCallback";
  }
  protected:
  explicit GetStatsCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // repeated .livekit.proto.RtcStats stats = 3;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::livekit::proto::RtcStats* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
      mutable_stats();
  private:
  const ::livekit::proto::RtcStats& _internal_stats(int index) const;
  ::livekit::proto::RtcStats* _internal_add_stats();
  public:
  const ::livekit::proto::RtcStats& stats(int index) const;
  ::livekit::proto::RtcStats* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
      stats() const;

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetStatsCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats > stats_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class TrackEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.TrackEvent) */ {
 public:
  inline TrackEvent() : TrackEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TrackEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackEvent(const TrackEvent& from);
  TrackEvent(TrackEvent&& from) noexcept
    : TrackEvent() {
    *this = ::std::move(from);
  }

  inline TrackEvent& operator=(const TrackEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackEvent& operator=(TrackEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackEvent* internal_default_instance() {
    return reinterpret_cast<const TrackEvent*>(
               &_TrackEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrackEvent& a, TrackEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TrackEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TrackEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackEvent";
  }
  protected:
  explicit TrackEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class TrackPublicationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackPublicationInfo) */ {
 public:
  inline TrackPublicationInfo() : TrackPublicationInfo(nullptr) {}
  ~TrackPublicationInfo() override;
  explicit PROTOBUF_CONSTEXPR TrackPublicationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPublicationInfo(const TrackPublicationInfo& from);
  TrackPublicationInfo(TrackPublicationInfo&& from) noexcept
    : TrackPublicationInfo() {
    *this = ::std::move(from);
  }

  inline TrackPublicationInfo& operator=(const TrackPublicationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublicationInfo& operator=(TrackPublicationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublicationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPublicationInfo* internal_default_instance() {
    return reinterpret_cast<const TrackPublicationInfo*>(
               &_TrackPublicationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TrackPublicationInfo& a, TrackPublicationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPublicationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublicationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublicationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPublicationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPublicationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPublicationInfo& from) {
    TrackPublicationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPublicationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackPublicationInfo";
  }
  protected:
  explicit TrackPublicationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kNameFieldNumber = 2,
    kMimeTypeFieldNumber = 8,
    kKindFieldNumber = 3,
    kSourceFieldNumber = 4,
    kWidthFieldNumber = 6,
    kHeightFieldNumber = 7,
    kSimulcastedFieldNumber = 5,
    kMutedFieldNumber = 9,
    kRemoteFieldNumber = 10,
    kEncryptionTypeFieldNumber = 11,
  };
  // required string sid = 1;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string mime_type = 8;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // required .livekit.proto.TrackKind kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::livekit::proto::TrackKind kind() const;
  void set_kind(::livekit::proto::TrackKind value);
  private:
  ::livekit::proto::TrackKind _internal_kind() const;
  void _internal_set_kind(::livekit::proto::TrackKind value);
  public:

  // required .livekit.proto.TrackSource source = 4;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::livekit::proto::TrackSource source() const;
  void set_source(::livekit::proto::TrackSource value);
  private:
  ::livekit::proto::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::proto::TrackSource value);
  public:

  // required uint32 width = 6;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // required uint32 height = 7;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // required bool simulcasted = 5;
  bool has_simulcasted() const;
  private:
  bool _internal_has_simulcasted() const;
  public:
  void clear_simulcasted();
  bool simulcasted() const;
  void set_simulcasted(bool value);
  private:
  bool _internal_simulcasted() const;
  void _internal_set_simulcasted(bool value);
  public:

  // required bool muted = 9;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // required bool remote = 10;
  bool has_remote() const;
  private:
  bool _internal_has_remote() const;
  public:
  void clear_remote();
  bool remote() const;
  void set_remote(bool value);
  private:
  bool _internal_remote() const;
  void _internal_set_remote(bool value);
  public:

  // required .livekit.proto.EncryptionType encryption_type = 11;
  bool has_encryption_type() const;
  private:
  bool _internal_has_encryption_type() const;
  public:
  void clear_encryption_type();
  ::livekit::proto::EncryptionType encryption_type() const;
  void set_encryption_type(::livekit::proto::EncryptionType value);
  private:
  ::livekit::proto::EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::livekit::proto::EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackPublicationInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    int kind_;
    int source_;
    uint32_t width_;
    uint32_t height_;
    bool simulcasted_;
    bool muted_;
    bool remote_;
    int encryption_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class OwnedTrackPublication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedTrackPublication) */ {
 public:
  inline OwnedTrackPublication() : OwnedTrackPublication(nullptr) {}
  ~OwnedTrackPublication() override;
  explicit PROTOBUF_CONSTEXPR OwnedTrackPublication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedTrackPublication(const OwnedTrackPublication& from);
  OwnedTrackPublication(OwnedTrackPublication&& from) noexcept
    : OwnedTrackPublication() {
    *this = ::std::move(from);
  }

  inline OwnedTrackPublication& operator=(const OwnedTrackPublication& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedTrackPublication& operator=(OwnedTrackPublication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedTrackPublication& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedTrackPublication* internal_default_instance() {
    return reinterpret_cast<const OwnedTrackPublication*>(
               &_OwnedTrackPublication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OwnedTrackPublication& a, OwnedTrackPublication& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedTrackPublication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedTrackPublication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedTrackPublication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedTrackPublication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedTrackPublication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedTrackPublication& from) {
    OwnedTrackPublication::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedTrackPublication* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedTrackPublication";
  }
  protected:
  explicit OwnedTrackPublication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.TrackPublicationInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::TrackPublicationInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackPublicationInfo* release_info();
  ::livekit::proto::TrackPublicationInfo* mutable_info();
  void set_allocated_info(::livekit::proto::TrackPublicationInfo* info);
  private:
  const ::livekit::proto::TrackPublicationInfo& _internal_info() const;
  ::livekit::proto::TrackPublicationInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::TrackPublicationInfo* info);
  ::livekit::proto::TrackPublicationInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedTrackPublication)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::TrackPublicationInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class TrackInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackInfo) */ {
 public:
  inline TrackInfo() : TrackInfo(nullptr) {}
  ~TrackInfo() override;
  explicit PROTOBUF_CONSTEXPR TrackInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackInfo(const TrackInfo& from);
  TrackInfo(TrackInfo&& from) noexcept
    : TrackInfo() {
    *this = ::std::move(from);
  }

  inline TrackInfo& operator=(const TrackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackInfo& operator=(TrackInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackInfo* internal_default_instance() {
    return reinterpret_cast<const TrackInfo*>(
               &_TrackInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrackInfo& a, TrackInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackInfo& from) {
    TrackInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackInfo";
  }
  protected:
  explicit TrackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kNameFieldNumber = 2,
    kKindFieldNumber = 3,
    kStreamStateFieldNumber = 4,
    kMutedFieldNumber = 5,
    kRemoteFieldNumber = 6,
  };
  // required string sid = 1;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .livekit.proto.TrackKind kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::livekit::proto::TrackKind kind() const;
  void set_kind(::livekit::proto::TrackKind value);
  private:
  ::livekit::proto::TrackKind _internal_kind() const;
  void _internal_set_kind(::livekit::proto::TrackKind value);
  public:

  // required .livekit.proto.StreamState stream_state = 4;
  bool has_stream_state() const;
  private:
  bool _internal_has_stream_state() const;
  public:
  void clear_stream_state();
  ::livekit::proto::StreamState stream_state() const;
  void set_stream_state(::livekit::proto::StreamState value);
  private:
  ::livekit::proto::StreamState _internal_stream_state() const;
  void _internal_set_stream_state(::livekit::proto::StreamState value);
  public:

  // required bool muted = 5;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // required bool remote = 6;
  bool has_remote() const;
  private:
  bool _internal_has_remote() const;
  public:
  void clear_remote();
  bool remote() const;
  void set_remote(bool value);
  private:
  bool _internal_remote() const;
  void _internal_set_remote(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int kind_;
    int stream_state_;
    bool muted_;
    bool remote_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class OwnedTrack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedTrack) */ {
 public:
  inline OwnedTrack() : OwnedTrack(nullptr) {}
  ~OwnedTrack() override;
  explicit PROTOBUF_CONSTEXPR OwnedTrack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedTrack(const OwnedTrack& from);
  OwnedTrack(OwnedTrack&& from) noexcept
    : OwnedTrack() {
    *this = ::std::move(from);
  }

  inline OwnedTrack& operator=(const OwnedTrack& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedTrack& operator=(OwnedTrack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedTrack& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedTrack* internal_default_instance() {
    return reinterpret_cast<const OwnedTrack*>(
               &_OwnedTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OwnedTrack& a, OwnedTrack& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedTrack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedTrack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedTrack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedTrack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedTrack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedTrack& from) {
    OwnedTrack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedTrack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedTrack";
  }
  protected:
  explicit OwnedTrack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.TrackInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::TrackInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackInfo* release_info();
  ::livekit::proto::TrackInfo* mutable_info();
  void set_allocated_info(::livekit::proto::TrackInfo* info);
  private:
  const ::livekit::proto::TrackInfo& _internal_info() const;
  ::livekit::proto::TrackInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::TrackInfo* info);
  ::livekit::proto::TrackInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedTrack)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::TrackInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class LocalTrackMuteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LocalTrackMuteRequest) */ {
 public:
  inline LocalTrackMuteRequest() : LocalTrackMuteRequest(nullptr) {}
  ~LocalTrackMuteRequest() override;
  explicit PROTOBUF_CONSTEXPR LocalTrackMuteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTrackMuteRequest(const LocalTrackMuteRequest& from);
  LocalTrackMuteRequest(LocalTrackMuteRequest&& from) noexcept
    : LocalTrackMuteRequest() {
    *this = ::std::move(from);
  }

  inline LocalTrackMuteRequest& operator=(const LocalTrackMuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTrackMuteRequest& operator=(LocalTrackMuteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTrackMuteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTrackMuteRequest* internal_default_instance() {
    return reinterpret_cast<const LocalTrackMuteRequest*>(
               &_LocalTrackMuteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LocalTrackMuteRequest& a, LocalTrackMuteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTrackMuteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTrackMuteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTrackMuteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTrackMuteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTrackMuteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTrackMuteRequest& from) {
    LocalTrackMuteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTrackMuteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LocalTrackMuteRequest";
  }
  protected:
  explicit LocalTrackMuteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackHandleFieldNumber = 1,
    kMuteFieldNumber = 2,
  };
  // required uint64 track_handle = 1;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // required bool mute = 2;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  bool mute() const;
  void set_mute(bool value);
  private:
  bool _internal_mute() const;
  void _internal_set_mute(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LocalTrackMuteRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t track_handle_;
    bool mute_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class LocalTrackMuteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LocalTrackMuteResponse) */ {
 public:
  inline LocalTrackMuteResponse() : LocalTrackMuteResponse(nullptr) {}
  ~LocalTrackMuteResponse() override;
  explicit PROTOBUF_CONSTEXPR LocalTrackMuteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTrackMuteResponse(const LocalTrackMuteResponse& from);
  LocalTrackMuteResponse(LocalTrackMuteResponse&& from) noexcept
    : LocalTrackMuteResponse() {
    *this = ::std::move(from);
  }

  inline LocalTrackMuteResponse& operator=(const LocalTrackMuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTrackMuteResponse& operator=(LocalTrackMuteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTrackMuteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTrackMuteResponse* internal_default_instance() {
    return reinterpret_cast<const LocalTrackMuteResponse*>(
               &_LocalTrackMuteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LocalTrackMuteResponse& a, LocalTrackMuteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTrackMuteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTrackMuteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTrackMuteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTrackMuteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTrackMuteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTrackMuteResponse& from) {
    LocalTrackMuteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTrackMuteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LocalTrackMuteResponse";
  }
  protected:
  explicit LocalTrackMuteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutedFieldNumber = 1,
  };
  // required bool muted = 1;
  bool has_muted() const;
  private:
  bool _internal_has_muted() const;
  public:
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LocalTrackMuteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool muted_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class EnableRemoteTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.EnableRemoteTrackRequest) */ {
 public:
  inline EnableRemoteTrackRequest() : EnableRemoteTrackRequest(nullptr) {}
  ~EnableRemoteTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR EnableRemoteTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableRemoteTrackRequest(const EnableRemoteTrackRequest& from);
  EnableRemoteTrackRequest(EnableRemoteTrackRequest&& from) noexcept
    : EnableRemoteTrackRequest() {
    *this = ::std::move(from);
  }

  inline EnableRemoteTrackRequest& operator=(const EnableRemoteTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableRemoteTrackRequest& operator=(EnableRemoteTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableRemoteTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableRemoteTrackRequest* internal_default_instance() {
    return reinterpret_cast<const EnableRemoteTrackRequest*>(
               &_EnableRemoteTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EnableRemoteTrackRequest& a, EnableRemoteTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableRemoteTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableRemoteTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableRemoteTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableRemoteTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableRemoteTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnableRemoteTrackRequest& from) {
    EnableRemoteTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableRemoteTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.EnableRemoteTrackRequest";
  }
  protected:
  explicit EnableRemoteTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackHandleFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // required uint64 track_handle = 1;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // required bool enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.EnableRemoteTrackRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t track_handle_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class EnableRemoteTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.EnableRemoteTrackResponse) */ {
 public:
  inline EnableRemoteTrackResponse() : EnableRemoteTrackResponse(nullptr) {}
  ~EnableRemoteTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR EnableRemoteTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnableRemoteTrackResponse(const EnableRemoteTrackResponse& from);
  EnableRemoteTrackResponse(EnableRemoteTrackResponse&& from) noexcept
    : EnableRemoteTrackResponse() {
    *this = ::std::move(from);
  }

  inline EnableRemoteTrackResponse& operator=(const EnableRemoteTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableRemoteTrackResponse& operator=(EnableRemoteTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableRemoteTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableRemoteTrackResponse* internal_default_instance() {
    return reinterpret_cast<const EnableRemoteTrackResponse*>(
               &_EnableRemoteTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EnableRemoteTrackResponse& a, EnableRemoteTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableRemoteTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableRemoteTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableRemoteTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableRemoteTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnableRemoteTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnableRemoteTrackResponse& from) {
    EnableRemoteTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableRemoteTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.EnableRemoteTrackResponse";
  }
  protected:
  explicit EnableRemoteTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // required bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.EnableRemoteTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class SetTrackSubscriptionPermissionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetTrackSubscriptionPermissionsRequest) */ {
 public:
  inline SetTrackSubscriptionPermissionsRequest() : SetTrackSubscriptionPermissionsRequest(nullptr) {}
  ~SetTrackSubscriptionPermissionsRequest() override;
  explicit PROTOBUF_CONSTEXPR SetTrackSubscriptionPermissionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackSubscriptionPermissionsRequest(const SetTrackSubscriptionPermissionsRequest& from);
  SetTrackSubscriptionPermissionsRequest(SetTrackSubscriptionPermissionsRequest&& from) noexcept
    : SetTrackSubscriptionPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline SetTrackSubscriptionPermissionsRequest& operator=(const SetTrackSubscriptionPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackSubscriptionPermissionsRequest& operator=(SetTrackSubscriptionPermissionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackSubscriptionPermissionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackSubscriptionPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const SetTrackSubscriptionPermissionsRequest*>(
               &_SetTrackSubscriptionPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetTrackSubscriptionPermissionsRequest& a, SetTrackSubscriptionPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackSubscriptionPermissionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackSubscriptionPermissionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackSubscriptionPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackSubscriptionPermissionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTrackSubscriptionPermissionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTrackSubscriptionPermissionsRequest& from) {
    SetTrackSubscriptionPermissionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTrackSubscriptionPermissionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetTrackSubscriptionPermissionsRequest";
  }
  protected:
  explicit SetTrackSubscriptionPermissionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kLocalParticipantHandleFieldNumber = 1,
    kAllParticipantsAllowedFieldNumber = 2,
  };
  // repeated .livekit.proto.ParticipantTrackPermission permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::livekit::proto::ParticipantTrackPermission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ParticipantTrackPermission >*
      mutable_permissions();
  private:
  const ::livekit::proto::ParticipantTrackPermission& _internal_permissions(int index) const;
  ::livekit::proto::ParticipantTrackPermission* _internal_add_permissions();
  public:
  const ::livekit::proto::ParticipantTrackPermission& permissions(int index) const;
  ::livekit::proto::ParticipantTrackPermission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ParticipantTrackPermission >&
      permissions() const;

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required bool all_participants_allowed = 2;
  bool has_all_participants_allowed() const;
  private:
  bool _internal_has_all_participants_allowed() const;
  public:
  void clear_all_participants_allowed();
  bool all_participants_allowed() const;
  void set_all_participants_allowed(bool value);
  private:
  bool _internal_all_participants_allowed() const;
  void _internal_set_all_participants_allowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetTrackSubscriptionPermissionsRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ParticipantTrackPermission > permissions_;
    uint64_t local_participant_handle_;
    bool all_participants_allowed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class ParticipantTrackPermission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantTrackPermission) */ {
 public:
  inline ParticipantTrackPermission() : ParticipantTrackPermission(nullptr) {}
  ~ParticipantTrackPermission() override;
  explicit PROTOBUF_CONSTEXPR ParticipantTrackPermission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantTrackPermission(const ParticipantTrackPermission& from);
  ParticipantTrackPermission(ParticipantTrackPermission&& from) noexcept
    : ParticipantTrackPermission() {
    *this = ::std::move(from);
  }

  inline ParticipantTrackPermission& operator=(const ParticipantTrackPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantTrackPermission& operator=(ParticipantTrackPermission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantTrackPermission& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantTrackPermission* internal_default_instance() {
    return reinterpret_cast<const ParticipantTrackPermission*>(
               &_ParticipantTrackPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ParticipantTrackPermission& a, ParticipantTrackPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantTrackPermission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantTrackPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantTrackPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantTrackPermission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantTrackPermission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantTrackPermission& from) {
    ParticipantTrackPermission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantTrackPermission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantTrackPermission";
  }
  protected:
  explicit ParticipantTrackPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedTrackSidsFieldNumber = 3,
    kParticipantIdentityFieldNumber = 1,
    kAllowAllFieldNumber = 2,
  };
  // repeated string allowed_track_sids = 3;
  int allowed_track_sids_size() const;
  private:
  int _internal_allowed_track_sids_size() const;
  public:
  void clear_allowed_track_sids();
  const std::string& allowed_track_sids(int index) const;
  std::string* mutable_allowed_track_sids(int index);
  void set_allowed_track_sids(int index, const std::string& value);
  void set_allowed_track_sids(int index, std::string&& value);
  void set_allowed_track_sids(int index, const char* value);
  void set_allowed_track_sids(int index, const char* value, size_t size);
  std::string* add_allowed_track_sids();
  void add_allowed_track_sids(const std::string& value);
  void add_allowed_track_sids(std::string&& value);
  void add_allowed_track_sids(const char* value);
  void add_allowed_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allowed_track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allowed_track_sids();
  private:
  const std::string& _internal_allowed_track_sids(int index) const;
  std::string* _internal_add_allowed_track_sids();
  public:

  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // optional bool allow_all = 2;
  bool has_allow_all() const;
  private:
  bool _internal_has_allow_all() const;
  public:
  void clear_allow_all();
  bool allow_all() const;
  void set_allow_all(bool value);
  private:
  bool _internal_allow_all() const;
  void _internal_set_allow_all(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantTrackPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allowed_track_sids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    bool allow_all_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_2eproto;
};
// -------------------------------------------------------------------

class SetTrackSubscriptionPermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SetTrackSubscriptionPermissionsResponse) */ {
 public:
  inline SetTrackSubscriptionPermissionsResponse() : SetTrackSubscriptionPermissionsResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetTrackSubscriptionPermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTrackSubscriptionPermissionsResponse(const SetTrackSubscriptionPermissionsResponse& from);
  SetTrackSubscriptionPermissionsResponse(SetTrackSubscriptionPermissionsResponse&& from) noexcept
    : SetTrackSubscriptionPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline SetTrackSubscriptionPermissionsResponse& operator=(const SetTrackSubscriptionPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTrackSubscriptionPermissionsResponse& operator=(SetTrackSubscriptionPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTrackSubscriptionPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTrackSubscriptionPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const SetTrackSubscriptionPermissionsResponse*>(
               &_SetTrackSubscriptionPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetTrackSubscriptionPermissionsResponse& a, SetTrackSubscriptionPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTrackSubscriptionPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTrackSubscriptionPermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTrackSubscriptionPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTrackSubscriptionPermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetTrackSubscriptionPermissionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetTrackSubscriptionPermissionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetTrackSubscriptionPermissionsResponse";
  }
  protected:
  explicit SetTrackSubscriptionPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SetTrackSubscriptionPermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_track_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateVideoTrackRequest

// required string name = 1;
inline bool CreateVideoTrackRequest::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateVideoTrackRequest::has_name() const {
  return _internal_has_name();
}
inline void CreateVideoTrackRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateVideoTrackRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateVideoTrackRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateVideoTrackRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.CreateVideoTrackRequest.name)
}
inline std::string* CreateVideoTrackRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CreateVideoTrackRequest.name)
  return _s;
}
inline const std::string& CreateVideoTrackRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateVideoTrackRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateVideoTrackRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateVideoTrackRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.CreateVideoTrackRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateVideoTrackRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CreateVideoTrackRequest.name)
}

// required uint64 source_handle = 2;
inline bool CreateVideoTrackRequest::_internal_has_source_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateVideoTrackRequest::has_source_handle() const {
  return _internal_has_source_handle();
}
inline void CreateVideoTrackRequest::clear_source_handle() {
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CreateVideoTrackRequest::_internal_source_handle() const {
  return _impl_.source_handle_;
}
inline uint64_t CreateVideoTrackRequest::source_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateVideoTrackRequest.source_handle)
  return _internal_source_handle();
}
inline void CreateVideoTrackRequest::_internal_set_source_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_handle_ = value;
}
inline void CreateVideoTrackRequest::set_source_handle(uint64_t value) {
  _internal_set_source_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CreateVideoTrackRequest.source_handle)
}

// -------------------------------------------------------------------

// CreateVideoTrackResponse

// required .livekit.proto.OwnedTrack track = 1;
inline bool CreateVideoTrackResponse::_internal_has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
  return value;
}
inline bool CreateVideoTrackResponse::has_track() const {
  return _internal_has_track();
}
inline void CreateVideoTrackResponse::clear_track() {
  if (_impl_.track_ != nullptr) _impl_.track_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedTrack& CreateVideoTrackResponse::_internal_track() const {
  const ::livekit::proto::OwnedTrack* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedTrack&>(
      ::livekit::proto::_OwnedTrack_default_instance_);
}
inline const ::livekit::proto::OwnedTrack& CreateVideoTrackResponse::track() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateVideoTrackResponse.track)
  return _internal_track();
}
inline void CreateVideoTrackResponse::unsafe_arena_set_allocated_track(
    ::livekit::proto::OwnedTrack* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.CreateVideoTrackResponse.track)
}
inline ::livekit::proto::OwnedTrack* CreateVideoTrackResponse::release_track() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedTrack* CreateVideoTrackResponse::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.proto.CreateVideoTrackResponse.track)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedTrack* CreateVideoTrackResponse::_internal_mutable_track() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedTrack>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::livekit::proto::OwnedTrack* CreateVideoTrackResponse::mutable_track() {
  ::livekit::proto::OwnedTrack* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CreateVideoTrackResponse.track)
  return _msg;
}
inline void CreateVideoTrackResponse::set_allocated_track(::livekit::proto::OwnedTrack* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.track_;
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(track);
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CreateVideoTrackResponse.track)
}

// -------------------------------------------------------------------

// CreateAudioTrackRequest

// required string name = 1;
inline bool CreateAudioTrackRequest::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateAudioTrackRequest::has_name() const {
  return _internal_has_name();
}
inline void CreateAudioTrackRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateAudioTrackRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateAudioTrackRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAudioTrackRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.CreateAudioTrackRequest.name)
}
inline std::string* CreateAudioTrackRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CreateAudioTrackRequest.name)
  return _s;
}
inline const std::string& CreateAudioTrackRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateAudioTrackRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAudioTrackRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAudioTrackRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.CreateAudioTrackRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateAudioTrackRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CreateAudioTrackRequest.name)
}

// required uint64 source_handle = 2;
inline bool CreateAudioTrackRequest::_internal_has_source_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateAudioTrackRequest::has_source_handle() const {
  return _internal_has_source_handle();
}
inline void CreateAudioTrackRequest::clear_source_handle() {
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CreateAudioTrackRequest::_internal_source_handle() const {
  return _impl_.source_handle_;
}
inline uint64_t CreateAudioTrackRequest::source_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateAudioTrackRequest.source_handle)
  return _internal_source_handle();
}
inline void CreateAudioTrackRequest::_internal_set_source_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_handle_ = value;
}
inline void CreateAudioTrackRequest::set_source_handle(uint64_t value) {
  _internal_set_source_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CreateAudioTrackRequest.source_handle)
}

// -------------------------------------------------------------------

// CreateAudioTrackResponse

// required .livekit.proto.OwnedTrack track = 1;
inline bool CreateAudioTrackResponse::_internal_has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
  return value;
}
inline bool CreateAudioTrackResponse::has_track() const {
  return _internal_has_track();
}
inline void CreateAudioTrackResponse::clear_track() {
  if (_impl_.track_ != nullptr) _impl_.track_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedTrack& CreateAudioTrackResponse::_internal_track() const {
  const ::livekit::proto::OwnedTrack* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedTrack&>(
      ::livekit::proto::_OwnedTrack_default_instance_);
}
inline const ::livekit::proto::OwnedTrack& CreateAudioTrackResponse::track() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CreateAudioTrackResponse.track)
  return _internal_track();
}
inline void CreateAudioTrackResponse::unsafe_arena_set_allocated_track(
    ::livekit::proto::OwnedTrack* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.CreateAudioTrackResponse.track)
}
inline ::livekit::proto::OwnedTrack* CreateAudioTrackResponse::release_track() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedTrack* CreateAudioTrackResponse::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.proto.CreateAudioTrackResponse.track)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedTrack* CreateAudioTrackResponse::_internal_mutable_track() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedTrack>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::livekit::proto::OwnedTrack* CreateAudioTrackResponse::mutable_track() {
  ::livekit::proto::OwnedTrack* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CreateAudioTrackResponse.track)
  return _msg;
}
inline void CreateAudioTrackResponse::set_allocated_track(::livekit::proto::OwnedTrack* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.track_;
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(track);
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CreateAudioTrackResponse.track)
}

// -------------------------------------------------------------------

// GetStatsRequest

// required uint64 track_handle = 1;
inline bool GetStatsRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetStatsRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void GetStatsRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetStatsRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t GetStatsRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetStatsRequest.track_handle)
  return _internal_track_handle();
}
inline void GetStatsRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_handle_ = value;
}
inline void GetStatsRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetStatsRequest.track_handle)
}

// -------------------------------------------------------------------

// GetStatsResponse

// required uint64 async_id = 1;
inline bool GetStatsResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetStatsResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void GetStatsResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetStatsResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t GetStatsResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetStatsResponse.async_id)
  return _internal_async_id();
}
inline void GetStatsResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void GetStatsResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetStatsResponse.async_id)
}

// -------------------------------------------------------------------

// GetStatsCallback

// required uint64 async_id = 1;
inline bool GetStatsCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetStatsCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void GetStatsCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t GetStatsCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t GetStatsCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetStatsCallback.async_id)
  return _internal_async_id();
}
inline void GetStatsCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void GetStatsCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetStatsCallback.async_id)
}

// optional string error = 2;
inline bool GetStatsCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetStatsCallback::has_error() const {
  return _internal_has_error();
}
inline void GetStatsCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetStatsCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetStatsCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStatsCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.GetStatsCallback.error)
}
inline std::string* GetStatsCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetStatsCallback.error)
  return _s;
}
inline const std::string& GetStatsCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void GetStatsCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStatsCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStatsCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetStatsCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetStatsCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.GetStatsCallback.error)
}

// repeated .livekit.proto.RtcStats stats = 3;
inline int GetStatsCallback::_internal_stats_size() const {
  return _impl_.stats_.size();
}
inline int GetStatsCallback::stats_size() const {
  return _internal_stats_size();
}
inline ::livekit::proto::RtcStats* GetStatsCallback::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetStatsCallback.stats)
  return _impl_.stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
GetStatsCallback::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.GetStatsCallback.stats)
  return &_impl_.stats_;
}
inline const ::livekit::proto::RtcStats& GetStatsCallback::_internal_stats(int index) const {
  return _impl_.stats_.Get(index);
}
inline const ::livekit::proto::RtcStats& GetStatsCallback::stats(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetStatsCallback.stats)
  return _internal_stats(index);
}
inline ::livekit::proto::RtcStats* GetStatsCallback::_internal_add_stats() {
  return _impl_.stats_.Add();
}
inline ::livekit::proto::RtcStats* GetStatsCallback::add_stats() {
  ::livekit::proto::RtcStats* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:livekit.proto.GetStatsCallback.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
GetStatsCallback::stats() const {
  // @@protoc_insertion_point(field_list:livekit.proto.GetStatsCallback.stats)
  return _impl_.stats_;
}

// -------------------------------------------------------------------

// TrackEvent

// -------------------------------------------------------------------

// TrackPublicationInfo

// required string sid = 1;
inline bool TrackPublicationInfo::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_sid() const {
  return _internal_has_sid();
}
inline void TrackPublicationInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackPublicationInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublicationInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.sid)
}
inline std::string* TrackPublicationInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublicationInfo.sid)
  return _s;
}
inline const std::string& TrackPublicationInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void TrackPublicationInfo::_internal_set_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::_internal_mutable_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublicationInfo.sid)
  if (!_internal_has_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackPublicationInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublicationInfo.sid)
}

// required string name = 2;
inline bool TrackPublicationInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_name() const {
  return _internal_has_name();
}
inline void TrackPublicationInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackPublicationInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublicationInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.name)
}
inline std::string* TrackPublicationInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublicationInfo.name)
  return _s;
}
inline const std::string& TrackPublicationInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TrackPublicationInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublicationInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackPublicationInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublicationInfo.name)
}

// required .livekit.proto.TrackKind kind = 3;
inline bool TrackPublicationInfo::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_kind() const {
  return _internal_has_kind();
}
inline void TrackPublicationInfo::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::TrackKind TrackPublicationInfo::_internal_kind() const {
  return static_cast< ::livekit::proto::TrackKind >(_impl_.kind_);
}
inline ::livekit::proto::TrackKind TrackPublicationInfo::kind() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.kind)
  return _internal_kind();
}
inline void TrackPublicationInfo::_internal_set_kind(::livekit::proto::TrackKind value) {
  assert(::livekit::proto::TrackKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.kind_ = value;
}
inline void TrackPublicationInfo::set_kind(::livekit::proto::TrackKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.kind)
}

// required .livekit.proto.TrackSource source = 4;
inline bool TrackPublicationInfo::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_source() const {
  return _internal_has_source();
}
inline void TrackPublicationInfo::clear_source() {
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::proto::TrackSource TrackPublicationInfo::_internal_source() const {
  return static_cast< ::livekit::proto::TrackSource >(_impl_.source_);
}
inline ::livekit::proto::TrackSource TrackPublicationInfo::source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.source)
  return _internal_source();
}
inline void TrackPublicationInfo::_internal_set_source(::livekit::proto::TrackSource value) {
  assert(::livekit::proto::TrackSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.source_ = value;
}
inline void TrackPublicationInfo::set_source(::livekit::proto::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.source)
}

// required bool simulcasted = 5;
inline bool TrackPublicationInfo::_internal_has_simulcasted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_simulcasted() const {
  return _internal_has_simulcasted();
}
inline void TrackPublicationInfo::clear_simulcasted() {
  _impl_.simulcasted_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool TrackPublicationInfo::_internal_simulcasted() const {
  return _impl_.simulcasted_;
}
inline bool TrackPublicationInfo::simulcasted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.simulcasted)
  return _internal_simulcasted();
}
inline void TrackPublicationInfo::_internal_set_simulcasted(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.simulcasted_ = value;
}
inline void TrackPublicationInfo::set_simulcasted(bool value) {
  _internal_set_simulcasted(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.simulcasted)
}

// required uint32 width = 6;
inline bool TrackPublicationInfo::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_width() const {
  return _internal_has_width();
}
inline void TrackPublicationInfo::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TrackPublicationInfo::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t TrackPublicationInfo::width() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.width)
  return _internal_width();
}
inline void TrackPublicationInfo::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.width_ = value;
}
inline void TrackPublicationInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.width)
}

// required uint32 height = 7;
inline bool TrackPublicationInfo::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_height() const {
  return _internal_has_height();
}
inline void TrackPublicationInfo::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TrackPublicationInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t TrackPublicationInfo::height() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.height)
  return _internal_height();
}
inline void TrackPublicationInfo::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.height_ = value;
}
inline void TrackPublicationInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.height)
}

// required string mime_type = 8;
inline bool TrackPublicationInfo::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void TrackPublicationInfo::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrackPublicationInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublicationInfo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.mime_type)
}
inline std::string* TrackPublicationInfo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublicationInfo.mime_type)
  return _s;
}
inline const std::string& TrackPublicationInfo::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void TrackPublicationInfo::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublicationInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublicationInfo.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackPublicationInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublicationInfo.mime_type)
}

// required bool muted = 9;
inline bool TrackPublicationInfo::_internal_has_muted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_muted() const {
  return _internal_has_muted();
}
inline void TrackPublicationInfo::clear_muted() {
  _impl_.muted_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TrackPublicationInfo::_internal_muted() const {
  return _impl_.muted_;
}
inline bool TrackPublicationInfo::muted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.muted)
  return _internal_muted();
}
inline void TrackPublicationInfo::_internal_set_muted(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.muted_ = value;
}
inline void TrackPublicationInfo::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.muted)
}

// required bool remote = 10;
inline bool TrackPublicationInfo::_internal_has_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_remote() const {
  return _internal_has_remote();
}
inline void TrackPublicationInfo::clear_remote() {
  _impl_.remote_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool TrackPublicationInfo::_internal_remote() const {
  return _impl_.remote_;
}
inline bool TrackPublicationInfo::remote() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.remote)
  return _internal_remote();
}
inline void TrackPublicationInfo::_internal_set_remote(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.remote_ = value;
}
inline void TrackPublicationInfo::set_remote(bool value) {
  _internal_set_remote(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.remote)
}

// required .livekit.proto.EncryptionType encryption_type = 11;
inline bool TrackPublicationInfo::_internal_has_encryption_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TrackPublicationInfo::has_encryption_type() const {
  return _internal_has_encryption_type();
}
inline void TrackPublicationInfo::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::livekit::proto::EncryptionType TrackPublicationInfo::_internal_encryption_type() const {
  return static_cast< ::livekit::proto::EncryptionType >(_impl_.encryption_type_);
}
inline ::livekit::proto::EncryptionType TrackPublicationInfo::encryption_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublicationInfo.encryption_type)
  return _internal_encryption_type();
}
inline void TrackPublicationInfo::_internal_set_encryption_type(::livekit::proto::EncryptionType value) {
  assert(::livekit::proto::EncryptionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.encryption_type_ = value;
}
inline void TrackPublicationInfo::set_encryption_type(::livekit::proto::EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublicationInfo.encryption_type)
}

// -------------------------------------------------------------------

// OwnedTrackPublication

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedTrackPublication::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedTrackPublication::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedTrackPublication::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedTrackPublication::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedTrackPublication.handle)
  return _internal_handle();
}
inline void OwnedTrackPublication::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedTrackPublication.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrackPublication::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrackPublication::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedTrackPublication.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrackPublication::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrackPublication::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedTrackPublication.handle)
  return _msg;
}
inline void OwnedTrackPublication::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedTrackPublication.handle)
}

// required .livekit.proto.TrackPublicationInfo info = 2;
inline bool OwnedTrackPublication::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedTrackPublication::has_info() const {
  return _internal_has_info();
}
inline void OwnedTrackPublication::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::TrackPublicationInfo& OwnedTrackPublication::_internal_info() const {
  const ::livekit::proto::TrackPublicationInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::TrackPublicationInfo&>(
      ::livekit::proto::_TrackPublicationInfo_default_instance_);
}
inline const ::livekit::proto::TrackPublicationInfo& OwnedTrackPublication::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedTrackPublication.info)
  return _internal_info();
}
inline void OwnedTrackPublication::unsafe_arena_set_allocated_info(
    ::livekit::proto::TrackPublicationInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedTrackPublication.info)
}
inline ::livekit::proto::TrackPublicationInfo* OwnedTrackPublication::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::TrackPublicationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::TrackPublicationInfo* OwnedTrackPublication::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedTrackPublication.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::TrackPublicationInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::TrackPublicationInfo* OwnedTrackPublication::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::TrackPublicationInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::TrackPublicationInfo* OwnedTrackPublication::mutable_info() {
  ::livekit::proto::TrackPublicationInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedTrackPublication.info)
  return _msg;
}
inline void OwnedTrackPublication::set_allocated_info(::livekit::proto::TrackPublicationInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedTrackPublication.info)
}

// -------------------------------------------------------------------

// TrackInfo

// required string sid = 1;
inline bool TrackInfo::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackInfo::has_sid() const {
  return _internal_has_sid();
}
inline void TrackInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.sid)
}
inline std::string* TrackInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackInfo.sid)
  return _s;
}
inline const std::string& TrackInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void TrackInfo::_internal_set_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackInfo.sid)
  if (!_internal_has_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackInfo.sid)
}

// required string name = 2;
inline bool TrackInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackInfo::has_name() const {
  return _internal_has_name();
}
inline void TrackInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.name)
}
inline std::string* TrackInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackInfo.name)
  return _s;
}
inline const std::string& TrackInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TrackInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackInfo.name)
}

// required .livekit.proto.TrackKind kind = 3;
inline bool TrackInfo::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackInfo::has_kind() const {
  return _internal_has_kind();
}
inline void TrackInfo::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::TrackKind TrackInfo::_internal_kind() const {
  return static_cast< ::livekit::proto::TrackKind >(_impl_.kind_);
}
inline ::livekit::proto::TrackKind TrackInfo::kind() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.kind)
  return _internal_kind();
}
inline void TrackInfo::_internal_set_kind(::livekit::proto::TrackKind value) {
  assert(::livekit::proto::TrackKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_ = value;
}
inline void TrackInfo::set_kind(::livekit::proto::TrackKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.kind)
}

// required .livekit.proto.StreamState stream_state = 4;
inline bool TrackInfo::_internal_has_stream_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrackInfo::has_stream_state() const {
  return _internal_has_stream_state();
}
inline void TrackInfo::clear_stream_state() {
  _impl_.stream_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::StreamState TrackInfo::_internal_stream_state() const {
  return static_cast< ::livekit::proto::StreamState >(_impl_.stream_state_);
}
inline ::livekit::proto::StreamState TrackInfo::stream_state() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.stream_state)
  return _internal_stream_state();
}
inline void TrackInfo::_internal_set_stream_state(::livekit::proto::StreamState value) {
  assert(::livekit::proto::StreamState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stream_state_ = value;
}
inline void TrackInfo::set_stream_state(::livekit::proto::StreamState value) {
  _internal_set_stream_state(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.stream_state)
}

// required bool muted = 5;
inline bool TrackInfo::_internal_has_muted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrackInfo::has_muted() const {
  return _internal_has_muted();
}
inline void TrackInfo::clear_muted() {
  _impl_.muted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TrackInfo::_internal_muted() const {
  return _impl_.muted_;
}
inline bool TrackInfo::muted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.muted)
  return _internal_muted();
}
inline void TrackInfo::_internal_set_muted(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.muted_ = value;
}
inline void TrackInfo::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.muted)
}

// required bool remote = 6;
inline bool TrackInfo::_internal_has_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrackInfo::has_remote() const {
  return _internal_has_remote();
}
inline void TrackInfo::clear_remote() {
  _impl_.remote_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TrackInfo::_internal_remote() const {
  return _impl_.remote_;
}
inline bool TrackInfo::remote() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackInfo.remote)
  return _internal_remote();
}
inline void TrackInfo::_internal_set_remote(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.remote_ = value;
}
inline void TrackInfo::set_remote(bool value) {
  _internal_set_remote(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackInfo.remote)
}

// -------------------------------------------------------------------

// OwnedTrack

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedTrack::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedTrack::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedTrack::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedTrack::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedTrack.handle)
  return _internal_handle();
}
inline void OwnedTrack::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedTrack.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrack::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrack::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedTrack.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrack::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedTrack::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedTrack.handle)
  return _msg;
}
inline void OwnedTrack::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedTrack.handle)
}

// required .livekit.proto.TrackInfo info = 2;
inline bool OwnedTrack::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedTrack::has_info() const {
  return _internal_has_info();
}
inline void OwnedTrack::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::TrackInfo& OwnedTrack::_internal_info() const {
  const ::livekit::proto::TrackInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::TrackInfo&>(
      ::livekit::proto::_TrackInfo_default_instance_);
}
inline const ::livekit::proto::TrackInfo& OwnedTrack::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedTrack.info)
  return _internal_info();
}
inline void OwnedTrack::unsafe_arena_set_allocated_info(
    ::livekit::proto::TrackInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedTrack.info)
}
inline ::livekit::proto::TrackInfo* OwnedTrack::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::TrackInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::TrackInfo* OwnedTrack::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedTrack.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::TrackInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::TrackInfo* OwnedTrack::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::TrackInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::TrackInfo* OwnedTrack::mutable_info() {
  ::livekit::proto::TrackInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedTrack.info)
  return _msg;
}
inline void OwnedTrack::set_allocated_info(::livekit::proto::TrackInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedTrack.info)
}

// -------------------------------------------------------------------

// LocalTrackMuteRequest

// required uint64 track_handle = 1;
inline bool LocalTrackMuteRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTrackMuteRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void LocalTrackMuteRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LocalTrackMuteRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t LocalTrackMuteRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackMuteRequest.track_handle)
  return _internal_track_handle();
}
inline void LocalTrackMuteRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_handle_ = value;
}
inline void LocalTrackMuteRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackMuteRequest.track_handle)
}

// required bool mute = 2;
inline bool LocalTrackMuteRequest::_internal_has_mute() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocalTrackMuteRequest::has_mute() const {
  return _internal_has_mute();
}
inline void LocalTrackMuteRequest::clear_mute() {
  _impl_.mute_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LocalTrackMuteRequest::_internal_mute() const {
  return _impl_.mute_;
}
inline bool LocalTrackMuteRequest::mute() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackMuteRequest.mute)
  return _internal_mute();
}
inline void LocalTrackMuteRequest::_internal_set_mute(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mute_ = value;
}
inline void LocalTrackMuteRequest::set_mute(bool value) {
  _internal_set_mute(value);
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackMuteRequest.mute)
}

// -------------------------------------------------------------------

// LocalTrackMuteResponse

// required bool muted = 1;
inline bool LocalTrackMuteResponse::_internal_has_muted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTrackMuteResponse::has_muted() const {
  return _internal_has_muted();
}
inline void LocalTrackMuteResponse::clear_muted() {
  _impl_.muted_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool LocalTrackMuteResponse::_internal_muted() const {
  return _impl_.muted_;
}
inline bool LocalTrackMuteResponse::muted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackMuteResponse.muted)
  return _internal_muted();
}
inline void LocalTrackMuteResponse::_internal_set_muted(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.muted_ = value;
}
inline void LocalTrackMuteResponse::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackMuteResponse.muted)
}

// -------------------------------------------------------------------

// EnableRemoteTrackRequest

// required uint64 track_handle = 1;
inline bool EnableRemoteTrackRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EnableRemoteTrackRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void EnableRemoteTrackRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t EnableRemoteTrackRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t EnableRemoteTrackRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EnableRemoteTrackRequest.track_handle)
  return _internal_track_handle();
}
inline void EnableRemoteTrackRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_handle_ = value;
}
inline void EnableRemoteTrackRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.EnableRemoteTrackRequest.track_handle)
}

// required bool enabled = 2;
inline bool EnableRemoteTrackRequest::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EnableRemoteTrackRequest::has_enabled() const {
  return _internal_has_enabled();
}
inline void EnableRemoteTrackRequest::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool EnableRemoteTrackRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool EnableRemoteTrackRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EnableRemoteTrackRequest.enabled)
  return _internal_enabled();
}
inline void EnableRemoteTrackRequest::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void EnableRemoteTrackRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.EnableRemoteTrackRequest.enabled)
}

// -------------------------------------------------------------------

// EnableRemoteTrackResponse

// required bool enabled = 1;
inline bool EnableRemoteTrackResponse::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EnableRemoteTrackResponse::has_enabled() const {
  return _internal_has_enabled();
}
inline void EnableRemoteTrackResponse::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EnableRemoteTrackResponse::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool EnableRemoteTrackResponse::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EnableRemoteTrackResponse.enabled)
  return _internal_enabled();
}
inline void EnableRemoteTrackResponse::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void EnableRemoteTrackResponse::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.EnableRemoteTrackResponse.enabled)
}

// -------------------------------------------------------------------

// SetTrackSubscriptionPermissionsRequest

// required uint64 local_participant_handle = 1;
inline bool SetTrackSubscriptionPermissionsRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetTrackSubscriptionPermissionsRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SetTrackSubscriptionPermissionsRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetTrackSubscriptionPermissionsRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SetTrackSubscriptionPermissionsRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetTrackSubscriptionPermissionsRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SetTrackSubscriptionPermissionsRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.local_participant_handle_ = value;
}
inline void SetTrackSubscriptionPermissionsRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetTrackSubscriptionPermissionsRequest.local_participant_handle)
}

// required bool all_participants_allowed = 2;
inline bool SetTrackSubscriptionPermissionsRequest::_internal_has_all_participants_allowed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetTrackSubscriptionPermissionsRequest::has_all_participants_allowed() const {
  return _internal_has_all_participants_allowed();
}
inline void SetTrackSubscriptionPermissionsRequest::clear_all_participants_allowed() {
  _impl_.all_participants_allowed_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SetTrackSubscriptionPermissionsRequest::_internal_all_participants_allowed() const {
  return _impl_.all_participants_allowed_;
}
inline bool SetTrackSubscriptionPermissionsRequest::all_participants_allowed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetTrackSubscriptionPermissionsRequest.all_participants_allowed)
  return _internal_all_participants_allowed();
}
inline void SetTrackSubscriptionPermissionsRequest::_internal_set_all_participants_allowed(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.all_participants_allowed_ = value;
}
inline void SetTrackSubscriptionPermissionsRequest::set_all_participants_allowed(bool value) {
  _internal_set_all_participants_allowed(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetTrackSubscriptionPermissionsRequest.all_participants_allowed)
}

// repeated .livekit.proto.ParticipantTrackPermission permissions = 3;
inline int SetTrackSubscriptionPermissionsRequest::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int SetTrackSubscriptionPermissionsRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void SetTrackSubscriptionPermissionsRequest::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::livekit::proto::ParticipantTrackPermission* SetTrackSubscriptionPermissionsRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetTrackSubscriptionPermissionsRequest.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ParticipantTrackPermission >*
SetTrackSubscriptionPermissionsRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SetTrackSubscriptionPermissionsRequest.permissions)
  return &_impl_.permissions_;
}
inline const ::livekit::proto::ParticipantTrackPermission& SetTrackSubscriptionPermissionsRequest::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::livekit::proto::ParticipantTrackPermission& SetTrackSubscriptionPermissionsRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetTrackSubscriptionPermissionsRequest.permissions)
  return _internal_permissions(index);
}
inline ::livekit::proto::ParticipantTrackPermission* SetTrackSubscriptionPermissionsRequest::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::livekit::proto::ParticipantTrackPermission* SetTrackSubscriptionPermissionsRequest::add_permissions() {
  ::livekit::proto::ParticipantTrackPermission* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:livekit.proto.SetTrackSubscriptionPermissionsRequest.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ParticipantTrackPermission >&
SetTrackSubscriptionPermissionsRequest::permissions() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SetTrackSubscriptionPermissionsRequest.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// ParticipantTrackPermission

// required string participant_identity = 1;
inline bool ParticipantTrackPermission::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParticipantTrackPermission::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ParticipantTrackPermission::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantTrackPermission::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantTrackPermission.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantTrackPermission::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantTrackPermission.participant_identity)
}
inline std::string* ParticipantTrackPermission::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantTrackPermission.participant_identity)
  return _s;
}
inline const std::string& ParticipantTrackPermission::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ParticipantTrackPermission::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantTrackPermission::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantTrackPermission::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantTrackPermission.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantTrackPermission::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantTrackPermission.participant_identity)
}

// optional bool allow_all = 2;
inline bool ParticipantTrackPermission::_internal_has_allow_all() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParticipantTrackPermission::has_allow_all() const {
  return _internal_has_allow_all();
}
inline void ParticipantTrackPermission::clear_allow_all() {
  _impl_.allow_all_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ParticipantTrackPermission::_internal_allow_all() const {
  return _impl_.allow_all_;
}
inline bool ParticipantTrackPermission::allow_all() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantTrackPermission.allow_all)
  return _internal_allow_all();
}
inline void ParticipantTrackPermission::_internal_set_allow_all(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.allow_all_ = value;
}
inline void ParticipantTrackPermission::set_allow_all(bool value) {
  _internal_set_allow_all(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantTrackPermission.allow_all)
}

// repeated string allowed_track_sids = 3;
inline int ParticipantTrackPermission::_internal_allowed_track_sids_size() const {
  return _impl_.allowed_track_sids_.size();
}
inline int ParticipantTrackPermission::allowed_track_sids_size() const {
  return _internal_allowed_track_sids_size();
}
inline void ParticipantTrackPermission::clear_allowed_track_sids() {
  _impl_.allowed_track_sids_.Clear();
}
inline std::string* ParticipantTrackPermission::add_allowed_track_sids() {
  std::string* _s = _internal_add_allowed_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
  return _s;
}
inline const std::string& ParticipantTrackPermission::_internal_allowed_track_sids(int index) const {
  return _impl_.allowed_track_sids_.Get(index);
}
inline const std::string& ParticipantTrackPermission::allowed_track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
  return _internal_allowed_track_sids(index);
}
inline std::string* ParticipantTrackPermission::mutable_allowed_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
  return _impl_.allowed_track_sids_.Mutable(index);
}
inline void ParticipantTrackPermission::set_allowed_track_sids(int index, const std::string& value) {
  _impl_.allowed_track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::set_allowed_track_sids(int index, std::string&& value) {
  _impl_.allowed_track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::set_allowed_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::set_allowed_track_sids(int index, const char* value, size_t size) {
  _impl_.allowed_track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline std::string* ParticipantTrackPermission::_internal_add_allowed_track_sids() {
  return _impl_.allowed_track_sids_.Add();
}
inline void ParticipantTrackPermission::add_allowed_track_sids(const std::string& value) {
  _impl_.allowed_track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::add_allowed_track_sids(std::string&& value) {
  _impl_.allowed_track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::add_allowed_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.allowed_track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline void ParticipantTrackPermission::add_allowed_track_sids(const char* value, size_t size) {
  _impl_.allowed_track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParticipantTrackPermission::allowed_track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
  return _impl_.allowed_track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParticipantTrackPermission::mutable_allowed_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ParticipantTrackPermission.allowed_track_sids)
  return &_impl_.allowed_track_sids_;
}

// -------------------------------------------------------------------

// SetTrackSubscriptionPermissionsResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::proto::TrackKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::TrackKind>() {
  return ::livekit::proto::TrackKind_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::TrackSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::TrackSource>() {
  return ::livekit::proto::TrackSource_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::StreamState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::StreamState>() {
  return ::livekit::proto::StreamState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_track_2eproto
