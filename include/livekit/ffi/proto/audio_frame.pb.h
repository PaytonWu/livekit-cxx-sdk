// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio_frame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_audio_5fframe_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_audio_5fframe_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "handle.pb.h"
#include "track.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_audio_5fframe_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_audio_5fframe_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_audio_5fframe_2eproto;
namespace livekit {
namespace proto {
class ApmProcessReverseStreamRequest;
struct ApmProcessReverseStreamRequestDefaultTypeInternal;
extern ApmProcessReverseStreamRequestDefaultTypeInternal _ApmProcessReverseStreamRequest_default_instance_;
class ApmProcessReverseStreamResponse;
struct ApmProcessReverseStreamResponseDefaultTypeInternal;
extern ApmProcessReverseStreamResponseDefaultTypeInternal _ApmProcessReverseStreamResponse_default_instance_;
class ApmProcessStreamRequest;
struct ApmProcessStreamRequestDefaultTypeInternal;
extern ApmProcessStreamRequestDefaultTypeInternal _ApmProcessStreamRequest_default_instance_;
class ApmProcessStreamResponse;
struct ApmProcessStreamResponseDefaultTypeInternal;
extern ApmProcessStreamResponseDefaultTypeInternal _ApmProcessStreamResponse_default_instance_;
class AudioFrameBufferInfo;
struct AudioFrameBufferInfoDefaultTypeInternal;
extern AudioFrameBufferInfoDefaultTypeInternal _AudioFrameBufferInfo_default_instance_;
class AudioFrameReceived;
struct AudioFrameReceivedDefaultTypeInternal;
extern AudioFrameReceivedDefaultTypeInternal _AudioFrameReceived_default_instance_;
class AudioResamplerInfo;
struct AudioResamplerInfoDefaultTypeInternal;
extern AudioResamplerInfoDefaultTypeInternal _AudioResamplerInfo_default_instance_;
class AudioSourceInfo;
struct AudioSourceInfoDefaultTypeInternal;
extern AudioSourceInfoDefaultTypeInternal _AudioSourceInfo_default_instance_;
class AudioSourceOptions;
struct AudioSourceOptionsDefaultTypeInternal;
extern AudioSourceOptionsDefaultTypeInternal _AudioSourceOptions_default_instance_;
class AudioStreamEOS;
struct AudioStreamEOSDefaultTypeInternal;
extern AudioStreamEOSDefaultTypeInternal _AudioStreamEOS_default_instance_;
class AudioStreamEvent;
struct AudioStreamEventDefaultTypeInternal;
extern AudioStreamEventDefaultTypeInternal _AudioStreamEvent_default_instance_;
class AudioStreamFromParticipantRequest;
struct AudioStreamFromParticipantRequestDefaultTypeInternal;
extern AudioStreamFromParticipantRequestDefaultTypeInternal _AudioStreamFromParticipantRequest_default_instance_;
class AudioStreamFromParticipantResponse;
struct AudioStreamFromParticipantResponseDefaultTypeInternal;
extern AudioStreamFromParticipantResponseDefaultTypeInternal _AudioStreamFromParticipantResponse_default_instance_;
class AudioStreamInfo;
struct AudioStreamInfoDefaultTypeInternal;
extern AudioStreamInfoDefaultTypeInternal _AudioStreamInfo_default_instance_;
class CaptureAudioFrameCallback;
struct CaptureAudioFrameCallbackDefaultTypeInternal;
extern CaptureAudioFrameCallbackDefaultTypeInternal _CaptureAudioFrameCallback_default_instance_;
class CaptureAudioFrameRequest;
struct CaptureAudioFrameRequestDefaultTypeInternal;
extern CaptureAudioFrameRequestDefaultTypeInternal _CaptureAudioFrameRequest_default_instance_;
class CaptureAudioFrameResponse;
struct CaptureAudioFrameResponseDefaultTypeInternal;
extern CaptureAudioFrameResponseDefaultTypeInternal _CaptureAudioFrameResponse_default_instance_;
class ClearAudioBufferRequest;
struct ClearAudioBufferRequestDefaultTypeInternal;
extern ClearAudioBufferRequestDefaultTypeInternal _ClearAudioBufferRequest_default_instance_;
class ClearAudioBufferResponse;
struct ClearAudioBufferResponseDefaultTypeInternal;
extern ClearAudioBufferResponseDefaultTypeInternal _ClearAudioBufferResponse_default_instance_;
class FlushSoxResamplerRequest;
struct FlushSoxResamplerRequestDefaultTypeInternal;
extern FlushSoxResamplerRequestDefaultTypeInternal _FlushSoxResamplerRequest_default_instance_;
class FlushSoxResamplerResponse;
struct FlushSoxResamplerResponseDefaultTypeInternal;
extern FlushSoxResamplerResponseDefaultTypeInternal _FlushSoxResamplerResponse_default_instance_;
class LoadAudioFilterPluginRequest;
struct LoadAudioFilterPluginRequestDefaultTypeInternal;
extern LoadAudioFilterPluginRequestDefaultTypeInternal _LoadAudioFilterPluginRequest_default_instance_;
class LoadAudioFilterPluginResponse;
struct LoadAudioFilterPluginResponseDefaultTypeInternal;
extern LoadAudioFilterPluginResponseDefaultTypeInternal _LoadAudioFilterPluginResponse_default_instance_;
class NewApmRequest;
struct NewApmRequestDefaultTypeInternal;
extern NewApmRequestDefaultTypeInternal _NewApmRequest_default_instance_;
class NewApmResponse;
struct NewApmResponseDefaultTypeInternal;
extern NewApmResponseDefaultTypeInternal _NewApmResponse_default_instance_;
class NewAudioResamplerRequest;
struct NewAudioResamplerRequestDefaultTypeInternal;
extern NewAudioResamplerRequestDefaultTypeInternal _NewAudioResamplerRequest_default_instance_;
class NewAudioResamplerResponse;
struct NewAudioResamplerResponseDefaultTypeInternal;
extern NewAudioResamplerResponseDefaultTypeInternal _NewAudioResamplerResponse_default_instance_;
class NewAudioSourceRequest;
struct NewAudioSourceRequestDefaultTypeInternal;
extern NewAudioSourceRequestDefaultTypeInternal _NewAudioSourceRequest_default_instance_;
class NewAudioSourceResponse;
struct NewAudioSourceResponseDefaultTypeInternal;
extern NewAudioSourceResponseDefaultTypeInternal _NewAudioSourceResponse_default_instance_;
class NewAudioStreamRequest;
struct NewAudioStreamRequestDefaultTypeInternal;
extern NewAudioStreamRequestDefaultTypeInternal _NewAudioStreamRequest_default_instance_;
class NewAudioStreamResponse;
struct NewAudioStreamResponseDefaultTypeInternal;
extern NewAudioStreamResponseDefaultTypeInternal _NewAudioStreamResponse_default_instance_;
class NewSoxResamplerRequest;
struct NewSoxResamplerRequestDefaultTypeInternal;
extern NewSoxResamplerRequestDefaultTypeInternal _NewSoxResamplerRequest_default_instance_;
class NewSoxResamplerResponse;
struct NewSoxResamplerResponseDefaultTypeInternal;
extern NewSoxResamplerResponseDefaultTypeInternal _NewSoxResamplerResponse_default_instance_;
class OwnedApm;
struct OwnedApmDefaultTypeInternal;
extern OwnedApmDefaultTypeInternal _OwnedApm_default_instance_;
class OwnedAudioFrameBuffer;
struct OwnedAudioFrameBufferDefaultTypeInternal;
extern OwnedAudioFrameBufferDefaultTypeInternal _OwnedAudioFrameBuffer_default_instance_;
class OwnedAudioResampler;
struct OwnedAudioResamplerDefaultTypeInternal;
extern OwnedAudioResamplerDefaultTypeInternal _OwnedAudioResampler_default_instance_;
class OwnedAudioSource;
struct OwnedAudioSourceDefaultTypeInternal;
extern OwnedAudioSourceDefaultTypeInternal _OwnedAudioSource_default_instance_;
class OwnedAudioStream;
struct OwnedAudioStreamDefaultTypeInternal;
extern OwnedAudioStreamDefaultTypeInternal _OwnedAudioStream_default_instance_;
class OwnedSoxResampler;
struct OwnedSoxResamplerDefaultTypeInternal;
extern OwnedSoxResamplerDefaultTypeInternal _OwnedSoxResampler_default_instance_;
class PushSoxResamplerRequest;
struct PushSoxResamplerRequestDefaultTypeInternal;
extern PushSoxResamplerRequestDefaultTypeInternal _PushSoxResamplerRequest_default_instance_;
class PushSoxResamplerResponse;
struct PushSoxResamplerResponseDefaultTypeInternal;
extern PushSoxResamplerResponseDefaultTypeInternal _PushSoxResamplerResponse_default_instance_;
class RemixAndResampleRequest;
struct RemixAndResampleRequestDefaultTypeInternal;
extern RemixAndResampleRequestDefaultTypeInternal _RemixAndResampleRequest_default_instance_;
class RemixAndResampleResponse;
struct RemixAndResampleResponseDefaultTypeInternal;
extern RemixAndResampleResponseDefaultTypeInternal _RemixAndResampleResponse_default_instance_;
class SoxResamplerInfo;
struct SoxResamplerInfoDefaultTypeInternal;
extern SoxResamplerInfoDefaultTypeInternal _SoxResamplerInfo_default_instance_;
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::proto::ApmProcessReverseStreamRequest* Arena::CreateMaybeMessage<::livekit::proto::ApmProcessReverseStreamRequest>(Arena*);
template<> ::livekit::proto::ApmProcessReverseStreamResponse* Arena::CreateMaybeMessage<::livekit::proto::ApmProcessReverseStreamResponse>(Arena*);
template<> ::livekit::proto::ApmProcessStreamRequest* Arena::CreateMaybeMessage<::livekit::proto::ApmProcessStreamRequest>(Arena*);
template<> ::livekit::proto::ApmProcessStreamResponse* Arena::CreateMaybeMessage<::livekit::proto::ApmProcessStreamResponse>(Arena*);
template<> ::livekit::proto::AudioFrameBufferInfo* Arena::CreateMaybeMessage<::livekit::proto::AudioFrameBufferInfo>(Arena*);
template<> ::livekit::proto::AudioFrameReceived* Arena::CreateMaybeMessage<::livekit::proto::AudioFrameReceived>(Arena*);
template<> ::livekit::proto::AudioResamplerInfo* Arena::CreateMaybeMessage<::livekit::proto::AudioResamplerInfo>(Arena*);
template<> ::livekit::proto::AudioSourceInfo* Arena::CreateMaybeMessage<::livekit::proto::AudioSourceInfo>(Arena*);
template<> ::livekit::proto::AudioSourceOptions* Arena::CreateMaybeMessage<::livekit::proto::AudioSourceOptions>(Arena*);
template<> ::livekit::proto::AudioStreamEOS* Arena::CreateMaybeMessage<::livekit::proto::AudioStreamEOS>(Arena*);
template<> ::livekit::proto::AudioStreamEvent* Arena::CreateMaybeMessage<::livekit::proto::AudioStreamEvent>(Arena*);
template<> ::livekit::proto::AudioStreamFromParticipantRequest* Arena::CreateMaybeMessage<::livekit::proto::AudioStreamFromParticipantRequest>(Arena*);
template<> ::livekit::proto::AudioStreamFromParticipantResponse* Arena::CreateMaybeMessage<::livekit::proto::AudioStreamFromParticipantResponse>(Arena*);
template<> ::livekit::proto::AudioStreamInfo* Arena::CreateMaybeMessage<::livekit::proto::AudioStreamInfo>(Arena*);
template<> ::livekit::proto::CaptureAudioFrameCallback* Arena::CreateMaybeMessage<::livekit::proto::CaptureAudioFrameCallback>(Arena*);
template<> ::livekit::proto::CaptureAudioFrameRequest* Arena::CreateMaybeMessage<::livekit::proto::CaptureAudioFrameRequest>(Arena*);
template<> ::livekit::proto::CaptureAudioFrameResponse* Arena::CreateMaybeMessage<::livekit::proto::CaptureAudioFrameResponse>(Arena*);
template<> ::livekit::proto::ClearAudioBufferRequest* Arena::CreateMaybeMessage<::livekit::proto::ClearAudioBufferRequest>(Arena*);
template<> ::livekit::proto::ClearAudioBufferResponse* Arena::CreateMaybeMessage<::livekit::proto::ClearAudioBufferResponse>(Arena*);
template<> ::livekit::proto::FlushSoxResamplerRequest* Arena::CreateMaybeMessage<::livekit::proto::FlushSoxResamplerRequest>(Arena*);
template<> ::livekit::proto::FlushSoxResamplerResponse* Arena::CreateMaybeMessage<::livekit::proto::FlushSoxResamplerResponse>(Arena*);
template<> ::livekit::proto::LoadAudioFilterPluginRequest* Arena::CreateMaybeMessage<::livekit::proto::LoadAudioFilterPluginRequest>(Arena*);
template<> ::livekit::proto::LoadAudioFilterPluginResponse* Arena::CreateMaybeMessage<::livekit::proto::LoadAudioFilterPluginResponse>(Arena*);
template<> ::livekit::proto::NewApmRequest* Arena::CreateMaybeMessage<::livekit::proto::NewApmRequest>(Arena*);
template<> ::livekit::proto::NewApmResponse* Arena::CreateMaybeMessage<::livekit::proto::NewApmResponse>(Arena*);
template<> ::livekit::proto::NewAudioResamplerRequest* Arena::CreateMaybeMessage<::livekit::proto::NewAudioResamplerRequest>(Arena*);
template<> ::livekit::proto::NewAudioResamplerResponse* Arena::CreateMaybeMessage<::livekit::proto::NewAudioResamplerResponse>(Arena*);
template<> ::livekit::proto::NewAudioSourceRequest* Arena::CreateMaybeMessage<::livekit::proto::NewAudioSourceRequest>(Arena*);
template<> ::livekit::proto::NewAudioSourceResponse* Arena::CreateMaybeMessage<::livekit::proto::NewAudioSourceResponse>(Arena*);
template<> ::livekit::proto::NewAudioStreamRequest* Arena::CreateMaybeMessage<::livekit::proto::NewAudioStreamRequest>(Arena*);
template<> ::livekit::proto::NewAudioStreamResponse* Arena::CreateMaybeMessage<::livekit::proto::NewAudioStreamResponse>(Arena*);
template<> ::livekit::proto::NewSoxResamplerRequest* Arena::CreateMaybeMessage<::livekit::proto::NewSoxResamplerRequest>(Arena*);
template<> ::livekit::proto::NewSoxResamplerResponse* Arena::CreateMaybeMessage<::livekit::proto::NewSoxResamplerResponse>(Arena*);
template<> ::livekit::proto::OwnedApm* Arena::CreateMaybeMessage<::livekit::proto::OwnedApm>(Arena*);
template<> ::livekit::proto::OwnedAudioFrameBuffer* Arena::CreateMaybeMessage<::livekit::proto::OwnedAudioFrameBuffer>(Arena*);
template<> ::livekit::proto::OwnedAudioResampler* Arena::CreateMaybeMessage<::livekit::proto::OwnedAudioResampler>(Arena*);
template<> ::livekit::proto::OwnedAudioSource* Arena::CreateMaybeMessage<::livekit::proto::OwnedAudioSource>(Arena*);
template<> ::livekit::proto::OwnedAudioStream* Arena::CreateMaybeMessage<::livekit::proto::OwnedAudioStream>(Arena*);
template<> ::livekit::proto::OwnedSoxResampler* Arena::CreateMaybeMessage<::livekit::proto::OwnedSoxResampler>(Arena*);
template<> ::livekit::proto::PushSoxResamplerRequest* Arena::CreateMaybeMessage<::livekit::proto::PushSoxResamplerRequest>(Arena*);
template<> ::livekit::proto::PushSoxResamplerResponse* Arena::CreateMaybeMessage<::livekit::proto::PushSoxResamplerResponse>(Arena*);
template<> ::livekit::proto::RemixAndResampleRequest* Arena::CreateMaybeMessage<::livekit::proto::RemixAndResampleRequest>(Arena*);
template<> ::livekit::proto::RemixAndResampleResponse* Arena::CreateMaybeMessage<::livekit::proto::RemixAndResampleResponse>(Arena*);
template<> ::livekit::proto::SoxResamplerInfo* Arena::CreateMaybeMessage<::livekit::proto::SoxResamplerInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {
namespace proto {

enum SoxResamplerDataType : int {
  SOXR_DATATYPE_INT16I = 0,
  SOXR_DATATYPE_INT16S = 1
};
bool SoxResamplerDataType_IsValid(int value);
constexpr SoxResamplerDataType SoxResamplerDataType_MIN = SOXR_DATATYPE_INT16I;
constexpr SoxResamplerDataType SoxResamplerDataType_MAX = SOXR_DATATYPE_INT16S;
constexpr int SoxResamplerDataType_ARRAYSIZE = SoxResamplerDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxResamplerDataType_descriptor();
template<typename T>
inline const std::string& SoxResamplerDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoxResamplerDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoxResamplerDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoxResamplerDataType_descriptor(), enum_t_value);
}
inline bool SoxResamplerDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoxResamplerDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoxResamplerDataType>(
    SoxResamplerDataType_descriptor(), name, value);
}
enum SoxQualityRecipe : int {
  SOXR_QUALITY_QUICK = 0,
  SOXR_QUALITY_LOW = 1,
  SOXR_QUALITY_MEDIUM = 2,
  SOXR_QUALITY_HIGH = 3,
  SOXR_QUALITY_VERYHIGH = 4
};
bool SoxQualityRecipe_IsValid(int value);
constexpr SoxQualityRecipe SoxQualityRecipe_MIN = SOXR_QUALITY_QUICK;
constexpr SoxQualityRecipe SoxQualityRecipe_MAX = SOXR_QUALITY_VERYHIGH;
constexpr int SoxQualityRecipe_ARRAYSIZE = SoxQualityRecipe_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxQualityRecipe_descriptor();
template<typename T>
inline const std::string& SoxQualityRecipe_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoxQualityRecipe>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoxQualityRecipe_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoxQualityRecipe_descriptor(), enum_t_value);
}
inline bool SoxQualityRecipe_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoxQualityRecipe* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoxQualityRecipe>(
    SoxQualityRecipe_descriptor(), name, value);
}
enum SoxFlagBits : int {
  SOXR_ROLLOFF_SMALL = 0,
  SOXR_ROLLOFF_MEDIUM = 1,
  SOXR_ROLLOFF_NONE = 2,
  SOXR_HIGH_PREC_CLOCK = 3,
  SOXR_DOUBLE_PRECISION = 4,
  SOXR_VR = 5
};
bool SoxFlagBits_IsValid(int value);
constexpr SoxFlagBits SoxFlagBits_MIN = SOXR_ROLLOFF_SMALL;
constexpr SoxFlagBits SoxFlagBits_MAX = SOXR_VR;
constexpr int SoxFlagBits_ARRAYSIZE = SoxFlagBits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SoxFlagBits_descriptor();
template<typename T>
inline const std::string& SoxFlagBits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SoxFlagBits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SoxFlagBits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SoxFlagBits_descriptor(), enum_t_value);
}
inline bool SoxFlagBits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SoxFlagBits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SoxFlagBits>(
    SoxFlagBits_descriptor(), name, value);
}
enum AudioStreamType : int {
  AUDIO_STREAM_NATIVE = 0,
  AUDIO_STREAM_HTML = 1
};
bool AudioStreamType_IsValid(int value);
constexpr AudioStreamType AudioStreamType_MIN = AUDIO_STREAM_NATIVE;
constexpr AudioStreamType AudioStreamType_MAX = AUDIO_STREAM_HTML;
constexpr int AudioStreamType_ARRAYSIZE = AudioStreamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioStreamType_descriptor();
template<typename T>
inline const std::string& AudioStreamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioStreamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioStreamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioStreamType_descriptor(), enum_t_value);
}
inline bool AudioStreamType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioStreamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioStreamType>(
    AudioStreamType_descriptor(), name, value);
}
enum AudioSourceType : int {
  AUDIO_SOURCE_NATIVE = 0
};
bool AudioSourceType_IsValid(int value);
constexpr AudioSourceType AudioSourceType_MIN = AUDIO_SOURCE_NATIVE;
constexpr AudioSourceType AudioSourceType_MAX = AUDIO_SOURCE_NATIVE;
constexpr int AudioSourceType_ARRAYSIZE = AudioSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioSourceType_descriptor();
template<typename T>
inline const std::string& AudioSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioSourceType_descriptor(), enum_t_value);
}
inline bool AudioSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioSourceType>(
    AudioSourceType_descriptor(), name, value);
}
// ===================================================================

class NewAudioStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioStreamRequest) */ {
 public:
  inline NewAudioStreamRequest() : NewAudioStreamRequest(nullptr) {}
  ~NewAudioStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR NewAudioStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioStreamRequest(const NewAudioStreamRequest& from);
  NewAudioStreamRequest(NewAudioStreamRequest&& from) noexcept
    : NewAudioStreamRequest() {
    *this = ::std::move(from);
  }

  inline NewAudioStreamRequest& operator=(const NewAudioStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioStreamRequest& operator=(NewAudioStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioStreamRequest* internal_default_instance() {
    return reinterpret_cast<const NewAudioStreamRequest*>(
               &_NewAudioStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NewAudioStreamRequest& a, NewAudioStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAudioStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAudioStreamRequest& from) {
    NewAudioStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAudioStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioStreamRequest";
  }
  protected:
  explicit NewAudioStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFilterModuleIdFieldNumber = 5,
    kAudioFilterOptionsFieldNumber = 6,
    kTrackHandleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kSampleRateFieldNumber = 3,
    kNumChannelsFieldNumber = 4,
  };
  // optional string audio_filter_module_id = 5;
  bool has_audio_filter_module_id() const;
  private:
  bool _internal_has_audio_filter_module_id() const;
  public:
  void clear_audio_filter_module_id();
  const std::string& audio_filter_module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_filter_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_filter_module_id();
  PROTOBUF_NODISCARD std::string* release_audio_filter_module_id();
  void set_allocated_audio_filter_module_id(std::string* audio_filter_module_id);
  private:
  const std::string& _internal_audio_filter_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_filter_module_id(const std::string& value);
  std::string* _internal_mutable_audio_filter_module_id();
  public:

  // optional string audio_filter_options = 6;
  bool has_audio_filter_options() const;
  private:
  bool _internal_has_audio_filter_options() const;
  public:
  void clear_audio_filter_options();
  const std::string& audio_filter_options() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_filter_options(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_filter_options();
  PROTOBUF_NODISCARD std::string* release_audio_filter_options();
  void set_allocated_audio_filter_options(std::string* audio_filter_options);
  private:
  const std::string& _internal_audio_filter_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_filter_options(const std::string& value);
  std::string* _internal_mutable_audio_filter_options();
  public:

  // required uint64 track_handle = 1;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // required .livekit.proto.AudioStreamType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::AudioStreamType type() const;
  void set_type(::livekit::proto::AudioStreamType value);
  private:
  ::livekit::proto::AudioStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::AudioStreamType value);
  public:

  // optional uint32 sample_rate = 3;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // optional uint32 num_channels = 4;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioStreamRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_filter_module_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_filter_options_;
    uint64_t track_handle_;
    int type_;
    uint32_t sample_rate_;
    uint32_t num_channels_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewAudioStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioStreamResponse) */ {
 public:
  inline NewAudioStreamResponse() : NewAudioStreamResponse(nullptr) {}
  ~NewAudioStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR NewAudioStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioStreamResponse(const NewAudioStreamResponse& from);
  NewAudioStreamResponse(NewAudioStreamResponse&& from) noexcept
    : NewAudioStreamResponse() {
    *this = ::std::move(from);
  }

  inline NewAudioStreamResponse& operator=(const NewAudioStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioStreamResponse& operator=(NewAudioStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioStreamResponse* internal_default_instance() {
    return reinterpret_cast<const NewAudioStreamResponse*>(
               &_NewAudioStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NewAudioStreamResponse& a, NewAudioStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAudioStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAudioStreamResponse& from) {
    NewAudioStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAudioStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioStreamResponse";
  }
  protected:
  explicit NewAudioStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::livekit::proto::OwnedAudioStream& stream() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioStream* release_stream();
  ::livekit::proto::OwnedAudioStream* mutable_stream();
  void set_allocated_stream(::livekit::proto::OwnedAudioStream* stream);
  private:
  const ::livekit::proto::OwnedAudioStream& _internal_stream() const;
  ::livekit::proto::OwnedAudioStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::livekit::proto::OwnedAudioStream* stream);
  ::livekit::proto::OwnedAudioStream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioStream* stream_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamFromParticipantRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioStreamFromParticipantRequest) */ {
 public:
  inline AudioStreamFromParticipantRequest() : AudioStreamFromParticipantRequest(nullptr) {}
  ~AudioStreamFromParticipantRequest() override;
  explicit PROTOBUF_CONSTEXPR AudioStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioStreamFromParticipantRequest(const AudioStreamFromParticipantRequest& from);
  AudioStreamFromParticipantRequest(AudioStreamFromParticipantRequest&& from) noexcept
    : AudioStreamFromParticipantRequest() {
    *this = ::std::move(from);
  }

  inline AudioStreamFromParticipantRequest& operator=(const AudioStreamFromParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamFromParticipantRequest& operator=(AudioStreamFromParticipantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioStreamFromParticipantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioStreamFromParticipantRequest* internal_default_instance() {
    return reinterpret_cast<const AudioStreamFromParticipantRequest*>(
               &_AudioStreamFromParticipantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AudioStreamFromParticipantRequest& a, AudioStreamFromParticipantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioStreamFromParticipantRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamFromParticipantRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioStreamFromParticipantRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioStreamFromParticipantRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioStreamFromParticipantRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioStreamFromParticipantRequest& from) {
    AudioStreamFromParticipantRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioStreamFromParticipantRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioStreamFromParticipantRequest";
  }
  protected:
  explicit AudioStreamFromParticipantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFilterModuleIdFieldNumber = 7,
    kAudioFilterOptionsFieldNumber = 8,
    kParticipantHandleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kTrackSourceFieldNumber = 3,
    kSampleRateFieldNumber = 5,
    kNumChannelsFieldNumber = 6,
  };
  // optional string audio_filter_module_id = 7;
  bool has_audio_filter_module_id() const;
  private:
  bool _internal_has_audio_filter_module_id() const;
  public:
  void clear_audio_filter_module_id();
  const std::string& audio_filter_module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_filter_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_filter_module_id();
  PROTOBUF_NODISCARD std::string* release_audio_filter_module_id();
  void set_allocated_audio_filter_module_id(std::string* audio_filter_module_id);
  private:
  const std::string& _internal_audio_filter_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_filter_module_id(const std::string& value);
  std::string* _internal_mutable_audio_filter_module_id();
  public:

  // optional string audio_filter_options = 8;
  bool has_audio_filter_options() const;
  private:
  bool _internal_has_audio_filter_options() const;
  public:
  void clear_audio_filter_options();
  const std::string& audio_filter_options() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_filter_options(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_filter_options();
  PROTOBUF_NODISCARD std::string* release_audio_filter_options();
  void set_allocated_audio_filter_options(std::string* audio_filter_options);
  private:
  const std::string& _internal_audio_filter_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_filter_options(const std::string& value);
  std::string* _internal_mutable_audio_filter_options();
  public:

  // required uint64 participant_handle = 1;
  bool has_participant_handle() const;
  private:
  bool _internal_has_participant_handle() const;
  public:
  void clear_participant_handle();
  uint64_t participant_handle() const;
  void set_participant_handle(uint64_t value);
  private:
  uint64_t _internal_participant_handle() const;
  void _internal_set_participant_handle(uint64_t value);
  public:

  // required .livekit.proto.AudioStreamType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::AudioStreamType type() const;
  void set_type(::livekit::proto::AudioStreamType value);
  private:
  ::livekit::proto::AudioStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::AudioStreamType value);
  public:

  // optional .livekit.proto.TrackSource track_source = 3;
  bool has_track_source() const;
  private:
  bool _internal_has_track_source() const;
  public:
  void clear_track_source();
  ::livekit::proto::TrackSource track_source() const;
  void set_track_source(::livekit::proto::TrackSource value);
  private:
  ::livekit::proto::TrackSource _internal_track_source() const;
  void _internal_set_track_source(::livekit::proto::TrackSource value);
  public:

  // optional uint32 sample_rate = 5;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // optional uint32 num_channels = 6;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioStreamFromParticipantRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_filter_module_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_filter_options_;
    uint64_t participant_handle_;
    int type_;
    int track_source_;
    uint32_t sample_rate_;
    uint32_t num_channels_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamFromParticipantResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioStreamFromParticipantResponse) */ {
 public:
  inline AudioStreamFromParticipantResponse() : AudioStreamFromParticipantResponse(nullptr) {}
  ~AudioStreamFromParticipantResponse() override;
  explicit PROTOBUF_CONSTEXPR AudioStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioStreamFromParticipantResponse(const AudioStreamFromParticipantResponse& from);
  AudioStreamFromParticipantResponse(AudioStreamFromParticipantResponse&& from) noexcept
    : AudioStreamFromParticipantResponse() {
    *this = ::std::move(from);
  }

  inline AudioStreamFromParticipantResponse& operator=(const AudioStreamFromParticipantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamFromParticipantResponse& operator=(AudioStreamFromParticipantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioStreamFromParticipantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioStreamFromParticipantResponse* internal_default_instance() {
    return reinterpret_cast<const AudioStreamFromParticipantResponse*>(
               &_AudioStreamFromParticipantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AudioStreamFromParticipantResponse& a, AudioStreamFromParticipantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioStreamFromParticipantResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamFromParticipantResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioStreamFromParticipantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioStreamFromParticipantResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioStreamFromParticipantResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioStreamFromParticipantResponse& from) {
    AudioStreamFromParticipantResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioStreamFromParticipantResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioStreamFromParticipantResponse";
  }
  protected:
  explicit AudioStreamFromParticipantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioStream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::livekit::proto::OwnedAudioStream& stream() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioStream* release_stream();
  ::livekit::proto::OwnedAudioStream* mutable_stream();
  void set_allocated_stream(::livekit::proto::OwnedAudioStream* stream);
  private:
  const ::livekit::proto::OwnedAudioStream& _internal_stream() const;
  ::livekit::proto::OwnedAudioStream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::livekit::proto::OwnedAudioStream* stream);
  ::livekit::proto::OwnedAudioStream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioStreamFromParticipantResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioStream* stream_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewAudioSourceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioSourceRequest) */ {
 public:
  inline NewAudioSourceRequest() : NewAudioSourceRequest(nullptr) {}
  ~NewAudioSourceRequest() override;
  explicit PROTOBUF_CONSTEXPR NewAudioSourceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioSourceRequest(const NewAudioSourceRequest& from);
  NewAudioSourceRequest(NewAudioSourceRequest&& from) noexcept
    : NewAudioSourceRequest() {
    *this = ::std::move(from);
  }

  inline NewAudioSourceRequest& operator=(const NewAudioSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioSourceRequest& operator=(NewAudioSourceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioSourceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioSourceRequest* internal_default_instance() {
    return reinterpret_cast<const NewAudioSourceRequest*>(
               &_NewAudioSourceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewAudioSourceRequest& a, NewAudioSourceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioSourceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioSourceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioSourceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioSourceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAudioSourceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAudioSourceRequest& from) {
    NewAudioSourceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAudioSourceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioSourceRequest";
  }
  protected:
  explicit NewAudioSourceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSampleRateFieldNumber = 3,
    kNumChannelsFieldNumber = 4,
    kQueueSizeMsFieldNumber = 5,
  };
  // optional .livekit.proto.AudioSourceOptions options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::livekit::proto::AudioSourceOptions& options() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioSourceOptions* release_options();
  ::livekit::proto::AudioSourceOptions* mutable_options();
  void set_allocated_options(::livekit::proto::AudioSourceOptions* options);
  private:
  const ::livekit::proto::AudioSourceOptions& _internal_options() const;
  ::livekit::proto::AudioSourceOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::livekit::proto::AudioSourceOptions* options);
  ::livekit::proto::AudioSourceOptions* unsafe_arena_release_options();

  // required .livekit.proto.AudioSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::AudioSourceType type() const;
  void set_type(::livekit::proto::AudioSourceType value);
  private:
  ::livekit::proto::AudioSourceType _internal_type() const;
  void _internal_set_type(::livekit::proto::AudioSourceType value);
  public:

  // required uint32 sample_rate = 3;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // required uint32 num_channels = 4;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // optional uint32 queue_size_ms = 5;
  bool has_queue_size_ms() const;
  private:
  bool _internal_has_queue_size_ms() const;
  public:
  void clear_queue_size_ms();
  uint32_t queue_size_ms() const;
  void set_queue_size_ms(uint32_t value);
  private:
  uint32_t _internal_queue_size_ms() const;
  void _internal_set_queue_size_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioSourceRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::AudioSourceOptions* options_;
    int type_;
    uint32_t sample_rate_;
    uint32_t num_channels_;
    uint32_t queue_size_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewAudioSourceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioSourceResponse) */ {
 public:
  inline NewAudioSourceResponse() : NewAudioSourceResponse(nullptr) {}
  ~NewAudioSourceResponse() override;
  explicit PROTOBUF_CONSTEXPR NewAudioSourceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioSourceResponse(const NewAudioSourceResponse& from);
  NewAudioSourceResponse(NewAudioSourceResponse&& from) noexcept
    : NewAudioSourceResponse() {
    *this = ::std::move(from);
  }

  inline NewAudioSourceResponse& operator=(const NewAudioSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioSourceResponse& operator=(NewAudioSourceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioSourceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioSourceResponse* internal_default_instance() {
    return reinterpret_cast<const NewAudioSourceResponse*>(
               &_NewAudioSourceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewAudioSourceResponse& a, NewAudioSourceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioSourceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioSourceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioSourceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioSourceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAudioSourceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAudioSourceResponse& from) {
    NewAudioSourceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAudioSourceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioSourceResponse";
  }
  protected:
  explicit NewAudioSourceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioSource source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::livekit::proto::OwnedAudioSource& source() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioSource* release_source();
  ::livekit::proto::OwnedAudioSource* mutable_source();
  void set_allocated_source(::livekit::proto::OwnedAudioSource* source);
  private:
  const ::livekit::proto::OwnedAudioSource& _internal_source() const;
  ::livekit::proto::OwnedAudioSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::livekit::proto::OwnedAudioSource* source);
  ::livekit::proto::OwnedAudioSource* unsafe_arena_release_source();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioSourceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioSource* source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class CaptureAudioFrameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CaptureAudioFrameRequest) */ {
 public:
  inline CaptureAudioFrameRequest() : CaptureAudioFrameRequest(nullptr) {}
  ~CaptureAudioFrameRequest() override;
  explicit PROTOBUF_CONSTEXPR CaptureAudioFrameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureAudioFrameRequest(const CaptureAudioFrameRequest& from);
  CaptureAudioFrameRequest(CaptureAudioFrameRequest&& from) noexcept
    : CaptureAudioFrameRequest() {
    *this = ::std::move(from);
  }

  inline CaptureAudioFrameRequest& operator=(const CaptureAudioFrameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureAudioFrameRequest& operator=(CaptureAudioFrameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureAudioFrameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureAudioFrameRequest* internal_default_instance() {
    return reinterpret_cast<const CaptureAudioFrameRequest*>(
               &_CaptureAudioFrameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CaptureAudioFrameRequest& a, CaptureAudioFrameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureAudioFrameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureAudioFrameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureAudioFrameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureAudioFrameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureAudioFrameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureAudioFrameRequest& from) {
    CaptureAudioFrameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureAudioFrameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CaptureAudioFrameRequest";
  }
  protected:
  explicit CaptureAudioFrameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kSourceHandleFieldNumber = 1,
  };
  // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::AudioFrameBufferInfo& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioFrameBufferInfo* release_buffer();
  ::livekit::proto::AudioFrameBufferInfo* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::AudioFrameBufferInfo* buffer);
  private:
  const ::livekit::proto::AudioFrameBufferInfo& _internal_buffer() const;
  ::livekit::proto::AudioFrameBufferInfo* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::AudioFrameBufferInfo* buffer);
  ::livekit::proto::AudioFrameBufferInfo* unsafe_arena_release_buffer();

  // required uint64 source_handle = 1;
  bool has_source_handle() const;
  private:
  bool _internal_has_source_handle() const;
  public:
  void clear_source_handle();
  uint64_t source_handle() const;
  void set_source_handle(uint64_t value);
  private:
  uint64_t _internal_source_handle() const;
  void _internal_set_source_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CaptureAudioFrameRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::AudioFrameBufferInfo* buffer_;
    uint64_t source_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class CaptureAudioFrameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CaptureAudioFrameResponse) */ {
 public:
  inline CaptureAudioFrameResponse() : CaptureAudioFrameResponse(nullptr) {}
  ~CaptureAudioFrameResponse() override;
  explicit PROTOBUF_CONSTEXPR CaptureAudioFrameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureAudioFrameResponse(const CaptureAudioFrameResponse& from);
  CaptureAudioFrameResponse(CaptureAudioFrameResponse&& from) noexcept
    : CaptureAudioFrameResponse() {
    *this = ::std::move(from);
  }

  inline CaptureAudioFrameResponse& operator=(const CaptureAudioFrameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureAudioFrameResponse& operator=(CaptureAudioFrameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureAudioFrameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureAudioFrameResponse* internal_default_instance() {
    return reinterpret_cast<const CaptureAudioFrameResponse*>(
               &_CaptureAudioFrameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CaptureAudioFrameResponse& a, CaptureAudioFrameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureAudioFrameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureAudioFrameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureAudioFrameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureAudioFrameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureAudioFrameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureAudioFrameResponse& from) {
    CaptureAudioFrameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureAudioFrameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CaptureAudioFrameResponse";
  }
  protected:
  explicit CaptureAudioFrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CaptureAudioFrameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class CaptureAudioFrameCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.CaptureAudioFrameCallback) */ {
 public:
  inline CaptureAudioFrameCallback() : CaptureAudioFrameCallback(nullptr) {}
  ~CaptureAudioFrameCallback() override;
  explicit PROTOBUF_CONSTEXPR CaptureAudioFrameCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureAudioFrameCallback(const CaptureAudioFrameCallback& from);
  CaptureAudioFrameCallback(CaptureAudioFrameCallback&& from) noexcept
    : CaptureAudioFrameCallback() {
    *this = ::std::move(from);
  }

  inline CaptureAudioFrameCallback& operator=(const CaptureAudioFrameCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureAudioFrameCallback& operator=(CaptureAudioFrameCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureAudioFrameCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureAudioFrameCallback* internal_default_instance() {
    return reinterpret_cast<const CaptureAudioFrameCallback*>(
               &_CaptureAudioFrameCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CaptureAudioFrameCallback& a, CaptureAudioFrameCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureAudioFrameCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureAudioFrameCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureAudioFrameCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureAudioFrameCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureAudioFrameCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureAudioFrameCallback& from) {
    CaptureAudioFrameCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureAudioFrameCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.CaptureAudioFrameCallback";
  }
  protected:
  explicit CaptureAudioFrameCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.CaptureAudioFrameCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ClearAudioBufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ClearAudioBufferRequest) */ {
 public:
  inline ClearAudioBufferRequest() : ClearAudioBufferRequest(nullptr) {}
  ~ClearAudioBufferRequest() override;
  explicit PROTOBUF_CONSTEXPR ClearAudioBufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAudioBufferRequest(const ClearAudioBufferRequest& from);
  ClearAudioBufferRequest(ClearAudioBufferRequest&& from) noexcept
    : ClearAudioBufferRequest() {
    *this = ::std::move(from);
  }

  inline ClearAudioBufferRequest& operator=(const ClearAudioBufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAudioBufferRequest& operator=(ClearAudioBufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAudioBufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAudioBufferRequest* internal_default_instance() {
    return reinterpret_cast<const ClearAudioBufferRequest*>(
               &_ClearAudioBufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClearAudioBufferRequest& a, ClearAudioBufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAudioBufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAudioBufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAudioBufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAudioBufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClearAudioBufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClearAudioBufferRequest& from) {
    ClearAudioBufferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAudioBufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ClearAudioBufferRequest";
  }
  protected:
  explicit ClearAudioBufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceHandleFieldNumber = 1,
  };
  // required uint64 source_handle = 1;
  bool has_source_handle() const;
  private:
  bool _internal_has_source_handle() const;
  public:
  void clear_source_handle();
  uint64_t source_handle() const;
  void set_source_handle(uint64_t value);
  private:
  uint64_t _internal_source_handle() const;
  void _internal_set_source_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ClearAudioBufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t source_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ClearAudioBufferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.ClearAudioBufferResponse) */ {
 public:
  inline ClearAudioBufferResponse() : ClearAudioBufferResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ClearAudioBufferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearAudioBufferResponse(const ClearAudioBufferResponse& from);
  ClearAudioBufferResponse(ClearAudioBufferResponse&& from) noexcept
    : ClearAudioBufferResponse() {
    *this = ::std::move(from);
  }

  inline ClearAudioBufferResponse& operator=(const ClearAudioBufferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAudioBufferResponse& operator=(ClearAudioBufferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearAudioBufferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearAudioBufferResponse* internal_default_instance() {
    return reinterpret_cast<const ClearAudioBufferResponse*>(
               &_ClearAudioBufferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ClearAudioBufferResponse& a, ClearAudioBufferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAudioBufferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAudioBufferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearAudioBufferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearAudioBufferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClearAudioBufferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClearAudioBufferResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ClearAudioBufferResponse";
  }
  protected:
  explicit ClearAudioBufferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.ClearAudioBufferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewAudioResamplerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioResamplerRequest) */ {
 public:
  inline NewAudioResamplerRequest() : NewAudioResamplerRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NewAudioResamplerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioResamplerRequest(const NewAudioResamplerRequest& from);
  NewAudioResamplerRequest(NewAudioResamplerRequest&& from) noexcept
    : NewAudioResamplerRequest() {
    *this = ::std::move(from);
  }

  inline NewAudioResamplerRequest& operator=(const NewAudioResamplerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioResamplerRequest& operator=(NewAudioResamplerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioResamplerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioResamplerRequest* internal_default_instance() {
    return reinterpret_cast<const NewAudioResamplerRequest*>(
               &_NewAudioResamplerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NewAudioResamplerRequest& a, NewAudioResamplerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioResamplerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioResamplerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioResamplerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioResamplerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NewAudioResamplerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NewAudioResamplerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioResamplerRequest";
  }
  protected:
  explicit NewAudioResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioResamplerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewAudioResamplerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewAudioResamplerResponse) */ {
 public:
  inline NewAudioResamplerResponse() : NewAudioResamplerResponse(nullptr) {}
  ~NewAudioResamplerResponse() override;
  explicit PROTOBUF_CONSTEXPR NewAudioResamplerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewAudioResamplerResponse(const NewAudioResamplerResponse& from);
  NewAudioResamplerResponse(NewAudioResamplerResponse&& from) noexcept
    : NewAudioResamplerResponse() {
    *this = ::std::move(from);
  }

  inline NewAudioResamplerResponse& operator=(const NewAudioResamplerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAudioResamplerResponse& operator=(NewAudioResamplerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAudioResamplerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAudioResamplerResponse* internal_default_instance() {
    return reinterpret_cast<const NewAudioResamplerResponse*>(
               &_NewAudioResamplerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NewAudioResamplerResponse& a, NewAudioResamplerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAudioResamplerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAudioResamplerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAudioResamplerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAudioResamplerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewAudioResamplerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewAudioResamplerResponse& from) {
    NewAudioResamplerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewAudioResamplerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewAudioResamplerResponse";
  }
  protected:
  explicit NewAudioResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResamplerFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioResampler resampler = 1;
  bool has_resampler() const;
  private:
  bool _internal_has_resampler() const;
  public:
  void clear_resampler();
  const ::livekit::proto::OwnedAudioResampler& resampler() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioResampler* release_resampler();
  ::livekit::proto::OwnedAudioResampler* mutable_resampler();
  void set_allocated_resampler(::livekit::proto::OwnedAudioResampler* resampler);
  private:
  const ::livekit::proto::OwnedAudioResampler& _internal_resampler() const;
  ::livekit::proto::OwnedAudioResampler* _internal_mutable_resampler();
  public:
  void unsafe_arena_set_allocated_resampler(
      ::livekit::proto::OwnedAudioResampler* resampler);
  ::livekit::proto::OwnedAudioResampler* unsafe_arena_release_resampler();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewAudioResamplerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioResampler* resampler_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class RemixAndResampleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RemixAndResampleRequest) */ {
 public:
  inline RemixAndResampleRequest() : RemixAndResampleRequest(nullptr) {}
  ~RemixAndResampleRequest() override;
  explicit PROTOBUF_CONSTEXPR RemixAndResampleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemixAndResampleRequest(const RemixAndResampleRequest& from);
  RemixAndResampleRequest(RemixAndResampleRequest&& from) noexcept
    : RemixAndResampleRequest() {
    *this = ::std::move(from);
  }

  inline RemixAndResampleRequest& operator=(const RemixAndResampleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemixAndResampleRequest& operator=(RemixAndResampleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemixAndResampleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemixAndResampleRequest* internal_default_instance() {
    return reinterpret_cast<const RemixAndResampleRequest*>(
               &_RemixAndResampleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RemixAndResampleRequest& a, RemixAndResampleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemixAndResampleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemixAndResampleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemixAndResampleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemixAndResampleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemixAndResampleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemixAndResampleRequest& from) {
    RemixAndResampleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemixAndResampleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RemixAndResampleRequest";
  }
  protected:
  explicit RemixAndResampleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kResamplerHandleFieldNumber = 1,
    kNumChannelsFieldNumber = 3,
    kSampleRateFieldNumber = 4,
  };
  // required .livekit.proto.AudioFrameBufferInfo buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::AudioFrameBufferInfo& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioFrameBufferInfo* release_buffer();
  ::livekit::proto::AudioFrameBufferInfo* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::AudioFrameBufferInfo* buffer);
  private:
  const ::livekit::proto::AudioFrameBufferInfo& _internal_buffer() const;
  ::livekit::proto::AudioFrameBufferInfo* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::AudioFrameBufferInfo* buffer);
  ::livekit::proto::AudioFrameBufferInfo* unsafe_arena_release_buffer();

  // required uint64 resampler_handle = 1;
  bool has_resampler_handle() const;
  private:
  bool _internal_has_resampler_handle() const;
  public:
  void clear_resampler_handle();
  uint64_t resampler_handle() const;
  void set_resampler_handle(uint64_t value);
  private:
  uint64_t _internal_resampler_handle() const;
  void _internal_set_resampler_handle(uint64_t value);
  public:

  // required uint32 num_channels = 3;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // required uint32 sample_rate = 4;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RemixAndResampleRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::AudioFrameBufferInfo* buffer_;
    uint64_t resampler_handle_;
    uint32_t num_channels_;
    uint32_t sample_rate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class RemixAndResampleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RemixAndResampleResponse) */ {
 public:
  inline RemixAndResampleResponse() : RemixAndResampleResponse(nullptr) {}
  ~RemixAndResampleResponse() override;
  explicit PROTOBUF_CONSTEXPR RemixAndResampleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemixAndResampleResponse(const RemixAndResampleResponse& from);
  RemixAndResampleResponse(RemixAndResampleResponse&& from) noexcept
    : RemixAndResampleResponse() {
    *this = ::std::move(from);
  }

  inline RemixAndResampleResponse& operator=(const RemixAndResampleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemixAndResampleResponse& operator=(RemixAndResampleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemixAndResampleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemixAndResampleResponse* internal_default_instance() {
    return reinterpret_cast<const RemixAndResampleResponse*>(
               &_RemixAndResampleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RemixAndResampleResponse& a, RemixAndResampleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemixAndResampleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemixAndResampleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemixAndResampleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemixAndResampleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemixAndResampleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemixAndResampleResponse& from) {
    RemixAndResampleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemixAndResampleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RemixAndResampleResponse";
  }
  protected:
  explicit RemixAndResampleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioFrameBuffer buffer = 1;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const ::livekit::proto::OwnedAudioFrameBuffer& buffer() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioFrameBuffer* release_buffer();
  ::livekit::proto::OwnedAudioFrameBuffer* mutable_buffer();
  void set_allocated_buffer(::livekit::proto::OwnedAudioFrameBuffer* buffer);
  private:
  const ::livekit::proto::OwnedAudioFrameBuffer& _internal_buffer() const;
  ::livekit::proto::OwnedAudioFrameBuffer* _internal_mutable_buffer();
  public:
  void unsafe_arena_set_allocated_buffer(
      ::livekit::proto::OwnedAudioFrameBuffer* buffer);
  ::livekit::proto::OwnedAudioFrameBuffer* unsafe_arena_release_buffer();

  // @@protoc_insertion_point(class_scope:livekit.proto.RemixAndResampleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioFrameBuffer* buffer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewApmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewApmRequest) */ {
 public:
  inline NewApmRequest() : NewApmRequest(nullptr) {}
  ~NewApmRequest() override;
  explicit PROTOBUF_CONSTEXPR NewApmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewApmRequest(const NewApmRequest& from);
  NewApmRequest(NewApmRequest&& from) noexcept
    : NewApmRequest() {
    *this = ::std::move(from);
  }

  inline NewApmRequest& operator=(const NewApmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewApmRequest& operator=(NewApmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewApmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewApmRequest* internal_default_instance() {
    return reinterpret_cast<const NewApmRequest*>(
               &_NewApmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NewApmRequest& a, NewApmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewApmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewApmRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewApmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewApmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewApmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewApmRequest& from) {
    NewApmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewApmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewApmRequest";
  }
  protected:
  explicit NewApmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEchoCancellerEnabledFieldNumber = 1,
    kGainControllerEnabledFieldNumber = 2,
    kHighPassFilterEnabledFieldNumber = 3,
    kNoiseSuppressionEnabledFieldNumber = 4,
  };
  // required bool echo_canceller_enabled = 1;
  bool has_echo_canceller_enabled() const;
  private:
  bool _internal_has_echo_canceller_enabled() const;
  public:
  void clear_echo_canceller_enabled();
  bool echo_canceller_enabled() const;
  void set_echo_canceller_enabled(bool value);
  private:
  bool _internal_echo_canceller_enabled() const;
  void _internal_set_echo_canceller_enabled(bool value);
  public:

  // required bool gain_controller_enabled = 2;
  bool has_gain_controller_enabled() const;
  private:
  bool _internal_has_gain_controller_enabled() const;
  public:
  void clear_gain_controller_enabled();
  bool gain_controller_enabled() const;
  void set_gain_controller_enabled(bool value);
  private:
  bool _internal_gain_controller_enabled() const;
  void _internal_set_gain_controller_enabled(bool value);
  public:

  // required bool high_pass_filter_enabled = 3;
  bool has_high_pass_filter_enabled() const;
  private:
  bool _internal_has_high_pass_filter_enabled() const;
  public:
  void clear_high_pass_filter_enabled();
  bool high_pass_filter_enabled() const;
  void set_high_pass_filter_enabled(bool value);
  private:
  bool _internal_high_pass_filter_enabled() const;
  void _internal_set_high_pass_filter_enabled(bool value);
  public:

  // required bool noise_suppression_enabled = 4;
  bool has_noise_suppression_enabled() const;
  private:
  bool _internal_has_noise_suppression_enabled() const;
  public:
  void clear_noise_suppression_enabled();
  bool noise_suppression_enabled() const;
  void set_noise_suppression_enabled(bool value);
  private:
  bool _internal_noise_suppression_enabled() const;
  void _internal_set_noise_suppression_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewApmRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool echo_canceller_enabled_;
    bool gain_controller_enabled_;
    bool high_pass_filter_enabled_;
    bool noise_suppression_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewApmResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewApmResponse) */ {
 public:
  inline NewApmResponse() : NewApmResponse(nullptr) {}
  ~NewApmResponse() override;
  explicit PROTOBUF_CONSTEXPR NewApmResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewApmResponse(const NewApmResponse& from);
  NewApmResponse(NewApmResponse&& from) noexcept
    : NewApmResponse() {
    *this = ::std::move(from);
  }

  inline NewApmResponse& operator=(const NewApmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewApmResponse& operator=(NewApmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewApmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewApmResponse* internal_default_instance() {
    return reinterpret_cast<const NewApmResponse*>(
               &_NewApmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NewApmResponse& a, NewApmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewApmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewApmResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewApmResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewApmResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewApmResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewApmResponse& from) {
    NewApmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewApmResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewApmResponse";
  }
  protected:
  explicit NewApmResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApmFieldNumber = 1,
  };
  // required .livekit.proto.OwnedApm apm = 1;
  bool has_apm() const;
  private:
  bool _internal_has_apm() const;
  public:
  void clear_apm();
  const ::livekit::proto::OwnedApm& apm() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedApm* release_apm();
  ::livekit::proto::OwnedApm* mutable_apm();
  void set_allocated_apm(::livekit::proto::OwnedApm* apm);
  private:
  const ::livekit::proto::OwnedApm& _internal_apm() const;
  ::livekit::proto::OwnedApm* _internal_mutable_apm();
  public:
  void unsafe_arena_set_allocated_apm(
      ::livekit::proto::OwnedApm* apm);
  ::livekit::proto::OwnedApm* unsafe_arena_release_apm();

  // @@protoc_insertion_point(class_scope:livekit.proto.NewApmResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedApm* apm_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ApmProcessStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ApmProcessStreamRequest) */ {
 public:
  inline ApmProcessStreamRequest() : ApmProcessStreamRequest(nullptr) {}
  ~ApmProcessStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR ApmProcessStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApmProcessStreamRequest(const ApmProcessStreamRequest& from);
  ApmProcessStreamRequest(ApmProcessStreamRequest&& from) noexcept
    : ApmProcessStreamRequest() {
    *this = ::std::move(from);
  }

  inline ApmProcessStreamRequest& operator=(const ApmProcessStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApmProcessStreamRequest& operator=(ApmProcessStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApmProcessStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApmProcessStreamRequest* internal_default_instance() {
    return reinterpret_cast<const ApmProcessStreamRequest*>(
               &_ApmProcessStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ApmProcessStreamRequest& a, ApmProcessStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApmProcessStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApmProcessStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApmProcessStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApmProcessStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApmProcessStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApmProcessStreamRequest& from) {
    ApmProcessStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApmProcessStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ApmProcessStreamRequest";
  }
  protected:
  explicit ApmProcessStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApmHandleFieldNumber = 1,
    kDataPtrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kSampleRateFieldNumber = 4,
    kNumChannelsFieldNumber = 5,
  };
  // required uint64 apm_handle = 1;
  bool has_apm_handle() const;
  private:
  bool _internal_has_apm_handle() const;
  public:
  void clear_apm_handle();
  uint64_t apm_handle() const;
  void set_apm_handle(uint64_t value);
  private:
  uint64_t _internal_apm_handle() const;
  void _internal_set_apm_handle(uint64_t value);
  public:

  // required uint64 data_ptr = 2;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // required uint32 sample_rate = 4;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // required uint32 num_channels = 5;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ApmProcessStreamRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t apm_handle_;
    uint64_t data_ptr_;
    uint32_t size_;
    uint32_t sample_rate_;
    uint32_t num_channels_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ApmProcessStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ApmProcessStreamResponse) */ {
 public:
  inline ApmProcessStreamResponse() : ApmProcessStreamResponse(nullptr) {}
  ~ApmProcessStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR ApmProcessStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApmProcessStreamResponse(const ApmProcessStreamResponse& from);
  ApmProcessStreamResponse(ApmProcessStreamResponse&& from) noexcept
    : ApmProcessStreamResponse() {
    *this = ::std::move(from);
  }

  inline ApmProcessStreamResponse& operator=(const ApmProcessStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApmProcessStreamResponse& operator=(ApmProcessStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApmProcessStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApmProcessStreamResponse* internal_default_instance() {
    return reinterpret_cast<const ApmProcessStreamResponse*>(
               &_ApmProcessStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ApmProcessStreamResponse& a, ApmProcessStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApmProcessStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApmProcessStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApmProcessStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApmProcessStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApmProcessStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApmProcessStreamResponse& from) {
    ApmProcessStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApmProcessStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ApmProcessStreamResponse";
  }
  protected:
  explicit ApmProcessStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ApmProcessStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ApmProcessReverseStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ApmProcessReverseStreamRequest) */ {
 public:
  inline ApmProcessReverseStreamRequest() : ApmProcessReverseStreamRequest(nullptr) {}
  ~ApmProcessReverseStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR ApmProcessReverseStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApmProcessReverseStreamRequest(const ApmProcessReverseStreamRequest& from);
  ApmProcessReverseStreamRequest(ApmProcessReverseStreamRequest&& from) noexcept
    : ApmProcessReverseStreamRequest() {
    *this = ::std::move(from);
  }

  inline ApmProcessReverseStreamRequest& operator=(const ApmProcessReverseStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApmProcessReverseStreamRequest& operator=(ApmProcessReverseStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApmProcessReverseStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApmProcessReverseStreamRequest* internal_default_instance() {
    return reinterpret_cast<const ApmProcessReverseStreamRequest*>(
               &_ApmProcessReverseStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ApmProcessReverseStreamRequest& a, ApmProcessReverseStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApmProcessReverseStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApmProcessReverseStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApmProcessReverseStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApmProcessReverseStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApmProcessReverseStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApmProcessReverseStreamRequest& from) {
    ApmProcessReverseStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApmProcessReverseStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ApmProcessReverseStreamRequest";
  }
  protected:
  explicit ApmProcessReverseStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApmHandleFieldNumber = 1,
    kDataPtrFieldNumber = 2,
    kSizeFieldNumber = 3,
    kSampleRateFieldNumber = 4,
    kNumChannelsFieldNumber = 5,
  };
  // required uint64 apm_handle = 1;
  bool has_apm_handle() const;
  private:
  bool _internal_has_apm_handle() const;
  public:
  void clear_apm_handle();
  uint64_t apm_handle() const;
  void set_apm_handle(uint64_t value);
  private:
  uint64_t _internal_apm_handle() const;
  void _internal_set_apm_handle(uint64_t value);
  public:

  // required uint64 data_ptr = 2;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // required uint32 sample_rate = 4;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // required uint32 num_channels = 5;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ApmProcessReverseStreamRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t apm_handle_;
    uint64_t data_ptr_;
    uint32_t size_;
    uint32_t sample_rate_;
    uint32_t num_channels_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class ApmProcessReverseStreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ApmProcessReverseStreamResponse) */ {
 public:
  inline ApmProcessReverseStreamResponse() : ApmProcessReverseStreamResponse(nullptr) {}
  ~ApmProcessReverseStreamResponse() override;
  explicit PROTOBUF_CONSTEXPR ApmProcessReverseStreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApmProcessReverseStreamResponse(const ApmProcessReverseStreamResponse& from);
  ApmProcessReverseStreamResponse(ApmProcessReverseStreamResponse&& from) noexcept
    : ApmProcessReverseStreamResponse() {
    *this = ::std::move(from);
  }

  inline ApmProcessReverseStreamResponse& operator=(const ApmProcessReverseStreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApmProcessReverseStreamResponse& operator=(ApmProcessReverseStreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApmProcessReverseStreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApmProcessReverseStreamResponse* internal_default_instance() {
    return reinterpret_cast<const ApmProcessReverseStreamResponse*>(
               &_ApmProcessReverseStreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ApmProcessReverseStreamResponse& a, ApmProcessReverseStreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ApmProcessReverseStreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApmProcessReverseStreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApmProcessReverseStreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApmProcessReverseStreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApmProcessReverseStreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ApmProcessReverseStreamResponse& from) {
    ApmProcessReverseStreamResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApmProcessReverseStreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ApmProcessReverseStreamResponse";
  }
  protected:
  explicit ApmProcessReverseStreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ApmProcessReverseStreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewSoxResamplerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewSoxResamplerRequest) */ {
 public:
  inline NewSoxResamplerRequest() : NewSoxResamplerRequest(nullptr) {}
  ~NewSoxResamplerRequest() override;
  explicit PROTOBUF_CONSTEXPR NewSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewSoxResamplerRequest(const NewSoxResamplerRequest& from);
  NewSoxResamplerRequest(NewSoxResamplerRequest&& from) noexcept
    : NewSoxResamplerRequest() {
    *this = ::std::move(from);
  }

  inline NewSoxResamplerRequest& operator=(const NewSoxResamplerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSoxResamplerRequest& operator=(NewSoxResamplerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSoxResamplerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewSoxResamplerRequest* internal_default_instance() {
    return reinterpret_cast<const NewSoxResamplerRequest*>(
               &_NewSoxResamplerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NewSoxResamplerRequest& a, NewSoxResamplerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewSoxResamplerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSoxResamplerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSoxResamplerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewSoxResamplerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewSoxResamplerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewSoxResamplerRequest& from) {
    NewSoxResamplerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSoxResamplerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewSoxResamplerRequest";
  }
  protected:
  explicit NewSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputRateFieldNumber = 1,
    kOutputRateFieldNumber = 2,
    kNumChannelsFieldNumber = 3,
    kInputDataTypeFieldNumber = 4,
    kOutputDataTypeFieldNumber = 5,
    kQualityRecipeFieldNumber = 6,
    kFlagsFieldNumber = 7,
  };
  // required double input_rate = 1;
  bool has_input_rate() const;
  private:
  bool _internal_has_input_rate() const;
  public:
  void clear_input_rate();
  double input_rate() const;
  void set_input_rate(double value);
  private:
  double _internal_input_rate() const;
  void _internal_set_input_rate(double value);
  public:

  // required double output_rate = 2;
  bool has_output_rate() const;
  private:
  bool _internal_has_output_rate() const;
  public:
  void clear_output_rate();
  double output_rate() const;
  void set_output_rate(double value);
  private:
  double _internal_output_rate() const;
  void _internal_set_output_rate(double value);
  public:

  // required uint32 num_channels = 3;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // required .livekit.proto.SoxResamplerDataType input_data_type = 4;
  bool has_input_data_type() const;
  private:
  bool _internal_has_input_data_type() const;
  public:
  void clear_input_data_type();
  ::livekit::proto::SoxResamplerDataType input_data_type() const;
  void set_input_data_type(::livekit::proto::SoxResamplerDataType value);
  private:
  ::livekit::proto::SoxResamplerDataType _internal_input_data_type() const;
  void _internal_set_input_data_type(::livekit::proto::SoxResamplerDataType value);
  public:

  // required .livekit.proto.SoxResamplerDataType output_data_type = 5;
  bool has_output_data_type() const;
  private:
  bool _internal_has_output_data_type() const;
  public:
  void clear_output_data_type();
  ::livekit::proto::SoxResamplerDataType output_data_type() const;
  void set_output_data_type(::livekit::proto::SoxResamplerDataType value);
  private:
  ::livekit::proto::SoxResamplerDataType _internal_output_data_type() const;
  void _internal_set_output_data_type(::livekit::proto::SoxResamplerDataType value);
  public:

  // required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
  bool has_quality_recipe() const;
  private:
  bool _internal_has_quality_recipe() const;
  public:
  void clear_quality_recipe();
  ::livekit::proto::SoxQualityRecipe quality_recipe() const;
  void set_quality_recipe(::livekit::proto::SoxQualityRecipe value);
  private:
  ::livekit::proto::SoxQualityRecipe _internal_quality_recipe() const;
  void _internal_set_quality_recipe(::livekit::proto::SoxQualityRecipe value);
  public:

  // optional uint32 flags = 7;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.NewSoxResamplerRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double input_rate_;
    double output_rate_;
    uint32_t num_channels_;
    int input_data_type_;
    int output_data_type_;
    int quality_recipe_;
    uint32_t flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class NewSoxResamplerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.NewSoxResamplerResponse) */ {
 public:
  inline NewSoxResamplerResponse() : NewSoxResamplerResponse(nullptr) {}
  ~NewSoxResamplerResponse() override;
  explicit PROTOBUF_CONSTEXPR NewSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewSoxResamplerResponse(const NewSoxResamplerResponse& from);
  NewSoxResamplerResponse(NewSoxResamplerResponse&& from) noexcept
    : NewSoxResamplerResponse() {
    *this = ::std::move(from);
  }

  inline NewSoxResamplerResponse& operator=(const NewSoxResamplerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSoxResamplerResponse& operator=(NewSoxResamplerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSoxResamplerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kResampler = 1,
    kError = 2,
    MESSAGE_NOT_SET = 0,
  };

  static inline const NewSoxResamplerResponse* internal_default_instance() {
    return reinterpret_cast<const NewSoxResamplerResponse*>(
               &_NewSoxResamplerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NewSoxResamplerResponse& a, NewSoxResamplerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NewSoxResamplerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSoxResamplerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSoxResamplerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewSoxResamplerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewSoxResamplerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewSoxResamplerResponse& from) {
    NewSoxResamplerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSoxResamplerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.NewSoxResamplerResponse";
  }
  protected:
  explicit NewSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResamplerFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .livekit.proto.OwnedSoxResampler resampler = 1;
  bool has_resampler() const;
  private:
  bool _internal_has_resampler() const;
  public:
  void clear_resampler();
  const ::livekit::proto::OwnedSoxResampler& resampler() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedSoxResampler* release_resampler();
  ::livekit::proto::OwnedSoxResampler* mutable_resampler();
  void set_allocated_resampler(::livekit::proto::OwnedSoxResampler* resampler);
  private:
  const ::livekit::proto::OwnedSoxResampler& _internal_resampler() const;
  ::livekit::proto::OwnedSoxResampler* _internal_mutable_resampler();
  public:
  void unsafe_arena_set_allocated_resampler(
      ::livekit::proto::OwnedSoxResampler* resampler);
  ::livekit::proto::OwnedSoxResampler* unsafe_arena_release_resampler();

  // string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.NewSoxResamplerResponse)
 private:
  class _Internal;
  void set_has_resampler();
  void set_has_error();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::OwnedSoxResampler* resampler_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PushSoxResamplerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PushSoxResamplerRequest) */ {
 public:
  inline PushSoxResamplerRequest() : PushSoxResamplerRequest(nullptr) {}
  ~PushSoxResamplerRequest() override;
  explicit PROTOBUF_CONSTEXPR PushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushSoxResamplerRequest(const PushSoxResamplerRequest& from);
  PushSoxResamplerRequest(PushSoxResamplerRequest&& from) noexcept
    : PushSoxResamplerRequest() {
    *this = ::std::move(from);
  }

  inline PushSoxResamplerRequest& operator=(const PushSoxResamplerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushSoxResamplerRequest& operator=(PushSoxResamplerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushSoxResamplerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushSoxResamplerRequest* internal_default_instance() {
    return reinterpret_cast<const PushSoxResamplerRequest*>(
               &_PushSoxResamplerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PushSoxResamplerRequest& a, PushSoxResamplerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushSoxResamplerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushSoxResamplerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushSoxResamplerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushSoxResamplerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushSoxResamplerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushSoxResamplerRequest& from) {
    PushSoxResamplerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushSoxResamplerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PushSoxResamplerRequest";
  }
  protected:
  explicit PushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResamplerHandleFieldNumber = 1,
    kDataPtrFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // required uint64 resampler_handle = 1;
  bool has_resampler_handle() const;
  private:
  bool _internal_has_resampler_handle() const;
  public:
  void clear_resampler_handle();
  uint64_t resampler_handle() const;
  void set_resampler_handle(uint64_t value);
  private:
  uint64_t _internal_resampler_handle() const;
  void _internal_set_resampler_handle(uint64_t value);
  public:

  // required uint64 data_ptr = 2;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PushSoxResamplerRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t resampler_handle_;
    uint64_t data_ptr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PushSoxResamplerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PushSoxResamplerResponse) */ {
 public:
  inline PushSoxResamplerResponse() : PushSoxResamplerResponse(nullptr) {}
  ~PushSoxResamplerResponse() override;
  explicit PROTOBUF_CONSTEXPR PushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushSoxResamplerResponse(const PushSoxResamplerResponse& from);
  PushSoxResamplerResponse(PushSoxResamplerResponse&& from) noexcept
    : PushSoxResamplerResponse() {
    *this = ::std::move(from);
  }

  inline PushSoxResamplerResponse& operator=(const PushSoxResamplerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushSoxResamplerResponse& operator=(PushSoxResamplerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushSoxResamplerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushSoxResamplerResponse* internal_default_instance() {
    return reinterpret_cast<const PushSoxResamplerResponse*>(
               &_PushSoxResamplerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PushSoxResamplerResponse& a, PushSoxResamplerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushSoxResamplerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushSoxResamplerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushSoxResamplerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushSoxResamplerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushSoxResamplerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushSoxResamplerResponse& from) {
    PushSoxResamplerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushSoxResamplerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PushSoxResamplerResponse";
  }
  protected:
  explicit PushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 3,
    kOutputPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional string error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 output_ptr = 1;
  bool has_output_ptr() const;
  private:
  bool _internal_has_output_ptr() const;
  public:
  void clear_output_ptr();
  uint64_t output_ptr() const;
  void set_output_ptr(uint64_t value);
  private:
  uint64_t _internal_output_ptr() const;
  void _internal_set_output_ptr(uint64_t value);
  public:

  // required uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PushSoxResamplerResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t output_ptr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class FlushSoxResamplerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.FlushSoxResamplerRequest) */ {
 public:
  inline FlushSoxResamplerRequest() : FlushSoxResamplerRequest(nullptr) {}
  ~FlushSoxResamplerRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushSoxResamplerRequest(const FlushSoxResamplerRequest& from);
  FlushSoxResamplerRequest(FlushSoxResamplerRequest&& from) noexcept
    : FlushSoxResamplerRequest() {
    *this = ::std::move(from);
  }

  inline FlushSoxResamplerRequest& operator=(const FlushSoxResamplerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushSoxResamplerRequest& operator=(FlushSoxResamplerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushSoxResamplerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushSoxResamplerRequest* internal_default_instance() {
    return reinterpret_cast<const FlushSoxResamplerRequest*>(
               &_FlushSoxResamplerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(FlushSoxResamplerRequest& a, FlushSoxResamplerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushSoxResamplerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushSoxResamplerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushSoxResamplerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushSoxResamplerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushSoxResamplerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushSoxResamplerRequest& from) {
    FlushSoxResamplerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushSoxResamplerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FlushSoxResamplerRequest";
  }
  protected:
  explicit FlushSoxResamplerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResamplerHandleFieldNumber = 1,
  };
  // required uint64 resampler_handle = 1;
  bool has_resampler_handle() const;
  private:
  bool _internal_has_resampler_handle() const;
  public:
  void clear_resampler_handle();
  uint64_t resampler_handle() const;
  void set_resampler_handle(uint64_t value);
  private:
  uint64_t _internal_resampler_handle() const;
  void _internal_set_resampler_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.FlushSoxResamplerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t resampler_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class FlushSoxResamplerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.FlushSoxResamplerResponse) */ {
 public:
  inline FlushSoxResamplerResponse() : FlushSoxResamplerResponse(nullptr) {}
  ~FlushSoxResamplerResponse() override;
  explicit PROTOBUF_CONSTEXPR FlushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushSoxResamplerResponse(const FlushSoxResamplerResponse& from);
  FlushSoxResamplerResponse(FlushSoxResamplerResponse&& from) noexcept
    : FlushSoxResamplerResponse() {
    *this = ::std::move(from);
  }

  inline FlushSoxResamplerResponse& operator=(const FlushSoxResamplerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushSoxResamplerResponse& operator=(FlushSoxResamplerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushSoxResamplerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushSoxResamplerResponse* internal_default_instance() {
    return reinterpret_cast<const FlushSoxResamplerResponse*>(
               &_FlushSoxResamplerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FlushSoxResamplerResponse& a, FlushSoxResamplerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushSoxResamplerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushSoxResamplerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushSoxResamplerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushSoxResamplerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushSoxResamplerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushSoxResamplerResponse& from) {
    FlushSoxResamplerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushSoxResamplerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FlushSoxResamplerResponse";
  }
  protected:
  explicit FlushSoxResamplerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 3,
    kOutputPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // optional string error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 output_ptr = 1;
  bool has_output_ptr() const;
  private:
  bool _internal_has_output_ptr() const;
  public:
  void clear_output_ptr();
  uint64_t output_ptr() const;
  void set_output_ptr(uint64_t value);
  private:
  uint64_t _internal_output_ptr() const;
  void _internal_set_output_ptr(uint64_t value);
  public:

  // required uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.FlushSoxResamplerResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t output_ptr_;
    uint32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioFrameBufferInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioFrameBufferInfo) */ {
 public:
  inline AudioFrameBufferInfo() : AudioFrameBufferInfo(nullptr) {}
  ~AudioFrameBufferInfo() override;
  explicit PROTOBUF_CONSTEXPR AudioFrameBufferInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioFrameBufferInfo(const AudioFrameBufferInfo& from);
  AudioFrameBufferInfo(AudioFrameBufferInfo&& from) noexcept
    : AudioFrameBufferInfo() {
    *this = ::std::move(from);
  }

  inline AudioFrameBufferInfo& operator=(const AudioFrameBufferInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFrameBufferInfo& operator=(AudioFrameBufferInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioFrameBufferInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioFrameBufferInfo* internal_default_instance() {
    return reinterpret_cast<const AudioFrameBufferInfo*>(
               &_AudioFrameBufferInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AudioFrameBufferInfo& a, AudioFrameBufferInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFrameBufferInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFrameBufferInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioFrameBufferInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioFrameBufferInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioFrameBufferInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioFrameBufferInfo& from) {
    AudioFrameBufferInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFrameBufferInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioFrameBufferInfo";
  }
  protected:
  explicit AudioFrameBufferInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPtrFieldNumber = 1,
    kNumChannelsFieldNumber = 2,
    kSampleRateFieldNumber = 3,
    kSamplesPerChannelFieldNumber = 4,
  };
  // required uint64 data_ptr = 1;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint32 num_channels = 2;
  bool has_num_channels() const;
  private:
  bool _internal_has_num_channels() const;
  public:
  void clear_num_channels();
  uint32_t num_channels() const;
  void set_num_channels(uint32_t value);
  private:
  uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(uint32_t value);
  public:

  // required uint32 sample_rate = 3;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // required uint32 samples_per_channel = 4;
  bool has_samples_per_channel() const;
  private:
  bool _internal_has_samples_per_channel() const;
  public:
  void clear_samples_per_channel();
  uint32_t samples_per_channel() const;
  void set_samples_per_channel(uint32_t value);
  private:
  uint32_t _internal_samples_per_channel() const;
  void _internal_set_samples_per_channel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioFrameBufferInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t data_ptr_;
    uint32_t num_channels_;
    uint32_t sample_rate_;
    uint32_t samples_per_channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedAudioFrameBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedAudioFrameBuffer) */ {
 public:
  inline OwnedAudioFrameBuffer() : OwnedAudioFrameBuffer(nullptr) {}
  ~OwnedAudioFrameBuffer() override;
  explicit PROTOBUF_CONSTEXPR OwnedAudioFrameBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedAudioFrameBuffer(const OwnedAudioFrameBuffer& from);
  OwnedAudioFrameBuffer(OwnedAudioFrameBuffer&& from) noexcept
    : OwnedAudioFrameBuffer() {
    *this = ::std::move(from);
  }

  inline OwnedAudioFrameBuffer& operator=(const OwnedAudioFrameBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedAudioFrameBuffer& operator=(OwnedAudioFrameBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedAudioFrameBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedAudioFrameBuffer* internal_default_instance() {
    return reinterpret_cast<const OwnedAudioFrameBuffer*>(
               &_OwnedAudioFrameBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(OwnedAudioFrameBuffer& a, OwnedAudioFrameBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedAudioFrameBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedAudioFrameBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedAudioFrameBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedAudioFrameBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedAudioFrameBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedAudioFrameBuffer& from) {
    OwnedAudioFrameBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedAudioFrameBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedAudioFrameBuffer";
  }
  protected:
  explicit OwnedAudioFrameBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.AudioFrameBufferInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::AudioFrameBufferInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioFrameBufferInfo* release_info();
  ::livekit::proto::AudioFrameBufferInfo* mutable_info();
  void set_allocated_info(::livekit::proto::AudioFrameBufferInfo* info);
  private:
  const ::livekit::proto::AudioFrameBufferInfo& _internal_info() const;
  ::livekit::proto::AudioFrameBufferInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::AudioFrameBufferInfo* info);
  ::livekit::proto::AudioFrameBufferInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedAudioFrameBuffer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::AudioFrameBufferInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioStreamInfo) */ {
 public:
  inline AudioStreamInfo() : AudioStreamInfo(nullptr) {}
  ~AudioStreamInfo() override;
  explicit PROTOBUF_CONSTEXPR AudioStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioStreamInfo(const AudioStreamInfo& from);
  AudioStreamInfo(AudioStreamInfo&& from) noexcept
    : AudioStreamInfo() {
    *this = ::std::move(from);
  }

  inline AudioStreamInfo& operator=(const AudioStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamInfo& operator=(AudioStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioStreamInfo* internal_default_instance() {
    return reinterpret_cast<const AudioStreamInfo*>(
               &_AudioStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AudioStreamInfo& a, AudioStreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioStreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioStreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioStreamInfo& from) {
    AudioStreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioStreamInfo";
  }
  protected:
  explicit AudioStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .livekit.proto.AudioStreamType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::AudioStreamType type() const;
  void set_type(::livekit::proto::AudioStreamType value);
  private:
  ::livekit::proto::AudioStreamType _internal_type() const;
  void _internal_set_type(::livekit::proto::AudioStreamType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedAudioStream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedAudioStream) */ {
 public:
  inline OwnedAudioStream() : OwnedAudioStream(nullptr) {}
  ~OwnedAudioStream() override;
  explicit PROTOBUF_CONSTEXPR OwnedAudioStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedAudioStream(const OwnedAudioStream& from);
  OwnedAudioStream(OwnedAudioStream&& from) noexcept
    : OwnedAudioStream() {
    *this = ::std::move(from);
  }

  inline OwnedAudioStream& operator=(const OwnedAudioStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedAudioStream& operator=(OwnedAudioStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedAudioStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedAudioStream* internal_default_instance() {
    return reinterpret_cast<const OwnedAudioStream*>(
               &_OwnedAudioStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(OwnedAudioStream& a, OwnedAudioStream& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedAudioStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedAudioStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedAudioStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedAudioStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedAudioStream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedAudioStream& from) {
    OwnedAudioStream::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedAudioStream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedAudioStream";
  }
  protected:
  explicit OwnedAudioStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.AudioStreamInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::AudioStreamInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioStreamInfo* release_info();
  ::livekit::proto::AudioStreamInfo* mutable_info();
  void set_allocated_info(::livekit::proto::AudioStreamInfo* info);
  private:
  const ::livekit::proto::AudioStreamInfo& _internal_info() const;
  ::livekit::proto::AudioStreamInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::AudioStreamInfo* info);
  ::livekit::proto::AudioStreamInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedAudioStream)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::AudioStreamInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioStreamEvent) */ {
 public:
  inline AudioStreamEvent() : AudioStreamEvent(nullptr) {}
  ~AudioStreamEvent() override;
  explicit PROTOBUF_CONSTEXPR AudioStreamEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioStreamEvent(const AudioStreamEvent& from);
  AudioStreamEvent(AudioStreamEvent&& from) noexcept
    : AudioStreamEvent() {
    *this = ::std::move(from);
  }

  inline AudioStreamEvent& operator=(const AudioStreamEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamEvent& operator=(AudioStreamEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioStreamEvent& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kFrameReceived = 2,
    kEos = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const AudioStreamEvent* internal_default_instance() {
    return reinterpret_cast<const AudioStreamEvent*>(
               &_AudioStreamEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AudioStreamEvent& a, AudioStreamEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioStreamEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioStreamEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioStreamEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioStreamEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioStreamEvent& from) {
    AudioStreamEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioStreamEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioStreamEvent";
  }
  protected:
  explicit AudioStreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamHandleFieldNumber = 1,
    kFrameReceivedFieldNumber = 2,
    kEosFieldNumber = 3,
  };
  // required uint64 stream_handle = 1;
  bool has_stream_handle() const;
  private:
  bool _internal_has_stream_handle() const;
  public:
  void clear_stream_handle();
  uint64_t stream_handle() const;
  void set_stream_handle(uint64_t value);
  private:
  uint64_t _internal_stream_handle() const;
  void _internal_set_stream_handle(uint64_t value);
  public:

  // .livekit.proto.AudioFrameReceived frame_received = 2;
  bool has_frame_received() const;
  private:
  bool _internal_has_frame_received() const;
  public:
  void clear_frame_received();
  const ::livekit::proto::AudioFrameReceived& frame_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioFrameReceived* release_frame_received();
  ::livekit::proto::AudioFrameReceived* mutable_frame_received();
  void set_allocated_frame_received(::livekit::proto::AudioFrameReceived* frame_received);
  private:
  const ::livekit::proto::AudioFrameReceived& _internal_frame_received() const;
  ::livekit::proto::AudioFrameReceived* _internal_mutable_frame_received();
  public:
  void unsafe_arena_set_allocated_frame_received(
      ::livekit::proto::AudioFrameReceived* frame_received);
  ::livekit::proto::AudioFrameReceived* unsafe_arena_release_frame_received();

  // .livekit.proto.AudioStreamEOS eos = 3;
  bool has_eos() const;
  private:
  bool _internal_has_eos() const;
  public:
  void clear_eos();
  const ::livekit::proto::AudioStreamEOS& eos() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioStreamEOS* release_eos();
  ::livekit::proto::AudioStreamEOS* mutable_eos();
  void set_allocated_eos(::livekit::proto::AudioStreamEOS* eos);
  private:
  const ::livekit::proto::AudioStreamEOS& _internal_eos() const;
  ::livekit::proto::AudioStreamEOS* _internal_mutable_eos();
  public:
  void unsafe_arena_set_allocated_eos(
      ::livekit::proto::AudioStreamEOS* eos);
  ::livekit::proto::AudioStreamEOS* unsafe_arena_release_eos();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.AudioStreamEvent)
 private:
  class _Internal;
  void set_has_frame_received();
  void set_has_eos();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t stream_handle_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::AudioFrameReceived* frame_received_;
      ::livekit::proto::AudioStreamEOS* eos_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioFrameReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioFrameReceived) */ {
 public:
  inline AudioFrameReceived() : AudioFrameReceived(nullptr) {}
  ~AudioFrameReceived() override;
  explicit PROTOBUF_CONSTEXPR AudioFrameReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioFrameReceived(const AudioFrameReceived& from);
  AudioFrameReceived(AudioFrameReceived&& from) noexcept
    : AudioFrameReceived() {
    *this = ::std::move(from);
  }

  inline AudioFrameReceived& operator=(const AudioFrameReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFrameReceived& operator=(AudioFrameReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioFrameReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioFrameReceived* internal_default_instance() {
    return reinterpret_cast<const AudioFrameReceived*>(
               &_AudioFrameReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AudioFrameReceived& a, AudioFrameReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFrameReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFrameReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioFrameReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioFrameReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioFrameReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioFrameReceived& from) {
    AudioFrameReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFrameReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioFrameReceived";
  }
  protected:
  explicit AudioFrameReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameFieldNumber = 1,
  };
  // required .livekit.proto.OwnedAudioFrameBuffer frame = 1;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::livekit::proto::OwnedAudioFrameBuffer& frame() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedAudioFrameBuffer* release_frame();
  ::livekit::proto::OwnedAudioFrameBuffer* mutable_frame();
  void set_allocated_frame(::livekit::proto::OwnedAudioFrameBuffer* frame);
  private:
  const ::livekit::proto::OwnedAudioFrameBuffer& _internal_frame() const;
  ::livekit::proto::OwnedAudioFrameBuffer* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::livekit::proto::OwnedAudioFrameBuffer* frame);
  ::livekit::proto::OwnedAudioFrameBuffer* unsafe_arena_release_frame();

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioFrameReceived)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedAudioFrameBuffer* frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioStreamEOS final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.AudioStreamEOS) */ {
 public:
  inline AudioStreamEOS() : AudioStreamEOS(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AudioStreamEOS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioStreamEOS(const AudioStreamEOS& from);
  AudioStreamEOS(AudioStreamEOS&& from) noexcept
    : AudioStreamEOS() {
    *this = ::std::move(from);
  }

  inline AudioStreamEOS& operator=(const AudioStreamEOS& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioStreamEOS& operator=(AudioStreamEOS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioStreamEOS& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioStreamEOS* internal_default_instance() {
    return reinterpret_cast<const AudioStreamEOS*>(
               &_AudioStreamEOS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AudioStreamEOS& a, AudioStreamEOS& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioStreamEOS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioStreamEOS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioStreamEOS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioStreamEOS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AudioStreamEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AudioStreamEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioStreamEOS";
  }
  protected:
  explicit AudioStreamEOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioStreamEOS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioSourceOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioSourceOptions) */ {
 public:
  inline AudioSourceOptions() : AudioSourceOptions(nullptr) {}
  ~AudioSourceOptions() override;
  explicit PROTOBUF_CONSTEXPR AudioSourceOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioSourceOptions(const AudioSourceOptions& from);
  AudioSourceOptions(AudioSourceOptions&& from) noexcept
    : AudioSourceOptions() {
    *this = ::std::move(from);
  }

  inline AudioSourceOptions& operator=(const AudioSourceOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioSourceOptions& operator=(AudioSourceOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioSourceOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioSourceOptions* internal_default_instance() {
    return reinterpret_cast<const AudioSourceOptions*>(
               &_AudioSourceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(AudioSourceOptions& a, AudioSourceOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioSourceOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioSourceOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioSourceOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioSourceOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioSourceOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioSourceOptions& from) {
    AudioSourceOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioSourceOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioSourceOptions";
  }
  protected:
  explicit AudioSourceOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEchoCancellationFieldNumber = 1,
    kNoiseSuppressionFieldNumber = 2,
    kAutoGainControlFieldNumber = 3,
  };
  // required bool echo_cancellation = 1;
  bool has_echo_cancellation() const;
  private:
  bool _internal_has_echo_cancellation() const;
  public:
  void clear_echo_cancellation();
  bool echo_cancellation() const;
  void set_echo_cancellation(bool value);
  private:
  bool _internal_echo_cancellation() const;
  void _internal_set_echo_cancellation(bool value);
  public:

  // required bool noise_suppression = 2;
  bool has_noise_suppression() const;
  private:
  bool _internal_has_noise_suppression() const;
  public:
  void clear_noise_suppression();
  bool noise_suppression() const;
  void set_noise_suppression(bool value);
  private:
  bool _internal_noise_suppression() const;
  void _internal_set_noise_suppression(bool value);
  public:

  // required bool auto_gain_control = 3;
  bool has_auto_gain_control() const;
  private:
  bool _internal_has_auto_gain_control() const;
  public:
  void clear_auto_gain_control();
  bool auto_gain_control() const;
  void set_auto_gain_control(bool value);
  private:
  bool _internal_auto_gain_control() const;
  void _internal_set_auto_gain_control(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioSourceOptions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool echo_cancellation_;
    bool noise_suppression_;
    bool auto_gain_control_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioSourceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioSourceInfo) */ {
 public:
  inline AudioSourceInfo() : AudioSourceInfo(nullptr) {}
  ~AudioSourceInfo() override;
  explicit PROTOBUF_CONSTEXPR AudioSourceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioSourceInfo(const AudioSourceInfo& from);
  AudioSourceInfo(AudioSourceInfo&& from) noexcept
    : AudioSourceInfo() {
    *this = ::std::move(from);
  }

  inline AudioSourceInfo& operator=(const AudioSourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioSourceInfo& operator=(AudioSourceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioSourceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioSourceInfo* internal_default_instance() {
    return reinterpret_cast<const AudioSourceInfo*>(
               &_AudioSourceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(AudioSourceInfo& a, AudioSourceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioSourceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioSourceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioSourceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioSourceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioSourceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioSourceInfo& from) {
    AudioSourceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioSourceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioSourceInfo";
  }
  protected:
  explicit AudioSourceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
  };
  // required .livekit.proto.AudioSourceType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::livekit::proto::AudioSourceType type() const;
  void set_type(::livekit::proto::AudioSourceType value);
  private:
  ::livekit::proto::AudioSourceType _internal_type() const;
  void _internal_set_type(::livekit::proto::AudioSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioSourceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedAudioSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedAudioSource) */ {
 public:
  inline OwnedAudioSource() : OwnedAudioSource(nullptr) {}
  ~OwnedAudioSource() override;
  explicit PROTOBUF_CONSTEXPR OwnedAudioSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedAudioSource(const OwnedAudioSource& from);
  OwnedAudioSource(OwnedAudioSource&& from) noexcept
    : OwnedAudioSource() {
    *this = ::std::move(from);
  }

  inline OwnedAudioSource& operator=(const OwnedAudioSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedAudioSource& operator=(OwnedAudioSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedAudioSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedAudioSource* internal_default_instance() {
    return reinterpret_cast<const OwnedAudioSource*>(
               &_OwnedAudioSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(OwnedAudioSource& a, OwnedAudioSource& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedAudioSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedAudioSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedAudioSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedAudioSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedAudioSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedAudioSource& from) {
    OwnedAudioSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedAudioSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedAudioSource";
  }
  protected:
  explicit OwnedAudioSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.AudioSourceInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::AudioSourceInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioSourceInfo* release_info();
  ::livekit::proto::AudioSourceInfo* mutable_info();
  void set_allocated_info(::livekit::proto::AudioSourceInfo* info);
  private:
  const ::livekit::proto::AudioSourceInfo& _internal_info() const;
  ::livekit::proto::AudioSourceInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::AudioSourceInfo* info);
  ::livekit::proto::AudioSourceInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedAudioSource)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::AudioSourceInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class AudioResamplerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.AudioResamplerInfo) */ {
 public:
  inline AudioResamplerInfo() : AudioResamplerInfo(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AudioResamplerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioResamplerInfo(const AudioResamplerInfo& from);
  AudioResamplerInfo(AudioResamplerInfo&& from) noexcept
    : AudioResamplerInfo() {
    *this = ::std::move(from);
  }

  inline AudioResamplerInfo& operator=(const AudioResamplerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioResamplerInfo& operator=(AudioResamplerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioResamplerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioResamplerInfo* internal_default_instance() {
    return reinterpret_cast<const AudioResamplerInfo*>(
               &_AudioResamplerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(AudioResamplerInfo& a, AudioResamplerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioResamplerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioResamplerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioResamplerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioResamplerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AudioResamplerInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AudioResamplerInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioResamplerInfo";
  }
  protected:
  explicit AudioResamplerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioResamplerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedAudioResampler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedAudioResampler) */ {
 public:
  inline OwnedAudioResampler() : OwnedAudioResampler(nullptr) {}
  ~OwnedAudioResampler() override;
  explicit PROTOBUF_CONSTEXPR OwnedAudioResampler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedAudioResampler(const OwnedAudioResampler& from);
  OwnedAudioResampler(OwnedAudioResampler&& from) noexcept
    : OwnedAudioResampler() {
    *this = ::std::move(from);
  }

  inline OwnedAudioResampler& operator=(const OwnedAudioResampler& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedAudioResampler& operator=(OwnedAudioResampler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedAudioResampler& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedAudioResampler* internal_default_instance() {
    return reinterpret_cast<const OwnedAudioResampler*>(
               &_OwnedAudioResampler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(OwnedAudioResampler& a, OwnedAudioResampler& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedAudioResampler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedAudioResampler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedAudioResampler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedAudioResampler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedAudioResampler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedAudioResampler& from) {
    OwnedAudioResampler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedAudioResampler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedAudioResampler";
  }
  protected:
  explicit OwnedAudioResampler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.AudioResamplerInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::AudioResamplerInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioResamplerInfo* release_info();
  ::livekit::proto::AudioResamplerInfo* mutable_info();
  void set_allocated_info(::livekit::proto::AudioResamplerInfo* info);
  private:
  const ::livekit::proto::AudioResamplerInfo& _internal_info() const;
  ::livekit::proto::AudioResamplerInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::AudioResamplerInfo* info);
  ::livekit::proto::AudioResamplerInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedAudioResampler)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::AudioResamplerInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedApm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedApm) */ {
 public:
  inline OwnedApm() : OwnedApm(nullptr) {}
  ~OwnedApm() override;
  explicit PROTOBUF_CONSTEXPR OwnedApm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedApm(const OwnedApm& from);
  OwnedApm(OwnedApm&& from) noexcept
    : OwnedApm() {
    *this = ::std::move(from);
  }

  inline OwnedApm& operator=(const OwnedApm& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedApm& operator=(OwnedApm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedApm& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedApm* internal_default_instance() {
    return reinterpret_cast<const OwnedApm*>(
               &_OwnedApm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(OwnedApm& a, OwnedApm& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedApm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedApm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedApm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedApm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedApm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedApm& from) {
    OwnedApm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedApm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedApm";
  }
  protected:
  explicit OwnedApm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedApm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SoxResamplerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SoxResamplerInfo) */ {
 public:
  inline SoxResamplerInfo() : SoxResamplerInfo(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SoxResamplerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoxResamplerInfo(const SoxResamplerInfo& from);
  SoxResamplerInfo(SoxResamplerInfo&& from) noexcept
    : SoxResamplerInfo() {
    *this = ::std::move(from);
  }

  inline SoxResamplerInfo& operator=(const SoxResamplerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoxResamplerInfo& operator=(SoxResamplerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoxResamplerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoxResamplerInfo* internal_default_instance() {
    return reinterpret_cast<const SoxResamplerInfo*>(
               &_SoxResamplerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SoxResamplerInfo& a, SoxResamplerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SoxResamplerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoxResamplerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoxResamplerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoxResamplerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SoxResamplerInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SoxResamplerInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SoxResamplerInfo";
  }
  protected:
  explicit SoxResamplerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SoxResamplerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class OwnedSoxResampler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedSoxResampler) */ {
 public:
  inline OwnedSoxResampler() : OwnedSoxResampler(nullptr) {}
  ~OwnedSoxResampler() override;
  explicit PROTOBUF_CONSTEXPR OwnedSoxResampler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedSoxResampler(const OwnedSoxResampler& from);
  OwnedSoxResampler(OwnedSoxResampler&& from) noexcept
    : OwnedSoxResampler() {
    *this = ::std::move(from);
  }

  inline OwnedSoxResampler& operator=(const OwnedSoxResampler& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedSoxResampler& operator=(OwnedSoxResampler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedSoxResampler& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedSoxResampler* internal_default_instance() {
    return reinterpret_cast<const OwnedSoxResampler*>(
               &_OwnedSoxResampler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(OwnedSoxResampler& a, OwnedSoxResampler& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedSoxResampler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedSoxResampler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedSoxResampler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedSoxResampler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedSoxResampler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedSoxResampler& from) {
    OwnedSoxResampler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedSoxResampler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedSoxResampler";
  }
  protected:
  explicit OwnedSoxResampler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.SoxResamplerInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::SoxResamplerInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::SoxResamplerInfo* release_info();
  ::livekit::proto::SoxResamplerInfo* mutable_info();
  void set_allocated_info(::livekit::proto::SoxResamplerInfo* info);
  private:
  const ::livekit::proto::SoxResamplerInfo& _internal_info() const;
  ::livekit::proto::SoxResamplerInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::SoxResamplerInfo* info);
  ::livekit::proto::SoxResamplerInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedSoxResampler)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::SoxResamplerInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class LoadAudioFilterPluginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LoadAudioFilterPluginRequest) */ {
 public:
  inline LoadAudioFilterPluginRequest() : LoadAudioFilterPluginRequest(nullptr) {}
  ~LoadAudioFilterPluginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoadAudioFilterPluginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadAudioFilterPluginRequest(const LoadAudioFilterPluginRequest& from);
  LoadAudioFilterPluginRequest(LoadAudioFilterPluginRequest&& from) noexcept
    : LoadAudioFilterPluginRequest() {
    *this = ::std::move(from);
  }

  inline LoadAudioFilterPluginRequest& operator=(const LoadAudioFilterPluginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadAudioFilterPluginRequest& operator=(LoadAudioFilterPluginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadAudioFilterPluginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadAudioFilterPluginRequest* internal_default_instance() {
    return reinterpret_cast<const LoadAudioFilterPluginRequest*>(
               &_LoadAudioFilterPluginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(LoadAudioFilterPluginRequest& a, LoadAudioFilterPluginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadAudioFilterPluginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadAudioFilterPluginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadAudioFilterPluginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadAudioFilterPluginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadAudioFilterPluginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadAudioFilterPluginRequest& from) {
    LoadAudioFilterPluginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadAudioFilterPluginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LoadAudioFilterPluginRequest";
  }
  protected:
  explicit LoadAudioFilterPluginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDependenciesFieldNumber = 2,
    kPluginPathFieldNumber = 1,
    kModuleIdFieldNumber = 3,
  };
  // repeated string dependencies = 2;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;
  public:
  void clear_dependencies();
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  void set_dependencies(int index, const std::string& value);
  void set_dependencies(int index, std::string&& value);
  void set_dependencies(int index, const char* value);
  void set_dependencies(int index, const char* value, size_t size);
  std::string* add_dependencies();
  void add_dependencies(const std::string& value);
  void add_dependencies(std::string&& value);
  void add_dependencies(const char* value);
  void add_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dependencies();
  private:
  const std::string& _internal_dependencies(int index) const;
  std::string* _internal_add_dependencies();
  public:

  // required string plugin_path = 1;
  bool has_plugin_path() const;
  private:
  bool _internal_has_plugin_path() const;
  public:
  void clear_plugin_path();
  const std::string& plugin_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plugin_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plugin_path();
  PROTOBUF_NODISCARD std::string* release_plugin_path();
  void set_allocated_plugin_path(std::string* plugin_path);
  private:
  const std::string& _internal_plugin_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plugin_path(const std::string& value);
  std::string* _internal_mutable_plugin_path();
  public:

  // required string module_id = 3;
  bool has_module_id() const;
  private:
  bool _internal_has_module_id() const;
  public:
  void clear_module_id();
  const std::string& module_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_id();
  PROTOBUF_NODISCARD std::string* release_module_id();
  void set_allocated_module_id(std::string* module_id);
  private:
  const std::string& _internal_module_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_id(const std::string& value);
  std::string* _internal_mutable_module_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LoadAudioFilterPluginRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dependencies_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// -------------------------------------------------------------------

class LoadAudioFilterPluginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LoadAudioFilterPluginResponse) */ {
 public:
  inline LoadAudioFilterPluginResponse() : LoadAudioFilterPluginResponse(nullptr) {}
  ~LoadAudioFilterPluginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoadAudioFilterPluginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadAudioFilterPluginResponse(const LoadAudioFilterPluginResponse& from);
  LoadAudioFilterPluginResponse(LoadAudioFilterPluginResponse&& from) noexcept
    : LoadAudioFilterPluginResponse() {
    *this = ::std::move(from);
  }

  inline LoadAudioFilterPluginResponse& operator=(const LoadAudioFilterPluginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadAudioFilterPluginResponse& operator=(LoadAudioFilterPluginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadAudioFilterPluginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadAudioFilterPluginResponse* internal_default_instance() {
    return reinterpret_cast<const LoadAudioFilterPluginResponse*>(
               &_LoadAudioFilterPluginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(LoadAudioFilterPluginResponse& a, LoadAudioFilterPluginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadAudioFilterPluginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadAudioFilterPluginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadAudioFilterPluginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadAudioFilterPluginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadAudioFilterPluginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadAudioFilterPluginResponse& from) {
    LoadAudioFilterPluginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadAudioFilterPluginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LoadAudioFilterPluginResponse";
  }
  protected:
  explicit LoadAudioFilterPluginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LoadAudioFilterPluginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_audio_5fframe_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NewAudioStreamRequest

// required uint64 track_handle = 1;
inline bool NewAudioStreamRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void NewAudioStreamRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t NewAudioStreamRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t NewAudioStreamRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.track_handle)
  return _internal_track_handle();
}
inline void NewAudioStreamRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.track_handle_ = value;
}
inline void NewAudioStreamRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.track_handle)
}

// required .livekit.proto.AudioStreamType type = 2;
inline bool NewAudioStreamRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_type() const {
  return _internal_has_type();
}
inline void NewAudioStreamRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::AudioStreamType NewAudioStreamRequest::_internal_type() const {
  return static_cast< ::livekit::proto::AudioStreamType >(_impl_.type_);
}
inline ::livekit::proto::AudioStreamType NewAudioStreamRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.type)
  return _internal_type();
}
inline void NewAudioStreamRequest::_internal_set_type(::livekit::proto::AudioStreamType value) {
  assert(::livekit::proto::AudioStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void NewAudioStreamRequest::set_type(::livekit::proto::AudioStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.type)
}

// optional uint32 sample_rate = 3;
inline bool NewAudioStreamRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void NewAudioStreamRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t NewAudioStreamRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t NewAudioStreamRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.sample_rate)
  return _internal_sample_rate();
}
inline void NewAudioStreamRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sample_rate_ = value;
}
inline void NewAudioStreamRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.sample_rate)
}

// optional uint32 num_channels = 4;
inline bool NewAudioStreamRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void NewAudioStreamRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t NewAudioStreamRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t NewAudioStreamRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.num_channels)
  return _internal_num_channels();
}
inline void NewAudioStreamRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.num_channels_ = value;
}
inline void NewAudioStreamRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.num_channels)
}

// optional string audio_filter_module_id = 5;
inline bool NewAudioStreamRequest::_internal_has_audio_filter_module_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_audio_filter_module_id() const {
  return _internal_has_audio_filter_module_id();
}
inline void NewAudioStreamRequest::clear_audio_filter_module_id() {
  _impl_.audio_filter_module_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NewAudioStreamRequest::audio_filter_module_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.audio_filter_module_id)
  return _internal_audio_filter_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAudioStreamRequest::set_audio_filter_module_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.audio_filter_module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.audio_filter_module_id)
}
inline std::string* NewAudioStreamRequest::mutable_audio_filter_module_id() {
  std::string* _s = _internal_mutable_audio_filter_module_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioStreamRequest.audio_filter_module_id)
  return _s;
}
inline const std::string& NewAudioStreamRequest::_internal_audio_filter_module_id() const {
  return _impl_.audio_filter_module_id_.Get();
}
inline void NewAudioStreamRequest::_internal_set_audio_filter_module_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.audio_filter_module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* NewAudioStreamRequest::_internal_mutable_audio_filter_module_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.audio_filter_module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* NewAudioStreamRequest::release_audio_filter_module_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioStreamRequest.audio_filter_module_id)
  if (!_internal_has_audio_filter_module_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.audio_filter_module_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_module_id_.IsDefault()) {
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewAudioStreamRequest::set_allocated_audio_filter_module_id(std::string* audio_filter_module_id) {
  if (audio_filter_module_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.audio_filter_module_id_.SetAllocated(audio_filter_module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_module_id_.IsDefault()) {
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioStreamRequest.audio_filter_module_id)
}

// optional string audio_filter_options = 6;
inline bool NewAudioStreamRequest::_internal_has_audio_filter_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewAudioStreamRequest::has_audio_filter_options() const {
  return _internal_has_audio_filter_options();
}
inline void NewAudioStreamRequest::clear_audio_filter_options() {
  _impl_.audio_filter_options_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NewAudioStreamRequest::audio_filter_options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamRequest.audio_filter_options)
  return _internal_audio_filter_options();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewAudioStreamRequest::set_audio_filter_options(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.audio_filter_options_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioStreamRequest.audio_filter_options)
}
inline std::string* NewAudioStreamRequest::mutable_audio_filter_options() {
  std::string* _s = _internal_mutable_audio_filter_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioStreamRequest.audio_filter_options)
  return _s;
}
inline const std::string& NewAudioStreamRequest::_internal_audio_filter_options() const {
  return _impl_.audio_filter_options_.Get();
}
inline void NewAudioStreamRequest::_internal_set_audio_filter_options(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_filter_options_.Set(value, GetArenaForAllocation());
}
inline std::string* NewAudioStreamRequest::_internal_mutable_audio_filter_options() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.audio_filter_options_.Mutable(GetArenaForAllocation());
}
inline std::string* NewAudioStreamRequest::release_audio_filter_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioStreamRequest.audio_filter_options)
  if (!_internal_has_audio_filter_options()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.audio_filter_options_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_options_.IsDefault()) {
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NewAudioStreamRequest::set_allocated_audio_filter_options(std::string* audio_filter_options) {
  if (audio_filter_options != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.audio_filter_options_.SetAllocated(audio_filter_options, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_options_.IsDefault()) {
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioStreamRequest.audio_filter_options)
}

// -------------------------------------------------------------------

// NewAudioStreamResponse

// required .livekit.proto.OwnedAudioStream stream = 1;
inline bool NewAudioStreamResponse::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool NewAudioStreamResponse::has_stream() const {
  return _internal_has_stream();
}
inline void NewAudioStreamResponse::clear_stream() {
  if (_impl_.stream_ != nullptr) _impl_.stream_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioStream& NewAudioStreamResponse::_internal_stream() const {
  const ::livekit::proto::OwnedAudioStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioStream&>(
      ::livekit::proto::_OwnedAudioStream_default_instance_);
}
inline const ::livekit::proto::OwnedAudioStream& NewAudioStreamResponse::stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioStreamResponse.stream)
  return _internal_stream();
}
inline void NewAudioStreamResponse::unsafe_arena_set_allocated_stream(
    ::livekit::proto::OwnedAudioStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewAudioStreamResponse.stream)
}
inline ::livekit::proto::OwnedAudioStream* NewAudioStreamResponse::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioStream* NewAudioStreamResponse::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioStreamResponse.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioStream* NewAudioStreamResponse::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::livekit::proto::OwnedAudioStream* NewAudioStreamResponse::mutable_stream() {
  ::livekit::proto::OwnedAudioStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioStreamResponse.stream)
  return _msg;
}
inline void NewAudioStreamResponse::set_allocated_stream(::livekit::proto::OwnedAudioStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioStreamResponse.stream)
}

// -------------------------------------------------------------------

// AudioStreamFromParticipantRequest

// required uint64 participant_handle = 1;
inline bool AudioStreamFromParticipantRequest::_internal_has_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_participant_handle() const {
  return _internal_has_participant_handle();
}
inline void AudioStreamFromParticipantRequest::clear_participant_handle() {
  _impl_.participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t AudioStreamFromParticipantRequest::_internal_participant_handle() const {
  return _impl_.participant_handle_;
}
inline uint64_t AudioStreamFromParticipantRequest::participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.participant_handle)
  return _internal_participant_handle();
}
inline void AudioStreamFromParticipantRequest::_internal_set_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.participant_handle_ = value;
}
inline void AudioStreamFromParticipantRequest::set_participant_handle(uint64_t value) {
  _internal_set_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.participant_handle)
}

// required .livekit.proto.AudioStreamType type = 2;
inline bool AudioStreamFromParticipantRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_type() const {
  return _internal_has_type();
}
inline void AudioStreamFromParticipantRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::AudioStreamType AudioStreamFromParticipantRequest::_internal_type() const {
  return static_cast< ::livekit::proto::AudioStreamType >(_impl_.type_);
}
inline ::livekit::proto::AudioStreamType AudioStreamFromParticipantRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.type)
  return _internal_type();
}
inline void AudioStreamFromParticipantRequest::_internal_set_type(::livekit::proto::AudioStreamType value) {
  assert(::livekit::proto::AudioStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void AudioStreamFromParticipantRequest::set_type(::livekit::proto::AudioStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.type)
}

// optional .livekit.proto.TrackSource track_source = 3;
inline bool AudioStreamFromParticipantRequest::_internal_has_track_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_track_source() const {
  return _internal_has_track_source();
}
inline void AudioStreamFromParticipantRequest::clear_track_source() {
  _impl_.track_source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::proto::TrackSource AudioStreamFromParticipantRequest::_internal_track_source() const {
  return static_cast< ::livekit::proto::TrackSource >(_impl_.track_source_);
}
inline ::livekit::proto::TrackSource AudioStreamFromParticipantRequest::track_source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.track_source)
  return _internal_track_source();
}
inline void AudioStreamFromParticipantRequest::_internal_set_track_source(::livekit::proto::TrackSource value) {
  assert(::livekit::proto::TrackSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.track_source_ = value;
}
inline void AudioStreamFromParticipantRequest::set_track_source(::livekit::proto::TrackSource value) {
  _internal_set_track_source(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.track_source)
}

// optional uint32 sample_rate = 5;
inline bool AudioStreamFromParticipantRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void AudioStreamFromParticipantRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t AudioStreamFromParticipantRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t AudioStreamFromParticipantRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.sample_rate)
  return _internal_sample_rate();
}
inline void AudioStreamFromParticipantRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sample_rate_ = value;
}
inline void AudioStreamFromParticipantRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.sample_rate)
}

// optional uint32 num_channels = 6;
inline bool AudioStreamFromParticipantRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void AudioStreamFromParticipantRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AudioStreamFromParticipantRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t AudioStreamFromParticipantRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.num_channels)
  return _internal_num_channels();
}
inline void AudioStreamFromParticipantRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_channels_ = value;
}
inline void AudioStreamFromParticipantRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.num_channels)
}

// optional string audio_filter_module_id = 7;
inline bool AudioStreamFromParticipantRequest::_internal_has_audio_filter_module_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_audio_filter_module_id() const {
  return _internal_has_audio_filter_module_id();
}
inline void AudioStreamFromParticipantRequest::clear_audio_filter_module_id() {
  _impl_.audio_filter_module_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioStreamFromParticipantRequest::audio_filter_module_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id)
  return _internal_audio_filter_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioStreamFromParticipantRequest::set_audio_filter_module_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.audio_filter_module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id)
}
inline std::string* AudioStreamFromParticipantRequest::mutable_audio_filter_module_id() {
  std::string* _s = _internal_mutable_audio_filter_module_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id)
  return _s;
}
inline const std::string& AudioStreamFromParticipantRequest::_internal_audio_filter_module_id() const {
  return _impl_.audio_filter_module_id_.Get();
}
inline void AudioStreamFromParticipantRequest::_internal_set_audio_filter_module_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.audio_filter_module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioStreamFromParticipantRequest::_internal_mutable_audio_filter_module_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.audio_filter_module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioStreamFromParticipantRequest::release_audio_filter_module_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id)
  if (!_internal_has_audio_filter_module_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.audio_filter_module_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_module_id_.IsDefault()) {
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioStreamFromParticipantRequest::set_allocated_audio_filter_module_id(std::string* audio_filter_module_id) {
  if (audio_filter_module_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.audio_filter_module_id_.SetAllocated(audio_filter_module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_module_id_.IsDefault()) {
    _impl_.audio_filter_module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_module_id)
}

// optional string audio_filter_options = 8;
inline bool AudioStreamFromParticipantRequest::_internal_has_audio_filter_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioStreamFromParticipantRequest::has_audio_filter_options() const {
  return _internal_has_audio_filter_options();
}
inline void AudioStreamFromParticipantRequest::clear_audio_filter_options() {
  _impl_.audio_filter_options_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioStreamFromParticipantRequest::audio_filter_options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options)
  return _internal_audio_filter_options();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioStreamFromParticipantRequest::set_audio_filter_options(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.audio_filter_options_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options)
}
inline std::string* AudioStreamFromParticipantRequest::mutable_audio_filter_options() {
  std::string* _s = _internal_mutable_audio_filter_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options)
  return _s;
}
inline const std::string& AudioStreamFromParticipantRequest::_internal_audio_filter_options() const {
  return _impl_.audio_filter_options_.Get();
}
inline void AudioStreamFromParticipantRequest::_internal_set_audio_filter_options(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_filter_options_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioStreamFromParticipantRequest::_internal_mutable_audio_filter_options() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.audio_filter_options_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioStreamFromParticipantRequest::release_audio_filter_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options)
  if (!_internal_has_audio_filter_options()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.audio_filter_options_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_options_.IsDefault()) {
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioStreamFromParticipantRequest::set_allocated_audio_filter_options(std::string* audio_filter_options) {
  if (audio_filter_options != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.audio_filter_options_.SetAllocated(audio_filter_options, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audio_filter_options_.IsDefault()) {
    _impl_.audio_filter_options_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioStreamFromParticipantRequest.audio_filter_options)
}

// -------------------------------------------------------------------

// AudioStreamFromParticipantResponse

// required .livekit.proto.OwnedAudioStream stream = 1;
inline bool AudioStreamFromParticipantResponse::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
  return value;
}
inline bool AudioStreamFromParticipantResponse::has_stream() const {
  return _internal_has_stream();
}
inline void AudioStreamFromParticipantResponse::clear_stream() {
  if (_impl_.stream_ != nullptr) _impl_.stream_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioStream& AudioStreamFromParticipantResponse::_internal_stream() const {
  const ::livekit::proto::OwnedAudioStream* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioStream&>(
      ::livekit::proto::_OwnedAudioStream_default_instance_);
}
inline const ::livekit::proto::OwnedAudioStream& AudioStreamFromParticipantResponse::stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamFromParticipantResponse.stream)
  return _internal_stream();
}
inline void AudioStreamFromParticipantResponse::unsafe_arena_set_allocated_stream(
    ::livekit::proto::OwnedAudioStream* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.AudioStreamFromParticipantResponse.stream)
}
inline ::livekit::proto::OwnedAudioStream* AudioStreamFromParticipantResponse::release_stream() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioStream* AudioStreamFromParticipantResponse::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioStreamFromParticipantResponse.stream)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioStream* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioStream* AudioStreamFromParticipantResponse::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioStream>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::livekit::proto::OwnedAudioStream* AudioStreamFromParticipantResponse::mutable_stream() {
  ::livekit::proto::OwnedAudioStream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioStreamFromParticipantResponse.stream)
  return _msg;
}
inline void AudioStreamFromParticipantResponse::set_allocated_stream(::livekit::proto::OwnedAudioStream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioStreamFromParticipantResponse.stream)
}

// -------------------------------------------------------------------

// NewAudioSourceRequest

// required .livekit.proto.AudioSourceType type = 1;
inline bool NewAudioSourceRequest::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewAudioSourceRequest::has_type() const {
  return _internal_has_type();
}
inline void NewAudioSourceRequest::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::AudioSourceType NewAudioSourceRequest::_internal_type() const {
  return static_cast< ::livekit::proto::AudioSourceType >(_impl_.type_);
}
inline ::livekit::proto::AudioSourceType NewAudioSourceRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceRequest.type)
  return _internal_type();
}
inline void NewAudioSourceRequest::_internal_set_type(::livekit::proto::AudioSourceType value) {
  assert(::livekit::proto::AudioSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void NewAudioSourceRequest::set_type(::livekit::proto::AudioSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioSourceRequest.type)
}

// optional .livekit.proto.AudioSourceOptions options = 2;
inline bool NewAudioSourceRequest::_internal_has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline bool NewAudioSourceRequest::has_options() const {
  return _internal_has_options();
}
inline void NewAudioSourceRequest::clear_options() {
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::AudioSourceOptions& NewAudioSourceRequest::_internal_options() const {
  const ::livekit::proto::AudioSourceOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioSourceOptions&>(
      ::livekit::proto::_AudioSourceOptions_default_instance_);
}
inline const ::livekit::proto::AudioSourceOptions& NewAudioSourceRequest::options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceRequest.options)
  return _internal_options();
}
inline void NewAudioSourceRequest::unsafe_arena_set_allocated_options(
    ::livekit::proto::AudioSourceOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewAudioSourceRequest.options)
}
inline ::livekit::proto::AudioSourceOptions* NewAudioSourceRequest::release_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioSourceOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioSourceOptions* NewAudioSourceRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioSourceRequest.options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioSourceOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioSourceOptions* NewAudioSourceRequest::_internal_mutable_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioSourceOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::livekit::proto::AudioSourceOptions* NewAudioSourceRequest::mutable_options() {
  ::livekit::proto::AudioSourceOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioSourceRequest.options)
  return _msg;
}
inline void NewAudioSourceRequest::set_allocated_options(::livekit::proto::AudioSourceOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioSourceRequest.options)
}

// required uint32 sample_rate = 3;
inline bool NewAudioSourceRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewAudioSourceRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void NewAudioSourceRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t NewAudioSourceRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t NewAudioSourceRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceRequest.sample_rate)
  return _internal_sample_rate();
}
inline void NewAudioSourceRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sample_rate_ = value;
}
inline void NewAudioSourceRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioSourceRequest.sample_rate)
}

// required uint32 num_channels = 4;
inline bool NewAudioSourceRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewAudioSourceRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void NewAudioSourceRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t NewAudioSourceRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t NewAudioSourceRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceRequest.num_channels)
  return _internal_num_channels();
}
inline void NewAudioSourceRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.num_channels_ = value;
}
inline void NewAudioSourceRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioSourceRequest.num_channels)
}

// optional uint32 queue_size_ms = 5;
inline bool NewAudioSourceRequest::_internal_has_queue_size_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NewAudioSourceRequest::has_queue_size_ms() const {
  return _internal_has_queue_size_ms();
}
inline void NewAudioSourceRequest::clear_queue_size_ms() {
  _impl_.queue_size_ms_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t NewAudioSourceRequest::_internal_queue_size_ms() const {
  return _impl_.queue_size_ms_;
}
inline uint32_t NewAudioSourceRequest::queue_size_ms() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceRequest.queue_size_ms)
  return _internal_queue_size_ms();
}
inline void NewAudioSourceRequest::_internal_set_queue_size_ms(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.queue_size_ms_ = value;
}
inline void NewAudioSourceRequest::set_queue_size_ms(uint32_t value) {
  _internal_set_queue_size_ms(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewAudioSourceRequest.queue_size_ms)
}

// -------------------------------------------------------------------

// NewAudioSourceResponse

// required .livekit.proto.OwnedAudioSource source = 1;
inline bool NewAudioSourceResponse::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_ != nullptr);
  return value;
}
inline bool NewAudioSourceResponse::has_source() const {
  return _internal_has_source();
}
inline void NewAudioSourceResponse::clear_source() {
  if (_impl_.source_ != nullptr) _impl_.source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioSource& NewAudioSourceResponse::_internal_source() const {
  const ::livekit::proto::OwnedAudioSource* p = _impl_.source_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioSource&>(
      ::livekit::proto::_OwnedAudioSource_default_instance_);
}
inline const ::livekit::proto::OwnedAudioSource& NewAudioSourceResponse::source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioSourceResponse.source)
  return _internal_source();
}
inline void NewAudioSourceResponse::unsafe_arena_set_allocated_source(
    ::livekit::proto::OwnedAudioSource* source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_);
  }
  _impl_.source_ = source;
  if (source) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewAudioSourceResponse.source)
}
inline ::livekit::proto::OwnedAudioSource* NewAudioSourceResponse::release_source() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioSource* NewAudioSourceResponse::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioSourceResponse.source)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioSource* temp = _impl_.source_;
  _impl_.source_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioSource* NewAudioSourceResponse::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioSource>(GetArenaForAllocation());
    _impl_.source_ = p;
  }
  return _impl_.source_;
}
inline ::livekit::proto::OwnedAudioSource* NewAudioSourceResponse::mutable_source() {
  ::livekit::proto::OwnedAudioSource* _msg = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioSourceResponse.source)
  return _msg;
}
inline void NewAudioSourceResponse::set_allocated_source(::livekit::proto::OwnedAudioSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.source_ = source;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioSourceResponse.source)
}

// -------------------------------------------------------------------

// CaptureAudioFrameRequest

// required uint64 source_handle = 1;
inline bool CaptureAudioFrameRequest::_internal_has_source_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CaptureAudioFrameRequest::has_source_handle() const {
  return _internal_has_source_handle();
}
inline void CaptureAudioFrameRequest::clear_source_handle() {
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CaptureAudioFrameRequest::_internal_source_handle() const {
  return _impl_.source_handle_;
}
inline uint64_t CaptureAudioFrameRequest::source_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureAudioFrameRequest.source_handle)
  return _internal_source_handle();
}
inline void CaptureAudioFrameRequest::_internal_set_source_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.source_handle_ = value;
}
inline void CaptureAudioFrameRequest::set_source_handle(uint64_t value) {
  _internal_set_source_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureAudioFrameRequest.source_handle)
}

// required .livekit.proto.AudioFrameBufferInfo buffer = 2;
inline bool CaptureAudioFrameRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool CaptureAudioFrameRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void CaptureAudioFrameRequest::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::AudioFrameBufferInfo& CaptureAudioFrameRequest::_internal_buffer() const {
  const ::livekit::proto::AudioFrameBufferInfo* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioFrameBufferInfo&>(
      ::livekit::proto::_AudioFrameBufferInfo_default_instance_);
}
inline const ::livekit::proto::AudioFrameBufferInfo& CaptureAudioFrameRequest::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureAudioFrameRequest.buffer)
  return _internal_buffer();
}
inline void CaptureAudioFrameRequest::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::AudioFrameBufferInfo* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.CaptureAudioFrameRequest.buffer)
}
inline ::livekit::proto::AudioFrameBufferInfo* CaptureAudioFrameRequest::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* CaptureAudioFrameRequest::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.CaptureAudioFrameRequest.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* CaptureAudioFrameRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioFrameBufferInfo>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::AudioFrameBufferInfo* CaptureAudioFrameRequest::mutable_buffer() {
  ::livekit::proto::AudioFrameBufferInfo* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CaptureAudioFrameRequest.buffer)
  return _msg;
}
inline void CaptureAudioFrameRequest::set_allocated_buffer(::livekit::proto::AudioFrameBufferInfo* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CaptureAudioFrameRequest.buffer)
}

// -------------------------------------------------------------------

// CaptureAudioFrameResponse

// required uint64 async_id = 1;
inline bool CaptureAudioFrameResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CaptureAudioFrameResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void CaptureAudioFrameResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CaptureAudioFrameResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t CaptureAudioFrameResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureAudioFrameResponse.async_id)
  return _internal_async_id();
}
inline void CaptureAudioFrameResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void CaptureAudioFrameResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureAudioFrameResponse.async_id)
}

// -------------------------------------------------------------------

// CaptureAudioFrameCallback

// required uint64 async_id = 1;
inline bool CaptureAudioFrameCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CaptureAudioFrameCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void CaptureAudioFrameCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CaptureAudioFrameCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t CaptureAudioFrameCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureAudioFrameCallback.async_id)
  return _internal_async_id();
}
inline void CaptureAudioFrameCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void CaptureAudioFrameCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureAudioFrameCallback.async_id)
}

// optional string error = 2;
inline bool CaptureAudioFrameCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CaptureAudioFrameCallback::has_error() const {
  return _internal_has_error();
}
inline void CaptureAudioFrameCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CaptureAudioFrameCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.CaptureAudioFrameCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CaptureAudioFrameCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.CaptureAudioFrameCallback.error)
}
inline std::string* CaptureAudioFrameCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.CaptureAudioFrameCallback.error)
  return _s;
}
inline const std::string& CaptureAudioFrameCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void CaptureAudioFrameCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureAudioFrameCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* CaptureAudioFrameCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.CaptureAudioFrameCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CaptureAudioFrameCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.CaptureAudioFrameCallback.error)
}

// -------------------------------------------------------------------

// ClearAudioBufferRequest

// required uint64 source_handle = 1;
inline bool ClearAudioBufferRequest::_internal_has_source_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClearAudioBufferRequest::has_source_handle() const {
  return _internal_has_source_handle();
}
inline void ClearAudioBufferRequest::clear_source_handle() {
  _impl_.source_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ClearAudioBufferRequest::_internal_source_handle() const {
  return _impl_.source_handle_;
}
inline uint64_t ClearAudioBufferRequest::source_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ClearAudioBufferRequest.source_handle)
  return _internal_source_handle();
}
inline void ClearAudioBufferRequest::_internal_set_source_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.source_handle_ = value;
}
inline void ClearAudioBufferRequest::set_source_handle(uint64_t value) {
  _internal_set_source_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ClearAudioBufferRequest.source_handle)
}

// -------------------------------------------------------------------

// ClearAudioBufferResponse

// -------------------------------------------------------------------

// NewAudioResamplerRequest

// -------------------------------------------------------------------

// NewAudioResamplerResponse

// required .livekit.proto.OwnedAudioResampler resampler = 1;
inline bool NewAudioResamplerResponse::_internal_has_resampler() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resampler_ != nullptr);
  return value;
}
inline bool NewAudioResamplerResponse::has_resampler() const {
  return _internal_has_resampler();
}
inline void NewAudioResamplerResponse::clear_resampler() {
  if (_impl_.resampler_ != nullptr) _impl_.resampler_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioResampler& NewAudioResamplerResponse::_internal_resampler() const {
  const ::livekit::proto::OwnedAudioResampler* p = _impl_.resampler_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioResampler&>(
      ::livekit::proto::_OwnedAudioResampler_default_instance_);
}
inline const ::livekit::proto::OwnedAudioResampler& NewAudioResamplerResponse::resampler() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewAudioResamplerResponse.resampler)
  return _internal_resampler();
}
inline void NewAudioResamplerResponse::unsafe_arena_set_allocated_resampler(
    ::livekit::proto::OwnedAudioResampler* resampler) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resampler_);
  }
  _impl_.resampler_ = resampler;
  if (resampler) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewAudioResamplerResponse.resampler)
}
inline ::livekit::proto::OwnedAudioResampler* NewAudioResamplerResponse::release_resampler() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioResampler* temp = _impl_.resampler_;
  _impl_.resampler_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioResampler* NewAudioResamplerResponse::unsafe_arena_release_resampler() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewAudioResamplerResponse.resampler)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioResampler* temp = _impl_.resampler_;
  _impl_.resampler_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioResampler* NewAudioResamplerResponse::_internal_mutable_resampler() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.resampler_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioResampler>(GetArenaForAllocation());
    _impl_.resampler_ = p;
  }
  return _impl_.resampler_;
}
inline ::livekit::proto::OwnedAudioResampler* NewAudioResamplerResponse::mutable_resampler() {
  ::livekit::proto::OwnedAudioResampler* _msg = _internal_mutable_resampler();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewAudioResamplerResponse.resampler)
  return _msg;
}
inline void NewAudioResamplerResponse::set_allocated_resampler(::livekit::proto::OwnedAudioResampler* resampler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resampler_;
  }
  if (resampler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resampler);
    if (message_arena != submessage_arena) {
      resampler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resampler, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resampler_ = resampler;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewAudioResamplerResponse.resampler)
}

// -------------------------------------------------------------------

// RemixAndResampleRequest

// required uint64 resampler_handle = 1;
inline bool RemixAndResampleRequest::_internal_has_resampler_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemixAndResampleRequest::has_resampler_handle() const {
  return _internal_has_resampler_handle();
}
inline void RemixAndResampleRequest::clear_resampler_handle() {
  _impl_.resampler_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RemixAndResampleRequest::_internal_resampler_handle() const {
  return _impl_.resampler_handle_;
}
inline uint64_t RemixAndResampleRequest::resampler_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RemixAndResampleRequest.resampler_handle)
  return _internal_resampler_handle();
}
inline void RemixAndResampleRequest::_internal_set_resampler_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resampler_handle_ = value;
}
inline void RemixAndResampleRequest::set_resampler_handle(uint64_t value) {
  _internal_set_resampler_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RemixAndResampleRequest.resampler_handle)
}

// required .livekit.proto.AudioFrameBufferInfo buffer = 2;
inline bool RemixAndResampleRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool RemixAndResampleRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void RemixAndResampleRequest::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::AudioFrameBufferInfo& RemixAndResampleRequest::_internal_buffer() const {
  const ::livekit::proto::AudioFrameBufferInfo* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioFrameBufferInfo&>(
      ::livekit::proto::_AudioFrameBufferInfo_default_instance_);
}
inline const ::livekit::proto::AudioFrameBufferInfo& RemixAndResampleRequest::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RemixAndResampleRequest.buffer)
  return _internal_buffer();
}
inline void RemixAndResampleRequest::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::AudioFrameBufferInfo* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RemixAndResampleRequest.buffer)
}
inline ::livekit::proto::AudioFrameBufferInfo* RemixAndResampleRequest::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* RemixAndResampleRequest::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.RemixAndResampleRequest.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* RemixAndResampleRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioFrameBufferInfo>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::AudioFrameBufferInfo* RemixAndResampleRequest::mutable_buffer() {
  ::livekit::proto::AudioFrameBufferInfo* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RemixAndResampleRequest.buffer)
  return _msg;
}
inline void RemixAndResampleRequest::set_allocated_buffer(::livekit::proto::AudioFrameBufferInfo* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RemixAndResampleRequest.buffer)
}

// required uint32 num_channels = 3;
inline bool RemixAndResampleRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemixAndResampleRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void RemixAndResampleRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RemixAndResampleRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t RemixAndResampleRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RemixAndResampleRequest.num_channels)
  return _internal_num_channels();
}
inline void RemixAndResampleRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_channels_ = value;
}
inline void RemixAndResampleRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RemixAndResampleRequest.num_channels)
}

// required uint32 sample_rate = 4;
inline bool RemixAndResampleRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RemixAndResampleRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void RemixAndResampleRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RemixAndResampleRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t RemixAndResampleRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RemixAndResampleRequest.sample_rate)
  return _internal_sample_rate();
}
inline void RemixAndResampleRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sample_rate_ = value;
}
inline void RemixAndResampleRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RemixAndResampleRequest.sample_rate)
}

// -------------------------------------------------------------------

// RemixAndResampleResponse

// required .livekit.proto.OwnedAudioFrameBuffer buffer = 1;
inline bool RemixAndResampleResponse::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.buffer_ != nullptr);
  return value;
}
inline bool RemixAndResampleResponse::has_buffer() const {
  return _internal_has_buffer();
}
inline void RemixAndResampleResponse::clear_buffer() {
  if (_impl_.buffer_ != nullptr) _impl_.buffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioFrameBuffer& RemixAndResampleResponse::_internal_buffer() const {
  const ::livekit::proto::OwnedAudioFrameBuffer* p = _impl_.buffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioFrameBuffer&>(
      ::livekit::proto::_OwnedAudioFrameBuffer_default_instance_);
}
inline const ::livekit::proto::OwnedAudioFrameBuffer& RemixAndResampleResponse::buffer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RemixAndResampleResponse.buffer)
  return _internal_buffer();
}
inline void RemixAndResampleResponse::unsafe_arena_set_allocated_buffer(
    ::livekit::proto::OwnedAudioFrameBuffer* buffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.buffer_);
  }
  _impl_.buffer_ = buffer;
  if (buffer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RemixAndResampleResponse.buffer)
}
inline ::livekit::proto::OwnedAudioFrameBuffer* RemixAndResampleResponse::release_buffer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioFrameBuffer* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* RemixAndResampleResponse::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_release:livekit.proto.RemixAndResampleResponse.buffer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioFrameBuffer* temp = _impl_.buffer_;
  _impl_.buffer_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* RemixAndResampleResponse::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.buffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioFrameBuffer>(GetArenaForAllocation());
    _impl_.buffer_ = p;
  }
  return _impl_.buffer_;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* RemixAndResampleResponse::mutable_buffer() {
  ::livekit::proto::OwnedAudioFrameBuffer* _msg = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RemixAndResampleResponse.buffer)
  return _msg;
}
inline void RemixAndResampleResponse::set_allocated_buffer(::livekit::proto::OwnedAudioFrameBuffer* buffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.buffer_;
  }
  if (buffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buffer);
    if (message_arena != submessage_arena) {
      buffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_ = buffer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RemixAndResampleResponse.buffer)
}

// -------------------------------------------------------------------

// NewApmRequest

// required bool echo_canceller_enabled = 1;
inline bool NewApmRequest::_internal_has_echo_canceller_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewApmRequest::has_echo_canceller_enabled() const {
  return _internal_has_echo_canceller_enabled();
}
inline void NewApmRequest::clear_echo_canceller_enabled() {
  _impl_.echo_canceller_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool NewApmRequest::_internal_echo_canceller_enabled() const {
  return _impl_.echo_canceller_enabled_;
}
inline bool NewApmRequest::echo_canceller_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewApmRequest.echo_canceller_enabled)
  return _internal_echo_canceller_enabled();
}
inline void NewApmRequest::_internal_set_echo_canceller_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.echo_canceller_enabled_ = value;
}
inline void NewApmRequest::set_echo_canceller_enabled(bool value) {
  _internal_set_echo_canceller_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewApmRequest.echo_canceller_enabled)
}

// required bool gain_controller_enabled = 2;
inline bool NewApmRequest::_internal_has_gain_controller_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewApmRequest::has_gain_controller_enabled() const {
  return _internal_has_gain_controller_enabled();
}
inline void NewApmRequest::clear_gain_controller_enabled() {
  _impl_.gain_controller_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool NewApmRequest::_internal_gain_controller_enabled() const {
  return _impl_.gain_controller_enabled_;
}
inline bool NewApmRequest::gain_controller_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewApmRequest.gain_controller_enabled)
  return _internal_gain_controller_enabled();
}
inline void NewApmRequest::_internal_set_gain_controller_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gain_controller_enabled_ = value;
}
inline void NewApmRequest::set_gain_controller_enabled(bool value) {
  _internal_set_gain_controller_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewApmRequest.gain_controller_enabled)
}

// required bool high_pass_filter_enabled = 3;
inline bool NewApmRequest::_internal_has_high_pass_filter_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewApmRequest::has_high_pass_filter_enabled() const {
  return _internal_has_high_pass_filter_enabled();
}
inline void NewApmRequest::clear_high_pass_filter_enabled() {
  _impl_.high_pass_filter_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NewApmRequest::_internal_high_pass_filter_enabled() const {
  return _impl_.high_pass_filter_enabled_;
}
inline bool NewApmRequest::high_pass_filter_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewApmRequest.high_pass_filter_enabled)
  return _internal_high_pass_filter_enabled();
}
inline void NewApmRequest::_internal_set_high_pass_filter_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.high_pass_filter_enabled_ = value;
}
inline void NewApmRequest::set_high_pass_filter_enabled(bool value) {
  _internal_set_high_pass_filter_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewApmRequest.high_pass_filter_enabled)
}

// required bool noise_suppression_enabled = 4;
inline bool NewApmRequest::_internal_has_noise_suppression_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewApmRequest::has_noise_suppression_enabled() const {
  return _internal_has_noise_suppression_enabled();
}
inline void NewApmRequest::clear_noise_suppression_enabled() {
  _impl_.noise_suppression_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool NewApmRequest::_internal_noise_suppression_enabled() const {
  return _impl_.noise_suppression_enabled_;
}
inline bool NewApmRequest::noise_suppression_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewApmRequest.noise_suppression_enabled)
  return _internal_noise_suppression_enabled();
}
inline void NewApmRequest::_internal_set_noise_suppression_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.noise_suppression_enabled_ = value;
}
inline void NewApmRequest::set_noise_suppression_enabled(bool value) {
  _internal_set_noise_suppression_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewApmRequest.noise_suppression_enabled)
}

// -------------------------------------------------------------------

// NewApmResponse

// required .livekit.proto.OwnedApm apm = 1;
inline bool NewApmResponse::_internal_has_apm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.apm_ != nullptr);
  return value;
}
inline bool NewApmResponse::has_apm() const {
  return _internal_has_apm();
}
inline void NewApmResponse::clear_apm() {
  if (_impl_.apm_ != nullptr) _impl_.apm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedApm& NewApmResponse::_internal_apm() const {
  const ::livekit::proto::OwnedApm* p = _impl_.apm_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedApm&>(
      ::livekit::proto::_OwnedApm_default_instance_);
}
inline const ::livekit::proto::OwnedApm& NewApmResponse::apm() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewApmResponse.apm)
  return _internal_apm();
}
inline void NewApmResponse::unsafe_arena_set_allocated_apm(
    ::livekit::proto::OwnedApm* apm) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.apm_);
  }
  _impl_.apm_ = apm;
  if (apm) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewApmResponse.apm)
}
inline ::livekit::proto::OwnedApm* NewApmResponse::release_apm() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedApm* temp = _impl_.apm_;
  _impl_.apm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedApm* NewApmResponse::unsafe_arena_release_apm() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewApmResponse.apm)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedApm* temp = _impl_.apm_;
  _impl_.apm_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedApm* NewApmResponse::_internal_mutable_apm() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.apm_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedApm>(GetArenaForAllocation());
    _impl_.apm_ = p;
  }
  return _impl_.apm_;
}
inline ::livekit::proto::OwnedApm* NewApmResponse::mutable_apm() {
  ::livekit::proto::OwnedApm* _msg = _internal_mutable_apm();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewApmResponse.apm)
  return _msg;
}
inline void NewApmResponse::set_allocated_apm(::livekit::proto::OwnedApm* apm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.apm_;
  }
  if (apm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apm);
    if (message_arena != submessage_arena) {
      apm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apm, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.apm_ = apm;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewApmResponse.apm)
}

// -------------------------------------------------------------------

// ApmProcessStreamRequest

// required uint64 apm_handle = 1;
inline bool ApmProcessStreamRequest::_internal_has_apm_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApmProcessStreamRequest::has_apm_handle() const {
  return _internal_has_apm_handle();
}
inline void ApmProcessStreamRequest::clear_apm_handle() {
  _impl_.apm_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ApmProcessStreamRequest::_internal_apm_handle() const {
  return _impl_.apm_handle_;
}
inline uint64_t ApmProcessStreamRequest::apm_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamRequest.apm_handle)
  return _internal_apm_handle();
}
inline void ApmProcessStreamRequest::_internal_set_apm_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.apm_handle_ = value;
}
inline void ApmProcessStreamRequest::set_apm_handle(uint64_t value) {
  _internal_set_apm_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamRequest.apm_handle)
}

// required uint64 data_ptr = 2;
inline bool ApmProcessStreamRequest::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApmProcessStreamRequest::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void ApmProcessStreamRequest::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ApmProcessStreamRequest::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t ApmProcessStreamRequest::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamRequest.data_ptr)
  return _internal_data_ptr();
}
inline void ApmProcessStreamRequest::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_ptr_ = value;
}
inline void ApmProcessStreamRequest::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamRequest.data_ptr)
}

// required uint32 size = 3;
inline bool ApmProcessStreamRequest::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApmProcessStreamRequest::has_size() const {
  return _internal_has_size();
}
inline void ApmProcessStreamRequest::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ApmProcessStreamRequest::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t ApmProcessStreamRequest::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamRequest.size)
  return _internal_size();
}
inline void ApmProcessStreamRequest::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void ApmProcessStreamRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamRequest.size)
}

// required uint32 sample_rate = 4;
inline bool ApmProcessStreamRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApmProcessStreamRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void ApmProcessStreamRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ApmProcessStreamRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t ApmProcessStreamRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamRequest.sample_rate)
  return _internal_sample_rate();
}
inline void ApmProcessStreamRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sample_rate_ = value;
}
inline void ApmProcessStreamRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamRequest.sample_rate)
}

// required uint32 num_channels = 5;
inline bool ApmProcessStreamRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApmProcessStreamRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void ApmProcessStreamRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApmProcessStreamRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t ApmProcessStreamRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamRequest.num_channels)
  return _internal_num_channels();
}
inline void ApmProcessStreamRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.num_channels_ = value;
}
inline void ApmProcessStreamRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamRequest.num_channels)
}

// -------------------------------------------------------------------

// ApmProcessStreamResponse

// optional string error = 1;
inline bool ApmProcessStreamResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApmProcessStreamResponse::has_error() const {
  return _internal_has_error();
}
inline void ApmProcessStreamResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApmProcessStreamResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessStreamResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApmProcessStreamResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessStreamResponse.error)
}
inline std::string* ApmProcessStreamResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ApmProcessStreamResponse.error)
  return _s;
}
inline const std::string& ApmProcessStreamResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ApmProcessStreamResponse::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ApmProcessStreamResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* ApmProcessStreamResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.ApmProcessStreamResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApmProcessStreamResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ApmProcessStreamResponse.error)
}

// -------------------------------------------------------------------

// ApmProcessReverseStreamRequest

// required uint64 apm_handle = 1;
inline bool ApmProcessReverseStreamRequest::_internal_has_apm_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamRequest::has_apm_handle() const {
  return _internal_has_apm_handle();
}
inline void ApmProcessReverseStreamRequest::clear_apm_handle() {
  _impl_.apm_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ApmProcessReverseStreamRequest::_internal_apm_handle() const {
  return _impl_.apm_handle_;
}
inline uint64_t ApmProcessReverseStreamRequest::apm_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamRequest.apm_handle)
  return _internal_apm_handle();
}
inline void ApmProcessReverseStreamRequest::_internal_set_apm_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.apm_handle_ = value;
}
inline void ApmProcessReverseStreamRequest::set_apm_handle(uint64_t value) {
  _internal_set_apm_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamRequest.apm_handle)
}

// required uint64 data_ptr = 2;
inline bool ApmProcessReverseStreamRequest::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamRequest::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void ApmProcessReverseStreamRequest::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ApmProcessReverseStreamRequest::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t ApmProcessReverseStreamRequest::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamRequest.data_ptr)
  return _internal_data_ptr();
}
inline void ApmProcessReverseStreamRequest::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_ptr_ = value;
}
inline void ApmProcessReverseStreamRequest::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamRequest.data_ptr)
}

// required uint32 size = 3;
inline bool ApmProcessReverseStreamRequest::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamRequest::has_size() const {
  return _internal_has_size();
}
inline void ApmProcessReverseStreamRequest::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ApmProcessReverseStreamRequest::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t ApmProcessReverseStreamRequest::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamRequest.size)
  return _internal_size();
}
inline void ApmProcessReverseStreamRequest::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void ApmProcessReverseStreamRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamRequest.size)
}

// required uint32 sample_rate = 4;
inline bool ApmProcessReverseStreamRequest::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamRequest::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void ApmProcessReverseStreamRequest::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ApmProcessReverseStreamRequest::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t ApmProcessReverseStreamRequest::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamRequest.sample_rate)
  return _internal_sample_rate();
}
inline void ApmProcessReverseStreamRequest::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sample_rate_ = value;
}
inline void ApmProcessReverseStreamRequest::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamRequest.sample_rate)
}

// required uint32 num_channels = 5;
inline bool ApmProcessReverseStreamRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void ApmProcessReverseStreamRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ApmProcessReverseStreamRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t ApmProcessReverseStreamRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamRequest.num_channels)
  return _internal_num_channels();
}
inline void ApmProcessReverseStreamRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.num_channels_ = value;
}
inline void ApmProcessReverseStreamRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamRequest.num_channels)
}

// -------------------------------------------------------------------

// ApmProcessReverseStreamResponse

// optional string error = 1;
inline bool ApmProcessReverseStreamResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApmProcessReverseStreamResponse::has_error() const {
  return _internal_has_error();
}
inline void ApmProcessReverseStreamResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApmProcessReverseStreamResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ApmProcessReverseStreamResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ApmProcessReverseStreamResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ApmProcessReverseStreamResponse.error)
}
inline std::string* ApmProcessReverseStreamResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ApmProcessReverseStreamResponse.error)
  return _s;
}
inline const std::string& ApmProcessReverseStreamResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void ApmProcessReverseStreamResponse::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ApmProcessReverseStreamResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* ApmProcessReverseStreamResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.ApmProcessReverseStreamResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ApmProcessReverseStreamResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ApmProcessReverseStreamResponse.error)
}

// -------------------------------------------------------------------

// NewSoxResamplerRequest

// required double input_rate = 1;
inline bool NewSoxResamplerRequest::_internal_has_input_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_input_rate() const {
  return _internal_has_input_rate();
}
inline void NewSoxResamplerRequest::clear_input_rate() {
  _impl_.input_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double NewSoxResamplerRequest::_internal_input_rate() const {
  return _impl_.input_rate_;
}
inline double NewSoxResamplerRequest::input_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.input_rate)
  return _internal_input_rate();
}
inline void NewSoxResamplerRequest::_internal_set_input_rate(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.input_rate_ = value;
}
inline void NewSoxResamplerRequest::set_input_rate(double value) {
  _internal_set_input_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.input_rate)
}

// required double output_rate = 2;
inline bool NewSoxResamplerRequest::_internal_has_output_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_output_rate() const {
  return _internal_has_output_rate();
}
inline void NewSoxResamplerRequest::clear_output_rate() {
  _impl_.output_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double NewSoxResamplerRequest::_internal_output_rate() const {
  return _impl_.output_rate_;
}
inline double NewSoxResamplerRequest::output_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.output_rate)
  return _internal_output_rate();
}
inline void NewSoxResamplerRequest::_internal_set_output_rate(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.output_rate_ = value;
}
inline void NewSoxResamplerRequest::set_output_rate(double value) {
  _internal_set_output_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.output_rate)
}

// required uint32 num_channels = 3;
inline bool NewSoxResamplerRequest::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void NewSoxResamplerRequest::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t NewSoxResamplerRequest::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t NewSoxResamplerRequest::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.num_channels)
  return _internal_num_channels();
}
inline void NewSoxResamplerRequest::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.num_channels_ = value;
}
inline void NewSoxResamplerRequest::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.num_channels)
}

// required .livekit.proto.SoxResamplerDataType input_data_type = 4;
inline bool NewSoxResamplerRequest::_internal_has_input_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_input_data_type() const {
  return _internal_has_input_data_type();
}
inline void NewSoxResamplerRequest::clear_input_data_type() {
  _impl_.input_data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::SoxResamplerDataType NewSoxResamplerRequest::_internal_input_data_type() const {
  return static_cast< ::livekit::proto::SoxResamplerDataType >(_impl_.input_data_type_);
}
inline ::livekit::proto::SoxResamplerDataType NewSoxResamplerRequest::input_data_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.input_data_type)
  return _internal_input_data_type();
}
inline void NewSoxResamplerRequest::_internal_set_input_data_type(::livekit::proto::SoxResamplerDataType value) {
  assert(::livekit::proto::SoxResamplerDataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.input_data_type_ = value;
}
inline void NewSoxResamplerRequest::set_input_data_type(::livekit::proto::SoxResamplerDataType value) {
  _internal_set_input_data_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.input_data_type)
}

// required .livekit.proto.SoxResamplerDataType output_data_type = 5;
inline bool NewSoxResamplerRequest::_internal_has_output_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_output_data_type() const {
  return _internal_has_output_data_type();
}
inline void NewSoxResamplerRequest::clear_output_data_type() {
  _impl_.output_data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::livekit::proto::SoxResamplerDataType NewSoxResamplerRequest::_internal_output_data_type() const {
  return static_cast< ::livekit::proto::SoxResamplerDataType >(_impl_.output_data_type_);
}
inline ::livekit::proto::SoxResamplerDataType NewSoxResamplerRequest::output_data_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.output_data_type)
  return _internal_output_data_type();
}
inline void NewSoxResamplerRequest::_internal_set_output_data_type(::livekit::proto::SoxResamplerDataType value) {
  assert(::livekit::proto::SoxResamplerDataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.output_data_type_ = value;
}
inline void NewSoxResamplerRequest::set_output_data_type(::livekit::proto::SoxResamplerDataType value) {
  _internal_set_output_data_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.output_data_type)
}

// required .livekit.proto.SoxQualityRecipe quality_recipe = 6;
inline bool NewSoxResamplerRequest::_internal_has_quality_recipe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_quality_recipe() const {
  return _internal_has_quality_recipe();
}
inline void NewSoxResamplerRequest::clear_quality_recipe() {
  _impl_.quality_recipe_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::livekit::proto::SoxQualityRecipe NewSoxResamplerRequest::_internal_quality_recipe() const {
  return static_cast< ::livekit::proto::SoxQualityRecipe >(_impl_.quality_recipe_);
}
inline ::livekit::proto::SoxQualityRecipe NewSoxResamplerRequest::quality_recipe() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.quality_recipe)
  return _internal_quality_recipe();
}
inline void NewSoxResamplerRequest::_internal_set_quality_recipe(::livekit::proto::SoxQualityRecipe value) {
  assert(::livekit::proto::SoxQualityRecipe_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.quality_recipe_ = value;
}
inline void NewSoxResamplerRequest::set_quality_recipe(::livekit::proto::SoxQualityRecipe value) {
  _internal_set_quality_recipe(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.quality_recipe)
}

// optional uint32 flags = 7;
inline bool NewSoxResamplerRequest::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NewSoxResamplerRequest::has_flags() const {
  return _internal_has_flags();
}
inline void NewSoxResamplerRequest::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t NewSoxResamplerRequest::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t NewSoxResamplerRequest::flags() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerRequest.flags)
  return _internal_flags();
}
inline void NewSoxResamplerRequest::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.flags_ = value;
}
inline void NewSoxResamplerRequest::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerRequest.flags)
}

// -------------------------------------------------------------------

// NewSoxResamplerResponse

// .livekit.proto.OwnedSoxResampler resampler = 1;
inline bool NewSoxResamplerResponse::_internal_has_resampler() const {
  return message_case() == kResampler;
}
inline bool NewSoxResamplerResponse::has_resampler() const {
  return _internal_has_resampler();
}
inline void NewSoxResamplerResponse::set_has_resampler() {
  _impl_._oneof_case_[0] = kResampler;
}
inline void NewSoxResamplerResponse::clear_resampler() {
  if (_internal_has_resampler()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.resampler_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::OwnedSoxResampler* NewSoxResamplerResponse::release_resampler() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewSoxResamplerResponse.resampler)
  if (_internal_has_resampler()) {
    clear_has_message();
    ::livekit::proto::OwnedSoxResampler* temp = _impl_.message_.resampler_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.resampler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::OwnedSoxResampler& NewSoxResamplerResponse::_internal_resampler() const {
  return _internal_has_resampler()
      ? *_impl_.message_.resampler_
      : reinterpret_cast< ::livekit::proto::OwnedSoxResampler&>(::livekit::proto::_OwnedSoxResampler_default_instance_);
}
inline const ::livekit::proto::OwnedSoxResampler& NewSoxResamplerResponse::resampler() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerResponse.resampler)
  return _internal_resampler();
}
inline ::livekit::proto::OwnedSoxResampler* NewSoxResamplerResponse::unsafe_arena_release_resampler() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.NewSoxResamplerResponse.resampler)
  if (_internal_has_resampler()) {
    clear_has_message();
    ::livekit::proto::OwnedSoxResampler* temp = _impl_.message_.resampler_;
    _impl_.message_.resampler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NewSoxResamplerResponse::unsafe_arena_set_allocated_resampler(::livekit::proto::OwnedSoxResampler* resampler) {
  clear_message();
  if (resampler) {
    set_has_resampler();
    _impl_.message_.resampler_ = resampler;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.NewSoxResamplerResponse.resampler)
}
inline ::livekit::proto::OwnedSoxResampler* NewSoxResamplerResponse::_internal_mutable_resampler() {
  if (!_internal_has_resampler()) {
    clear_message();
    set_has_resampler();
    _impl_.message_.resampler_ = CreateMaybeMessage< ::livekit::proto::OwnedSoxResampler >(GetArenaForAllocation());
  }
  return _impl_.message_.resampler_;
}
inline ::livekit::proto::OwnedSoxResampler* NewSoxResamplerResponse::mutable_resampler() {
  ::livekit::proto::OwnedSoxResampler* _msg = _internal_mutable_resampler();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewSoxResamplerResponse.resampler)
  return _msg;
}

// string error = 2;
inline bool NewSoxResamplerResponse::_internal_has_error() const {
  return message_case() == kError;
}
inline bool NewSoxResamplerResponse::has_error() const {
  return _internal_has_error();
}
inline void NewSoxResamplerResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void NewSoxResamplerResponse::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& NewSoxResamplerResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.NewSoxResamplerResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void NewSoxResamplerResponse::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.NewSoxResamplerResponse.error)
}
inline std::string* NewSoxResamplerResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.NewSoxResamplerResponse.error)
  return _s;
}
inline const std::string& NewSoxResamplerResponse::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void NewSoxResamplerResponse::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* NewSoxResamplerResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* NewSoxResamplerResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.NewSoxResamplerResponse.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void NewSoxResamplerResponse::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.NewSoxResamplerResponse.error)
}

inline bool NewSoxResamplerResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void NewSoxResamplerResponse::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline NewSoxResamplerResponse::MessageCase NewSoxResamplerResponse::message_case() const {
  return NewSoxResamplerResponse::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PushSoxResamplerRequest

// required uint64 resampler_handle = 1;
inline bool PushSoxResamplerRequest::_internal_has_resampler_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PushSoxResamplerRequest::has_resampler_handle() const {
  return _internal_has_resampler_handle();
}
inline void PushSoxResamplerRequest::clear_resampler_handle() {
  _impl_.resampler_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PushSoxResamplerRequest::_internal_resampler_handle() const {
  return _impl_.resampler_handle_;
}
inline uint64_t PushSoxResamplerRequest::resampler_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerRequest.resampler_handle)
  return _internal_resampler_handle();
}
inline void PushSoxResamplerRequest::_internal_set_resampler_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resampler_handle_ = value;
}
inline void PushSoxResamplerRequest::set_resampler_handle(uint64_t value) {
  _internal_set_resampler_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerRequest.resampler_handle)
}

// required uint64 data_ptr = 2;
inline bool PushSoxResamplerRequest::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PushSoxResamplerRequest::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void PushSoxResamplerRequest::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PushSoxResamplerRequest::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t PushSoxResamplerRequest::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerRequest.data_ptr)
  return _internal_data_ptr();
}
inline void PushSoxResamplerRequest::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_ptr_ = value;
}
inline void PushSoxResamplerRequest::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerRequest.data_ptr)
}

// required uint32 size = 3;
inline bool PushSoxResamplerRequest::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PushSoxResamplerRequest::has_size() const {
  return _internal_has_size();
}
inline void PushSoxResamplerRequest::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PushSoxResamplerRequest::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t PushSoxResamplerRequest::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerRequest.size)
  return _internal_size();
}
inline void PushSoxResamplerRequest::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void PushSoxResamplerRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerRequest.size)
}

// -------------------------------------------------------------------

// PushSoxResamplerResponse

// required uint64 output_ptr = 1;
inline bool PushSoxResamplerResponse::_internal_has_output_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PushSoxResamplerResponse::has_output_ptr() const {
  return _internal_has_output_ptr();
}
inline void PushSoxResamplerResponse::clear_output_ptr() {
  _impl_.output_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PushSoxResamplerResponse::_internal_output_ptr() const {
  return _impl_.output_ptr_;
}
inline uint64_t PushSoxResamplerResponse::output_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerResponse.output_ptr)
  return _internal_output_ptr();
}
inline void PushSoxResamplerResponse::_internal_set_output_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.output_ptr_ = value;
}
inline void PushSoxResamplerResponse::set_output_ptr(uint64_t value) {
  _internal_set_output_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerResponse.output_ptr)
}

// required uint32 size = 2;
inline bool PushSoxResamplerResponse::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PushSoxResamplerResponse::has_size() const {
  return _internal_has_size();
}
inline void PushSoxResamplerResponse::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PushSoxResamplerResponse::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t PushSoxResamplerResponse::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerResponse.size)
  return _internal_size();
}
inline void PushSoxResamplerResponse::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void PushSoxResamplerResponse::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerResponse.size)
}

// optional string error = 3;
inline bool PushSoxResamplerResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PushSoxResamplerResponse::has_error() const {
  return _internal_has_error();
}
inline void PushSoxResamplerResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PushSoxResamplerResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PushSoxResamplerResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushSoxResamplerResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PushSoxResamplerResponse.error)
}
inline std::string* PushSoxResamplerResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PushSoxResamplerResponse.error)
  return _s;
}
inline const std::string& PushSoxResamplerResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PushSoxResamplerResponse::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PushSoxResamplerResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PushSoxResamplerResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.PushSoxResamplerResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PushSoxResamplerResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PushSoxResamplerResponse.error)
}

// -------------------------------------------------------------------

// FlushSoxResamplerRequest

// required uint64 resampler_handle = 1;
inline bool FlushSoxResamplerRequest::_internal_has_resampler_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlushSoxResamplerRequest::has_resampler_handle() const {
  return _internal_has_resampler_handle();
}
inline void FlushSoxResamplerRequest::clear_resampler_handle() {
  _impl_.resampler_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t FlushSoxResamplerRequest::_internal_resampler_handle() const {
  return _impl_.resampler_handle_;
}
inline uint64_t FlushSoxResamplerRequest::resampler_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FlushSoxResamplerRequest.resampler_handle)
  return _internal_resampler_handle();
}
inline void FlushSoxResamplerRequest::_internal_set_resampler_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resampler_handle_ = value;
}
inline void FlushSoxResamplerRequest::set_resampler_handle(uint64_t value) {
  _internal_set_resampler_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FlushSoxResamplerRequest.resampler_handle)
}

// -------------------------------------------------------------------

// FlushSoxResamplerResponse

// required uint64 output_ptr = 1;
inline bool FlushSoxResamplerResponse::_internal_has_output_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FlushSoxResamplerResponse::has_output_ptr() const {
  return _internal_has_output_ptr();
}
inline void FlushSoxResamplerResponse::clear_output_ptr() {
  _impl_.output_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t FlushSoxResamplerResponse::_internal_output_ptr() const {
  return _impl_.output_ptr_;
}
inline uint64_t FlushSoxResamplerResponse::output_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FlushSoxResamplerResponse.output_ptr)
  return _internal_output_ptr();
}
inline void FlushSoxResamplerResponse::_internal_set_output_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.output_ptr_ = value;
}
inline void FlushSoxResamplerResponse::set_output_ptr(uint64_t value) {
  _internal_set_output_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FlushSoxResamplerResponse.output_ptr)
}

// required uint32 size = 2;
inline bool FlushSoxResamplerResponse::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FlushSoxResamplerResponse::has_size() const {
  return _internal_has_size();
}
inline void FlushSoxResamplerResponse::clear_size() {
  _impl_.size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t FlushSoxResamplerResponse::_internal_size() const {
  return _impl_.size_;
}
inline uint32_t FlushSoxResamplerResponse::size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FlushSoxResamplerResponse.size)
  return _internal_size();
}
inline void FlushSoxResamplerResponse::_internal_set_size(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void FlushSoxResamplerResponse::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FlushSoxResamplerResponse.size)
}

// optional string error = 3;
inline bool FlushSoxResamplerResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlushSoxResamplerResponse::has_error() const {
  return _internal_has_error();
}
inline void FlushSoxResamplerResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlushSoxResamplerResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FlushSoxResamplerResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlushSoxResamplerResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FlushSoxResamplerResponse.error)
}
inline std::string* FlushSoxResamplerResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FlushSoxResamplerResponse.error)
  return _s;
}
inline const std::string& FlushSoxResamplerResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void FlushSoxResamplerResponse::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* FlushSoxResamplerResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* FlushSoxResamplerResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.FlushSoxResamplerResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FlushSoxResamplerResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FlushSoxResamplerResponse.error)
}

// -------------------------------------------------------------------

// AudioFrameBufferInfo

// required uint64 data_ptr = 1;
inline bool AudioFrameBufferInfo::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioFrameBufferInfo::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void AudioFrameBufferInfo::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AudioFrameBufferInfo::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t AudioFrameBufferInfo::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioFrameBufferInfo.data_ptr)
  return _internal_data_ptr();
}
inline void AudioFrameBufferInfo::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_ptr_ = value;
}
inline void AudioFrameBufferInfo::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioFrameBufferInfo.data_ptr)
}

// required uint32 num_channels = 2;
inline bool AudioFrameBufferInfo::_internal_has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioFrameBufferInfo::has_num_channels() const {
  return _internal_has_num_channels();
}
inline void AudioFrameBufferInfo::clear_num_channels() {
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AudioFrameBufferInfo::_internal_num_channels() const {
  return _impl_.num_channels_;
}
inline uint32_t AudioFrameBufferInfo::num_channels() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioFrameBufferInfo.num_channels)
  return _internal_num_channels();
}
inline void AudioFrameBufferInfo::_internal_set_num_channels(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.num_channels_ = value;
}
inline void AudioFrameBufferInfo::set_num_channels(uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioFrameBufferInfo.num_channels)
}

// required uint32 sample_rate = 3;
inline bool AudioFrameBufferInfo::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioFrameBufferInfo::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void AudioFrameBufferInfo::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t AudioFrameBufferInfo::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t AudioFrameBufferInfo::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioFrameBufferInfo.sample_rate)
  return _internal_sample_rate();
}
inline void AudioFrameBufferInfo::_internal_set_sample_rate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sample_rate_ = value;
}
inline void AudioFrameBufferInfo::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioFrameBufferInfo.sample_rate)
}

// required uint32 samples_per_channel = 4;
inline bool AudioFrameBufferInfo::_internal_has_samples_per_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioFrameBufferInfo::has_samples_per_channel() const {
  return _internal_has_samples_per_channel();
}
inline void AudioFrameBufferInfo::clear_samples_per_channel() {
  _impl_.samples_per_channel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t AudioFrameBufferInfo::_internal_samples_per_channel() const {
  return _impl_.samples_per_channel_;
}
inline uint32_t AudioFrameBufferInfo::samples_per_channel() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioFrameBufferInfo.samples_per_channel)
  return _internal_samples_per_channel();
}
inline void AudioFrameBufferInfo::_internal_set_samples_per_channel(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.samples_per_channel_ = value;
}
inline void AudioFrameBufferInfo::set_samples_per_channel(uint32_t value) {
  _internal_set_samples_per_channel(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioFrameBufferInfo.samples_per_channel)
}

// -------------------------------------------------------------------

// OwnedAudioFrameBuffer

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedAudioFrameBuffer::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedAudioFrameBuffer::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioFrameBuffer::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioFrameBuffer::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioFrameBuffer.handle)
  return _internal_handle();
}
inline void OwnedAudioFrameBuffer::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioFrameBuffer.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioFrameBuffer::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioFrameBuffer::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioFrameBuffer.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioFrameBuffer::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioFrameBuffer::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioFrameBuffer.handle)
  return _msg;
}
inline void OwnedAudioFrameBuffer::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioFrameBuffer.handle)
}

// required .livekit.proto.AudioFrameBufferInfo info = 2;
inline bool OwnedAudioFrameBuffer::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedAudioFrameBuffer::has_info() const {
  return _internal_has_info();
}
inline void OwnedAudioFrameBuffer::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::AudioFrameBufferInfo& OwnedAudioFrameBuffer::_internal_info() const {
  const ::livekit::proto::AudioFrameBufferInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioFrameBufferInfo&>(
      ::livekit::proto::_AudioFrameBufferInfo_default_instance_);
}
inline const ::livekit::proto::AudioFrameBufferInfo& OwnedAudioFrameBuffer::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioFrameBuffer.info)
  return _internal_info();
}
inline void OwnedAudioFrameBuffer::unsafe_arena_set_allocated_info(
    ::livekit::proto::AudioFrameBufferInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioFrameBuffer.info)
}
inline ::livekit::proto::AudioFrameBufferInfo* OwnedAudioFrameBuffer::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* OwnedAudioFrameBuffer::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioFrameBuffer.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioFrameBufferInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioFrameBufferInfo* OwnedAudioFrameBuffer::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioFrameBufferInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::AudioFrameBufferInfo* OwnedAudioFrameBuffer::mutable_info() {
  ::livekit::proto::AudioFrameBufferInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioFrameBuffer.info)
  return _msg;
}
inline void OwnedAudioFrameBuffer::set_allocated_info(::livekit::proto::AudioFrameBufferInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioFrameBuffer.info)
}

// -------------------------------------------------------------------

// AudioStreamInfo

// required .livekit.proto.AudioStreamType type = 1;
inline bool AudioStreamInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioStreamInfo::has_type() const {
  return _internal_has_type();
}
inline void AudioStreamInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::AudioStreamType AudioStreamInfo::_internal_type() const {
  return static_cast< ::livekit::proto::AudioStreamType >(_impl_.type_);
}
inline ::livekit::proto::AudioStreamType AudioStreamInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamInfo.type)
  return _internal_type();
}
inline void AudioStreamInfo::_internal_set_type(::livekit::proto::AudioStreamType value) {
  assert(::livekit::proto::AudioStreamType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void AudioStreamInfo::set_type(::livekit::proto::AudioStreamType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamInfo.type)
}

// -------------------------------------------------------------------

// OwnedAudioStream

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedAudioStream::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedAudioStream::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioStream::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioStream::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioStream.handle)
  return _internal_handle();
}
inline void OwnedAudioStream::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioStream.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioStream::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioStream::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioStream.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioStream::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioStream::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioStream.handle)
  return _msg;
}
inline void OwnedAudioStream::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioStream.handle)
}

// required .livekit.proto.AudioStreamInfo info = 2;
inline bool OwnedAudioStream::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedAudioStream::has_info() const {
  return _internal_has_info();
}
inline void OwnedAudioStream::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::AudioStreamInfo& OwnedAudioStream::_internal_info() const {
  const ::livekit::proto::AudioStreamInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioStreamInfo&>(
      ::livekit::proto::_AudioStreamInfo_default_instance_);
}
inline const ::livekit::proto::AudioStreamInfo& OwnedAudioStream::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioStream.info)
  return _internal_info();
}
inline void OwnedAudioStream::unsafe_arena_set_allocated_info(
    ::livekit::proto::AudioStreamInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioStream.info)
}
inline ::livekit::proto::AudioStreamInfo* OwnedAudioStream::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioStreamInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioStreamInfo* OwnedAudioStream::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioStream.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioStreamInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioStreamInfo* OwnedAudioStream::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioStreamInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::AudioStreamInfo* OwnedAudioStream::mutable_info() {
  ::livekit::proto::AudioStreamInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioStream.info)
  return _msg;
}
inline void OwnedAudioStream::set_allocated_info(::livekit::proto::AudioStreamInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioStream.info)
}

// -------------------------------------------------------------------

// AudioStreamEvent

// required uint64 stream_handle = 1;
inline bool AudioStreamEvent::_internal_has_stream_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioStreamEvent::has_stream_handle() const {
  return _internal_has_stream_handle();
}
inline void AudioStreamEvent::clear_stream_handle() {
  _impl_.stream_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AudioStreamEvent::_internal_stream_handle() const {
  return _impl_.stream_handle_;
}
inline uint64_t AudioStreamEvent::stream_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamEvent.stream_handle)
  return _internal_stream_handle();
}
inline void AudioStreamEvent::_internal_set_stream_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_handle_ = value;
}
inline void AudioStreamEvent::set_stream_handle(uint64_t value) {
  _internal_set_stream_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioStreamEvent.stream_handle)
}

// .livekit.proto.AudioFrameReceived frame_received = 2;
inline bool AudioStreamEvent::_internal_has_frame_received() const {
  return message_case() == kFrameReceived;
}
inline bool AudioStreamEvent::has_frame_received() const {
  return _internal_has_frame_received();
}
inline void AudioStreamEvent::set_has_frame_received() {
  _impl_._oneof_case_[0] = kFrameReceived;
}
inline void AudioStreamEvent::clear_frame_received() {
  if (_internal_has_frame_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.frame_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::AudioFrameReceived* AudioStreamEvent::release_frame_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioStreamEvent.frame_received)
  if (_internal_has_frame_received()) {
    clear_has_message();
    ::livekit::proto::AudioFrameReceived* temp = _impl_.message_.frame_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.frame_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::AudioFrameReceived& AudioStreamEvent::_internal_frame_received() const {
  return _internal_has_frame_received()
      ? *_impl_.message_.frame_received_
      : reinterpret_cast< ::livekit::proto::AudioFrameReceived&>(::livekit::proto::_AudioFrameReceived_default_instance_);
}
inline const ::livekit::proto::AudioFrameReceived& AudioStreamEvent::frame_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamEvent.frame_received)
  return _internal_frame_received();
}
inline ::livekit::proto::AudioFrameReceived* AudioStreamEvent::unsafe_arena_release_frame_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.AudioStreamEvent.frame_received)
  if (_internal_has_frame_received()) {
    clear_has_message();
    ::livekit::proto::AudioFrameReceived* temp = _impl_.message_.frame_received_;
    _impl_.message_.frame_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioStreamEvent::unsafe_arena_set_allocated_frame_received(::livekit::proto::AudioFrameReceived* frame_received) {
  clear_message();
  if (frame_received) {
    set_has_frame_received();
    _impl_.message_.frame_received_ = frame_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.AudioStreamEvent.frame_received)
}
inline ::livekit::proto::AudioFrameReceived* AudioStreamEvent::_internal_mutable_frame_received() {
  if (!_internal_has_frame_received()) {
    clear_message();
    set_has_frame_received();
    _impl_.message_.frame_received_ = CreateMaybeMessage< ::livekit::proto::AudioFrameReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.frame_received_;
}
inline ::livekit::proto::AudioFrameReceived* AudioStreamEvent::mutable_frame_received() {
  ::livekit::proto::AudioFrameReceived* _msg = _internal_mutable_frame_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioStreamEvent.frame_received)
  return _msg;
}

// .livekit.proto.AudioStreamEOS eos = 3;
inline bool AudioStreamEvent::_internal_has_eos() const {
  return message_case() == kEos;
}
inline bool AudioStreamEvent::has_eos() const {
  return _internal_has_eos();
}
inline void AudioStreamEvent::set_has_eos() {
  _impl_._oneof_case_[0] = kEos;
}
inline void AudioStreamEvent::clear_eos() {
  if (_internal_has_eos()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.eos_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::AudioStreamEOS* AudioStreamEvent::release_eos() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioStreamEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::AudioStreamEOS* temp = _impl_.message_.eos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::AudioStreamEOS& AudioStreamEvent::_internal_eos() const {
  return _internal_has_eos()
      ? *_impl_.message_.eos_
      : reinterpret_cast< ::livekit::proto::AudioStreamEOS&>(::livekit::proto::_AudioStreamEOS_default_instance_);
}
inline const ::livekit::proto::AudioStreamEOS& AudioStreamEvent::eos() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioStreamEvent.eos)
  return _internal_eos();
}
inline ::livekit::proto::AudioStreamEOS* AudioStreamEvent::unsafe_arena_release_eos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.AudioStreamEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::AudioStreamEOS* temp = _impl_.message_.eos_;
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AudioStreamEvent::unsafe_arena_set_allocated_eos(::livekit::proto::AudioStreamEOS* eos) {
  clear_message();
  if (eos) {
    set_has_eos();
    _impl_.message_.eos_ = eos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.AudioStreamEvent.eos)
}
inline ::livekit::proto::AudioStreamEOS* AudioStreamEvent::_internal_mutable_eos() {
  if (!_internal_has_eos()) {
    clear_message();
    set_has_eos();
    _impl_.message_.eos_ = CreateMaybeMessage< ::livekit::proto::AudioStreamEOS >(GetArenaForAllocation());
  }
  return _impl_.message_.eos_;
}
inline ::livekit::proto::AudioStreamEOS* AudioStreamEvent::mutable_eos() {
  ::livekit::proto::AudioStreamEOS* _msg = _internal_mutable_eos();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioStreamEvent.eos)
  return _msg;
}

inline bool AudioStreamEvent::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void AudioStreamEvent::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline AudioStreamEvent::MessageCase AudioStreamEvent::message_case() const {
  return AudioStreamEvent::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AudioFrameReceived

// required .livekit.proto.OwnedAudioFrameBuffer frame = 1;
inline bool AudioFrameReceived::_internal_has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_ != nullptr);
  return value;
}
inline bool AudioFrameReceived::has_frame() const {
  return _internal_has_frame();
}
inline void AudioFrameReceived::clear_frame() {
  if (_impl_.frame_ != nullptr) _impl_.frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedAudioFrameBuffer& AudioFrameReceived::_internal_frame() const {
  const ::livekit::proto::OwnedAudioFrameBuffer* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedAudioFrameBuffer&>(
      ::livekit::proto::_OwnedAudioFrameBuffer_default_instance_);
}
inline const ::livekit::proto::OwnedAudioFrameBuffer& AudioFrameReceived::frame() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioFrameReceived.frame)
  return _internal_frame();
}
inline void AudioFrameReceived::unsafe_arena_set_allocated_frame(
    ::livekit::proto::OwnedAudioFrameBuffer* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = frame;
  if (frame) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.AudioFrameReceived.frame)
}
inline ::livekit::proto::OwnedAudioFrameBuffer* AudioFrameReceived::release_frame() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioFrameBuffer* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* AudioFrameReceived::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:livekit.proto.AudioFrameReceived.frame)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedAudioFrameBuffer* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* AudioFrameReceived::_internal_mutable_frame() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedAudioFrameBuffer>(GetArenaForAllocation());
    _impl_.frame_ = p;
  }
  return _impl_.frame_;
}
inline ::livekit::proto::OwnedAudioFrameBuffer* AudioFrameReceived::mutable_frame() {
  ::livekit::proto::OwnedAudioFrameBuffer* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AudioFrameReceived.frame)
  return _msg;
}
inline void AudioFrameReceived::set_allocated_frame(::livekit::proto::OwnedAudioFrameBuffer* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AudioFrameReceived.frame)
}

// -------------------------------------------------------------------

// AudioStreamEOS

// -------------------------------------------------------------------

// AudioSourceOptions

// required bool echo_cancellation = 1;
inline bool AudioSourceOptions::_internal_has_echo_cancellation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioSourceOptions::has_echo_cancellation() const {
  return _internal_has_echo_cancellation();
}
inline void AudioSourceOptions::clear_echo_cancellation() {
  _impl_.echo_cancellation_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AudioSourceOptions::_internal_echo_cancellation() const {
  return _impl_.echo_cancellation_;
}
inline bool AudioSourceOptions::echo_cancellation() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioSourceOptions.echo_cancellation)
  return _internal_echo_cancellation();
}
inline void AudioSourceOptions::_internal_set_echo_cancellation(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.echo_cancellation_ = value;
}
inline void AudioSourceOptions::set_echo_cancellation(bool value) {
  _internal_set_echo_cancellation(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioSourceOptions.echo_cancellation)
}

// required bool noise_suppression = 2;
inline bool AudioSourceOptions::_internal_has_noise_suppression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioSourceOptions::has_noise_suppression() const {
  return _internal_has_noise_suppression();
}
inline void AudioSourceOptions::clear_noise_suppression() {
  _impl_.noise_suppression_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AudioSourceOptions::_internal_noise_suppression() const {
  return _impl_.noise_suppression_;
}
inline bool AudioSourceOptions::noise_suppression() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioSourceOptions.noise_suppression)
  return _internal_noise_suppression();
}
inline void AudioSourceOptions::_internal_set_noise_suppression(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.noise_suppression_ = value;
}
inline void AudioSourceOptions::set_noise_suppression(bool value) {
  _internal_set_noise_suppression(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioSourceOptions.noise_suppression)
}

// required bool auto_gain_control = 3;
inline bool AudioSourceOptions::_internal_has_auto_gain_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioSourceOptions::has_auto_gain_control() const {
  return _internal_has_auto_gain_control();
}
inline void AudioSourceOptions::clear_auto_gain_control() {
  _impl_.auto_gain_control_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool AudioSourceOptions::_internal_auto_gain_control() const {
  return _impl_.auto_gain_control_;
}
inline bool AudioSourceOptions::auto_gain_control() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioSourceOptions.auto_gain_control)
  return _internal_auto_gain_control();
}
inline void AudioSourceOptions::_internal_set_auto_gain_control(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auto_gain_control_ = value;
}
inline void AudioSourceOptions::set_auto_gain_control(bool value) {
  _internal_set_auto_gain_control(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioSourceOptions.auto_gain_control)
}

// -------------------------------------------------------------------

// AudioSourceInfo

// required .livekit.proto.AudioSourceType type = 2;
inline bool AudioSourceInfo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioSourceInfo::has_type() const {
  return _internal_has_type();
}
inline void AudioSourceInfo::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::AudioSourceType AudioSourceInfo::_internal_type() const {
  return static_cast< ::livekit::proto::AudioSourceType >(_impl_.type_);
}
inline ::livekit::proto::AudioSourceType AudioSourceInfo::type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioSourceInfo.type)
  return _internal_type();
}
inline void AudioSourceInfo::_internal_set_type(::livekit::proto::AudioSourceType value) {
  assert(::livekit::proto::AudioSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void AudioSourceInfo::set_type(::livekit::proto::AudioSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioSourceInfo.type)
}

// -------------------------------------------------------------------

// OwnedAudioSource

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedAudioSource::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedAudioSource::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioSource::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioSource::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioSource.handle)
  return _internal_handle();
}
inline void OwnedAudioSource::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioSource.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioSource::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioSource::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioSource.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioSource::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioSource::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioSource.handle)
  return _msg;
}
inline void OwnedAudioSource::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioSource.handle)
}

// required .livekit.proto.AudioSourceInfo info = 2;
inline bool OwnedAudioSource::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedAudioSource::has_info() const {
  return _internal_has_info();
}
inline void OwnedAudioSource::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::AudioSourceInfo& OwnedAudioSource::_internal_info() const {
  const ::livekit::proto::AudioSourceInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioSourceInfo&>(
      ::livekit::proto::_AudioSourceInfo_default_instance_);
}
inline const ::livekit::proto::AudioSourceInfo& OwnedAudioSource::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioSource.info)
  return _internal_info();
}
inline void OwnedAudioSource::unsafe_arena_set_allocated_info(
    ::livekit::proto::AudioSourceInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioSource.info)
}
inline ::livekit::proto::AudioSourceInfo* OwnedAudioSource::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioSourceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioSourceInfo* OwnedAudioSource::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioSource.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioSourceInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioSourceInfo* OwnedAudioSource::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioSourceInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::AudioSourceInfo* OwnedAudioSource::mutable_info() {
  ::livekit::proto::AudioSourceInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioSource.info)
  return _msg;
}
inline void OwnedAudioSource::set_allocated_info(::livekit::proto::AudioSourceInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioSource.info)
}

// -------------------------------------------------------------------

// AudioResamplerInfo

// -------------------------------------------------------------------

// OwnedAudioResampler

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedAudioResampler::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedAudioResampler::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioResampler::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedAudioResampler::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioResampler.handle)
  return _internal_handle();
}
inline void OwnedAudioResampler::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioResampler.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioResampler::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioResampler::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioResampler.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioResampler::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedAudioResampler::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioResampler.handle)
  return _msg;
}
inline void OwnedAudioResampler::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioResampler.handle)
}

// required .livekit.proto.AudioResamplerInfo info = 2;
inline bool OwnedAudioResampler::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedAudioResampler::has_info() const {
  return _internal_has_info();
}
inline void OwnedAudioResampler::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::AudioResamplerInfo& OwnedAudioResampler::_internal_info() const {
  const ::livekit::proto::AudioResamplerInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioResamplerInfo&>(
      ::livekit::proto::_AudioResamplerInfo_default_instance_);
}
inline const ::livekit::proto::AudioResamplerInfo& OwnedAudioResampler::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedAudioResampler.info)
  return _internal_info();
}
inline void OwnedAudioResampler::unsafe_arena_set_allocated_info(
    ::livekit::proto::AudioResamplerInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedAudioResampler.info)
}
inline ::livekit::proto::AudioResamplerInfo* OwnedAudioResampler::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioResamplerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioResamplerInfo* OwnedAudioResampler::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedAudioResampler.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::AudioResamplerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioResamplerInfo* OwnedAudioResampler::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioResamplerInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::AudioResamplerInfo* OwnedAudioResampler::mutable_info() {
  ::livekit::proto::AudioResamplerInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedAudioResampler.info)
  return _msg;
}
inline void OwnedAudioResampler::set_allocated_info(::livekit::proto::AudioResamplerInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedAudioResampler.info)
}

// -------------------------------------------------------------------

// OwnedApm

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedApm::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedApm::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedApm::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedApm::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedApm.handle)
  return _internal_handle();
}
inline void OwnedApm::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedApm.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedApm::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedApm::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedApm.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedApm::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedApm::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedApm.handle)
  return _msg;
}
inline void OwnedApm::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedApm.handle)
}

// -------------------------------------------------------------------

// SoxResamplerInfo

// -------------------------------------------------------------------

// OwnedSoxResampler

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedSoxResampler::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedSoxResampler::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedSoxResampler::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedSoxResampler::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedSoxResampler.handle)
  return _internal_handle();
}
inline void OwnedSoxResampler::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedSoxResampler.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedSoxResampler::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedSoxResampler::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedSoxResampler.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedSoxResampler::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedSoxResampler::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedSoxResampler.handle)
  return _msg;
}
inline void OwnedSoxResampler::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedSoxResampler.handle)
}

// required .livekit.proto.SoxResamplerInfo info = 2;
inline bool OwnedSoxResampler::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedSoxResampler::has_info() const {
  return _internal_has_info();
}
inline void OwnedSoxResampler::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::SoxResamplerInfo& OwnedSoxResampler::_internal_info() const {
  const ::livekit::proto::SoxResamplerInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::SoxResamplerInfo&>(
      ::livekit::proto::_SoxResamplerInfo_default_instance_);
}
inline const ::livekit::proto::SoxResamplerInfo& OwnedSoxResampler::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedSoxResampler.info)
  return _internal_info();
}
inline void OwnedSoxResampler::unsafe_arena_set_allocated_info(
    ::livekit::proto::SoxResamplerInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedSoxResampler.info)
}
inline ::livekit::proto::SoxResamplerInfo* OwnedSoxResampler::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::SoxResamplerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::SoxResamplerInfo* OwnedSoxResampler::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedSoxResampler.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::SoxResamplerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::SoxResamplerInfo* OwnedSoxResampler::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::SoxResamplerInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::SoxResamplerInfo* OwnedSoxResampler::mutable_info() {
  ::livekit::proto::SoxResamplerInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedSoxResampler.info)
  return _msg;
}
inline void OwnedSoxResampler::set_allocated_info(::livekit::proto::SoxResamplerInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedSoxResampler.info)
}

// -------------------------------------------------------------------

// LoadAudioFilterPluginRequest

// required string plugin_path = 1;
inline bool LoadAudioFilterPluginRequest::_internal_has_plugin_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadAudioFilterPluginRequest::has_plugin_path() const {
  return _internal_has_plugin_path();
}
inline void LoadAudioFilterPluginRequest::clear_plugin_path() {
  _impl_.plugin_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadAudioFilterPluginRequest::plugin_path() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LoadAudioFilterPluginRequest.plugin_path)
  return _internal_plugin_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadAudioFilterPluginRequest::set_plugin_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.plugin_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LoadAudioFilterPluginRequest.plugin_path)
}
inline std::string* LoadAudioFilterPluginRequest::mutable_plugin_path() {
  std::string* _s = _internal_mutable_plugin_path();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LoadAudioFilterPluginRequest.plugin_path)
  return _s;
}
inline const std::string& LoadAudioFilterPluginRequest::_internal_plugin_path() const {
  return _impl_.plugin_path_.Get();
}
inline void LoadAudioFilterPluginRequest::_internal_set_plugin_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plugin_path_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginRequest::_internal_mutable_plugin_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.plugin_path_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginRequest::release_plugin_path() {
  // @@protoc_insertion_point(field_release:livekit.proto.LoadAudioFilterPluginRequest.plugin_path)
  if (!_internal_has_plugin_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.plugin_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugin_path_.IsDefault()) {
    _impl_.plugin_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadAudioFilterPluginRequest::set_allocated_plugin_path(std::string* plugin_path) {
  if (plugin_path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.plugin_path_.SetAllocated(plugin_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plugin_path_.IsDefault()) {
    _impl_.plugin_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LoadAudioFilterPluginRequest.plugin_path)
}

// repeated string dependencies = 2;
inline int LoadAudioFilterPluginRequest::_internal_dependencies_size() const {
  return _impl_.dependencies_.size();
}
inline int LoadAudioFilterPluginRequest::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void LoadAudioFilterPluginRequest::clear_dependencies() {
  _impl_.dependencies_.Clear();
}
inline std::string* LoadAudioFilterPluginRequest::add_dependencies() {
  std::string* _s = _internal_add_dependencies();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
  return _s;
}
inline const std::string& LoadAudioFilterPluginRequest::_internal_dependencies(int index) const {
  return _impl_.dependencies_.Get(index);
}
inline const std::string& LoadAudioFilterPluginRequest::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
  return _internal_dependencies(index);
}
inline std::string* LoadAudioFilterPluginRequest::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
  return _impl_.dependencies_.Mutable(index);
}
inline void LoadAudioFilterPluginRequest::set_dependencies(int index, const std::string& value) {
  _impl_.dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::set_dependencies(int index, std::string&& value) {
  _impl_.dependencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::set_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::set_dependencies(int index, const char* value, size_t size) {
  _impl_.dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline std::string* LoadAudioFilterPluginRequest::_internal_add_dependencies() {
  return _impl_.dependencies_.Add();
}
inline void LoadAudioFilterPluginRequest::add_dependencies(const std::string& value) {
  _impl_.dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::add_dependencies(std::string&& value) {
  _impl_.dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::add_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline void LoadAudioFilterPluginRequest::add_dependencies(const char* value, size_t size) {
  _impl_.dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoadAudioFilterPluginRequest::dependencies() const {
  // @@protoc_insertion_point(field_list:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
  return _impl_.dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoadAudioFilterPluginRequest::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.LoadAudioFilterPluginRequest.dependencies)
  return &_impl_.dependencies_;
}

// required string module_id = 3;
inline bool LoadAudioFilterPluginRequest::_internal_has_module_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoadAudioFilterPluginRequest::has_module_id() const {
  return _internal_has_module_id();
}
inline void LoadAudioFilterPluginRequest::clear_module_id() {
  _impl_.module_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoadAudioFilterPluginRequest::module_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LoadAudioFilterPluginRequest.module_id)
  return _internal_module_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadAudioFilterPluginRequest::set_module_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.module_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LoadAudioFilterPluginRequest.module_id)
}
inline std::string* LoadAudioFilterPluginRequest::mutable_module_id() {
  std::string* _s = _internal_mutable_module_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LoadAudioFilterPluginRequest.module_id)
  return _s;
}
inline const std::string& LoadAudioFilterPluginRequest::_internal_module_id() const {
  return _impl_.module_id_.Get();
}
inline void LoadAudioFilterPluginRequest::_internal_set_module_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.module_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginRequest::_internal_mutable_module_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.module_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginRequest::release_module_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.LoadAudioFilterPluginRequest.module_id)
  if (!_internal_has_module_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.module_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_id_.IsDefault()) {
    _impl_.module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadAudioFilterPluginRequest::set_allocated_module_id(std::string* module_id) {
  if (module_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.module_id_.SetAllocated(module_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_id_.IsDefault()) {
    _impl_.module_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LoadAudioFilterPluginRequest.module_id)
}

// -------------------------------------------------------------------

// LoadAudioFilterPluginResponse

// optional string error = 1;
inline bool LoadAudioFilterPluginResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadAudioFilterPluginResponse::has_error() const {
  return _internal_has_error();
}
inline void LoadAudioFilterPluginResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadAudioFilterPluginResponse::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LoadAudioFilterPluginResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadAudioFilterPluginResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LoadAudioFilterPluginResponse.error)
}
inline std::string* LoadAudioFilterPluginResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LoadAudioFilterPluginResponse.error)
  return _s;
}
inline const std::string& LoadAudioFilterPluginResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void LoadAudioFilterPluginResponse::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* LoadAudioFilterPluginResponse::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.LoadAudioFilterPluginResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoadAudioFilterPluginResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LoadAudioFilterPluginResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::proto::SoxResamplerDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::SoxResamplerDataType>() {
  return ::livekit::proto::SoxResamplerDataType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::SoxQualityRecipe> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::SoxQualityRecipe>() {
  return ::livekit::proto::SoxQualityRecipe_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::SoxFlagBits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::SoxFlagBits>() {
  return ::livekit::proto::SoxFlagBits_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::AudioStreamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::AudioStreamType>() {
  return ::livekit::proto::AudioStreamType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::AudioSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::AudioSourceType>() {
  return ::livekit::proto::AudioSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_audio_5fframe_2eproto
