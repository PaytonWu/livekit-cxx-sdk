// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_room.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5froom_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5froom_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
#include "livekit_egress.pb.h"
#include "livekit_agent_dispatch.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5froom_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5froom_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5froom_2eproto;
namespace livekit {
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class DeleteRoomRequest;
struct DeleteRoomRequestDefaultTypeInternal;
extern DeleteRoomRequestDefaultTypeInternal _DeleteRoomRequest_default_instance_;
class DeleteRoomResponse;
struct DeleteRoomResponseDefaultTypeInternal;
extern DeleteRoomResponseDefaultTypeInternal _DeleteRoomResponse_default_instance_;
class ListParticipantsRequest;
struct ListParticipantsRequestDefaultTypeInternal;
extern ListParticipantsRequestDefaultTypeInternal _ListParticipantsRequest_default_instance_;
class ListParticipantsResponse;
struct ListParticipantsResponseDefaultTypeInternal;
extern ListParticipantsResponseDefaultTypeInternal _ListParticipantsResponse_default_instance_;
class ListRoomsRequest;
struct ListRoomsRequestDefaultTypeInternal;
extern ListRoomsRequestDefaultTypeInternal _ListRoomsRequest_default_instance_;
class ListRoomsResponse;
struct ListRoomsResponseDefaultTypeInternal;
extern ListRoomsResponseDefaultTypeInternal _ListRoomsResponse_default_instance_;
class MuteRoomTrackRequest;
struct MuteRoomTrackRequestDefaultTypeInternal;
extern MuteRoomTrackRequestDefaultTypeInternal _MuteRoomTrackRequest_default_instance_;
class MuteRoomTrackResponse;
struct MuteRoomTrackResponseDefaultTypeInternal;
extern MuteRoomTrackResponseDefaultTypeInternal _MuteRoomTrackResponse_default_instance_;
class RemoveParticipantResponse;
struct RemoveParticipantResponseDefaultTypeInternal;
extern RemoveParticipantResponseDefaultTypeInternal _RemoveParticipantResponse_default_instance_;
class RoomAgent;
struct RoomAgentDefaultTypeInternal;
extern RoomAgentDefaultTypeInternal _RoomAgent_default_instance_;
class RoomConfiguration;
struct RoomConfigurationDefaultTypeInternal;
extern RoomConfigurationDefaultTypeInternal _RoomConfiguration_default_instance_;
class RoomEgress;
struct RoomEgressDefaultTypeInternal;
extern RoomEgressDefaultTypeInternal _RoomEgress_default_instance_;
class RoomParticipantIdentity;
struct RoomParticipantIdentityDefaultTypeInternal;
extern RoomParticipantIdentityDefaultTypeInternal _RoomParticipantIdentity_default_instance_;
class SendDataRequest;
struct SendDataRequestDefaultTypeInternal;
extern SendDataRequestDefaultTypeInternal _SendDataRequest_default_instance_;
class SendDataResponse;
struct SendDataResponseDefaultTypeInternal;
extern SendDataResponseDefaultTypeInternal _SendDataResponse_default_instance_;
class UpdateParticipantRequest;
struct UpdateParticipantRequestDefaultTypeInternal;
extern UpdateParticipantRequestDefaultTypeInternal _UpdateParticipantRequest_default_instance_;
class UpdateParticipantRequest_AttributesEntry_DoNotUse;
struct UpdateParticipantRequest_AttributesEntry_DoNotUseDefaultTypeInternal;
extern UpdateParticipantRequest_AttributesEntry_DoNotUseDefaultTypeInternal _UpdateParticipantRequest_AttributesEntry_DoNotUse_default_instance_;
class UpdateRoomMetadataRequest;
struct UpdateRoomMetadataRequestDefaultTypeInternal;
extern UpdateRoomMetadataRequestDefaultTypeInternal _UpdateRoomMetadataRequest_default_instance_;
class UpdateSubscriptionsRequest;
struct UpdateSubscriptionsRequestDefaultTypeInternal;
extern UpdateSubscriptionsRequestDefaultTypeInternal _UpdateSubscriptionsRequest_default_instance_;
class UpdateSubscriptionsResponse;
struct UpdateSubscriptionsResponseDefaultTypeInternal;
extern UpdateSubscriptionsResponseDefaultTypeInternal _UpdateSubscriptionsResponse_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::CreateRoomRequest* Arena::CreateMaybeMessage<::livekit::CreateRoomRequest>(Arena*);
template<> ::livekit::DeleteRoomRequest* Arena::CreateMaybeMessage<::livekit::DeleteRoomRequest>(Arena*);
template<> ::livekit::DeleteRoomResponse* Arena::CreateMaybeMessage<::livekit::DeleteRoomResponse>(Arena*);
template<> ::livekit::ListParticipantsRequest* Arena::CreateMaybeMessage<::livekit::ListParticipantsRequest>(Arena*);
template<> ::livekit::ListParticipantsResponse* Arena::CreateMaybeMessage<::livekit::ListParticipantsResponse>(Arena*);
template<> ::livekit::ListRoomsRequest* Arena::CreateMaybeMessage<::livekit::ListRoomsRequest>(Arena*);
template<> ::livekit::ListRoomsResponse* Arena::CreateMaybeMessage<::livekit::ListRoomsResponse>(Arena*);
template<> ::livekit::MuteRoomTrackRequest* Arena::CreateMaybeMessage<::livekit::MuteRoomTrackRequest>(Arena*);
template<> ::livekit::MuteRoomTrackResponse* Arena::CreateMaybeMessage<::livekit::MuteRoomTrackResponse>(Arena*);
template<> ::livekit::RemoveParticipantResponse* Arena::CreateMaybeMessage<::livekit::RemoveParticipantResponse>(Arena*);
template<> ::livekit::RoomAgent* Arena::CreateMaybeMessage<::livekit::RoomAgent>(Arena*);
template<> ::livekit::RoomConfiguration* Arena::CreateMaybeMessage<::livekit::RoomConfiguration>(Arena*);
template<> ::livekit::RoomEgress* Arena::CreateMaybeMessage<::livekit::RoomEgress>(Arena*);
template<> ::livekit::RoomParticipantIdentity* Arena::CreateMaybeMessage<::livekit::RoomParticipantIdentity>(Arena*);
template<> ::livekit::SendDataRequest* Arena::CreateMaybeMessage<::livekit::SendDataRequest>(Arena*);
template<> ::livekit::SendDataResponse* Arena::CreateMaybeMessage<::livekit::SendDataResponse>(Arena*);
template<> ::livekit::UpdateParticipantRequest* Arena::CreateMaybeMessage<::livekit::UpdateParticipantRequest>(Arena*);
template<> ::livekit::UpdateParticipantRequest_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::UpdateParticipantRequest_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::UpdateRoomMetadataRequest* Arena::CreateMaybeMessage<::livekit::UpdateRoomMetadataRequest>(Arena*);
template<> ::livekit::UpdateSubscriptionsRequest* Arena::CreateMaybeMessage<::livekit::UpdateSubscriptionsRequest>(Arena*);
template<> ::livekit::UpdateSubscriptionsResponse* Arena::CreateMaybeMessage<::livekit::UpdateSubscriptionsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

// ===================================================================

class CreateRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  ~CreateRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomRequest& from) {
    CreateRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 14,
    kNameFieldNumber = 1,
    kNodeIdFieldNumber = 4,
    kMetadataFieldNumber = 5,
    kRoomPresetFieldNumber = 12,
    kEgressFieldNumber = 6,
    kEmptyTimeoutFieldNumber = 2,
    kMaxParticipantsFieldNumber = 3,
    kMinPlayoutDelayFieldNumber = 7,
    kMaxPlayoutDelayFieldNumber = 8,
    kDepartureTimeoutFieldNumber = 10,
    kSyncStreamsFieldNumber = 9,
    kReplayEnabledFieldNumber = 13,
  };
  // repeated .livekit.RoomAgentDispatch agents = 14;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::livekit::RoomAgentDispatch* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
      mutable_agents();
  private:
  const ::livekit::RoomAgentDispatch& _internal_agents(int index) const;
  ::livekit::RoomAgentDispatch* _internal_add_agents();
  public:
  const ::livekit::RoomAgentDispatch& agents(int index) const;
  ::livekit::RoomAgentDispatch* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
      agents() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string node_id = 4;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string metadata = 5;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string room_preset = 12;
  void clear_room_preset();
  const std::string& room_preset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_preset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_preset();
  PROTOBUF_NODISCARD std::string* release_room_preset();
  void set_allocated_room_preset(std::string* room_preset);
  private:
  const std::string& _internal_room_preset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_preset(const std::string& value);
  std::string* _internal_mutable_room_preset();
  public:

  // .livekit.RoomEgress egress = 6;
  bool has_egress() const;
  private:
  bool _internal_has_egress() const;
  public:
  void clear_egress();
  const ::livekit::RoomEgress& egress() const;
  PROTOBUF_NODISCARD ::livekit::RoomEgress* release_egress();
  ::livekit::RoomEgress* mutable_egress();
  void set_allocated_egress(::livekit::RoomEgress* egress);
  private:
  const ::livekit::RoomEgress& _internal_egress() const;
  ::livekit::RoomEgress* _internal_mutable_egress();
  public:
  void unsafe_arena_set_allocated_egress(
      ::livekit::RoomEgress* egress);
  ::livekit::RoomEgress* unsafe_arena_release_egress();

  // uint32 empty_timeout = 2;
  void clear_empty_timeout();
  uint32_t empty_timeout() const;
  void set_empty_timeout(uint32_t value);
  private:
  uint32_t _internal_empty_timeout() const;
  void _internal_set_empty_timeout(uint32_t value);
  public:

  // uint32 max_participants = 3;
  void clear_max_participants();
  uint32_t max_participants() const;
  void set_max_participants(uint32_t value);
  private:
  uint32_t _internal_max_participants() const;
  void _internal_set_max_participants(uint32_t value);
  public:

  // uint32 min_playout_delay = 7;
  void clear_min_playout_delay();
  uint32_t min_playout_delay() const;
  void set_min_playout_delay(uint32_t value);
  private:
  uint32_t _internal_min_playout_delay() const;
  void _internal_set_min_playout_delay(uint32_t value);
  public:

  // uint32 max_playout_delay = 8;
  void clear_max_playout_delay();
  uint32_t max_playout_delay() const;
  void set_max_playout_delay(uint32_t value);
  private:
  uint32_t _internal_max_playout_delay() const;
  void _internal_set_max_playout_delay(uint32_t value);
  public:

  // uint32 departure_timeout = 10;
  void clear_departure_timeout();
  uint32_t departure_timeout() const;
  void set_departure_timeout(uint32_t value);
  private:
  uint32_t _internal_departure_timeout() const;
  void _internal_set_departure_timeout(uint32_t value);
  public:

  // bool sync_streams = 9;
  void clear_sync_streams();
  bool sync_streams() const;
  void set_sync_streams(bool value);
  private:
  bool _internal_sync_streams() const;
  void _internal_set_sync_streams(bool value);
  public:

  // bool replay_enabled = 13;
  void clear_replay_enabled();
  bool replay_enabled() const;
  void set_replay_enabled(bool value);
  private:
  bool _internal_replay_enabled() const;
  void _internal_set_replay_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch > agents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_preset_;
    ::livekit::RoomEgress* egress_;
    uint32_t empty_timeout_;
    uint32_t max_participants_;
    uint32_t min_playout_delay_;
    uint32_t max_playout_delay_;
    uint32_t departure_timeout_;
    bool sync_streams_;
    bool replay_enabled_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class RoomEgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomEgress) */ {
 public:
  inline RoomEgress() : RoomEgress(nullptr) {}
  ~RoomEgress() override;
  explicit PROTOBUF_CONSTEXPR RoomEgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomEgress(const RoomEgress& from);
  RoomEgress(RoomEgress&& from) noexcept
    : RoomEgress() {
    *this = ::std::move(from);
  }

  inline RoomEgress& operator=(const RoomEgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomEgress& operator=(RoomEgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomEgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomEgress* internal_default_instance() {
    return reinterpret_cast<const RoomEgress*>(
               &_RoomEgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoomEgress& a, RoomEgress& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomEgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomEgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomEgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomEgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomEgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomEgress& from) {
    RoomEgress::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomEgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomEgress";
  }
  protected:
  explicit RoomEgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
    kTracksFieldNumber = 2,
    kParticipantFieldNumber = 3,
  };
  // .livekit.RoomCompositeEgressRequest room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::RoomCompositeEgressRequest& room() const;
  PROTOBUF_NODISCARD ::livekit::RoomCompositeEgressRequest* release_room();
  ::livekit::RoomCompositeEgressRequest* mutable_room();
  void set_allocated_room(::livekit::RoomCompositeEgressRequest* room);
  private:
  const ::livekit::RoomCompositeEgressRequest& _internal_room() const;
  ::livekit::RoomCompositeEgressRequest* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::RoomCompositeEgressRequest* room);
  ::livekit::RoomCompositeEgressRequest* unsafe_arena_release_room();

  // .livekit.AutoTrackEgress tracks = 2;
  bool has_tracks() const;
  private:
  bool _internal_has_tracks() const;
  public:
  void clear_tracks();
  const ::livekit::AutoTrackEgress& tracks() const;
  PROTOBUF_NODISCARD ::livekit::AutoTrackEgress* release_tracks();
  ::livekit::AutoTrackEgress* mutable_tracks();
  void set_allocated_tracks(::livekit::AutoTrackEgress* tracks);
  private:
  const ::livekit::AutoTrackEgress& _internal_tracks() const;
  ::livekit::AutoTrackEgress* _internal_mutable_tracks();
  public:
  void unsafe_arena_set_allocated_tracks(
      ::livekit::AutoTrackEgress* tracks);
  ::livekit::AutoTrackEgress* unsafe_arena_release_tracks();

  // .livekit.AutoParticipantEgress participant = 3;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::AutoParticipantEgress& participant() const;
  PROTOBUF_NODISCARD ::livekit::AutoParticipantEgress* release_participant();
  ::livekit::AutoParticipantEgress* mutable_participant();
  void set_allocated_participant(::livekit::AutoParticipantEgress* participant);
  private:
  const ::livekit::AutoParticipantEgress& _internal_participant() const;
  ::livekit::AutoParticipantEgress* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::AutoParticipantEgress* participant);
  ::livekit::AutoParticipantEgress* unsafe_arena_release_participant();

  // @@protoc_insertion_point(class_scope:livekit.RoomEgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::RoomCompositeEgressRequest* room_;
    ::livekit::AutoTrackEgress* tracks_;
    ::livekit::AutoParticipantEgress* participant_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class RoomAgent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomAgent) */ {
 public:
  inline RoomAgent() : RoomAgent(nullptr) {}
  ~RoomAgent() override;
  explicit PROTOBUF_CONSTEXPR RoomAgent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomAgent(const RoomAgent& from);
  RoomAgent(RoomAgent&& from) noexcept
    : RoomAgent() {
    *this = ::std::move(from);
  }

  inline RoomAgent& operator=(const RoomAgent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomAgent& operator=(RoomAgent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomAgent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomAgent* internal_default_instance() {
    return reinterpret_cast<const RoomAgent*>(
               &_RoomAgent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoomAgent& a, RoomAgent& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomAgent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomAgent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomAgent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomAgent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomAgent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomAgent& from) {
    RoomAgent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomAgent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomAgent";
  }
  protected:
  explicit RoomAgent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDispatchesFieldNumber = 1,
  };
  // repeated .livekit.RoomAgentDispatch dispatches = 1;
  int dispatches_size() const;
  private:
  int _internal_dispatches_size() const;
  public:
  void clear_dispatches();
  ::livekit::RoomAgentDispatch* mutable_dispatches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
      mutable_dispatches();
  private:
  const ::livekit::RoomAgentDispatch& _internal_dispatches(int index) const;
  ::livekit::RoomAgentDispatch* _internal_add_dispatches();
  public:
  const ::livekit::RoomAgentDispatch& dispatches(int index) const;
  ::livekit::RoomAgentDispatch* add_dispatches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
      dispatches() const;

  // @@protoc_insertion_point(class_scope:livekit.RoomAgent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch > dispatches_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListRoomsRequest) */ {
 public:
  inline ListRoomsRequest() : ListRoomsRequest(nullptr) {}
  ~ListRoomsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsRequest(const ListRoomsRequest& from);
  ListRoomsRequest(ListRoomsRequest&& from) noexcept
    : ListRoomsRequest() {
    *this = ::std::move(from);
  }

  inline ListRoomsRequest& operator=(const ListRoomsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsRequest& operator=(ListRoomsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRoomsRequest*>(
               &_ListRoomsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListRoomsRequest& a, ListRoomsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRoomsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRoomsRequest& from) {
    ListRoomsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoomsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListRoomsRequest";
  }
  protected:
  explicit ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
  };
  // repeated string names = 1;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ListRoomsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListRoomsResponse) */ {
 public:
  inline ListRoomsResponse() : ListRoomsResponse(nullptr) {}
  ~ListRoomsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsResponse(const ListRoomsResponse& from);
  ListRoomsResponse(ListRoomsResponse&& from) noexcept
    : ListRoomsResponse() {
    *this = ::std::move(from);
  }

  inline ListRoomsResponse& operator=(const ListRoomsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsResponse& operator=(ListRoomsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRoomsResponse*>(
               &_ListRoomsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListRoomsResponse& a, ListRoomsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRoomsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRoomsResponse& from) {
    ListRoomsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoomsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListRoomsResponse";
  }
  protected:
  explicit ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .livekit.Room rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::livekit::Room* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Room >*
      mutable_rooms();
  private:
  const ::livekit::Room& _internal_rooms(int index) const;
  ::livekit::Room* _internal_add_rooms();
  public:
  const ::livekit::Room& rooms(int index) const;
  ::livekit::Room* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Room >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:livekit.ListRoomsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Room > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DeleteRoomRequest) */ {
 public:
  inline DeleteRoomRequest() : DeleteRoomRequest(nullptr) {}
  ~DeleteRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRoomRequest(const DeleteRoomRequest& from);
  DeleteRoomRequest(DeleteRoomRequest&& from) noexcept
    : DeleteRoomRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRoomRequest& operator=(const DeleteRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoomRequest& operator=(DeleteRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRoomRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRoomRequest*>(
               &_DeleteRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeleteRoomRequest& a, DeleteRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRoomRequest& from) {
    DeleteRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DeleteRoomRequest";
  }
  protected:
  explicit DeleteRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // @@protoc_insertion_point(class_scope:livekit.DeleteRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.DeleteRoomResponse) */ {
 public:
  inline DeleteRoomResponse() : DeleteRoomResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRoomResponse(const DeleteRoomResponse& from);
  DeleteRoomResponse(DeleteRoomResponse&& from) noexcept
    : DeleteRoomResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRoomResponse& operator=(const DeleteRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoomResponse& operator=(DeleteRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRoomResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRoomResponse*>(
               &_DeleteRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteRoomResponse& a, DeleteRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRoomResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRoomResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DeleteRoomResponse";
  }
  protected:
  explicit DeleteRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.DeleteRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class ListParticipantsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListParticipantsRequest) */ {
 public:
  inline ListParticipantsRequest() : ListParticipantsRequest(nullptr) {}
  ~ListParticipantsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListParticipantsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListParticipantsRequest(const ListParticipantsRequest& from);
  ListParticipantsRequest(ListParticipantsRequest&& from) noexcept
    : ListParticipantsRequest() {
    *this = ::std::move(from);
  }

  inline ListParticipantsRequest& operator=(const ListParticipantsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListParticipantsRequest& operator=(ListParticipantsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListParticipantsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListParticipantsRequest* internal_default_instance() {
    return reinterpret_cast<const ListParticipantsRequest*>(
               &_ListParticipantsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ListParticipantsRequest& a, ListParticipantsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListParticipantsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListParticipantsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListParticipantsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListParticipantsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListParticipantsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListParticipantsRequest& from) {
    ListParticipantsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListParticipantsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListParticipantsRequest";
  }
  protected:
  explicit ListParticipantsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ListParticipantsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class ListParticipantsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListParticipantsResponse) */ {
 public:
  inline ListParticipantsResponse() : ListParticipantsResponse(nullptr) {}
  ~ListParticipantsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListParticipantsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListParticipantsResponse(const ListParticipantsResponse& from);
  ListParticipantsResponse(ListParticipantsResponse&& from) noexcept
    : ListParticipantsResponse() {
    *this = ::std::move(from);
  }

  inline ListParticipantsResponse& operator=(const ListParticipantsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListParticipantsResponse& operator=(ListParticipantsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListParticipantsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListParticipantsResponse* internal_default_instance() {
    return reinterpret_cast<const ListParticipantsResponse*>(
               &_ListParticipantsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListParticipantsResponse& a, ListParticipantsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListParticipantsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListParticipantsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListParticipantsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListParticipantsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListParticipantsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListParticipantsResponse& from) {
    ListParticipantsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListParticipantsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListParticipantsResponse";
  }
  protected:
  explicit ListParticipantsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 1,
  };
  // repeated .livekit.ParticipantInfo participants = 1;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::livekit::ParticipantInfo* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
      mutable_participants();
  private:
  const ::livekit::ParticipantInfo& _internal_participants(int index) const;
  ::livekit::ParticipantInfo* _internal_add_participants();
  public:
  const ::livekit::ParticipantInfo& participants(int index) const;
  ::livekit::ParticipantInfo* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
      participants() const;

  // @@protoc_insertion_point(class_scope:livekit.ListParticipantsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo > participants_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class RoomParticipantIdentity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomParticipantIdentity) */ {
 public:
  inline RoomParticipantIdentity() : RoomParticipantIdentity(nullptr) {}
  ~RoomParticipantIdentity() override;
  explicit PROTOBUF_CONSTEXPR RoomParticipantIdentity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomParticipantIdentity(const RoomParticipantIdentity& from);
  RoomParticipantIdentity(RoomParticipantIdentity&& from) noexcept
    : RoomParticipantIdentity() {
    *this = ::std::move(from);
  }

  inline RoomParticipantIdentity& operator=(const RoomParticipantIdentity& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomParticipantIdentity& operator=(RoomParticipantIdentity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomParticipantIdentity& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomParticipantIdentity* internal_default_instance() {
    return reinterpret_cast<const RoomParticipantIdentity*>(
               &_RoomParticipantIdentity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoomParticipantIdentity& a, RoomParticipantIdentity& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomParticipantIdentity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomParticipantIdentity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomParticipantIdentity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomParticipantIdentity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomParticipantIdentity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomParticipantIdentity& from) {
    RoomParticipantIdentity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomParticipantIdentity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomParticipantIdentity";
  }
  protected:
  explicit RoomParticipantIdentity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
    kIdentityFieldNumber = 2,
  };
  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // @@protoc_insertion_point(class_scope:livekit.RoomParticipantIdentity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class RemoveParticipantResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.RemoveParticipantResponse) */ {
 public:
  inline RemoveParticipantResponse() : RemoveParticipantResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveParticipantResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveParticipantResponse(const RemoveParticipantResponse& from);
  RemoveParticipantResponse(RemoveParticipantResponse&& from) noexcept
    : RemoveParticipantResponse() {
    *this = ::std::move(from);
  }

  inline RemoveParticipantResponse& operator=(const RemoveParticipantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveParticipantResponse& operator=(RemoveParticipantResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveParticipantResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveParticipantResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveParticipantResponse*>(
               &_RemoveParticipantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RemoveParticipantResponse& a, RemoveParticipantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveParticipantResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveParticipantResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveParticipantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveParticipantResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveParticipantResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveParticipantResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RemoveParticipantResponse";
  }
  protected:
  explicit RemoveParticipantResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.RemoveParticipantResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class MuteRoomTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.MuteRoomTrackRequest) */ {
 public:
  inline MuteRoomTrackRequest() : MuteRoomTrackRequest(nullptr) {}
  ~MuteRoomTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR MuteRoomTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MuteRoomTrackRequest(const MuteRoomTrackRequest& from);
  MuteRoomTrackRequest(MuteRoomTrackRequest&& from) noexcept
    : MuteRoomTrackRequest() {
    *this = ::std::move(from);
  }

  inline MuteRoomTrackRequest& operator=(const MuteRoomTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuteRoomTrackRequest& operator=(MuteRoomTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuteRoomTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuteRoomTrackRequest* internal_default_instance() {
    return reinterpret_cast<const MuteRoomTrackRequest*>(
               &_MuteRoomTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MuteRoomTrackRequest& a, MuteRoomTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MuteRoomTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuteRoomTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuteRoomTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MuteRoomTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MuteRoomTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MuteRoomTrackRequest& from) {
    MuteRoomTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MuteRoomTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.MuteRoomTrackRequest";
  }
  protected:
  explicit MuteRoomTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kTrackSidFieldNumber = 3,
    kMutedFieldNumber = 4,
  };
  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string track_sid = 3;
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // bool muted = 4;
  void clear_muted();
  bool muted() const;
  void set_muted(bool value);
  private:
  bool _internal_muted() const;
  void _internal_set_muted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.MuteRoomTrackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    bool muted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class MuteRoomTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.MuteRoomTrackResponse) */ {
 public:
  inline MuteRoomTrackResponse() : MuteRoomTrackResponse(nullptr) {}
  ~MuteRoomTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR MuteRoomTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MuteRoomTrackResponse(const MuteRoomTrackResponse& from);
  MuteRoomTrackResponse(MuteRoomTrackResponse&& from) noexcept
    : MuteRoomTrackResponse() {
    *this = ::std::move(from);
  }

  inline MuteRoomTrackResponse& operator=(const MuteRoomTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuteRoomTrackResponse& operator=(MuteRoomTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuteRoomTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuteRoomTrackResponse* internal_default_instance() {
    return reinterpret_cast<const MuteRoomTrackResponse*>(
               &_MuteRoomTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MuteRoomTrackResponse& a, MuteRoomTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MuteRoomTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuteRoomTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuteRoomTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MuteRoomTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MuteRoomTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MuteRoomTrackResponse& from) {
    MuteRoomTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MuteRoomTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.MuteRoomTrackResponse";
  }
  protected:
  explicit MuteRoomTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackFieldNumber = 1,
  };
  // .livekit.TrackInfo track = 1;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::TrackInfo& track() const;
  PROTOBUF_NODISCARD ::livekit::TrackInfo* release_track();
  ::livekit::TrackInfo* mutable_track();
  void set_allocated_track(::livekit::TrackInfo* track);
  private:
  const ::livekit::TrackInfo& _internal_track() const;
  ::livekit::TrackInfo* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::TrackInfo* track);
  ::livekit::TrackInfo* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.MuteRoomTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::TrackInfo* track_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class UpdateParticipantRequest_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateParticipantRequest_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateParticipantRequest_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UpdateParticipantRequest_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UpdateParticipantRequest_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UpdateParticipantRequest_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UpdateParticipantRequest_AttributesEntry_DoNotUse& other);
  static const UpdateParticipantRequest_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateParticipantRequest_AttributesEntry_DoNotUse*>(&_UpdateParticipantRequest_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.UpdateParticipantRequest.AttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.UpdateParticipantRequest.AttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5froom_2eproto;
};

// -------------------------------------------------------------------

class UpdateParticipantRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateParticipantRequest) */ {
 public:
  inline UpdateParticipantRequest() : UpdateParticipantRequest(nullptr) {}
  ~UpdateParticipantRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateParticipantRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateParticipantRequest(const UpdateParticipantRequest& from);
  UpdateParticipantRequest(UpdateParticipantRequest&& from) noexcept
    : UpdateParticipantRequest() {
    *this = ::std::move(from);
  }

  inline UpdateParticipantRequest& operator=(const UpdateParticipantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateParticipantRequest& operator=(UpdateParticipantRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateParticipantRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateParticipantRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateParticipantRequest*>(
               &_UpdateParticipantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateParticipantRequest& a, UpdateParticipantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateParticipantRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateParticipantRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateParticipantRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateParticipantRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateParticipantRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateParticipantRequest& from) {
    UpdateParticipantRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateParticipantRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateParticipantRequest";
  }
  protected:
  explicit UpdateParticipantRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kRoomFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kNameFieldNumber = 5,
    kPermissionFieldNumber = 4,
  };
  // map<string, string> attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string metadata = 3;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .livekit.ParticipantPermission permission = 4;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  const ::livekit::ParticipantPermission& permission() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantPermission* release_permission();
  ::livekit::ParticipantPermission* mutable_permission();
  void set_allocated_permission(::livekit::ParticipantPermission* permission);
  private:
  const ::livekit::ParticipantPermission& _internal_permission() const;
  ::livekit::ParticipantPermission* _internal_mutable_permission();
  public:
  void unsafe_arena_set_allocated_permission(
      ::livekit::ParticipantPermission* permission);
  ::livekit::ParticipantPermission* unsafe_arena_release_permission();

  // @@protoc_insertion_point(class_scope:livekit.UpdateParticipantRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        UpdateParticipantRequest_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::livekit::ParticipantPermission* permission_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateSubscriptionsRequest) */ {
 public:
  inline UpdateSubscriptionsRequest() : UpdateSubscriptionsRequest(nullptr) {}
  ~UpdateSubscriptionsRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionsRequest(const UpdateSubscriptionsRequest& from);
  UpdateSubscriptionsRequest(UpdateSubscriptionsRequest&& from) noexcept
    : UpdateSubscriptionsRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionsRequest& operator=(const UpdateSubscriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionsRequest& operator=(UpdateSubscriptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionsRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionsRequest*>(
               &_UpdateSubscriptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateSubscriptionsRequest& a, UpdateSubscriptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscriptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscriptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSubscriptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateSubscriptionsRequest& from) {
    UpdateSubscriptionsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSubscriptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateSubscriptionsRequest";
  }
  protected:
  explicit UpdateSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidsFieldNumber = 3,
    kParticipantTracksFieldNumber = 5,
    kRoomFieldNumber = 1,
    kIdentityFieldNumber = 2,
    kSubscribeFieldNumber = 4,
  };
  // repeated string track_sids = 3;
  int track_sids_size() const;
  private:
  int _internal_track_sids_size() const;
  public:
  void clear_track_sids();
  const std::string& track_sids(int index) const;
  std::string* mutable_track_sids(int index);
  void set_track_sids(int index, const std::string& value);
  void set_track_sids(int index, std::string&& value);
  void set_track_sids(int index, const char* value);
  void set_track_sids(int index, const char* value, size_t size);
  std::string* add_track_sids();
  void add_track_sids(const std::string& value);
  void add_track_sids(std::string&& value);
  void add_track_sids(const char* value);
  void add_track_sids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& track_sids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_track_sids();
  private:
  const std::string& _internal_track_sids(int index) const;
  std::string* _internal_add_track_sids();
  public:

  // repeated .livekit.ParticipantTracks participant_tracks = 5;
  int participant_tracks_size() const;
  private:
  int _internal_participant_tracks_size() const;
  public:
  void clear_participant_tracks();
  ::livekit::ParticipantTracks* mutable_participant_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
      mutable_participant_tracks();
  private:
  const ::livekit::ParticipantTracks& _internal_participant_tracks(int index) const;
  ::livekit::ParticipantTracks* _internal_add_participant_tracks();
  public:
  const ::livekit::ParticipantTracks& participant_tracks(int index) const;
  ::livekit::ParticipantTracks* add_participant_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
      participant_tracks() const;

  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string identity = 2;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // bool subscribe = 4;
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateSubscriptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> track_sids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks > participant_tracks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    bool subscribe_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class UpdateSubscriptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.UpdateSubscriptionsResponse) */ {
 public:
  inline UpdateSubscriptionsResponse() : UpdateSubscriptionsResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSubscriptionsResponse(const UpdateSubscriptionsResponse& from);
  UpdateSubscriptionsResponse(UpdateSubscriptionsResponse&& from) noexcept
    : UpdateSubscriptionsResponse() {
    *this = ::std::move(from);
  }

  inline UpdateSubscriptionsResponse& operator=(const UpdateSubscriptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSubscriptionsResponse& operator=(UpdateSubscriptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSubscriptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSubscriptionsResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSubscriptionsResponse*>(
               &_UpdateSubscriptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateSubscriptionsResponse& a, UpdateSubscriptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSubscriptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSubscriptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSubscriptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSubscriptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateSubscriptionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateSubscriptionsResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateSubscriptionsResponse";
  }
  protected:
  explicit UpdateSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.UpdateSubscriptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class SendDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SendDataRequest) */ {
 public:
  inline SendDataRequest() : SendDataRequest(nullptr) {}
  ~SendDataRequest() override;
  explicit PROTOBUF_CONSTEXPR SendDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendDataRequest(const SendDataRequest& from);
  SendDataRequest(SendDataRequest&& from) noexcept
    : SendDataRequest() {
    *this = ::std::move(from);
  }

  inline SendDataRequest& operator=(const SendDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendDataRequest& operator=(SendDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendDataRequest* internal_default_instance() {
    return reinterpret_cast<const SendDataRequest*>(
               &_SendDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SendDataRequest& a, SendDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendDataRequest& from) {
    SendDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SendDataRequest";
  }
  protected:
  explicit SendDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationSidsFieldNumber = 4,
    kDestinationIdentitiesFieldNumber = 6,
    kRoomFieldNumber = 1,
    kDataFieldNumber = 2,
    kTopicFieldNumber = 5,
    kNonceFieldNumber = 7,
    kKindFieldNumber = 3,
  };
  // repeated string destination_sids = 4 [deprecated = true];
  PROTOBUF_DEPRECATED int destination_sids_size() const;
  private:
  int _internal_destination_sids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_destination_sids();
  PROTOBUF_DEPRECATED const std::string& destination_sids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_destination_sids(int index);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_destination_sids();
  PROTOBUF_DEPRECATED void add_destination_sids(const std::string& value);
  PROTOBUF_DEPRECATED void add_destination_sids(std::string&& value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_sids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_sids();
  private:
  const std::string& _internal_destination_sids(int index) const;
  std::string* _internal_add_destination_sids();
  public:

  // repeated string destination_identities = 6;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional string topic = 5;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // bytes nonce = 7;
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // .livekit.DataPacket.Kind kind = 3;
  void clear_kind();
  ::livekit::DataPacket_Kind kind() const;
  void set_kind(::livekit::DataPacket_Kind value);
  private:
  ::livekit::DataPacket_Kind _internal_kind() const;
  void _internal_set_kind(::livekit::DataPacket_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SendDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_sids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class SendDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.SendDataResponse) */ {
 public:
  inline SendDataResponse() : SendDataResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SendDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendDataResponse(const SendDataResponse& from);
  SendDataResponse(SendDataResponse&& from) noexcept
    : SendDataResponse() {
    *this = ::std::move(from);
  }

  inline SendDataResponse& operator=(const SendDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendDataResponse& operator=(SendDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendDataResponse* internal_default_instance() {
    return reinterpret_cast<const SendDataResponse*>(
               &_SendDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SendDataResponse& a, SendDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SendDataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SendDataResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SendDataResponse";
  }
  protected:
  explicit SendDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.SendDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class UpdateRoomMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateRoomMetadataRequest) */ {
 public:
  inline UpdateRoomMetadataRequest() : UpdateRoomMetadataRequest(nullptr) {}
  ~UpdateRoomMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRoomMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRoomMetadataRequest(const UpdateRoomMetadataRequest& from);
  UpdateRoomMetadataRequest(UpdateRoomMetadataRequest&& from) noexcept
    : UpdateRoomMetadataRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRoomMetadataRequest& operator=(const UpdateRoomMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRoomMetadataRequest& operator=(UpdateRoomMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRoomMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRoomMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRoomMetadataRequest*>(
               &_UpdateRoomMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateRoomMetadataRequest& a, UpdateRoomMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRoomMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRoomMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRoomMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRoomMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRoomMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRoomMetadataRequest& from) {
    UpdateRoomMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRoomMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateRoomMetadataRequest";
  }
  protected:
  explicit UpdateRoomMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string room = 1;
  void clear_room();
  const std::string& room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room();
  PROTOBUF_NODISCARD std::string* release_room();
  void set_allocated_room(std::string* room);
  private:
  const std::string& _internal_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room(const std::string& value);
  std::string* _internal_mutable_room();
  public:

  // string metadata = 2;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateRoomMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// -------------------------------------------------------------------

class RoomConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RoomConfiguration) */ {
 public:
  inline RoomConfiguration() : RoomConfiguration(nullptr) {}
  ~RoomConfiguration() override;
  explicit PROTOBUF_CONSTEXPR RoomConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomConfiguration(const RoomConfiguration& from);
  RoomConfiguration(RoomConfiguration&& from) noexcept
    : RoomConfiguration() {
    *this = ::std::move(from);
  }

  inline RoomConfiguration& operator=(const RoomConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomConfiguration& operator=(RoomConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomConfiguration* internal_default_instance() {
    return reinterpret_cast<const RoomConfiguration*>(
               &_RoomConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RoomConfiguration& a, RoomConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomConfiguration& from) {
    RoomConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RoomConfiguration";
  }
  protected:
  explicit RoomConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentsFieldNumber = 10,
    kNameFieldNumber = 1,
    kEgressFieldNumber = 5,
    kEmptyTimeoutFieldNumber = 2,
    kDepartureTimeoutFieldNumber = 3,
    kMaxParticipantsFieldNumber = 4,
    kMinPlayoutDelayFieldNumber = 7,
    kMaxPlayoutDelayFieldNumber = 8,
    kSyncStreamsFieldNumber = 9,
  };
  // repeated .livekit.RoomAgentDispatch agents = 10;
  int agents_size() const;
  private:
  int _internal_agents_size() const;
  public:
  void clear_agents();
  ::livekit::RoomAgentDispatch* mutable_agents(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
      mutable_agents();
  private:
  const ::livekit::RoomAgentDispatch& _internal_agents(int index) const;
  ::livekit::RoomAgentDispatch* _internal_add_agents();
  public:
  const ::livekit::RoomAgentDispatch& agents(int index) const;
  ::livekit::RoomAgentDispatch* add_agents();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
      agents() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .livekit.RoomEgress egress = 5;
  bool has_egress() const;
  private:
  bool _internal_has_egress() const;
  public:
  void clear_egress();
  const ::livekit::RoomEgress& egress() const;
  PROTOBUF_NODISCARD ::livekit::RoomEgress* release_egress();
  ::livekit::RoomEgress* mutable_egress();
  void set_allocated_egress(::livekit::RoomEgress* egress);
  private:
  const ::livekit::RoomEgress& _internal_egress() const;
  ::livekit::RoomEgress* _internal_mutable_egress();
  public:
  void unsafe_arena_set_allocated_egress(
      ::livekit::RoomEgress* egress);
  ::livekit::RoomEgress* unsafe_arena_release_egress();

  // uint32 empty_timeout = 2;
  void clear_empty_timeout();
  uint32_t empty_timeout() const;
  void set_empty_timeout(uint32_t value);
  private:
  uint32_t _internal_empty_timeout() const;
  void _internal_set_empty_timeout(uint32_t value);
  public:

  // uint32 departure_timeout = 3;
  void clear_departure_timeout();
  uint32_t departure_timeout() const;
  void set_departure_timeout(uint32_t value);
  private:
  uint32_t _internal_departure_timeout() const;
  void _internal_set_departure_timeout(uint32_t value);
  public:

  // uint32 max_participants = 4;
  void clear_max_participants();
  uint32_t max_participants() const;
  void set_max_participants(uint32_t value);
  private:
  uint32_t _internal_max_participants() const;
  void _internal_set_max_participants(uint32_t value);
  public:

  // uint32 min_playout_delay = 7;
  void clear_min_playout_delay();
  uint32_t min_playout_delay() const;
  void set_min_playout_delay(uint32_t value);
  private:
  uint32_t _internal_min_playout_delay() const;
  void _internal_set_min_playout_delay(uint32_t value);
  public:

  // uint32 max_playout_delay = 8;
  void clear_max_playout_delay();
  uint32_t max_playout_delay() const;
  void set_max_playout_delay(uint32_t value);
  private:
  uint32_t _internal_max_playout_delay() const;
  void _internal_set_max_playout_delay(uint32_t value);
  public:

  // bool sync_streams = 9;
  void clear_sync_streams();
  bool sync_streams() const;
  void set_sync_streams(bool value);
  private:
  bool _internal_sync_streams() const;
  void _internal_set_sync_streams(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RoomConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch > agents_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::livekit::RoomEgress* egress_;
    uint32_t empty_timeout_;
    uint32_t departure_timeout_;
    uint32_t max_participants_;
    uint32_t min_playout_delay_;
    uint32_t max_playout_delay_;
    bool sync_streams_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5froom_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateRoomRequest

// string name = 1;
inline void CreateRoomRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.name)
}
inline std::string* CreateRoomRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.name)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateRoomRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.CreateRoomRequest.name)
  return _impl_.name_.Release();
}
inline void CreateRoomRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateRoomRequest.name)
}

// string room_preset = 12;
inline void CreateRoomRequest::clear_room_preset() {
  _impl_.room_preset_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::room_preset() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.room_preset)
  return _internal_room_preset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_room_preset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_preset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.room_preset)
}
inline std::string* CreateRoomRequest::mutable_room_preset() {
  std::string* _s = _internal_mutable_room_preset();
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.room_preset)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_room_preset() const {
  return _impl_.room_preset_.Get();
}
inline void CreateRoomRequest::_internal_set_room_preset(const std::string& value) {
  
  _impl_.room_preset_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_room_preset() {
  
  return _impl_.room_preset_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_room_preset() {
  // @@protoc_insertion_point(field_release:livekit.CreateRoomRequest.room_preset)
  return _impl_.room_preset_.Release();
}
inline void CreateRoomRequest::set_allocated_room_preset(std::string* room_preset) {
  if (room_preset != nullptr) {
    
  } else {
    
  }
  _impl_.room_preset_.SetAllocated(room_preset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_preset_.IsDefault()) {
    _impl_.room_preset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateRoomRequest.room_preset)
}

// uint32 empty_timeout = 2;
inline void CreateRoomRequest::clear_empty_timeout() {
  _impl_.empty_timeout_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_empty_timeout() const {
  return _impl_.empty_timeout_;
}
inline uint32_t CreateRoomRequest::empty_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.empty_timeout)
  return _internal_empty_timeout();
}
inline void CreateRoomRequest::_internal_set_empty_timeout(uint32_t value) {
  
  _impl_.empty_timeout_ = value;
}
inline void CreateRoomRequest::set_empty_timeout(uint32_t value) {
  _internal_set_empty_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.empty_timeout)
}

// uint32 departure_timeout = 10;
inline void CreateRoomRequest::clear_departure_timeout() {
  _impl_.departure_timeout_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_departure_timeout() const {
  return _impl_.departure_timeout_;
}
inline uint32_t CreateRoomRequest::departure_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.departure_timeout)
  return _internal_departure_timeout();
}
inline void CreateRoomRequest::_internal_set_departure_timeout(uint32_t value) {
  
  _impl_.departure_timeout_ = value;
}
inline void CreateRoomRequest::set_departure_timeout(uint32_t value) {
  _internal_set_departure_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.departure_timeout)
}

// uint32 max_participants = 3;
inline void CreateRoomRequest::clear_max_participants() {
  _impl_.max_participants_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_max_participants() const {
  return _impl_.max_participants_;
}
inline uint32_t CreateRoomRequest::max_participants() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.max_participants)
  return _internal_max_participants();
}
inline void CreateRoomRequest::_internal_set_max_participants(uint32_t value) {
  
  _impl_.max_participants_ = value;
}
inline void CreateRoomRequest::set_max_participants(uint32_t value) {
  _internal_set_max_participants(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.max_participants)
}

// string node_id = 4;
inline void CreateRoomRequest::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::node_id() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.node_id)
}
inline std::string* CreateRoomRequest::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.node_id)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void CreateRoomRequest::_internal_set_node_id(const std::string& value) {
  
  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_node_id() {
  
  return _impl_.node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:livekit.CreateRoomRequest.node_id)
  return _impl_.node_id_.Release();
}
inline void CreateRoomRequest::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  _impl_.node_id_.SetAllocated(node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateRoomRequest.node_id)
}

// string metadata = 5;
inline void CreateRoomRequest::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.metadata)
}
inline std::string* CreateRoomRequest::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.metadata)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void CreateRoomRequest::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.CreateRoomRequest.metadata)
  return _impl_.metadata_.Release();
}
inline void CreateRoomRequest::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateRoomRequest.metadata)
}

// .livekit.RoomEgress egress = 6;
inline bool CreateRoomRequest::_internal_has_egress() const {
  return this != internal_default_instance() && _impl_.egress_ != nullptr;
}
inline bool CreateRoomRequest::has_egress() const {
  return _internal_has_egress();
}
inline void CreateRoomRequest::clear_egress() {
  if (GetArenaForAllocation() == nullptr && _impl_.egress_ != nullptr) {
    delete _impl_.egress_;
  }
  _impl_.egress_ = nullptr;
}
inline const ::livekit::RoomEgress& CreateRoomRequest::_internal_egress() const {
  const ::livekit::RoomEgress* p = _impl_.egress_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RoomEgress&>(
      ::livekit::_RoomEgress_default_instance_);
}
inline const ::livekit::RoomEgress& CreateRoomRequest::egress() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.egress)
  return _internal_egress();
}
inline void CreateRoomRequest::unsafe_arena_set_allocated_egress(
    ::livekit::RoomEgress* egress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.egress_);
  }
  _impl_.egress_ = egress;
  if (egress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.CreateRoomRequest.egress)
}
inline ::livekit::RoomEgress* CreateRoomRequest::release_egress() {
  
  ::livekit::RoomEgress* temp = _impl_.egress_;
  _impl_.egress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RoomEgress* CreateRoomRequest::unsafe_arena_release_egress() {
  // @@protoc_insertion_point(field_release:livekit.CreateRoomRequest.egress)
  
  ::livekit::RoomEgress* temp = _impl_.egress_;
  _impl_.egress_ = nullptr;
  return temp;
}
inline ::livekit::RoomEgress* CreateRoomRequest::_internal_mutable_egress() {
  
  if (_impl_.egress_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RoomEgress>(GetArenaForAllocation());
    _impl_.egress_ = p;
  }
  return _impl_.egress_;
}
inline ::livekit::RoomEgress* CreateRoomRequest::mutable_egress() {
  ::livekit::RoomEgress* _msg = _internal_mutable_egress();
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.egress)
  return _msg;
}
inline void CreateRoomRequest::set_allocated_egress(::livekit::RoomEgress* egress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.egress_;
  }
  if (egress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(egress);
    if (message_arena != submessage_arena) {
      egress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, egress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.egress_ = egress;
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateRoomRequest.egress)
}

// uint32 min_playout_delay = 7;
inline void CreateRoomRequest::clear_min_playout_delay() {
  _impl_.min_playout_delay_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_min_playout_delay() const {
  return _impl_.min_playout_delay_;
}
inline uint32_t CreateRoomRequest::min_playout_delay() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.min_playout_delay)
  return _internal_min_playout_delay();
}
inline void CreateRoomRequest::_internal_set_min_playout_delay(uint32_t value) {
  
  _impl_.min_playout_delay_ = value;
}
inline void CreateRoomRequest::set_min_playout_delay(uint32_t value) {
  _internal_set_min_playout_delay(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.min_playout_delay)
}

// uint32 max_playout_delay = 8;
inline void CreateRoomRequest::clear_max_playout_delay() {
  _impl_.max_playout_delay_ = 0u;
}
inline uint32_t CreateRoomRequest::_internal_max_playout_delay() const {
  return _impl_.max_playout_delay_;
}
inline uint32_t CreateRoomRequest::max_playout_delay() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.max_playout_delay)
  return _internal_max_playout_delay();
}
inline void CreateRoomRequest::_internal_set_max_playout_delay(uint32_t value) {
  
  _impl_.max_playout_delay_ = value;
}
inline void CreateRoomRequest::set_max_playout_delay(uint32_t value) {
  _internal_set_max_playout_delay(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.max_playout_delay)
}

// bool sync_streams = 9;
inline void CreateRoomRequest::clear_sync_streams() {
  _impl_.sync_streams_ = false;
}
inline bool CreateRoomRequest::_internal_sync_streams() const {
  return _impl_.sync_streams_;
}
inline bool CreateRoomRequest::sync_streams() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.sync_streams)
  return _internal_sync_streams();
}
inline void CreateRoomRequest::_internal_set_sync_streams(bool value) {
  
  _impl_.sync_streams_ = value;
}
inline void CreateRoomRequest::set_sync_streams(bool value) {
  _internal_set_sync_streams(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.sync_streams)
}

// bool replay_enabled = 13;
inline void CreateRoomRequest::clear_replay_enabled() {
  _impl_.replay_enabled_ = false;
}
inline bool CreateRoomRequest::_internal_replay_enabled() const {
  return _impl_.replay_enabled_;
}
inline bool CreateRoomRequest::replay_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.replay_enabled)
  return _internal_replay_enabled();
}
inline void CreateRoomRequest::_internal_set_replay_enabled(bool value) {
  
  _impl_.replay_enabled_ = value;
}
inline void CreateRoomRequest::set_replay_enabled(bool value) {
  _internal_set_replay_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.CreateRoomRequest.replay_enabled)
}

// repeated .livekit.RoomAgentDispatch agents = 14;
inline int CreateRoomRequest::_internal_agents_size() const {
  return _impl_.agents_.size();
}
inline int CreateRoomRequest::agents_size() const {
  return _internal_agents_size();
}
inline ::livekit::RoomAgentDispatch* CreateRoomRequest::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.CreateRoomRequest.agents)
  return _impl_.agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
CreateRoomRequest::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:livekit.CreateRoomRequest.agents)
  return &_impl_.agents_;
}
inline const ::livekit::RoomAgentDispatch& CreateRoomRequest::_internal_agents(int index) const {
  return _impl_.agents_.Get(index);
}
inline const ::livekit::RoomAgentDispatch& CreateRoomRequest::agents(int index) const {
  // @@protoc_insertion_point(field_get:livekit.CreateRoomRequest.agents)
  return _internal_agents(index);
}
inline ::livekit::RoomAgentDispatch* CreateRoomRequest::_internal_add_agents() {
  return _impl_.agents_.Add();
}
inline ::livekit::RoomAgentDispatch* CreateRoomRequest::add_agents() {
  ::livekit::RoomAgentDispatch* _add = _internal_add_agents();
  // @@protoc_insertion_point(field_add:livekit.CreateRoomRequest.agents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
CreateRoomRequest::agents() const {
  // @@protoc_insertion_point(field_list:livekit.CreateRoomRequest.agents)
  return _impl_.agents_;
}

// -------------------------------------------------------------------

// RoomEgress

// .livekit.RoomCompositeEgressRequest room = 1;
inline bool RoomEgress::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool RoomEgress::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::RoomCompositeEgressRequest& RoomEgress::_internal_room() const {
  const ::livekit::RoomCompositeEgressRequest* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RoomCompositeEgressRequest&>(
      ::livekit::_RoomCompositeEgressRequest_default_instance_);
}
inline const ::livekit::RoomCompositeEgressRequest& RoomEgress::room() const {
  // @@protoc_insertion_point(field_get:livekit.RoomEgress.room)
  return _internal_room();
}
inline void RoomEgress::unsafe_arena_set_allocated_room(
    ::livekit::RoomCompositeEgressRequest* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomEgress.room)
}
inline ::livekit::RoomCompositeEgressRequest* RoomEgress::release_room() {
  
  ::livekit::RoomCompositeEgressRequest* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RoomCompositeEgressRequest* RoomEgress::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.RoomEgress.room)
  
  ::livekit::RoomCompositeEgressRequest* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::RoomCompositeEgressRequest* RoomEgress::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RoomCompositeEgressRequest>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::RoomCompositeEgressRequest* RoomEgress::mutable_room() {
  ::livekit::RoomCompositeEgressRequest* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.RoomEgress.room)
  return _msg;
}
inline void RoomEgress::set_allocated_room(::livekit::RoomCompositeEgressRequest* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomEgress.room)
}

// .livekit.AutoParticipantEgress participant = 3;
inline bool RoomEgress::_internal_has_participant() const {
  return this != internal_default_instance() && _impl_.participant_ != nullptr;
}
inline bool RoomEgress::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::AutoParticipantEgress& RoomEgress::_internal_participant() const {
  const ::livekit::AutoParticipantEgress* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::AutoParticipantEgress&>(
      ::livekit::_AutoParticipantEgress_default_instance_);
}
inline const ::livekit::AutoParticipantEgress& RoomEgress::participant() const {
  // @@protoc_insertion_point(field_get:livekit.RoomEgress.participant)
  return _internal_participant();
}
inline void RoomEgress::unsafe_arena_set_allocated_participant(
    ::livekit::AutoParticipantEgress* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = participant;
  if (participant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomEgress.participant)
}
inline ::livekit::AutoParticipantEgress* RoomEgress::release_participant() {
  
  ::livekit::AutoParticipantEgress* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::AutoParticipantEgress* RoomEgress::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.RoomEgress.participant)
  
  ::livekit::AutoParticipantEgress* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::AutoParticipantEgress* RoomEgress::_internal_mutable_participant() {
  
  if (_impl_.participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::AutoParticipantEgress>(GetArenaForAllocation());
    _impl_.participant_ = p;
  }
  return _impl_.participant_;
}
inline ::livekit::AutoParticipantEgress* RoomEgress::mutable_participant() {
  ::livekit::AutoParticipantEgress* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.RoomEgress.participant)
  return _msg;
}
inline void RoomEgress::set_allocated_participant(::livekit::AutoParticipantEgress* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomEgress.participant)
}

// .livekit.AutoTrackEgress tracks = 2;
inline bool RoomEgress::_internal_has_tracks() const {
  return this != internal_default_instance() && _impl_.tracks_ != nullptr;
}
inline bool RoomEgress::has_tracks() const {
  return _internal_has_tracks();
}
inline const ::livekit::AutoTrackEgress& RoomEgress::_internal_tracks() const {
  const ::livekit::AutoTrackEgress* p = _impl_.tracks_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::AutoTrackEgress&>(
      ::livekit::_AutoTrackEgress_default_instance_);
}
inline const ::livekit::AutoTrackEgress& RoomEgress::tracks() const {
  // @@protoc_insertion_point(field_get:livekit.RoomEgress.tracks)
  return _internal_tracks();
}
inline void RoomEgress::unsafe_arena_set_allocated_tracks(
    ::livekit::AutoTrackEgress* tracks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tracks_);
  }
  _impl_.tracks_ = tracks;
  if (tracks) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomEgress.tracks)
}
inline ::livekit::AutoTrackEgress* RoomEgress::release_tracks() {
  
  ::livekit::AutoTrackEgress* temp = _impl_.tracks_;
  _impl_.tracks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::AutoTrackEgress* RoomEgress::unsafe_arena_release_tracks() {
  // @@protoc_insertion_point(field_release:livekit.RoomEgress.tracks)
  
  ::livekit::AutoTrackEgress* temp = _impl_.tracks_;
  _impl_.tracks_ = nullptr;
  return temp;
}
inline ::livekit::AutoTrackEgress* RoomEgress::_internal_mutable_tracks() {
  
  if (_impl_.tracks_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::AutoTrackEgress>(GetArenaForAllocation());
    _impl_.tracks_ = p;
  }
  return _impl_.tracks_;
}
inline ::livekit::AutoTrackEgress* RoomEgress::mutable_tracks() {
  ::livekit::AutoTrackEgress* _msg = _internal_mutable_tracks();
  // @@protoc_insertion_point(field_mutable:livekit.RoomEgress.tracks)
  return _msg;
}
inline void RoomEgress::set_allocated_tracks(::livekit::AutoTrackEgress* tracks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tracks_);
  }
  if (tracks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tracks));
    if (message_arena != submessage_arena) {
      tracks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tracks, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tracks_ = tracks;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomEgress.tracks)
}

// -------------------------------------------------------------------

// RoomAgent

// repeated .livekit.RoomAgentDispatch dispatches = 1;
inline int RoomAgent::_internal_dispatches_size() const {
  return _impl_.dispatches_.size();
}
inline int RoomAgent::dispatches_size() const {
  return _internal_dispatches_size();
}
inline ::livekit::RoomAgentDispatch* RoomAgent::mutable_dispatches(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomAgent.dispatches)
  return _impl_.dispatches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
RoomAgent::mutable_dispatches() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomAgent.dispatches)
  return &_impl_.dispatches_;
}
inline const ::livekit::RoomAgentDispatch& RoomAgent::_internal_dispatches(int index) const {
  return _impl_.dispatches_.Get(index);
}
inline const ::livekit::RoomAgentDispatch& RoomAgent::dispatches(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomAgent.dispatches)
  return _internal_dispatches(index);
}
inline ::livekit::RoomAgentDispatch* RoomAgent::_internal_add_dispatches() {
  return _impl_.dispatches_.Add();
}
inline ::livekit::RoomAgentDispatch* RoomAgent::add_dispatches() {
  ::livekit::RoomAgentDispatch* _add = _internal_add_dispatches();
  // @@protoc_insertion_point(field_add:livekit.RoomAgent.dispatches)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
RoomAgent::dispatches() const {
  // @@protoc_insertion_point(field_list:livekit.RoomAgent.dispatches)
  return _impl_.dispatches_;
}

// -------------------------------------------------------------------

// ListRoomsRequest

// repeated string names = 1;
inline int ListRoomsRequest::_internal_names_size() const {
  return _impl_.names_.size();
}
inline int ListRoomsRequest::names_size() const {
  return _internal_names_size();
}
inline void ListRoomsRequest::clear_names() {
  _impl_.names_.Clear();
}
inline std::string* ListRoomsRequest::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:livekit.ListRoomsRequest.names)
  return _s;
}
inline const std::string& ListRoomsRequest::_internal_names(int index) const {
  return _impl_.names_.Get(index);
}
inline const std::string& ListRoomsRequest::names(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ListRoomsRequest.names)
  return _internal_names(index);
}
inline std::string* ListRoomsRequest::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ListRoomsRequest.names)
  return _impl_.names_.Mutable(index);
}
inline void ListRoomsRequest::set_names(int index, const std::string& value) {
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::set_names(int index, std::string&& value) {
  _impl_.names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::set_names(int index, const char* value, size_t size) {
  _impl_.names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.ListRoomsRequest.names)
}
inline std::string* ListRoomsRequest::_internal_add_names() {
  return _impl_.names_.Add();
}
inline void ListRoomsRequest::add_names(const std::string& value) {
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::add_names(std::string&& value) {
  _impl_.names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.ListRoomsRequest.names)
}
inline void ListRoomsRequest::add_names(const char* value, size_t size) {
  _impl_.names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.ListRoomsRequest.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListRoomsRequest::names() const {
  // @@protoc_insertion_point(field_list:livekit.ListRoomsRequest.names)
  return _impl_.names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListRoomsRequest::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListRoomsRequest.names)
  return &_impl_.names_;
}

// -------------------------------------------------------------------

// ListRoomsResponse

// repeated .livekit.Room rooms = 1;
inline int ListRoomsResponse::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int ListRoomsResponse::rooms_size() const {
  return _internal_rooms_size();
}
inline ::livekit::Room* ListRoomsResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ListRoomsResponse.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Room >*
ListRoomsResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListRoomsResponse.rooms)
  return &_impl_.rooms_;
}
inline const ::livekit::Room& ListRoomsResponse::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::livekit::Room& ListRoomsResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ListRoomsResponse.rooms)
  return _internal_rooms(index);
}
inline ::livekit::Room* ListRoomsResponse::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::livekit::Room* ListRoomsResponse::add_rooms() {
  ::livekit::Room* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:livekit.ListRoomsResponse.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::Room >&
ListRoomsResponse::rooms() const {
  // @@protoc_insertion_point(field_list:livekit.ListRoomsResponse.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// DeleteRoomRequest

// string room = 1;
inline void DeleteRoomRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& DeleteRoomRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.DeleteRoomRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRoomRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DeleteRoomRequest.room)
}
inline std::string* DeleteRoomRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.DeleteRoomRequest.room)
  return _s;
}
inline const std::string& DeleteRoomRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void DeleteRoomRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRoomRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRoomRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.DeleteRoomRequest.room)
  return _impl_.room_.Release();
}
inline void DeleteRoomRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DeleteRoomRequest.room)
}

// -------------------------------------------------------------------

// DeleteRoomResponse

// -------------------------------------------------------------------

// ListParticipantsRequest

// string room = 1;
inline void ListParticipantsRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& ListParticipantsRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.ListParticipantsRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListParticipantsRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ListParticipantsRequest.room)
}
inline std::string* ListParticipantsRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.ListParticipantsRequest.room)
  return _s;
}
inline const std::string& ListParticipantsRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void ListParticipantsRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* ListParticipantsRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* ListParticipantsRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.ListParticipantsRequest.room)
  return _impl_.room_.Release();
}
inline void ListParticipantsRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ListParticipantsRequest.room)
}

// -------------------------------------------------------------------

// ListParticipantsResponse

// repeated .livekit.ParticipantInfo participants = 1;
inline int ListParticipantsResponse::_internal_participants_size() const {
  return _impl_.participants_.size();
}
inline int ListParticipantsResponse::participants_size() const {
  return _internal_participants_size();
}
inline ::livekit::ParticipantInfo* ListParticipantsResponse::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ListParticipantsResponse.participants)
  return _impl_.participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >*
ListParticipantsResponse::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListParticipantsResponse.participants)
  return &_impl_.participants_;
}
inline const ::livekit::ParticipantInfo& ListParticipantsResponse::_internal_participants(int index) const {
  return _impl_.participants_.Get(index);
}
inline const ::livekit::ParticipantInfo& ListParticipantsResponse::participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ListParticipantsResponse.participants)
  return _internal_participants(index);
}
inline ::livekit::ParticipantInfo* ListParticipantsResponse::_internal_add_participants() {
  return _impl_.participants_.Add();
}
inline ::livekit::ParticipantInfo* ListParticipantsResponse::add_participants() {
  ::livekit::ParticipantInfo* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:livekit.ListParticipantsResponse.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantInfo >&
ListParticipantsResponse::participants() const {
  // @@protoc_insertion_point(field_list:livekit.ListParticipantsResponse.participants)
  return _impl_.participants_;
}

// -------------------------------------------------------------------

// RoomParticipantIdentity

// string room = 1;
inline void RoomParticipantIdentity::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& RoomParticipantIdentity::room() const {
  // @@protoc_insertion_point(field_get:livekit.RoomParticipantIdentity.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomParticipantIdentity::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomParticipantIdentity.room)
}
inline std::string* RoomParticipantIdentity::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.RoomParticipantIdentity.room)
  return _s;
}
inline const std::string& RoomParticipantIdentity::_internal_room() const {
  return _impl_.room_.Get();
}
inline void RoomParticipantIdentity::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomParticipantIdentity::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomParticipantIdentity::release_room() {
  // @@protoc_insertion_point(field_release:livekit.RoomParticipantIdentity.room)
  return _impl_.room_.Release();
}
inline void RoomParticipantIdentity::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomParticipantIdentity.room)
}

// string identity = 2;
inline void RoomParticipantIdentity::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& RoomParticipantIdentity::identity() const {
  // @@protoc_insertion_point(field_get:livekit.RoomParticipantIdentity.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomParticipantIdentity::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomParticipantIdentity.identity)
}
inline std::string* RoomParticipantIdentity::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.RoomParticipantIdentity.identity)
  return _s;
}
inline const std::string& RoomParticipantIdentity::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void RoomParticipantIdentity::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomParticipantIdentity::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomParticipantIdentity::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.RoomParticipantIdentity.identity)
  return _impl_.identity_.Release();
}
inline void RoomParticipantIdentity::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomParticipantIdentity.identity)
}

// -------------------------------------------------------------------

// RemoveParticipantResponse

// -------------------------------------------------------------------

// MuteRoomTrackRequest

// string room = 1;
inline void MuteRoomTrackRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& MuteRoomTrackRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.MuteRoomTrackRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MuteRoomTrackRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.MuteRoomTrackRequest.room)
}
inline std::string* MuteRoomTrackRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.MuteRoomTrackRequest.room)
  return _s;
}
inline const std::string& MuteRoomTrackRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void MuteRoomTrackRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.MuteRoomTrackRequest.room)
  return _impl_.room_.Release();
}
inline void MuteRoomTrackRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteRoomTrackRequest.room)
}

// string identity = 2;
inline void MuteRoomTrackRequest::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& MuteRoomTrackRequest::identity() const {
  // @@protoc_insertion_point(field_get:livekit.MuteRoomTrackRequest.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MuteRoomTrackRequest::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.MuteRoomTrackRequest.identity)
}
inline std::string* MuteRoomTrackRequest::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.MuteRoomTrackRequest.identity)
  return _s;
}
inline const std::string& MuteRoomTrackRequest::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void MuteRoomTrackRequest::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.MuteRoomTrackRequest.identity)
  return _impl_.identity_.Release();
}
inline void MuteRoomTrackRequest::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteRoomTrackRequest.identity)
}

// string track_sid = 3;
inline void MuteRoomTrackRequest::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
}
inline const std::string& MuteRoomTrackRequest::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.MuteRoomTrackRequest.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MuteRoomTrackRequest::set_track_sid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.MuteRoomTrackRequest.track_sid)
}
inline std::string* MuteRoomTrackRequest::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.MuteRoomTrackRequest.track_sid)
  return _s;
}
inline const std::string& MuteRoomTrackRequest::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void MuteRoomTrackRequest::_internal_set_track_sid(const std::string& value) {
  
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::_internal_mutable_track_sid() {
  
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* MuteRoomTrackRequest::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.MuteRoomTrackRequest.track_sid)
  return _impl_.track_sid_.Release();
}
inline void MuteRoomTrackRequest::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    
  } else {
    
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteRoomTrackRequest.track_sid)
}

// bool muted = 4;
inline void MuteRoomTrackRequest::clear_muted() {
  _impl_.muted_ = false;
}
inline bool MuteRoomTrackRequest::_internal_muted() const {
  return _impl_.muted_;
}
inline bool MuteRoomTrackRequest::muted() const {
  // @@protoc_insertion_point(field_get:livekit.MuteRoomTrackRequest.muted)
  return _internal_muted();
}
inline void MuteRoomTrackRequest::_internal_set_muted(bool value) {
  
  _impl_.muted_ = value;
}
inline void MuteRoomTrackRequest::set_muted(bool value) {
  _internal_set_muted(value);
  // @@protoc_insertion_point(field_set:livekit.MuteRoomTrackRequest.muted)
}

// -------------------------------------------------------------------

// MuteRoomTrackResponse

// .livekit.TrackInfo track = 1;
inline bool MuteRoomTrackResponse::_internal_has_track() const {
  return this != internal_default_instance() && _impl_.track_ != nullptr;
}
inline bool MuteRoomTrackResponse::has_track() const {
  return _internal_has_track();
}
inline const ::livekit::TrackInfo& MuteRoomTrackResponse::_internal_track() const {
  const ::livekit::TrackInfo* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::TrackInfo&>(
      ::livekit::_TrackInfo_default_instance_);
}
inline const ::livekit::TrackInfo& MuteRoomTrackResponse::track() const {
  // @@protoc_insertion_point(field_get:livekit.MuteRoomTrackResponse.track)
  return _internal_track();
}
inline void MuteRoomTrackResponse::unsafe_arena_set_allocated_track(
    ::livekit::TrackInfo* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.MuteRoomTrackResponse.track)
}
inline ::livekit::TrackInfo* MuteRoomTrackResponse::release_track() {
  
  ::livekit::TrackInfo* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::TrackInfo* MuteRoomTrackResponse::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.MuteRoomTrackResponse.track)
  
  ::livekit::TrackInfo* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::TrackInfo* MuteRoomTrackResponse::_internal_mutable_track() {
  
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::TrackInfo>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::livekit::TrackInfo* MuteRoomTrackResponse::mutable_track() {
  ::livekit::TrackInfo* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.MuteRoomTrackResponse.track)
  return _msg;
}
inline void MuteRoomTrackResponse::set_allocated_track(::livekit::TrackInfo* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track));
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.MuteRoomTrackResponse.track)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateParticipantRequest

// string room = 1;
inline void UpdateParticipantRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& UpdateParticipantRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantRequest.room)
}
inline std::string* UpdateParticipantRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantRequest.room)
  return _s;
}
inline const std::string& UpdateParticipantRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void UpdateParticipantRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantRequest.room)
  return _impl_.room_.Release();
}
inline void UpdateParticipantRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantRequest.room)
}

// string identity = 2;
inline void UpdateParticipantRequest::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& UpdateParticipantRequest::identity() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantRequest.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantRequest::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantRequest.identity)
}
inline std::string* UpdateParticipantRequest::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantRequest.identity)
  return _s;
}
inline const std::string& UpdateParticipantRequest::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void UpdateParticipantRequest::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantRequest.identity)
  return _impl_.identity_.Release();
}
inline void UpdateParticipantRequest::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantRequest.identity)
}

// string metadata = 3;
inline void UpdateParticipantRequest::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& UpdateParticipantRequest::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantRequest.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantRequest::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantRequest.metadata)
}
inline std::string* UpdateParticipantRequest::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantRequest.metadata)
  return _s;
}
inline const std::string& UpdateParticipantRequest::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void UpdateParticipantRequest::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantRequest.metadata)
  return _impl_.metadata_.Release();
}
inline void UpdateParticipantRequest::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantRequest.metadata)
}

// .livekit.ParticipantPermission permission = 4;
inline bool UpdateParticipantRequest::_internal_has_permission() const {
  return this != internal_default_instance() && _impl_.permission_ != nullptr;
}
inline bool UpdateParticipantRequest::has_permission() const {
  return _internal_has_permission();
}
inline const ::livekit::ParticipantPermission& UpdateParticipantRequest::_internal_permission() const {
  const ::livekit::ParticipantPermission* p = _impl_.permission_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantPermission&>(
      ::livekit::_ParticipantPermission_default_instance_);
}
inline const ::livekit::ParticipantPermission& UpdateParticipantRequest::permission() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantRequest.permission)
  return _internal_permission();
}
inline void UpdateParticipantRequest::unsafe_arena_set_allocated_permission(
    ::livekit::ParticipantPermission* permission) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  _impl_.permission_ = permission;
  if (permission) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.UpdateParticipantRequest.permission)
}
inline ::livekit::ParticipantPermission* UpdateParticipantRequest::release_permission() {
  
  ::livekit::ParticipantPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantPermission* UpdateParticipantRequest::unsafe_arena_release_permission() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantRequest.permission)
  
  ::livekit::ParticipantPermission* temp = _impl_.permission_;
  _impl_.permission_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantPermission* UpdateParticipantRequest::_internal_mutable_permission() {
  
  if (_impl_.permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantPermission>(GetArenaForAllocation());
    _impl_.permission_ = p;
  }
  return _impl_.permission_;
}
inline ::livekit::ParticipantPermission* UpdateParticipantRequest::mutable_permission() {
  ::livekit::ParticipantPermission* _msg = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantRequest.permission)
  return _msg;
}
inline void UpdateParticipantRequest::set_allocated_permission(::livekit::ParticipantPermission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_);
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(permission));
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantRequest.permission)
}

// string name = 5;
inline void UpdateParticipantRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateParticipantRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateParticipantRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateParticipantRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateParticipantRequest.name)
}
inline std::string* UpdateParticipantRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateParticipantRequest.name)
  return _s;
}
inline const std::string& UpdateParticipantRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateParticipantRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateParticipantRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.UpdateParticipantRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateParticipantRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateParticipantRequest.name)
}

// map<string, string> attributes = 6;
inline int UpdateParticipantRequest::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int UpdateParticipantRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline void UpdateParticipantRequest::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateParticipantRequest::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateParticipantRequest::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.UpdateParticipantRequest.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateParticipantRequest::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateParticipantRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.UpdateParticipantRequest.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// UpdateSubscriptionsRequest

// string room = 1;
inline void UpdateSubscriptionsRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionsRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscriptionsRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionsRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscriptionsRequest.room)
}
inline std::string* UpdateSubscriptionsRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscriptionsRequest.room)
  return _s;
}
inline const std::string& UpdateSubscriptionsRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void UpdateSubscriptionsRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionsRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionsRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.UpdateSubscriptionsRequest.room)
  return _impl_.room_.Release();
}
inline void UpdateSubscriptionsRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateSubscriptionsRequest.room)
}

// string identity = 2;
inline void UpdateSubscriptionsRequest::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& UpdateSubscriptionsRequest::identity() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscriptionsRequest.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSubscriptionsRequest::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscriptionsRequest.identity)
}
inline std::string* UpdateSubscriptionsRequest::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscriptionsRequest.identity)
  return _s;
}
inline const std::string& UpdateSubscriptionsRequest::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void UpdateSubscriptionsRequest::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionsRequest::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSubscriptionsRequest::release_identity() {
  // @@protoc_insertion_point(field_release:livekit.UpdateSubscriptionsRequest.identity)
  return _impl_.identity_.Release();
}
inline void UpdateSubscriptionsRequest::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateSubscriptionsRequest.identity)
}

// repeated string track_sids = 3;
inline int UpdateSubscriptionsRequest::_internal_track_sids_size() const {
  return _impl_.track_sids_.size();
}
inline int UpdateSubscriptionsRequest::track_sids_size() const {
  return _internal_track_sids_size();
}
inline void UpdateSubscriptionsRequest::clear_track_sids() {
  _impl_.track_sids_.Clear();
}
inline std::string* UpdateSubscriptionsRequest::add_track_sids() {
  std::string* _s = _internal_add_track_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.UpdateSubscriptionsRequest.track_sids)
  return _s;
}
inline const std::string& UpdateSubscriptionsRequest::_internal_track_sids(int index) const {
  return _impl_.track_sids_.Get(index);
}
inline const std::string& UpdateSubscriptionsRequest::track_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscriptionsRequest.track_sids)
  return _internal_track_sids(index);
}
inline std::string* UpdateSubscriptionsRequest::mutable_track_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscriptionsRequest.track_sids)
  return _impl_.track_sids_.Mutable(index);
}
inline void UpdateSubscriptionsRequest::set_track_sids(int index, const std::string& value) {
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::set_track_sids(int index, std::string&& value) {
  _impl_.track_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::set_track_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::set_track_sids(int index, const char* value, size_t size) {
  _impl_.track_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline std::string* UpdateSubscriptionsRequest::_internal_add_track_sids() {
  return _impl_.track_sids_.Add();
}
inline void UpdateSubscriptionsRequest::add_track_sids(const std::string& value) {
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::add_track_sids(std::string&& value) {
  _impl_.track_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::add_track_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.track_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline void UpdateSubscriptionsRequest::add_track_sids(const char* value, size_t size) {
  _impl_.track_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.UpdateSubscriptionsRequest.track_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateSubscriptionsRequest::track_sids() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscriptionsRequest.track_sids)
  return _impl_.track_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateSubscriptionsRequest::mutable_track_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscriptionsRequest.track_sids)
  return &_impl_.track_sids_;
}

// bool subscribe = 4;
inline void UpdateSubscriptionsRequest::clear_subscribe() {
  _impl_.subscribe_ = false;
}
inline bool UpdateSubscriptionsRequest::_internal_subscribe() const {
  return _impl_.subscribe_;
}
inline bool UpdateSubscriptionsRequest::subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscriptionsRequest.subscribe)
  return _internal_subscribe();
}
inline void UpdateSubscriptionsRequest::_internal_set_subscribe(bool value) {
  
  _impl_.subscribe_ = value;
}
inline void UpdateSubscriptionsRequest::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateSubscriptionsRequest.subscribe)
}

// repeated .livekit.ParticipantTracks participant_tracks = 5;
inline int UpdateSubscriptionsRequest::_internal_participant_tracks_size() const {
  return _impl_.participant_tracks_.size();
}
inline int UpdateSubscriptionsRequest::participant_tracks_size() const {
  return _internal_participant_tracks_size();
}
inline ::livekit::ParticipantTracks* UpdateSubscriptionsRequest::mutable_participant_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.UpdateSubscriptionsRequest.participant_tracks)
  return _impl_.participant_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >*
UpdateSubscriptionsRequest::mutable_participant_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.UpdateSubscriptionsRequest.participant_tracks)
  return &_impl_.participant_tracks_;
}
inline const ::livekit::ParticipantTracks& UpdateSubscriptionsRequest::_internal_participant_tracks(int index) const {
  return _impl_.participant_tracks_.Get(index);
}
inline const ::livekit::ParticipantTracks& UpdateSubscriptionsRequest::participant_tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.UpdateSubscriptionsRequest.participant_tracks)
  return _internal_participant_tracks(index);
}
inline ::livekit::ParticipantTracks* UpdateSubscriptionsRequest::_internal_add_participant_tracks() {
  return _impl_.participant_tracks_.Add();
}
inline ::livekit::ParticipantTracks* UpdateSubscriptionsRequest::add_participant_tracks() {
  ::livekit::ParticipantTracks* _add = _internal_add_participant_tracks();
  // @@protoc_insertion_point(field_add:livekit.UpdateSubscriptionsRequest.participant_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::ParticipantTracks >&
UpdateSubscriptionsRequest::participant_tracks() const {
  // @@protoc_insertion_point(field_list:livekit.UpdateSubscriptionsRequest.participant_tracks)
  return _impl_.participant_tracks_;
}

// -------------------------------------------------------------------

// UpdateSubscriptionsResponse

// -------------------------------------------------------------------

// SendDataRequest

// string room = 1;
inline void SendDataRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& SendDataRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendDataRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.room)
}
inline std::string* SendDataRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.room)
  return _s;
}
inline const std::string& SendDataRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void SendDataRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* SendDataRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* SendDataRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.SendDataRequest.room)
  return _impl_.room_.Release();
}
inline void SendDataRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SendDataRequest.room)
}

// bytes data = 2;
inline void SendDataRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SendDataRequest::data() const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendDataRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.data)
}
inline std::string* SendDataRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.data)
  return _s;
}
inline const std::string& SendDataRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SendDataRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SendDataRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SendDataRequest::release_data() {
  // @@protoc_insertion_point(field_release:livekit.SendDataRequest.data)
  return _impl_.data_.Release();
}
inline void SendDataRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SendDataRequest.data)
}

// .livekit.DataPacket.Kind kind = 3;
inline void SendDataRequest::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::livekit::DataPacket_Kind SendDataRequest::_internal_kind() const {
  return static_cast< ::livekit::DataPacket_Kind >(_impl_.kind_);
}
inline ::livekit::DataPacket_Kind SendDataRequest::kind() const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.kind)
  return _internal_kind();
}
inline void SendDataRequest::_internal_set_kind(::livekit::DataPacket_Kind value) {
  
  _impl_.kind_ = value;
}
inline void SendDataRequest::set_kind(::livekit::DataPacket_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.kind)
}

// repeated string destination_sids = 4 [deprecated = true];
inline int SendDataRequest::_internal_destination_sids_size() const {
  return _impl_.destination_sids_.size();
}
inline int SendDataRequest::destination_sids_size() const {
  return _internal_destination_sids_size();
}
inline void SendDataRequest::clear_destination_sids() {
  _impl_.destination_sids_.Clear();
}
inline std::string* SendDataRequest::add_destination_sids() {
  std::string* _s = _internal_add_destination_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.SendDataRequest.destination_sids)
  return _s;
}
inline const std::string& SendDataRequest::_internal_destination_sids(int index) const {
  return _impl_.destination_sids_.Get(index);
}
inline const std::string& SendDataRequest::destination_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.destination_sids)
  return _internal_destination_sids(index);
}
inline std::string* SendDataRequest::mutable_destination_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.destination_sids)
  return _impl_.destination_sids_.Mutable(index);
}
inline void SendDataRequest::set_destination_sids(int index, const std::string& value) {
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::set_destination_sids(int index, std::string&& value) {
  _impl_.destination_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::set_destination_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::set_destination_sids(int index, const char* value, size_t size) {
  _impl_.destination_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.SendDataRequest.destination_sids)
}
inline std::string* SendDataRequest::_internal_add_destination_sids() {
  return _impl_.destination_sids_.Add();
}
inline void SendDataRequest::add_destination_sids(const std::string& value) {
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::add_destination_sids(std::string&& value) {
  _impl_.destination_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::add_destination_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.SendDataRequest.destination_sids)
}
inline void SendDataRequest::add_destination_sids(const char* value, size_t size) {
  _impl_.destination_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.SendDataRequest.destination_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendDataRequest::destination_sids() const {
  // @@protoc_insertion_point(field_list:livekit.SendDataRequest.destination_sids)
  return _impl_.destination_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendDataRequest::mutable_destination_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SendDataRequest.destination_sids)
  return &_impl_.destination_sids_;
}

// repeated string destination_identities = 6;
inline int SendDataRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int SendDataRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void SendDataRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* SendDataRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.SendDataRequest.destination_identities)
  return _s;
}
inline const std::string& SendDataRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& SendDataRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* SendDataRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void SendDataRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.SendDataRequest.destination_identities)
}
inline std::string* SendDataRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void SendDataRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.SendDataRequest.destination_identities)
}
inline void SendDataRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.SendDataRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendDataRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.SendDataRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendDataRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.SendDataRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// optional string topic = 5;
inline bool SendDataRequest::_internal_has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendDataRequest::has_topic() const {
  return _internal_has_topic();
}
inline void SendDataRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendDataRequest::topic() const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendDataRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.topic)
}
inline std::string* SendDataRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.topic)
  return _s;
}
inline const std::string& SendDataRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void SendDataRequest::_internal_set_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* SendDataRequest::_internal_mutable_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* SendDataRequest::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.SendDataRequest.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendDataRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SendDataRequest.topic)
}

// bytes nonce = 7;
inline void SendDataRequest::clear_nonce() {
  _impl_.nonce_.ClearToEmpty();
}
inline const std::string& SendDataRequest::nonce() const {
  // @@protoc_insertion_point(field_get:livekit.SendDataRequest.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendDataRequest::set_nonce(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nonce_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.SendDataRequest.nonce)
}
inline std::string* SendDataRequest::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:livekit.SendDataRequest.nonce)
  return _s;
}
inline const std::string& SendDataRequest::_internal_nonce() const {
  return _impl_.nonce_.Get();
}
inline void SendDataRequest::_internal_set_nonce(const std::string& value) {
  
  _impl_.nonce_.Set(value, GetArenaForAllocation());
}
inline std::string* SendDataRequest::_internal_mutable_nonce() {
  
  return _impl_.nonce_.Mutable(GetArenaForAllocation());
}
inline std::string* SendDataRequest::release_nonce() {
  // @@protoc_insertion_point(field_release:livekit.SendDataRequest.nonce)
  return _impl_.nonce_.Release();
}
inline void SendDataRequest::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    
  } else {
    
  }
  _impl_.nonce_.SetAllocated(nonce, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nonce_.IsDefault()) {
    _impl_.nonce_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.SendDataRequest.nonce)
}

// -------------------------------------------------------------------

// SendDataResponse

// -------------------------------------------------------------------

// UpdateRoomMetadataRequest

// string room = 1;
inline void UpdateRoomMetadataRequest::clear_room() {
  _impl_.room_.ClearToEmpty();
}
inline const std::string& UpdateRoomMetadataRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateRoomMetadataRequest.room)
  return _internal_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRoomMetadataRequest::set_room(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateRoomMetadataRequest.room)
}
inline std::string* UpdateRoomMetadataRequest::mutable_room() {
  std::string* _s = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateRoomMetadataRequest.room)
  return _s;
}
inline const std::string& UpdateRoomMetadataRequest::_internal_room() const {
  return _impl_.room_.Get();
}
inline void UpdateRoomMetadataRequest::_internal_set_room(const std::string& value) {
  
  _impl_.room_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRoomMetadataRequest::_internal_mutable_room() {
  
  return _impl_.room_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRoomMetadataRequest::release_room() {
  // @@protoc_insertion_point(field_release:livekit.UpdateRoomMetadataRequest.room)
  return _impl_.room_.Release();
}
inline void UpdateRoomMetadataRequest::set_allocated_room(std::string* room) {
  if (room != nullptr) {
    
  } else {
    
  }
  _impl_.room_.SetAllocated(room, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_.IsDefault()) {
    _impl_.room_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateRoomMetadataRequest.room)
}

// string metadata = 2;
inline void UpdateRoomMetadataRequest::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& UpdateRoomMetadataRequest::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateRoomMetadataRequest.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateRoomMetadataRequest::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateRoomMetadataRequest.metadata)
}
inline std::string* UpdateRoomMetadataRequest::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateRoomMetadataRequest.metadata)
  return _s;
}
inline const std::string& UpdateRoomMetadataRequest::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void UpdateRoomMetadataRequest::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateRoomMetadataRequest::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateRoomMetadataRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.UpdateRoomMetadataRequest.metadata)
  return _impl_.metadata_.Release();
}
inline void UpdateRoomMetadataRequest::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateRoomMetadataRequest.metadata)
}

// -------------------------------------------------------------------

// RoomConfiguration

// string name = 1;
inline void RoomConfiguration::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RoomConfiguration::name() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.name)
}
inline std::string* RoomConfiguration::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.RoomConfiguration.name)
  return _s;
}
inline const std::string& RoomConfiguration::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RoomConfiguration::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomConfiguration::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:livekit.RoomConfiguration.name)
  return _impl_.name_.Release();
}
inline void RoomConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomConfiguration.name)
}

// uint32 empty_timeout = 2;
inline void RoomConfiguration::clear_empty_timeout() {
  _impl_.empty_timeout_ = 0u;
}
inline uint32_t RoomConfiguration::_internal_empty_timeout() const {
  return _impl_.empty_timeout_;
}
inline uint32_t RoomConfiguration::empty_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.empty_timeout)
  return _internal_empty_timeout();
}
inline void RoomConfiguration::_internal_set_empty_timeout(uint32_t value) {
  
  _impl_.empty_timeout_ = value;
}
inline void RoomConfiguration::set_empty_timeout(uint32_t value) {
  _internal_set_empty_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.empty_timeout)
}

// uint32 departure_timeout = 3;
inline void RoomConfiguration::clear_departure_timeout() {
  _impl_.departure_timeout_ = 0u;
}
inline uint32_t RoomConfiguration::_internal_departure_timeout() const {
  return _impl_.departure_timeout_;
}
inline uint32_t RoomConfiguration::departure_timeout() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.departure_timeout)
  return _internal_departure_timeout();
}
inline void RoomConfiguration::_internal_set_departure_timeout(uint32_t value) {
  
  _impl_.departure_timeout_ = value;
}
inline void RoomConfiguration::set_departure_timeout(uint32_t value) {
  _internal_set_departure_timeout(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.departure_timeout)
}

// uint32 max_participants = 4;
inline void RoomConfiguration::clear_max_participants() {
  _impl_.max_participants_ = 0u;
}
inline uint32_t RoomConfiguration::_internal_max_participants() const {
  return _impl_.max_participants_;
}
inline uint32_t RoomConfiguration::max_participants() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.max_participants)
  return _internal_max_participants();
}
inline void RoomConfiguration::_internal_set_max_participants(uint32_t value) {
  
  _impl_.max_participants_ = value;
}
inline void RoomConfiguration::set_max_participants(uint32_t value) {
  _internal_set_max_participants(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.max_participants)
}

// .livekit.RoomEgress egress = 5;
inline bool RoomConfiguration::_internal_has_egress() const {
  return this != internal_default_instance() && _impl_.egress_ != nullptr;
}
inline bool RoomConfiguration::has_egress() const {
  return _internal_has_egress();
}
inline void RoomConfiguration::clear_egress() {
  if (GetArenaForAllocation() == nullptr && _impl_.egress_ != nullptr) {
    delete _impl_.egress_;
  }
  _impl_.egress_ = nullptr;
}
inline const ::livekit::RoomEgress& RoomConfiguration::_internal_egress() const {
  const ::livekit::RoomEgress* p = _impl_.egress_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::RoomEgress&>(
      ::livekit::_RoomEgress_default_instance_);
}
inline const ::livekit::RoomEgress& RoomConfiguration::egress() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.egress)
  return _internal_egress();
}
inline void RoomConfiguration::unsafe_arena_set_allocated_egress(
    ::livekit::RoomEgress* egress) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.egress_);
  }
  _impl_.egress_ = egress;
  if (egress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RoomConfiguration.egress)
}
inline ::livekit::RoomEgress* RoomConfiguration::release_egress() {
  
  ::livekit::RoomEgress* temp = _impl_.egress_;
  _impl_.egress_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::RoomEgress* RoomConfiguration::unsafe_arena_release_egress() {
  // @@protoc_insertion_point(field_release:livekit.RoomConfiguration.egress)
  
  ::livekit::RoomEgress* temp = _impl_.egress_;
  _impl_.egress_ = nullptr;
  return temp;
}
inline ::livekit::RoomEgress* RoomConfiguration::_internal_mutable_egress() {
  
  if (_impl_.egress_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::RoomEgress>(GetArenaForAllocation());
    _impl_.egress_ = p;
  }
  return _impl_.egress_;
}
inline ::livekit::RoomEgress* RoomConfiguration::mutable_egress() {
  ::livekit::RoomEgress* _msg = _internal_mutable_egress();
  // @@protoc_insertion_point(field_mutable:livekit.RoomConfiguration.egress)
  return _msg;
}
inline void RoomConfiguration::set_allocated_egress(::livekit::RoomEgress* egress) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.egress_;
  }
  if (egress) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(egress);
    if (message_arena != submessage_arena) {
      egress = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, egress, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.egress_ = egress;
  // @@protoc_insertion_point(field_set_allocated:livekit.RoomConfiguration.egress)
}

// uint32 min_playout_delay = 7;
inline void RoomConfiguration::clear_min_playout_delay() {
  _impl_.min_playout_delay_ = 0u;
}
inline uint32_t RoomConfiguration::_internal_min_playout_delay() const {
  return _impl_.min_playout_delay_;
}
inline uint32_t RoomConfiguration::min_playout_delay() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.min_playout_delay)
  return _internal_min_playout_delay();
}
inline void RoomConfiguration::_internal_set_min_playout_delay(uint32_t value) {
  
  _impl_.min_playout_delay_ = value;
}
inline void RoomConfiguration::set_min_playout_delay(uint32_t value) {
  _internal_set_min_playout_delay(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.min_playout_delay)
}

// uint32 max_playout_delay = 8;
inline void RoomConfiguration::clear_max_playout_delay() {
  _impl_.max_playout_delay_ = 0u;
}
inline uint32_t RoomConfiguration::_internal_max_playout_delay() const {
  return _impl_.max_playout_delay_;
}
inline uint32_t RoomConfiguration::max_playout_delay() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.max_playout_delay)
  return _internal_max_playout_delay();
}
inline void RoomConfiguration::_internal_set_max_playout_delay(uint32_t value) {
  
  _impl_.max_playout_delay_ = value;
}
inline void RoomConfiguration::set_max_playout_delay(uint32_t value) {
  _internal_set_max_playout_delay(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.max_playout_delay)
}

// bool sync_streams = 9;
inline void RoomConfiguration::clear_sync_streams() {
  _impl_.sync_streams_ = false;
}
inline bool RoomConfiguration::_internal_sync_streams() const {
  return _impl_.sync_streams_;
}
inline bool RoomConfiguration::sync_streams() const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.sync_streams)
  return _internal_sync_streams();
}
inline void RoomConfiguration::_internal_set_sync_streams(bool value) {
  
  _impl_.sync_streams_ = value;
}
inline void RoomConfiguration::set_sync_streams(bool value) {
  _internal_set_sync_streams(value);
  // @@protoc_insertion_point(field_set:livekit.RoomConfiguration.sync_streams)
}

// repeated .livekit.RoomAgentDispatch agents = 10;
inline int RoomConfiguration::_internal_agents_size() const {
  return _impl_.agents_.size();
}
inline int RoomConfiguration::agents_size() const {
  return _internal_agents_size();
}
inline ::livekit::RoomAgentDispatch* RoomConfiguration::mutable_agents(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.RoomConfiguration.agents)
  return _impl_.agents_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >*
RoomConfiguration::mutable_agents() {
  // @@protoc_insertion_point(field_mutable_list:livekit.RoomConfiguration.agents)
  return &_impl_.agents_;
}
inline const ::livekit::RoomAgentDispatch& RoomConfiguration::_internal_agents(int index) const {
  return _impl_.agents_.Get(index);
}
inline const ::livekit::RoomAgentDispatch& RoomConfiguration::agents(int index) const {
  // @@protoc_insertion_point(field_get:livekit.RoomConfiguration.agents)
  return _internal_agents(index);
}
inline ::livekit::RoomAgentDispatch* RoomConfiguration::_internal_add_agents() {
  return _impl_.agents_.Add();
}
inline ::livekit::RoomAgentDispatch* RoomConfiguration::add_agents() {
  ::livekit::RoomAgentDispatch* _add = _internal_add_agents();
  // @@protoc_insertion_point(field_add:livekit.RoomConfiguration.agents)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::RoomAgentDispatch >&
RoomConfiguration::agents() const {
  // @@protoc_insertion_point(field_list:livekit.RoomConfiguration.agents)
  return _impl_.agents_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5froom_2eproto
