// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_ingress.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5fingress_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5fingress_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5fingress_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fingress_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5fingress_2eproto;
namespace livekit {
class CreateIngressRequest;
struct CreateIngressRequestDefaultTypeInternal;
extern CreateIngressRequestDefaultTypeInternal _CreateIngressRequest_default_instance_;
class DeleteIngressRequest;
struct DeleteIngressRequestDefaultTypeInternal;
extern DeleteIngressRequestDefaultTypeInternal _DeleteIngressRequest_default_instance_;
class IngressAudioEncodingOptions;
struct IngressAudioEncodingOptionsDefaultTypeInternal;
extern IngressAudioEncodingOptionsDefaultTypeInternal _IngressAudioEncodingOptions_default_instance_;
class IngressAudioOptions;
struct IngressAudioOptionsDefaultTypeInternal;
extern IngressAudioOptionsDefaultTypeInternal _IngressAudioOptions_default_instance_;
class IngressInfo;
struct IngressInfoDefaultTypeInternal;
extern IngressInfoDefaultTypeInternal _IngressInfo_default_instance_;
class IngressState;
struct IngressStateDefaultTypeInternal;
extern IngressStateDefaultTypeInternal _IngressState_default_instance_;
class IngressVideoEncodingOptions;
struct IngressVideoEncodingOptionsDefaultTypeInternal;
extern IngressVideoEncodingOptionsDefaultTypeInternal _IngressVideoEncodingOptions_default_instance_;
class IngressVideoOptions;
struct IngressVideoOptionsDefaultTypeInternal;
extern IngressVideoOptionsDefaultTypeInternal _IngressVideoOptions_default_instance_;
class InputAudioState;
struct InputAudioStateDefaultTypeInternal;
extern InputAudioStateDefaultTypeInternal _InputAudioState_default_instance_;
class InputVideoState;
struct InputVideoStateDefaultTypeInternal;
extern InputVideoStateDefaultTypeInternal _InputVideoState_default_instance_;
class ListIngressRequest;
struct ListIngressRequestDefaultTypeInternal;
extern ListIngressRequestDefaultTypeInternal _ListIngressRequest_default_instance_;
class ListIngressResponse;
struct ListIngressResponseDefaultTypeInternal;
extern ListIngressResponseDefaultTypeInternal _ListIngressResponse_default_instance_;
class UpdateIngressRequest;
struct UpdateIngressRequestDefaultTypeInternal;
extern UpdateIngressRequestDefaultTypeInternal _UpdateIngressRequest_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::CreateIngressRequest* Arena::CreateMaybeMessage<::livekit::CreateIngressRequest>(Arena*);
template<> ::livekit::DeleteIngressRequest* Arena::CreateMaybeMessage<::livekit::DeleteIngressRequest>(Arena*);
template<> ::livekit::IngressAudioEncodingOptions* Arena::CreateMaybeMessage<::livekit::IngressAudioEncodingOptions>(Arena*);
template<> ::livekit::IngressAudioOptions* Arena::CreateMaybeMessage<::livekit::IngressAudioOptions>(Arena*);
template<> ::livekit::IngressInfo* Arena::CreateMaybeMessage<::livekit::IngressInfo>(Arena*);
template<> ::livekit::IngressState* Arena::CreateMaybeMessage<::livekit::IngressState>(Arena*);
template<> ::livekit::IngressVideoEncodingOptions* Arena::CreateMaybeMessage<::livekit::IngressVideoEncodingOptions>(Arena*);
template<> ::livekit::IngressVideoOptions* Arena::CreateMaybeMessage<::livekit::IngressVideoOptions>(Arena*);
template<> ::livekit::InputAudioState* Arena::CreateMaybeMessage<::livekit::InputAudioState>(Arena*);
template<> ::livekit::InputVideoState* Arena::CreateMaybeMessage<::livekit::InputVideoState>(Arena*);
template<> ::livekit::ListIngressRequest* Arena::CreateMaybeMessage<::livekit::ListIngressRequest>(Arena*);
template<> ::livekit::ListIngressResponse* Arena::CreateMaybeMessage<::livekit::ListIngressResponse>(Arena*);
template<> ::livekit::UpdateIngressRequest* Arena::CreateMaybeMessage<::livekit::UpdateIngressRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum IngressState_Status : int {
  IngressState_Status_ENDPOINT_INACTIVE = 0,
  IngressState_Status_ENDPOINT_BUFFERING = 1,
  IngressState_Status_ENDPOINT_PUBLISHING = 2,
  IngressState_Status_ENDPOINT_ERROR = 3,
  IngressState_Status_ENDPOINT_COMPLETE = 4,
  IngressState_Status_IngressState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IngressState_Status_IngressState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IngressState_Status_IsValid(int value);
constexpr IngressState_Status IngressState_Status_Status_MIN = IngressState_Status_ENDPOINT_INACTIVE;
constexpr IngressState_Status IngressState_Status_Status_MAX = IngressState_Status_ENDPOINT_COMPLETE;
constexpr int IngressState_Status_Status_ARRAYSIZE = IngressState_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressState_Status_descriptor();
template<typename T>
inline const std::string& IngressState_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IngressState_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IngressState_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IngressState_Status_descriptor(), enum_t_value);
}
inline bool IngressState_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IngressState_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IngressState_Status>(
    IngressState_Status_descriptor(), name, value);
}
enum IngressInput : int {
  RTMP_INPUT = 0,
  WHIP_INPUT = 1,
  URL_INPUT = 2,
  IngressInput_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IngressInput_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IngressInput_IsValid(int value);
constexpr IngressInput IngressInput_MIN = RTMP_INPUT;
constexpr IngressInput IngressInput_MAX = URL_INPUT;
constexpr int IngressInput_ARRAYSIZE = IngressInput_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressInput_descriptor();
template<typename T>
inline const std::string& IngressInput_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IngressInput>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IngressInput_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IngressInput_descriptor(), enum_t_value);
}
inline bool IngressInput_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IngressInput* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IngressInput>(
    IngressInput_descriptor(), name, value);
}
enum IngressAudioEncodingPreset : int {
  OPUS_STEREO_96KBPS = 0,
  OPUS_MONO_64KBS = 1,
  IngressAudioEncodingPreset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IngressAudioEncodingPreset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IngressAudioEncodingPreset_IsValid(int value);
constexpr IngressAudioEncodingPreset IngressAudioEncodingPreset_MIN = OPUS_STEREO_96KBPS;
constexpr IngressAudioEncodingPreset IngressAudioEncodingPreset_MAX = OPUS_MONO_64KBS;
constexpr int IngressAudioEncodingPreset_ARRAYSIZE = IngressAudioEncodingPreset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressAudioEncodingPreset_descriptor();
template<typename T>
inline const std::string& IngressAudioEncodingPreset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IngressAudioEncodingPreset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IngressAudioEncodingPreset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IngressAudioEncodingPreset_descriptor(), enum_t_value);
}
inline bool IngressAudioEncodingPreset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IngressAudioEncodingPreset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IngressAudioEncodingPreset>(
    IngressAudioEncodingPreset_descriptor(), name, value);
}
enum IngressVideoEncodingPreset : int {
  H264_720P_30FPS_3_LAYERS = 0,
  H264_1080P_30FPS_3_LAYERS = 1,
  H264_540P_25FPS_2_LAYERS = 2,
  H264_720P_30FPS_1_LAYER = 3,
  H264_1080P_30FPS_1_LAYER = 4,
  H264_720P_30FPS_3_LAYERS_HIGH_MOTION = 5,
  H264_1080P_30FPS_3_LAYERS_HIGH_MOTION = 6,
  H264_540P_25FPS_2_LAYERS_HIGH_MOTION = 7,
  H264_720P_30FPS_1_LAYER_HIGH_MOTION = 8,
  H264_1080P_30FPS_1_LAYER_HIGH_MOTION = 9,
  IngressVideoEncodingPreset_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IngressVideoEncodingPreset_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IngressVideoEncodingPreset_IsValid(int value);
constexpr IngressVideoEncodingPreset IngressVideoEncodingPreset_MIN = H264_720P_30FPS_3_LAYERS;
constexpr IngressVideoEncodingPreset IngressVideoEncodingPreset_MAX = H264_1080P_30FPS_1_LAYER_HIGH_MOTION;
constexpr int IngressVideoEncodingPreset_ARRAYSIZE = IngressVideoEncodingPreset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IngressVideoEncodingPreset_descriptor();
template<typename T>
inline const std::string& IngressVideoEncodingPreset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IngressVideoEncodingPreset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IngressVideoEncodingPreset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IngressVideoEncodingPreset_descriptor(), enum_t_value);
}
inline bool IngressVideoEncodingPreset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IngressVideoEncodingPreset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IngressVideoEncodingPreset>(
    IngressVideoEncodingPreset_descriptor(), name, value);
}
// ===================================================================

class CreateIngressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.CreateIngressRequest) */ {
 public:
  inline CreateIngressRequest() : CreateIngressRequest(nullptr) {}
  ~CreateIngressRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateIngressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIngressRequest(const CreateIngressRequest& from);
  CreateIngressRequest(CreateIngressRequest&& from) noexcept
    : CreateIngressRequest() {
    *this = ::std::move(from);
  }

  inline CreateIngressRequest& operator=(const CreateIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIngressRequest& operator=(CreateIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIngressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIngressRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIngressRequest*>(
               &_CreateIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateIngressRequest& a, CreateIngressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIngressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIngressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIngressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIngressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIngressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateIngressRequest& from) {
    CreateIngressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIngressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.CreateIngressRequest";
  }
  protected:
  explicit CreateIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRoomNameFieldNumber = 3,
    kParticipantIdentityFieldNumber = 4,
    kParticipantNameFieldNumber = 5,
    kUrlFieldNumber = 9,
    kParticipantMetadataFieldNumber = 10,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kInputTypeFieldNumber = 1,
    kBypassTranscodingFieldNumber = 8,
    kEnableTranscodingFieldNumber = 11,
    kEnabledFieldNumber = 12,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string room_name = 3;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string participant_identity = 4;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // string participant_name = 5;
  void clear_participant_name();
  const std::string& participant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_name();
  PROTOBUF_NODISCARD std::string* release_participant_name();
  void set_allocated_participant_name(std::string* participant_name);
  private:
  const std::string& _internal_participant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* _internal_mutable_participant_name();
  public:

  // string url = 9;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string participant_metadata = 10;
  void clear_participant_metadata();
  const std::string& participant_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_metadata();
  PROTOBUF_NODISCARD std::string* release_participant_metadata();
  void set_allocated_participant_metadata(std::string* participant_metadata);
  private:
  const std::string& _internal_participant_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* _internal_mutable_participant_metadata();
  public:

  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::livekit::IngressAudioOptions& audio() const;
  PROTOBUF_NODISCARD ::livekit::IngressAudioOptions* release_audio();
  ::livekit::IngressAudioOptions* mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* audio);
  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::livekit::IngressAudioOptions* audio);
  ::livekit::IngressAudioOptions* unsafe_arena_release_audio();

  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::IngressVideoOptions& video() const;
  PROTOBUF_NODISCARD ::livekit::IngressVideoOptions* release_video();
  ::livekit::IngressVideoOptions* mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* video);
  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::IngressVideoOptions* video);
  ::livekit::IngressVideoOptions* unsafe_arena_release_video();

  // .livekit.IngressInput input_type = 1;
  void clear_input_type();
  ::livekit::IngressInput input_type() const;
  void set_input_type(::livekit::IngressInput value);
  private:
  ::livekit::IngressInput _internal_input_type() const;
  void _internal_set_input_type(::livekit::IngressInput value);
  public:

  // bool bypass_transcoding = 8 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_bypass_transcoding();
  PROTOBUF_DEPRECATED bool bypass_transcoding() const;
  PROTOBUF_DEPRECATED void set_bypass_transcoding(bool value);
  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);
  public:

  // optional bool enable_transcoding = 11;
  bool has_enable_transcoding() const;
  private:
  bool _internal_has_enable_transcoding() const;
  public:
  void clear_enable_transcoding();
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);
  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);
  public:

  // optional bool enabled = 12;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.CreateIngressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* audio_;
    ::livekit::IngressVideoOptions* video_;
    int input_type_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressAudioOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressAudioOptions) */ {
 public:
  inline IngressAudioOptions() : IngressAudioOptions(nullptr) {}
  ~IngressAudioOptions() override;
  explicit PROTOBUF_CONSTEXPR IngressAudioOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressAudioOptions(const IngressAudioOptions& from);
  IngressAudioOptions(IngressAudioOptions&& from) noexcept
    : IngressAudioOptions() {
    *this = ::std::move(from);
  }

  inline IngressAudioOptions& operator=(const IngressAudioOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressAudioOptions& operator=(IngressAudioOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressAudioOptions& default_instance() {
    return *internal_default_instance();
  }
  enum EncodingOptionsCase {
    kPreset = 3,
    kOptions = 4,
    ENCODING_OPTIONS_NOT_SET = 0,
  };

  static inline const IngressAudioOptions* internal_default_instance() {
    return reinterpret_cast<const IngressAudioOptions*>(
               &_IngressAudioOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IngressAudioOptions& a, IngressAudioOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressAudioOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressAudioOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressAudioOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressAudioOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressAudioOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressAudioOptions& from) {
    IngressAudioOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressAudioOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressAudioOptions";
  }
  protected:
  explicit IngressAudioOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kPresetFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .livekit.TrackSource source = 2;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // .livekit.IngressAudioEncodingPreset preset = 3;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::IngressAudioEncodingPreset preset() const;
  void set_preset(::livekit::IngressAudioEncodingPreset value);
  private:
  ::livekit::IngressAudioEncodingPreset _internal_preset() const;
  void _internal_set_preset(::livekit::IngressAudioEncodingPreset value);
  public:

  // .livekit.IngressAudioEncodingOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::livekit::IngressAudioEncodingOptions& options() const;
  PROTOBUF_NODISCARD ::livekit::IngressAudioEncodingOptions* release_options();
  ::livekit::IngressAudioEncodingOptions* mutable_options();
  void set_allocated_options(::livekit::IngressAudioEncodingOptions* options);
  private:
  const ::livekit::IngressAudioEncodingOptions& _internal_options() const;
  ::livekit::IngressAudioEncodingOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::livekit::IngressAudioEncodingOptions* options);
  ::livekit::IngressAudioEncodingOptions* unsafe_arena_release_options();

  void clear_encoding_options();
  EncodingOptionsCase encoding_options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.IngressAudioOptions)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_options();

  inline bool has_encoding_options() const;
  inline void clear_has_encoding_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int source_;
    union EncodingOptionsUnion {
      constexpr EncodingOptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::IngressAudioEncodingOptions* options_;
    } encoding_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressVideoOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressVideoOptions) */ {
 public:
  inline IngressVideoOptions() : IngressVideoOptions(nullptr) {}
  ~IngressVideoOptions() override;
  explicit PROTOBUF_CONSTEXPR IngressVideoOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressVideoOptions(const IngressVideoOptions& from);
  IngressVideoOptions(IngressVideoOptions&& from) noexcept
    : IngressVideoOptions() {
    *this = ::std::move(from);
  }

  inline IngressVideoOptions& operator=(const IngressVideoOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressVideoOptions& operator=(IngressVideoOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressVideoOptions& default_instance() {
    return *internal_default_instance();
  }
  enum EncodingOptionsCase {
    kPreset = 3,
    kOptions = 4,
    ENCODING_OPTIONS_NOT_SET = 0,
  };

  static inline const IngressVideoOptions* internal_default_instance() {
    return reinterpret_cast<const IngressVideoOptions*>(
               &_IngressVideoOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IngressVideoOptions& a, IngressVideoOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressVideoOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressVideoOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressVideoOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressVideoOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressVideoOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressVideoOptions& from) {
    IngressVideoOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressVideoOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressVideoOptions";
  }
  protected:
  explicit IngressVideoOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kPresetFieldNumber = 3,
    kOptionsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .livekit.TrackSource source = 2;
  void clear_source();
  ::livekit::TrackSource source() const;
  void set_source(::livekit::TrackSource value);
  private:
  ::livekit::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::TrackSource value);
  public:

  // .livekit.IngressVideoEncodingPreset preset = 3;
  bool has_preset() const;
  private:
  bool _internal_has_preset() const;
  public:
  void clear_preset();
  ::livekit::IngressVideoEncodingPreset preset() const;
  void set_preset(::livekit::IngressVideoEncodingPreset value);
  private:
  ::livekit::IngressVideoEncodingPreset _internal_preset() const;
  void _internal_set_preset(::livekit::IngressVideoEncodingPreset value);
  public:

  // .livekit.IngressVideoEncodingOptions options = 4;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::livekit::IngressVideoEncodingOptions& options() const;
  PROTOBUF_NODISCARD ::livekit::IngressVideoEncodingOptions* release_options();
  ::livekit::IngressVideoEncodingOptions* mutable_options();
  void set_allocated_options(::livekit::IngressVideoEncodingOptions* options);
  private:
  const ::livekit::IngressVideoEncodingOptions& _internal_options() const;
  ::livekit::IngressVideoEncodingOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::livekit::IngressVideoEncodingOptions* options);
  ::livekit::IngressVideoEncodingOptions* unsafe_arena_release_options();

  void clear_encoding_options();
  EncodingOptionsCase encoding_options_case() const;
  // @@protoc_insertion_point(class_scope:livekit.IngressVideoOptions)
 private:
  class _Internal;
  void set_has_preset();
  void set_has_options();

  inline bool has_encoding_options() const;
  inline void clear_has_encoding_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int source_;
    union EncodingOptionsUnion {
      constexpr EncodingOptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int preset_;
      ::livekit::IngressVideoEncodingOptions* options_;
    } encoding_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressAudioEncodingOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressAudioEncodingOptions) */ {
 public:
  inline IngressAudioEncodingOptions() : IngressAudioEncodingOptions(nullptr) {}
  ~IngressAudioEncodingOptions() override;
  explicit PROTOBUF_CONSTEXPR IngressAudioEncodingOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressAudioEncodingOptions(const IngressAudioEncodingOptions& from);
  IngressAudioEncodingOptions(IngressAudioEncodingOptions&& from) noexcept
    : IngressAudioEncodingOptions() {
    *this = ::std::move(from);
  }

  inline IngressAudioEncodingOptions& operator=(const IngressAudioEncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressAudioEncodingOptions& operator=(IngressAudioEncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressAudioEncodingOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngressAudioEncodingOptions* internal_default_instance() {
    return reinterpret_cast<const IngressAudioEncodingOptions*>(
               &_IngressAudioEncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IngressAudioEncodingOptions& a, IngressAudioEncodingOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressAudioEncodingOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressAudioEncodingOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressAudioEncodingOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressAudioEncodingOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressAudioEncodingOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressAudioEncodingOptions& from) {
    IngressAudioEncodingOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressAudioEncodingOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressAudioEncodingOptions";
  }
  protected:
  explicit IngressAudioEncodingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioCodecFieldNumber = 1,
    kBitrateFieldNumber = 2,
    kDisableDtxFieldNumber = 3,
    kChannelsFieldNumber = 4,
  };
  // .livekit.AudioCodec audio_codec = 1;
  void clear_audio_codec();
  ::livekit::AudioCodec audio_codec() const;
  void set_audio_codec(::livekit::AudioCodec value);
  private:
  ::livekit::AudioCodec _internal_audio_codec() const;
  void _internal_set_audio_codec(::livekit::AudioCodec value);
  public:

  // uint32 bitrate = 2;
  void clear_bitrate();
  uint32_t bitrate() const;
  void set_bitrate(uint32_t value);
  private:
  uint32_t _internal_bitrate() const;
  void _internal_set_bitrate(uint32_t value);
  public:

  // bool disable_dtx = 3;
  void clear_disable_dtx();
  bool disable_dtx() const;
  void set_disable_dtx(bool value);
  private:
  bool _internal_disable_dtx() const;
  void _internal_set_disable_dtx(bool value);
  public:

  // uint32 channels = 4;
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.IngressAudioEncodingOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int audio_codec_;
    uint32_t bitrate_;
    bool disable_dtx_;
    uint32_t channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressVideoEncodingOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressVideoEncodingOptions) */ {
 public:
  inline IngressVideoEncodingOptions() : IngressVideoEncodingOptions(nullptr) {}
  ~IngressVideoEncodingOptions() override;
  explicit PROTOBUF_CONSTEXPR IngressVideoEncodingOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressVideoEncodingOptions(const IngressVideoEncodingOptions& from);
  IngressVideoEncodingOptions(IngressVideoEncodingOptions&& from) noexcept
    : IngressVideoEncodingOptions() {
    *this = ::std::move(from);
  }

  inline IngressVideoEncodingOptions& operator=(const IngressVideoEncodingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressVideoEncodingOptions& operator=(IngressVideoEncodingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressVideoEncodingOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngressVideoEncodingOptions* internal_default_instance() {
    return reinterpret_cast<const IngressVideoEncodingOptions*>(
               &_IngressVideoEncodingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IngressVideoEncodingOptions& a, IngressVideoEncodingOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressVideoEncodingOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressVideoEncodingOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressVideoEncodingOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressVideoEncodingOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressVideoEncodingOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressVideoEncodingOptions& from) {
    IngressVideoEncodingOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressVideoEncodingOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressVideoEncodingOptions";
  }
  protected:
  explicit IngressVideoEncodingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 3,
    kFrameRateFieldNumber = 2,
    kVideoCodecFieldNumber = 1,
  };
  // repeated .livekit.VideoLayer layers = 3;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::livekit::VideoLayer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
      mutable_layers();
  private:
  const ::livekit::VideoLayer& _internal_layers(int index) const;
  ::livekit::VideoLayer* _internal_add_layers();
  public:
  const ::livekit::VideoLayer& layers(int index) const;
  ::livekit::VideoLayer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
      layers() const;

  // double frame_rate = 2;
  void clear_frame_rate();
  double frame_rate() const;
  void set_frame_rate(double value);
  private:
  double _internal_frame_rate() const;
  void _internal_set_frame_rate(double value);
  public:

  // .livekit.VideoCodec video_codec = 1;
  void clear_video_codec();
  ::livekit::VideoCodec video_codec() const;
  void set_video_codec(::livekit::VideoCodec value);
  private:
  ::livekit::VideoCodec _internal_video_codec() const;
  void _internal_set_video_codec(::livekit::VideoCodec value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.IngressVideoEncodingOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer > layers_;
    double frame_rate_;
    int video_codec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressInfo) */ {
 public:
  inline IngressInfo() : IngressInfo(nullptr) {}
  ~IngressInfo() override;
  explicit PROTOBUF_CONSTEXPR IngressInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressInfo(const IngressInfo& from);
  IngressInfo(IngressInfo&& from) noexcept
    : IngressInfo() {
    *this = ::std::move(from);
  }

  inline IngressInfo& operator=(const IngressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressInfo& operator=(IngressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngressInfo* internal_default_instance() {
    return reinterpret_cast<const IngressInfo*>(
               &_IngressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IngressInfo& a, IngressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressInfo& from) {
    IngressInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressInfo";
  }
  protected:
  explicit IngressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngressIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kStreamKeyFieldNumber = 3,
    kUrlFieldNumber = 4,
    kRoomNameFieldNumber = 8,
    kParticipantIdentityFieldNumber = 9,
    kParticipantNameFieldNumber = 10,
    kParticipantMetadataFieldNumber = 14,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kStateFieldNumber = 12,
    kInputTypeFieldNumber = 5,
    kBypassTranscodingFieldNumber = 13,
    kEnableTranscodingFieldNumber = 15,
    kReusableFieldNumber = 11,
    kEnabledFieldNumber = 16,
  };
  // string ingress_id = 1;
  void clear_ingress_id();
  const std::string& ingress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_id();
  PROTOBUF_NODISCARD std::string* release_ingress_id();
  void set_allocated_ingress_id(std::string* ingress_id);
  private:
  const std::string& _internal_ingress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* _internal_mutable_ingress_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string stream_key = 3;
  void clear_stream_key();
  const std::string& stream_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_key();
  PROTOBUF_NODISCARD std::string* release_stream_key();
  void set_allocated_stream_key(std::string* stream_key);
  private:
  const std::string& _internal_stream_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
  std::string* _internal_mutable_stream_key();
  public:

  // string url = 4;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string room_name = 8;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string participant_identity = 9;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // string participant_name = 10;
  void clear_participant_name();
  const std::string& participant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_name();
  PROTOBUF_NODISCARD std::string* release_participant_name();
  void set_allocated_participant_name(std::string* participant_name);
  private:
  const std::string& _internal_participant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* _internal_mutable_participant_name();
  public:

  // string participant_metadata = 14;
  void clear_participant_metadata();
  const std::string& participant_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_metadata();
  PROTOBUF_NODISCARD std::string* release_participant_metadata();
  void set_allocated_participant_metadata(std::string* participant_metadata);
  private:
  const std::string& _internal_participant_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* _internal_mutable_participant_metadata();
  public:

  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::livekit::IngressAudioOptions& audio() const;
  PROTOBUF_NODISCARD ::livekit::IngressAudioOptions* release_audio();
  ::livekit::IngressAudioOptions* mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* audio);
  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::livekit::IngressAudioOptions* audio);
  ::livekit::IngressAudioOptions* unsafe_arena_release_audio();

  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::IngressVideoOptions& video() const;
  PROTOBUF_NODISCARD ::livekit::IngressVideoOptions* release_video();
  ::livekit::IngressVideoOptions* mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* video);
  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::IngressVideoOptions* video);
  ::livekit::IngressVideoOptions* unsafe_arena_release_video();

  // .livekit.IngressState state = 12;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::livekit::IngressState& state() const;
  PROTOBUF_NODISCARD ::livekit::IngressState* release_state();
  ::livekit::IngressState* mutable_state();
  void set_allocated_state(::livekit::IngressState* state);
  private:
  const ::livekit::IngressState& _internal_state() const;
  ::livekit::IngressState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::livekit::IngressState* state);
  ::livekit::IngressState* unsafe_arena_release_state();

  // .livekit.IngressInput input_type = 5;
  void clear_input_type();
  ::livekit::IngressInput input_type() const;
  void set_input_type(::livekit::IngressInput value);
  private:
  ::livekit::IngressInput _internal_input_type() const;
  void _internal_set_input_type(::livekit::IngressInput value);
  public:

  // bool bypass_transcoding = 13 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_bypass_transcoding();
  PROTOBUF_DEPRECATED bool bypass_transcoding() const;
  PROTOBUF_DEPRECATED void set_bypass_transcoding(bool value);
  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);
  public:

  // optional bool enable_transcoding = 15;
  bool has_enable_transcoding() const;
  private:
  bool _internal_has_enable_transcoding() const;
  public:
  void clear_enable_transcoding();
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);
  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);
  public:

  // bool reusable = 11;
  void clear_reusable();
  bool reusable() const;
  void set_reusable(bool value);
  private:
  bool _internal_reusable() const;
  void _internal_set_reusable(bool value);
  public:

  // optional bool enabled = 16;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.IngressInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* audio_;
    ::livekit::IngressVideoOptions* video_;
    ::livekit::IngressState* state_;
    int input_type_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool reusable_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class IngressState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.IngressState) */ {
 public:
  inline IngressState() : IngressState(nullptr) {}
  ~IngressState() override;
  explicit PROTOBUF_CONSTEXPR IngressState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IngressState(const IngressState& from);
  IngressState(IngressState&& from) noexcept
    : IngressState() {
    *this = ::std::move(from);
  }

  inline IngressState& operator=(const IngressState& from) {
    CopyFrom(from);
    return *this;
  }
  inline IngressState& operator=(IngressState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IngressState& default_instance() {
    return *internal_default_instance();
  }
  static inline const IngressState* internal_default_instance() {
    return reinterpret_cast<const IngressState*>(
               &_IngressState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IngressState& a, IngressState& b) {
    a.Swap(&b);
  }
  inline void Swap(IngressState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IngressState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IngressState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IngressState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IngressState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IngressState& from) {
    IngressState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IngressState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.IngressState";
  }
  protected:
  explicit IngressState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IngressState_Status Status;
  static constexpr Status ENDPOINT_INACTIVE =
    IngressState_Status_ENDPOINT_INACTIVE;
  static constexpr Status ENDPOINT_BUFFERING =
    IngressState_Status_ENDPOINT_BUFFERING;
  static constexpr Status ENDPOINT_PUBLISHING =
    IngressState_Status_ENDPOINT_PUBLISHING;
  static constexpr Status ENDPOINT_ERROR =
    IngressState_Status_ENDPOINT_ERROR;
  static constexpr Status ENDPOINT_COMPLETE =
    IngressState_Status_ENDPOINT_COMPLETE;
  static inline bool Status_IsValid(int value) {
    return IngressState_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    IngressState_Status_Status_MIN;
  static constexpr Status Status_MAX =
    IngressState_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    IngressState_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return IngressState_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return IngressState_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return IngressState_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 6,
    kErrorFieldNumber = 2,
    kRoomIdFieldNumber = 5,
    kResourceIdFieldNumber = 9,
    kVideoFieldNumber = 3,
    kAudioFieldNumber = 4,
    kStartedAtFieldNumber = 7,
    kEndedAtFieldNumber = 8,
    kUpdatedAtFieldNumber = 10,
    kStatusFieldNumber = 1,
  };
  // repeated .livekit.TrackInfo tracks = 6;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::livekit::TrackInfo* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
      mutable_tracks();
  private:
  const ::livekit::TrackInfo& _internal_tracks(int index) const;
  ::livekit::TrackInfo* _internal_add_tracks();
  public:
  const ::livekit::TrackInfo& tracks(int index) const;
  ::livekit::TrackInfo* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
      tracks() const;

  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string room_id = 5;
  void clear_room_id();
  const std::string& room_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_id();
  PROTOBUF_NODISCARD std::string* release_room_id();
  void set_allocated_room_id(std::string* room_id);
  private:
  const std::string& _internal_room_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_id(const std::string& value);
  std::string* _internal_mutable_room_id();
  public:

  // string resource_id = 9;
  void clear_resource_id();
  const std::string& resource_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_id();
  PROTOBUF_NODISCARD std::string* release_resource_id();
  void set_allocated_resource_id(std::string* resource_id);
  private:
  const std::string& _internal_resource_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
  std::string* _internal_mutable_resource_id();
  public:

  // .livekit.InputVideoState video = 3;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::InputVideoState& video() const;
  PROTOBUF_NODISCARD ::livekit::InputVideoState* release_video();
  ::livekit::InputVideoState* mutable_video();
  void set_allocated_video(::livekit::InputVideoState* video);
  private:
  const ::livekit::InputVideoState& _internal_video() const;
  ::livekit::InputVideoState* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::InputVideoState* video);
  ::livekit::InputVideoState* unsafe_arena_release_video();

  // .livekit.InputAudioState audio = 4;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::livekit::InputAudioState& audio() const;
  PROTOBUF_NODISCARD ::livekit::InputAudioState* release_audio();
  ::livekit::InputAudioState* mutable_audio();
  void set_allocated_audio(::livekit::InputAudioState* audio);
  private:
  const ::livekit::InputAudioState& _internal_audio() const;
  ::livekit::InputAudioState* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::livekit::InputAudioState* audio);
  ::livekit::InputAudioState* unsafe_arena_release_audio();

  // int64 started_at = 7;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 8;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // int64 updated_at = 10;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // .livekit.IngressState.Status status = 1;
  void clear_status();
  ::livekit::IngressState_Status status() const;
  void set_status(::livekit::IngressState_Status value);
  private:
  ::livekit::IngressState_Status _internal_status() const;
  void _internal_set_status(::livekit::IngressState_Status value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.IngressState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo > tracks_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
    ::livekit::InputVideoState* video_;
    ::livekit::InputAudioState* audio_;
    int64_t started_at_;
    int64_t ended_at_;
    int64_t updated_at_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class InputVideoState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.InputVideoState) */ {
 public:
  inline InputVideoState() : InputVideoState(nullptr) {}
  ~InputVideoState() override;
  explicit PROTOBUF_CONSTEXPR InputVideoState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputVideoState(const InputVideoState& from);
  InputVideoState(InputVideoState&& from) noexcept
    : InputVideoState() {
    *this = ::std::move(from);
  }

  inline InputVideoState& operator=(const InputVideoState& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputVideoState& operator=(InputVideoState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputVideoState& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputVideoState* internal_default_instance() {
    return reinterpret_cast<const InputVideoState*>(
               &_InputVideoState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InputVideoState& a, InputVideoState& b) {
    a.Swap(&b);
  }
  inline void Swap(InputVideoState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputVideoState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputVideoState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputVideoState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputVideoState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputVideoState& from) {
    InputVideoState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputVideoState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.InputVideoState";
  }
  protected:
  explicit InputVideoState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 1,
    kAverageBitrateFieldNumber = 2,
    kWidthFieldNumber = 3,
    kFramerateFieldNumber = 5,
    kHeightFieldNumber = 4,
  };
  // string mime_type = 1;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // uint32 average_bitrate = 2;
  void clear_average_bitrate();
  uint32_t average_bitrate() const;
  void set_average_bitrate(uint32_t value);
  private:
  uint32_t _internal_average_bitrate() const;
  void _internal_set_average_bitrate(uint32_t value);
  public:

  // uint32 width = 3;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // double framerate = 5;
  void clear_framerate();
  double framerate() const;
  void set_framerate(double value);
  private:
  double _internal_framerate() const;
  void _internal_set_framerate(double value);
  public:

  // uint32 height = 4;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.InputVideoState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    uint32_t average_bitrate_;
    uint32_t width_;
    double framerate_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class InputAudioState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.InputAudioState) */ {
 public:
  inline InputAudioState() : InputAudioState(nullptr) {}
  ~InputAudioState() override;
  explicit PROTOBUF_CONSTEXPR InputAudioState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputAudioState(const InputAudioState& from);
  InputAudioState(InputAudioState&& from) noexcept
    : InputAudioState() {
    *this = ::std::move(from);
  }

  inline InputAudioState& operator=(const InputAudioState& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputAudioState& operator=(InputAudioState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputAudioState& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputAudioState* internal_default_instance() {
    return reinterpret_cast<const InputAudioState*>(
               &_InputAudioState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InputAudioState& a, InputAudioState& b) {
    a.Swap(&b);
  }
  inline void Swap(InputAudioState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputAudioState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputAudioState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputAudioState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputAudioState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputAudioState& from) {
    InputAudioState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputAudioState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.InputAudioState";
  }
  protected:
  explicit InputAudioState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 1,
    kAverageBitrateFieldNumber = 2,
    kChannelsFieldNumber = 3,
    kSampleRateFieldNumber = 4,
  };
  // string mime_type = 1;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // uint32 average_bitrate = 2;
  void clear_average_bitrate();
  uint32_t average_bitrate() const;
  void set_average_bitrate(uint32_t value);
  private:
  uint32_t _internal_average_bitrate() const;
  void _internal_set_average_bitrate(uint32_t value);
  public:

  // uint32 channels = 3;
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // uint32 sample_rate = 4;
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.InputAudioState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    uint32_t average_bitrate_;
    uint32_t channels_;
    uint32_t sample_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class UpdateIngressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateIngressRequest) */ {
 public:
  inline UpdateIngressRequest() : UpdateIngressRequest(nullptr) {}
  ~UpdateIngressRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateIngressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateIngressRequest(const UpdateIngressRequest& from);
  UpdateIngressRequest(UpdateIngressRequest&& from) noexcept
    : UpdateIngressRequest() {
    *this = ::std::move(from);
  }

  inline UpdateIngressRequest& operator=(const UpdateIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIngressRequest& operator=(UpdateIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIngressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateIngressRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateIngressRequest*>(
               &_UpdateIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateIngressRequest& a, UpdateIngressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateIngressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIngressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateIngressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateIngressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateIngressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateIngressRequest& from) {
    UpdateIngressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateIngressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateIngressRequest";
  }
  protected:
  explicit UpdateIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngressIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRoomNameFieldNumber = 3,
    kParticipantIdentityFieldNumber = 4,
    kParticipantNameFieldNumber = 5,
    kParticipantMetadataFieldNumber = 9,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kBypassTranscodingFieldNumber = 8,
    kEnableTranscodingFieldNumber = 10,
    kEnabledFieldNumber = 11,
  };
  // string ingress_id = 1;
  void clear_ingress_id();
  const std::string& ingress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_id();
  PROTOBUF_NODISCARD std::string* release_ingress_id();
  void set_allocated_ingress_id(std::string* ingress_id);
  private:
  const std::string& _internal_ingress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* _internal_mutable_ingress_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string room_name = 3;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string participant_identity = 4;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // string participant_name = 5;
  void clear_participant_name();
  const std::string& participant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_name();
  PROTOBUF_NODISCARD std::string* release_participant_name();
  void set_allocated_participant_name(std::string* participant_name);
  private:
  const std::string& _internal_participant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* _internal_mutable_participant_name();
  public:

  // string participant_metadata = 9;
  void clear_participant_metadata();
  const std::string& participant_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_metadata();
  PROTOBUF_NODISCARD std::string* release_participant_metadata();
  void set_allocated_participant_metadata(std::string* participant_metadata);
  private:
  const std::string& _internal_participant_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* _internal_mutable_participant_metadata();
  public:

  // .livekit.IngressAudioOptions audio = 6;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::livekit::IngressAudioOptions& audio() const;
  PROTOBUF_NODISCARD ::livekit::IngressAudioOptions* release_audio();
  ::livekit::IngressAudioOptions* mutable_audio();
  void set_allocated_audio(::livekit::IngressAudioOptions* audio);
  private:
  const ::livekit::IngressAudioOptions& _internal_audio() const;
  ::livekit::IngressAudioOptions* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::livekit::IngressAudioOptions* audio);
  ::livekit::IngressAudioOptions* unsafe_arena_release_audio();

  // .livekit.IngressVideoOptions video = 7;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::livekit::IngressVideoOptions& video() const;
  PROTOBUF_NODISCARD ::livekit::IngressVideoOptions* release_video();
  ::livekit::IngressVideoOptions* mutable_video();
  void set_allocated_video(::livekit::IngressVideoOptions* video);
  private:
  const ::livekit::IngressVideoOptions& _internal_video() const;
  ::livekit::IngressVideoOptions* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::livekit::IngressVideoOptions* video);
  ::livekit::IngressVideoOptions* unsafe_arena_release_video();

  // optional bool bypass_transcoding = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_bypass_transcoding() const;
  private:
  bool _internal_has_bypass_transcoding() const;
  public:
  PROTOBUF_DEPRECATED void clear_bypass_transcoding();
  PROTOBUF_DEPRECATED bool bypass_transcoding() const;
  PROTOBUF_DEPRECATED void set_bypass_transcoding(bool value);
  private:
  bool _internal_bypass_transcoding() const;
  void _internal_set_bypass_transcoding(bool value);
  public:

  // optional bool enable_transcoding = 10;
  bool has_enable_transcoding() const;
  private:
  bool _internal_has_enable_transcoding() const;
  public:
  void clear_enable_transcoding();
  bool enable_transcoding() const;
  void set_enable_transcoding(bool value);
  private:
  bool _internal_enable_transcoding() const;
  void _internal_set_enable_transcoding(bool value);
  public:

  // optional bool enabled = 11;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateIngressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_metadata_;
    ::livekit::IngressAudioOptions* audio_;
    ::livekit::IngressVideoOptions* video_;
    bool bypass_transcoding_;
    bool enable_transcoding_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class ListIngressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListIngressRequest) */ {
 public:
  inline ListIngressRequest() : ListIngressRequest(nullptr) {}
  ~ListIngressRequest() override;
  explicit PROTOBUF_CONSTEXPR ListIngressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIngressRequest(const ListIngressRequest& from);
  ListIngressRequest(ListIngressRequest&& from) noexcept
    : ListIngressRequest() {
    *this = ::std::move(from);
  }

  inline ListIngressRequest& operator=(const ListIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIngressRequest& operator=(ListIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIngressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIngressRequest* internal_default_instance() {
    return reinterpret_cast<const ListIngressRequest*>(
               &_ListIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListIngressRequest& a, ListIngressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIngressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIngressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIngressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIngressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIngressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListIngressRequest& from) {
    ListIngressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIngressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListIngressRequest";
  }
  protected:
  explicit ListIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kIngressIdFieldNumber = 2,
  };
  // string room_name = 1;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string ingress_id = 2;
  void clear_ingress_id();
  const std::string& ingress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_id();
  PROTOBUF_NODISCARD std::string* release_ingress_id();
  void set_allocated_ingress_id(std::string* ingress_id);
  private:
  const std::string& _internal_ingress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* _internal_mutable_ingress_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.ListIngressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class ListIngressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ListIngressResponse) */ {
 public:
  inline ListIngressResponse() : ListIngressResponse(nullptr) {}
  ~ListIngressResponse() override;
  explicit PROTOBUF_CONSTEXPR ListIngressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIngressResponse(const ListIngressResponse& from);
  ListIngressResponse(ListIngressResponse&& from) noexcept
    : ListIngressResponse() {
    *this = ::std::move(from);
  }

  inline ListIngressResponse& operator=(const ListIngressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIngressResponse& operator=(ListIngressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIngressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIngressResponse* internal_default_instance() {
    return reinterpret_cast<const ListIngressResponse*>(
               &_ListIngressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListIngressResponse& a, ListIngressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIngressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIngressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIngressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIngressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIngressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListIngressResponse& from) {
    ListIngressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIngressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ListIngressResponse";
  }
  protected:
  explicit ListIngressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .livekit.IngressInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::livekit::IngressInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::IngressInfo >*
      mutable_items();
  private:
  const ::livekit::IngressInfo& _internal_items(int index) const;
  ::livekit::IngressInfo* _internal_add_items();
  public:
  const ::livekit::IngressInfo& items(int index) const;
  ::livekit::IngressInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::IngressInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:livekit.ListIngressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::IngressInfo > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// -------------------------------------------------------------------

class DeleteIngressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.DeleteIngressRequest) */ {
 public:
  inline DeleteIngressRequest() : DeleteIngressRequest(nullptr) {}
  ~DeleteIngressRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteIngressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteIngressRequest(const DeleteIngressRequest& from);
  DeleteIngressRequest(DeleteIngressRequest&& from) noexcept
    : DeleteIngressRequest() {
    *this = ::std::move(from);
  }

  inline DeleteIngressRequest& operator=(const DeleteIngressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIngressRequest& operator=(DeleteIngressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIngressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIngressRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIngressRequest*>(
               &_DeleteIngressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteIngressRequest& a, DeleteIngressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIngressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIngressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteIngressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteIngressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteIngressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteIngressRequest& from) {
    DeleteIngressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIngressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.DeleteIngressRequest";
  }
  protected:
  explicit DeleteIngressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIngressIdFieldNumber = 1,
  };
  // string ingress_id = 1;
  void clear_ingress_id();
  const std::string& ingress_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_id();
  PROTOBUF_NODISCARD std::string* release_ingress_id();
  void set_allocated_ingress_id(std::string* ingress_id);
  private:
  const std::string& _internal_ingress_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_id(const std::string& value);
  std::string* _internal_mutable_ingress_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.DeleteIngressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fingress_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateIngressRequest

// .livekit.IngressInput input_type = 1;
inline void CreateIngressRequest::clear_input_type() {
  _impl_.input_type_ = 0;
}
inline ::livekit::IngressInput CreateIngressRequest::_internal_input_type() const {
  return static_cast< ::livekit::IngressInput >(_impl_.input_type_);
}
inline ::livekit::IngressInput CreateIngressRequest::input_type() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.input_type)
  return _internal_input_type();
}
inline void CreateIngressRequest::_internal_set_input_type(::livekit::IngressInput value) {
  
  _impl_.input_type_ = value;
}
inline void CreateIngressRequest::set_input_type(::livekit::IngressInput value) {
  _internal_set_input_type(value);
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.input_type)
}

// string url = 9;
inline void CreateIngressRequest::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::url() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.url)
}
inline std::string* CreateIngressRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.url)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_url() const {
  return _impl_.url_.Get();
}
inline void CreateIngressRequest::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_url() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.url)
  return _impl_.url_.Release();
}
inline void CreateIngressRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.url)
}

// string name = 2;
inline void CreateIngressRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.name)
}
inline std::string* CreateIngressRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateIngressRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.name)
  return _impl_.name_.Release();
}
inline void CreateIngressRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.name)
}

// string room_name = 3;
inline void CreateIngressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.room_name)
}
inline std::string* CreateIngressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.room_name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void CreateIngressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void CreateIngressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.room_name)
}

// string participant_identity = 4;
inline void CreateIngressRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_identity)
}
inline std::string* CreateIngressRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_identity)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void CreateIngressRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_identity)
}

// string participant_name = 5;
inline void CreateIngressRequest::clear_participant_name() {
  _impl_.participant_name_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::participant_name() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_name)
  return _internal_participant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_participant_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_name)
}
inline std::string* CreateIngressRequest::mutable_participant_name() {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_name)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_name() const {
  return _impl_.participant_name_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_name(const std::string& value) {
  
  _impl_.participant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_participant_name() {
  
  return _impl_.participant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_participant_name() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_name)
  return _impl_.participant_name_.Release();
}
inline void CreateIngressRequest::set_allocated_participant_name(std::string* participant_name) {
  if (participant_name != nullptr) {
    
  } else {
    
  }
  _impl_.participant_name_.SetAllocated(participant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_name)
}

// string participant_metadata = 10;
inline void CreateIngressRequest::clear_participant_metadata() {
  _impl_.participant_metadata_.ClearToEmpty();
}
inline const std::string& CreateIngressRequest::participant_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.participant_metadata)
  return _internal_participant_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIngressRequest::set_participant_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.participant_metadata)
}
inline std::string* CreateIngressRequest::mutable_participant_metadata() {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.participant_metadata)
  return _s;
}
inline const std::string& CreateIngressRequest::_internal_participant_metadata() const {
  return _impl_.participant_metadata_.Get();
}
inline void CreateIngressRequest::_internal_set_participant_metadata(const std::string& value) {
  
  _impl_.participant_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::_internal_mutable_participant_metadata() {
  
  return _impl_.participant_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIngressRequest::release_participant_metadata() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.participant_metadata)
  return _impl_.participant_metadata_.Release();
}
inline void CreateIngressRequest::set_allocated_participant_metadata(std::string* participant_metadata) {
  if (participant_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.participant_metadata_.SetAllocated(participant_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.participant_metadata)
}

// bool bypass_transcoding = 8 [deprecated = true];
inline void CreateIngressRequest::clear_bypass_transcoding() {
  _impl_.bypass_transcoding_ = false;
}
inline bool CreateIngressRequest::_internal_bypass_transcoding() const {
  return _impl_.bypass_transcoding_;
}
inline bool CreateIngressRequest::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void CreateIngressRequest::_internal_set_bypass_transcoding(bool value) {
  
  _impl_.bypass_transcoding_ = value;
}
inline void CreateIngressRequest::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.bypass_transcoding)
}

// optional bool enable_transcoding = 11;
inline bool CreateIngressRequest::_internal_has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateIngressRequest::has_enable_transcoding() const {
  return _internal_has_enable_transcoding();
}
inline void CreateIngressRequest::clear_enable_transcoding() {
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CreateIngressRequest::_internal_enable_transcoding() const {
  return _impl_.enable_transcoding_;
}
inline bool CreateIngressRequest::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void CreateIngressRequest::_internal_set_enable_transcoding(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_transcoding_ = value;
}
inline void CreateIngressRequest::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.enable_transcoding)
}

// .livekit.IngressAudioOptions audio = 6;
inline bool CreateIngressRequest::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool CreateIngressRequest::has_audio() const {
  return _internal_has_audio();
}
inline void CreateIngressRequest::clear_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
}
inline const ::livekit::IngressAudioOptions& CreateIngressRequest::_internal_audio() const {
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(
      ::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& CreateIngressRequest::audio() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.audio)
  return _internal_audio();
}
inline void CreateIngressRequest::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.CreateIngressRequest.audio)
}
inline ::livekit::IngressAudioOptions* CreateIngressRequest::release_audio() {
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressAudioOptions* CreateIngressRequest::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.audio)
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* CreateIngressRequest::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressAudioOptions>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* CreateIngressRequest::mutable_audio() {
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.audio)
  return _msg;
}
inline void CreateIngressRequest::set_allocated_audio(::livekit::IngressAudioOptions* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool CreateIngressRequest::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool CreateIngressRequest::has_video() const {
  return _internal_has_video();
}
inline void CreateIngressRequest::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::livekit::IngressVideoOptions& CreateIngressRequest::_internal_video() const {
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(
      ::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& CreateIngressRequest::video() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.video)
  return _internal_video();
}
inline void CreateIngressRequest::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.CreateIngressRequest.video)
}
inline ::livekit::IngressVideoOptions* CreateIngressRequest::release_video() {
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressVideoOptions* CreateIngressRequest::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.CreateIngressRequest.video)
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* CreateIngressRequest::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressVideoOptions>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* CreateIngressRequest::mutable_video() {
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.CreateIngressRequest.video)
  return _msg;
}
inline void CreateIngressRequest::set_allocated_video(::livekit::IngressVideoOptions* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.CreateIngressRequest.video)
}

// optional bool enabled = 12;
inline bool CreateIngressRequest::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CreateIngressRequest::has_enabled() const {
  return _internal_has_enabled();
}
inline void CreateIngressRequest::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CreateIngressRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool CreateIngressRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.CreateIngressRequest.enabled)
  return _internal_enabled();
}
inline void CreateIngressRequest::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void CreateIngressRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.CreateIngressRequest.enabled)
}

// -------------------------------------------------------------------

// IngressAudioOptions

// string name = 1;
inline void IngressAudioOptions::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IngressAudioOptions::name() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressAudioOptions::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.name)
}
inline std::string* IngressAudioOptions::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressAudioOptions.name)
  return _s;
}
inline const std::string& IngressAudioOptions::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IngressAudioOptions::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressAudioOptions::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressAudioOptions::release_name() {
  // @@protoc_insertion_point(field_release:livekit.IngressAudioOptions.name)
  return _impl_.name_.Release();
}
inline void IngressAudioOptions::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressAudioOptions.name)
}

// .livekit.TrackSource source = 2;
inline void IngressAudioOptions::clear_source() {
  _impl_.source_ = 0;
}
inline ::livekit::TrackSource IngressAudioOptions::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(_impl_.source_);
}
inline ::livekit::TrackSource IngressAudioOptions::source() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.source)
  return _internal_source();
}
inline void IngressAudioOptions::_internal_set_source(::livekit::TrackSource value) {
  
  _impl_.source_ = value;
}
inline void IngressAudioOptions::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.source)
}

// .livekit.IngressAudioEncodingPreset preset = 3;
inline bool IngressAudioOptions::_internal_has_preset() const {
  return encoding_options_case() == kPreset;
}
inline bool IngressAudioOptions::has_preset() const {
  return _internal_has_preset();
}
inline void IngressAudioOptions::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void IngressAudioOptions::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.encoding_options_.preset_ = 0;
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressAudioEncodingPreset IngressAudioOptions::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::IngressAudioEncodingPreset >(_impl_.encoding_options_.preset_);
  }
  return static_cast< ::livekit::IngressAudioEncodingPreset >(0);
}
inline ::livekit::IngressAudioEncodingPreset IngressAudioOptions::preset() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.preset)
  return _internal_preset();
}
inline void IngressAudioOptions::_internal_set_preset(::livekit::IngressAudioEncodingPreset value) {
  if (!_internal_has_preset()) {
    clear_encoding_options();
    set_has_preset();
  }
  _impl_.encoding_options_.preset_ = value;
}
inline void IngressAudioOptions::set_preset(::livekit::IngressAudioEncodingPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioOptions.preset)
}

// .livekit.IngressAudioEncodingOptions options = 4;
inline bool IngressAudioOptions::_internal_has_options() const {
  return encoding_options_case() == kOptions;
}
inline bool IngressAudioOptions::has_options() const {
  return _internal_has_options();
}
inline void IngressAudioOptions::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void IngressAudioOptions::clear_options() {
  if (_internal_has_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.encoding_options_.options_;
    }
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressAudioEncodingOptions* IngressAudioOptions::release_options() {
  // @@protoc_insertion_point(field_release:livekit.IngressAudioOptions.options)
  if (_internal_has_options()) {
    clear_has_encoding_options();
    ::livekit::IngressAudioEncodingOptions* temp = _impl_.encoding_options_.options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::IngressAudioEncodingOptions& IngressAudioOptions::_internal_options() const {
  return _internal_has_options()
      ? *_impl_.encoding_options_.options_
      : reinterpret_cast< ::livekit::IngressAudioEncodingOptions&>(::livekit::_IngressAudioEncodingOptions_default_instance_);
}
inline const ::livekit::IngressAudioEncodingOptions& IngressAudioOptions::options() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioOptions.options)
  return _internal_options();
}
inline ::livekit::IngressAudioEncodingOptions* IngressAudioOptions::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.IngressAudioOptions.options)
  if (_internal_has_options()) {
    clear_has_encoding_options();
    ::livekit::IngressAudioEncodingOptions* temp = _impl_.encoding_options_.options_;
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngressAudioOptions::unsafe_arena_set_allocated_options(::livekit::IngressAudioEncodingOptions* options) {
  clear_encoding_options();
  if (options) {
    set_has_options();
    _impl_.encoding_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressAudioOptions.options)
}
inline ::livekit::IngressAudioEncodingOptions* IngressAudioOptions::_internal_mutable_options() {
  if (!_internal_has_options()) {
    clear_encoding_options();
    set_has_options();
    _impl_.encoding_options_.options_ = CreateMaybeMessage< ::livekit::IngressAudioEncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.encoding_options_.options_;
}
inline ::livekit::IngressAudioEncodingOptions* IngressAudioOptions::mutable_options() {
  ::livekit::IngressAudioEncodingOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.IngressAudioOptions.options)
  return _msg;
}

inline bool IngressAudioOptions::has_encoding_options() const {
  return encoding_options_case() != ENCODING_OPTIONS_NOT_SET;
}
inline void IngressAudioOptions::clear_has_encoding_options() {
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}
inline IngressAudioOptions::EncodingOptionsCase IngressAudioOptions::encoding_options_case() const {
  return IngressAudioOptions::EncodingOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngressVideoOptions

// string name = 1;
inline void IngressVideoOptions::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IngressVideoOptions::name() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressVideoOptions::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.name)
}
inline std::string* IngressVideoOptions::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoOptions.name)
  return _s;
}
inline const std::string& IngressVideoOptions::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IngressVideoOptions::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressVideoOptions::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressVideoOptions::release_name() {
  // @@protoc_insertion_point(field_release:livekit.IngressVideoOptions.name)
  return _impl_.name_.Release();
}
inline void IngressVideoOptions::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressVideoOptions.name)
}

// .livekit.TrackSource source = 2;
inline void IngressVideoOptions::clear_source() {
  _impl_.source_ = 0;
}
inline ::livekit::TrackSource IngressVideoOptions::_internal_source() const {
  return static_cast< ::livekit::TrackSource >(_impl_.source_);
}
inline ::livekit::TrackSource IngressVideoOptions::source() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.source)
  return _internal_source();
}
inline void IngressVideoOptions::_internal_set_source(::livekit::TrackSource value) {
  
  _impl_.source_ = value;
}
inline void IngressVideoOptions::set_source(::livekit::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.source)
}

// .livekit.IngressVideoEncodingPreset preset = 3;
inline bool IngressVideoOptions::_internal_has_preset() const {
  return encoding_options_case() == kPreset;
}
inline bool IngressVideoOptions::has_preset() const {
  return _internal_has_preset();
}
inline void IngressVideoOptions::set_has_preset() {
  _impl_._oneof_case_[0] = kPreset;
}
inline void IngressVideoOptions::clear_preset() {
  if (_internal_has_preset()) {
    _impl_.encoding_options_.preset_ = 0;
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressVideoEncodingPreset IngressVideoOptions::_internal_preset() const {
  if (_internal_has_preset()) {
    return static_cast< ::livekit::IngressVideoEncodingPreset >(_impl_.encoding_options_.preset_);
  }
  return static_cast< ::livekit::IngressVideoEncodingPreset >(0);
}
inline ::livekit::IngressVideoEncodingPreset IngressVideoOptions::preset() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.preset)
  return _internal_preset();
}
inline void IngressVideoOptions::_internal_set_preset(::livekit::IngressVideoEncodingPreset value) {
  if (!_internal_has_preset()) {
    clear_encoding_options();
    set_has_preset();
  }
  _impl_.encoding_options_.preset_ = value;
}
inline void IngressVideoOptions::set_preset(::livekit::IngressVideoEncodingPreset value) {
  _internal_set_preset(value);
  // @@protoc_insertion_point(field_set:livekit.IngressVideoOptions.preset)
}

// .livekit.IngressVideoEncodingOptions options = 4;
inline bool IngressVideoOptions::_internal_has_options() const {
  return encoding_options_case() == kOptions;
}
inline bool IngressVideoOptions::has_options() const {
  return _internal_has_options();
}
inline void IngressVideoOptions::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void IngressVideoOptions::clear_options() {
  if (_internal_has_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.encoding_options_.options_;
    }
    clear_has_encoding_options();
  }
}
inline ::livekit::IngressVideoEncodingOptions* IngressVideoOptions::release_options() {
  // @@protoc_insertion_point(field_release:livekit.IngressVideoOptions.options)
  if (_internal_has_options()) {
    clear_has_encoding_options();
    ::livekit::IngressVideoEncodingOptions* temp = _impl_.encoding_options_.options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::IngressVideoEncodingOptions& IngressVideoOptions::_internal_options() const {
  return _internal_has_options()
      ? *_impl_.encoding_options_.options_
      : reinterpret_cast< ::livekit::IngressVideoEncodingOptions&>(::livekit::_IngressVideoEncodingOptions_default_instance_);
}
inline const ::livekit::IngressVideoEncodingOptions& IngressVideoOptions::options() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoOptions.options)
  return _internal_options();
}
inline ::livekit::IngressVideoEncodingOptions* IngressVideoOptions::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.IngressVideoOptions.options)
  if (_internal_has_options()) {
    clear_has_encoding_options();
    ::livekit::IngressVideoEncodingOptions* temp = _impl_.encoding_options_.options_;
    _impl_.encoding_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IngressVideoOptions::unsafe_arena_set_allocated_options(::livekit::IngressVideoEncodingOptions* options) {
  clear_encoding_options();
  if (options) {
    set_has_options();
    _impl_.encoding_options_.options_ = options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressVideoOptions.options)
}
inline ::livekit::IngressVideoEncodingOptions* IngressVideoOptions::_internal_mutable_options() {
  if (!_internal_has_options()) {
    clear_encoding_options();
    set_has_options();
    _impl_.encoding_options_.options_ = CreateMaybeMessage< ::livekit::IngressVideoEncodingOptions >(GetArenaForAllocation());
  }
  return _impl_.encoding_options_.options_;
}
inline ::livekit::IngressVideoEncodingOptions* IngressVideoOptions::mutable_options() {
  ::livekit::IngressVideoEncodingOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoOptions.options)
  return _msg;
}

inline bool IngressVideoOptions::has_encoding_options() const {
  return encoding_options_case() != ENCODING_OPTIONS_NOT_SET;
}
inline void IngressVideoOptions::clear_has_encoding_options() {
  _impl_._oneof_case_[0] = ENCODING_OPTIONS_NOT_SET;
}
inline IngressVideoOptions::EncodingOptionsCase IngressVideoOptions::encoding_options_case() const {
  return IngressVideoOptions::EncodingOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IngressAudioEncodingOptions

// .livekit.AudioCodec audio_codec = 1;
inline void IngressAudioEncodingOptions::clear_audio_codec() {
  _impl_.audio_codec_ = 0;
}
inline ::livekit::AudioCodec IngressAudioEncodingOptions::_internal_audio_codec() const {
  return static_cast< ::livekit::AudioCodec >(_impl_.audio_codec_);
}
inline ::livekit::AudioCodec IngressAudioEncodingOptions::audio_codec() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.audio_codec)
  return _internal_audio_codec();
}
inline void IngressAudioEncodingOptions::_internal_set_audio_codec(::livekit::AudioCodec value) {
  
  _impl_.audio_codec_ = value;
}
inline void IngressAudioEncodingOptions::set_audio_codec(::livekit::AudioCodec value) {
  _internal_set_audio_codec(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.audio_codec)
}

// uint32 bitrate = 2;
inline void IngressAudioEncodingOptions::clear_bitrate() {
  _impl_.bitrate_ = 0u;
}
inline uint32_t IngressAudioEncodingOptions::_internal_bitrate() const {
  return _impl_.bitrate_;
}
inline uint32_t IngressAudioEncodingOptions::bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.bitrate)
  return _internal_bitrate();
}
inline void IngressAudioEncodingOptions::_internal_set_bitrate(uint32_t value) {
  
  _impl_.bitrate_ = value;
}
inline void IngressAudioEncodingOptions::set_bitrate(uint32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.bitrate)
}

// bool disable_dtx = 3;
inline void IngressAudioEncodingOptions::clear_disable_dtx() {
  _impl_.disable_dtx_ = false;
}
inline bool IngressAudioEncodingOptions::_internal_disable_dtx() const {
  return _impl_.disable_dtx_;
}
inline bool IngressAudioEncodingOptions::disable_dtx() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.disable_dtx)
  return _internal_disable_dtx();
}
inline void IngressAudioEncodingOptions::_internal_set_disable_dtx(bool value) {
  
  _impl_.disable_dtx_ = value;
}
inline void IngressAudioEncodingOptions::set_disable_dtx(bool value) {
  _internal_set_disable_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.disable_dtx)
}

// uint32 channels = 4;
inline void IngressAudioEncodingOptions::clear_channels() {
  _impl_.channels_ = 0u;
}
inline uint32_t IngressAudioEncodingOptions::_internal_channels() const {
  return _impl_.channels_;
}
inline uint32_t IngressAudioEncodingOptions::channels() const {
  // @@protoc_insertion_point(field_get:livekit.IngressAudioEncodingOptions.channels)
  return _internal_channels();
}
inline void IngressAudioEncodingOptions::_internal_set_channels(uint32_t value) {
  
  _impl_.channels_ = value;
}
inline void IngressAudioEncodingOptions::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:livekit.IngressAudioEncodingOptions.channels)
}

// -------------------------------------------------------------------

// IngressVideoEncodingOptions

// .livekit.VideoCodec video_codec = 1;
inline void IngressVideoEncodingOptions::clear_video_codec() {
  _impl_.video_codec_ = 0;
}
inline ::livekit::VideoCodec IngressVideoEncodingOptions::_internal_video_codec() const {
  return static_cast< ::livekit::VideoCodec >(_impl_.video_codec_);
}
inline ::livekit::VideoCodec IngressVideoEncodingOptions::video_codec() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.video_codec)
  return _internal_video_codec();
}
inline void IngressVideoEncodingOptions::_internal_set_video_codec(::livekit::VideoCodec value) {
  
  _impl_.video_codec_ = value;
}
inline void IngressVideoEncodingOptions::set_video_codec(::livekit::VideoCodec value) {
  _internal_set_video_codec(value);
  // @@protoc_insertion_point(field_set:livekit.IngressVideoEncodingOptions.video_codec)
}

// double frame_rate = 2;
inline void IngressVideoEncodingOptions::clear_frame_rate() {
  _impl_.frame_rate_ = 0;
}
inline double IngressVideoEncodingOptions::_internal_frame_rate() const {
  return _impl_.frame_rate_;
}
inline double IngressVideoEncodingOptions::frame_rate() const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.frame_rate)
  return _internal_frame_rate();
}
inline void IngressVideoEncodingOptions::_internal_set_frame_rate(double value) {
  
  _impl_.frame_rate_ = value;
}
inline void IngressVideoEncodingOptions::set_frame_rate(double value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:livekit.IngressVideoEncodingOptions.frame_rate)
}

// repeated .livekit.VideoLayer layers = 3;
inline int IngressVideoEncodingOptions::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int IngressVideoEncodingOptions::layers_size() const {
  return _internal_layers_size();
}
inline ::livekit::VideoLayer* IngressVideoEncodingOptions::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.IngressVideoEncodingOptions.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >*
IngressVideoEncodingOptions::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.IngressVideoEncodingOptions.layers)
  return &_impl_.layers_;
}
inline const ::livekit::VideoLayer& IngressVideoEncodingOptions::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::livekit::VideoLayer& IngressVideoEncodingOptions::layers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.IngressVideoEncodingOptions.layers)
  return _internal_layers(index);
}
inline ::livekit::VideoLayer* IngressVideoEncodingOptions::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::livekit::VideoLayer* IngressVideoEncodingOptions::add_layers() {
  ::livekit::VideoLayer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:livekit.IngressVideoEncodingOptions.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::VideoLayer >&
IngressVideoEncodingOptions::layers() const {
  // @@protoc_insertion_point(field_list:livekit.IngressVideoEncodingOptions.layers)
  return _impl_.layers_;
}

// -------------------------------------------------------------------

// IngressInfo

// string ingress_id = 1;
inline void IngressInfo::clear_ingress_id() {
  _impl_.ingress_id_.ClearToEmpty();
}
inline const std::string& IngressInfo::ingress_id() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.ingress_id)
  return _internal_ingress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_ingress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ingress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.ingress_id)
}
inline std::string* IngressInfo::mutable_ingress_id() {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.ingress_id)
  return _s;
}
inline const std::string& IngressInfo::_internal_ingress_id() const {
  return _impl_.ingress_id_.Get();
}
inline void IngressInfo::_internal_set_ingress_id(const std::string& value) {
  
  _impl_.ingress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_ingress_id() {
  
  return _impl_.ingress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_ingress_id() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.ingress_id)
  return _impl_.ingress_id_.Release();
}
inline void IngressInfo::set_allocated_ingress_id(std::string* ingress_id) {
  if (ingress_id != nullptr) {
    
  } else {
    
  }
  _impl_.ingress_id_.SetAllocated(ingress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.ingress_id)
}

// string name = 2;
inline void IngressInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& IngressInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.name)
}
inline std::string* IngressInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.name)
  return _s;
}
inline const std::string& IngressInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void IngressInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.name)
  return _impl_.name_.Release();
}
inline void IngressInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.name)
}

// string stream_key = 3;
inline void IngressInfo::clear_stream_key() {
  _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& IngressInfo::stream_key() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.stream_key)
  return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_stream_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stream_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.stream_key)
}
inline std::string* IngressInfo::mutable_stream_key() {
  std::string* _s = _internal_mutable_stream_key();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.stream_key)
  return _s;
}
inline const std::string& IngressInfo::_internal_stream_key() const {
  return _impl_.stream_key_.Get();
}
inline void IngressInfo::_internal_set_stream_key(const std::string& value) {
  
  _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_stream_key() {
  
  return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_stream_key() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.stream_key)
  return _impl_.stream_key_.Release();
}
inline void IngressInfo::set_allocated_stream_key(std::string* stream_key) {
  if (stream_key != nullptr) {
    
  } else {
    
  }
  _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_key_.IsDefault()) {
    _impl_.stream_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.stream_key)
}

// string url = 4;
inline void IngressInfo::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& IngressInfo::url() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.url)
}
inline std::string* IngressInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.url)
  return _s;
}
inline const std::string& IngressInfo::_internal_url() const {
  return _impl_.url_.Get();
}
inline void IngressInfo::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_url() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.url)
  return _impl_.url_.Release();
}
inline void IngressInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.url)
}

// .livekit.IngressInput input_type = 5;
inline void IngressInfo::clear_input_type() {
  _impl_.input_type_ = 0;
}
inline ::livekit::IngressInput IngressInfo::_internal_input_type() const {
  return static_cast< ::livekit::IngressInput >(_impl_.input_type_);
}
inline ::livekit::IngressInput IngressInfo::input_type() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.input_type)
  return _internal_input_type();
}
inline void IngressInfo::_internal_set_input_type(::livekit::IngressInput value) {
  
  _impl_.input_type_ = value;
}
inline void IngressInfo::set_input_type(::livekit::IngressInput value) {
  _internal_set_input_type(value);
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.input_type)
}

// bool bypass_transcoding = 13 [deprecated = true];
inline void IngressInfo::clear_bypass_transcoding() {
  _impl_.bypass_transcoding_ = false;
}
inline bool IngressInfo::_internal_bypass_transcoding() const {
  return _impl_.bypass_transcoding_;
}
inline bool IngressInfo::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void IngressInfo::_internal_set_bypass_transcoding(bool value) {
  
  _impl_.bypass_transcoding_ = value;
}
inline void IngressInfo::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.bypass_transcoding)
}

// optional bool enable_transcoding = 15;
inline bool IngressInfo::_internal_has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IngressInfo::has_enable_transcoding() const {
  return _internal_has_enable_transcoding();
}
inline void IngressInfo::clear_enable_transcoding() {
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool IngressInfo::_internal_enable_transcoding() const {
  return _impl_.enable_transcoding_;
}
inline bool IngressInfo::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void IngressInfo::_internal_set_enable_transcoding(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enable_transcoding_ = value;
}
inline void IngressInfo::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.enable_transcoding)
}

// .livekit.IngressAudioOptions audio = 6;
inline bool IngressInfo::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool IngressInfo::has_audio() const {
  return _internal_has_audio();
}
inline void IngressInfo::clear_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
}
inline const ::livekit::IngressAudioOptions& IngressInfo::_internal_audio() const {
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(
      ::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& IngressInfo::audio() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.audio)
  return _internal_audio();
}
inline void IngressInfo::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.audio)
}
inline ::livekit::IngressAudioOptions* IngressInfo::release_audio() {
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressAudioOptions* IngressInfo::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.audio)
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* IngressInfo::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressAudioOptions>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* IngressInfo::mutable_audio() {
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.audio)
  return _msg;
}
inline void IngressInfo::set_allocated_audio(::livekit::IngressAudioOptions* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool IngressInfo::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool IngressInfo::has_video() const {
  return _internal_has_video();
}
inline void IngressInfo::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::livekit::IngressVideoOptions& IngressInfo::_internal_video() const {
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(
      ::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& IngressInfo::video() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.video)
  return _internal_video();
}
inline void IngressInfo::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.video)
}
inline ::livekit::IngressVideoOptions* IngressInfo::release_video() {
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressVideoOptions* IngressInfo::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.video)
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* IngressInfo::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressVideoOptions>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* IngressInfo::mutable_video() {
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.video)
  return _msg;
}
inline void IngressInfo::set_allocated_video(::livekit::IngressVideoOptions* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.video)
}

// string room_name = 8;
inline void IngressInfo::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& IngressInfo::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.room_name)
}
inline std::string* IngressInfo::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.room_name)
  return _s;
}
inline const std::string& IngressInfo::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void IngressInfo::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.room_name)
  return _impl_.room_name_.Release();
}
inline void IngressInfo::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.room_name)
}

// string participant_identity = 9;
inline void IngressInfo::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& IngressInfo::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_identity)
}
inline std::string* IngressInfo::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_identity)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void IngressInfo::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void IngressInfo::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_identity)
}

// string participant_name = 10;
inline void IngressInfo::clear_participant_name() {
  _impl_.participant_name_.ClearToEmpty();
}
inline const std::string& IngressInfo::participant_name() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_name)
  return _internal_participant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_participant_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_name)
}
inline std::string* IngressInfo::mutable_participant_name() {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_name)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_name() const {
  return _impl_.participant_name_.Get();
}
inline void IngressInfo::_internal_set_participant_name(const std::string& value) {
  
  _impl_.participant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_participant_name() {
  
  return _impl_.participant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_participant_name() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_name)
  return _impl_.participant_name_.Release();
}
inline void IngressInfo::set_allocated_participant_name(std::string* participant_name) {
  if (participant_name != nullptr) {
    
  } else {
    
  }
  _impl_.participant_name_.SetAllocated(participant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_name)
}

// string participant_metadata = 14;
inline void IngressInfo::clear_participant_metadata() {
  _impl_.participant_metadata_.ClearToEmpty();
}
inline const std::string& IngressInfo::participant_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.participant_metadata)
  return _internal_participant_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressInfo::set_participant_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.participant_metadata)
}
inline std::string* IngressInfo::mutable_participant_metadata() {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.participant_metadata)
  return _s;
}
inline const std::string& IngressInfo::_internal_participant_metadata() const {
  return _impl_.participant_metadata_.Get();
}
inline void IngressInfo::_internal_set_participant_metadata(const std::string& value) {
  
  _impl_.participant_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressInfo::_internal_mutable_participant_metadata() {
  
  return _impl_.participant_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressInfo::release_participant_metadata() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.participant_metadata)
  return _impl_.participant_metadata_.Release();
}
inline void IngressInfo::set_allocated_participant_metadata(std::string* participant_metadata) {
  if (participant_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.participant_metadata_.SetAllocated(participant_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.participant_metadata)
}

// bool reusable = 11;
inline void IngressInfo::clear_reusable() {
  _impl_.reusable_ = false;
}
inline bool IngressInfo::_internal_reusable() const {
  return _impl_.reusable_;
}
inline bool IngressInfo::reusable() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.reusable)
  return _internal_reusable();
}
inline void IngressInfo::_internal_set_reusable(bool value) {
  
  _impl_.reusable_ = value;
}
inline void IngressInfo::set_reusable(bool value) {
  _internal_set_reusable(value);
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.reusable)
}

// .livekit.IngressState state = 12;
inline bool IngressInfo::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool IngressInfo::has_state() const {
  return _internal_has_state();
}
inline void IngressInfo::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::livekit::IngressState& IngressInfo::_internal_state() const {
  const ::livekit::IngressState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressState&>(
      ::livekit::_IngressState_default_instance_);
}
inline const ::livekit::IngressState& IngressInfo::state() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.state)
  return _internal_state();
}
inline void IngressInfo::unsafe_arena_set_allocated_state(
    ::livekit::IngressState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressInfo.state)
}
inline ::livekit::IngressState* IngressInfo::release_state() {
  
  ::livekit::IngressState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressState* IngressInfo::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:livekit.IngressInfo.state)
  
  ::livekit::IngressState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::livekit::IngressState* IngressInfo::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::livekit::IngressState* IngressInfo::mutable_state() {
  ::livekit::IngressState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:livekit.IngressInfo.state)
  return _msg;
}
inline void IngressInfo::set_allocated_state(::livekit::IngressState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressInfo.state)
}

// optional bool enabled = 16;
inline bool IngressInfo::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IngressInfo::has_enabled() const {
  return _internal_has_enabled();
}
inline void IngressInfo::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool IngressInfo::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool IngressInfo::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.IngressInfo.enabled)
  return _internal_enabled();
}
inline void IngressInfo::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void IngressInfo::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.IngressInfo.enabled)
}

// -------------------------------------------------------------------

// IngressState

// .livekit.IngressState.Status status = 1;
inline void IngressState::clear_status() {
  _impl_.status_ = 0;
}
inline ::livekit::IngressState_Status IngressState::_internal_status() const {
  return static_cast< ::livekit::IngressState_Status >(_impl_.status_);
}
inline ::livekit::IngressState_Status IngressState::status() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.status)
  return _internal_status();
}
inline void IngressState::_internal_set_status(::livekit::IngressState_Status value) {
  
  _impl_.status_ = value;
}
inline void IngressState::set_status(::livekit::IngressState_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.IngressState.status)
}

// string error = 2;
inline void IngressState::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& IngressState::error() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressState::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressState.error)
}
inline std::string* IngressState::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.error)
  return _s;
}
inline const std::string& IngressState::_internal_error() const {
  return _impl_.error_.Get();
}
inline void IngressState::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressState::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressState::release_error() {
  // @@protoc_insertion_point(field_release:livekit.IngressState.error)
  return _impl_.error_.Release();
}
inline void IngressState::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.error)
}

// .livekit.InputVideoState video = 3;
inline bool IngressState::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool IngressState::has_video() const {
  return _internal_has_video();
}
inline void IngressState::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::livekit::InputVideoState& IngressState::_internal_video() const {
  const ::livekit::InputVideoState* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::InputVideoState&>(
      ::livekit::_InputVideoState_default_instance_);
}
inline const ::livekit::InputVideoState& IngressState::video() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.video)
  return _internal_video();
}
inline void IngressState::unsafe_arena_set_allocated_video(
    ::livekit::InputVideoState* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressState.video)
}
inline ::livekit::InputVideoState* IngressState::release_video() {
  
  ::livekit::InputVideoState* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::InputVideoState* IngressState::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.IngressState.video)
  
  ::livekit::InputVideoState* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::InputVideoState* IngressState::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::InputVideoState>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::livekit::InputVideoState* IngressState::mutable_video() {
  ::livekit::InputVideoState* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.video)
  return _msg;
}
inline void IngressState::set_allocated_video(::livekit::InputVideoState* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.video)
}

// .livekit.InputAudioState audio = 4;
inline bool IngressState::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool IngressState::has_audio() const {
  return _internal_has_audio();
}
inline void IngressState::clear_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
}
inline const ::livekit::InputAudioState& IngressState::_internal_audio() const {
  const ::livekit::InputAudioState* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::InputAudioState&>(
      ::livekit::_InputAudioState_default_instance_);
}
inline const ::livekit::InputAudioState& IngressState::audio() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.audio)
  return _internal_audio();
}
inline void IngressState::unsafe_arena_set_allocated_audio(
    ::livekit::InputAudioState* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.IngressState.audio)
}
inline ::livekit::InputAudioState* IngressState::release_audio() {
  
  ::livekit::InputAudioState* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::InputAudioState* IngressState::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:livekit.IngressState.audio)
  
  ::livekit::InputAudioState* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::InputAudioState* IngressState::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::InputAudioState>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::livekit::InputAudioState* IngressState::mutable_audio() {
  ::livekit::InputAudioState* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.audio)
  return _msg;
}
inline void IngressState::set_allocated_audio(::livekit::InputAudioState* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.audio)
}

// string room_id = 5;
inline void IngressState::clear_room_id() {
  _impl_.room_id_.ClearToEmpty();
}
inline const std::string& IngressState::room_id() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.room_id)
  return _internal_room_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressState::set_room_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressState.room_id)
}
inline std::string* IngressState::mutable_room_id() {
  std::string* _s = _internal_mutable_room_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.room_id)
  return _s;
}
inline const std::string& IngressState::_internal_room_id() const {
  return _impl_.room_id_.Get();
}
inline void IngressState::_internal_set_room_id(const std::string& value) {
  
  _impl_.room_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressState::_internal_mutable_room_id() {
  
  return _impl_.room_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressState::release_room_id() {
  // @@protoc_insertion_point(field_release:livekit.IngressState.room_id)
  return _impl_.room_id_.Release();
}
inline void IngressState::set_allocated_room_id(std::string* room_id) {
  if (room_id != nullptr) {
    
  } else {
    
  }
  _impl_.room_id_.SetAllocated(room_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_id_.IsDefault()) {
    _impl_.room_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.room_id)
}

// int64 started_at = 7;
inline void IngressState::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t IngressState::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t IngressState::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.started_at)
  return _internal_started_at();
}
inline void IngressState::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void IngressState::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.IngressState.started_at)
}

// int64 ended_at = 8;
inline void IngressState::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t IngressState::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t IngressState::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.ended_at)
  return _internal_ended_at();
}
inline void IngressState::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void IngressState::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.IngressState.ended_at)
}

// int64 updated_at = 10;
inline void IngressState::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t IngressState::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t IngressState::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.updated_at)
  return _internal_updated_at();
}
inline void IngressState::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void IngressState::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:livekit.IngressState.updated_at)
}

// string resource_id = 9;
inline void IngressState::clear_resource_id() {
  _impl_.resource_id_.ClearToEmpty();
}
inline const std::string& IngressState::resource_id() const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.resource_id)
  return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IngressState::set_resource_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resource_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.IngressState.resource_id)
}
inline std::string* IngressState::mutable_resource_id() {
  std::string* _s = _internal_mutable_resource_id();
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.resource_id)
  return _s;
}
inline const std::string& IngressState::_internal_resource_id() const {
  return _impl_.resource_id_.Get();
}
inline void IngressState::_internal_set_resource_id(const std::string& value) {
  
  _impl_.resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IngressState::_internal_mutable_resource_id() {
  
  return _impl_.resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IngressState::release_resource_id() {
  // @@protoc_insertion_point(field_release:livekit.IngressState.resource_id)
  return _impl_.resource_id_.Release();
}
inline void IngressState::set_allocated_resource_id(std::string* resource_id) {
  if (resource_id != nullptr) {
    
  } else {
    
  }
  _impl_.resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_id_.IsDefault()) {
    _impl_.resource_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.IngressState.resource_id)
}

// repeated .livekit.TrackInfo tracks = 6;
inline int IngressState::_internal_tracks_size() const {
  return _impl_.tracks_.size();
}
inline int IngressState::tracks_size() const {
  return _internal_tracks_size();
}
inline ::livekit::TrackInfo* IngressState::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.IngressState.tracks)
  return _impl_.tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >*
IngressState::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:livekit.IngressState.tracks)
  return &_impl_.tracks_;
}
inline const ::livekit::TrackInfo& IngressState::_internal_tracks(int index) const {
  return _impl_.tracks_.Get(index);
}
inline const ::livekit::TrackInfo& IngressState::tracks(int index) const {
  // @@protoc_insertion_point(field_get:livekit.IngressState.tracks)
  return _internal_tracks(index);
}
inline ::livekit::TrackInfo* IngressState::_internal_add_tracks() {
  return _impl_.tracks_.Add();
}
inline ::livekit::TrackInfo* IngressState::add_tracks() {
  ::livekit::TrackInfo* _add = _internal_add_tracks();
  // @@protoc_insertion_point(field_add:livekit.IngressState.tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::TrackInfo >&
IngressState::tracks() const {
  // @@protoc_insertion_point(field_list:livekit.IngressState.tracks)
  return _impl_.tracks_;
}

// -------------------------------------------------------------------

// InputVideoState

// string mime_type = 1;
inline void InputVideoState::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& InputVideoState::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputVideoState::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.mime_type)
}
inline std::string* InputVideoState::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.InputVideoState.mime_type)
  return _s;
}
inline const std::string& InputVideoState::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void InputVideoState::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InputVideoState::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* InputVideoState::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.InputVideoState.mime_type)
  return _impl_.mime_type_.Release();
}
inline void InputVideoState::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.InputVideoState.mime_type)
}

// uint32 average_bitrate = 2;
inline void InputVideoState::clear_average_bitrate() {
  _impl_.average_bitrate_ = 0u;
}
inline uint32_t InputVideoState::_internal_average_bitrate() const {
  return _impl_.average_bitrate_;
}
inline uint32_t InputVideoState::average_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.average_bitrate)
  return _internal_average_bitrate();
}
inline void InputVideoState::_internal_set_average_bitrate(uint32_t value) {
  
  _impl_.average_bitrate_ = value;
}
inline void InputVideoState::set_average_bitrate(uint32_t value) {
  _internal_set_average_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.average_bitrate)
}

// uint32 width = 3;
inline void InputVideoState::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t InputVideoState::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t InputVideoState::width() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.width)
  return _internal_width();
}
inline void InputVideoState::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void InputVideoState::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.width)
}

// uint32 height = 4;
inline void InputVideoState::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t InputVideoState::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t InputVideoState::height() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.height)
  return _internal_height();
}
inline void InputVideoState::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void InputVideoState::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.height)
}

// double framerate = 5;
inline void InputVideoState::clear_framerate() {
  _impl_.framerate_ = 0;
}
inline double InputVideoState::_internal_framerate() const {
  return _impl_.framerate_;
}
inline double InputVideoState::framerate() const {
  // @@protoc_insertion_point(field_get:livekit.InputVideoState.framerate)
  return _internal_framerate();
}
inline void InputVideoState::_internal_set_framerate(double value) {
  
  _impl_.framerate_ = value;
}
inline void InputVideoState::set_framerate(double value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:livekit.InputVideoState.framerate)
}

// -------------------------------------------------------------------

// InputAudioState

// string mime_type = 1;
inline void InputAudioState::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& InputAudioState::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputAudioState::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.mime_type)
}
inline std::string* InputAudioState::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.InputAudioState.mime_type)
  return _s;
}
inline const std::string& InputAudioState::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void InputAudioState::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InputAudioState::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* InputAudioState::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.InputAudioState.mime_type)
  return _impl_.mime_type_.Release();
}
inline void InputAudioState::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.InputAudioState.mime_type)
}

// uint32 average_bitrate = 2;
inline void InputAudioState::clear_average_bitrate() {
  _impl_.average_bitrate_ = 0u;
}
inline uint32_t InputAudioState::_internal_average_bitrate() const {
  return _impl_.average_bitrate_;
}
inline uint32_t InputAudioState::average_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.average_bitrate)
  return _internal_average_bitrate();
}
inline void InputAudioState::_internal_set_average_bitrate(uint32_t value) {
  
  _impl_.average_bitrate_ = value;
}
inline void InputAudioState::set_average_bitrate(uint32_t value) {
  _internal_set_average_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.average_bitrate)
}

// uint32 channels = 3;
inline void InputAudioState::clear_channels() {
  _impl_.channels_ = 0u;
}
inline uint32_t InputAudioState::_internal_channels() const {
  return _impl_.channels_;
}
inline uint32_t InputAudioState::channels() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.channels)
  return _internal_channels();
}
inline void InputAudioState::_internal_set_channels(uint32_t value) {
  
  _impl_.channels_ = value;
}
inline void InputAudioState::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.channels)
}

// uint32 sample_rate = 4;
inline void InputAudioState::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
}
inline uint32_t InputAudioState::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t InputAudioState::sample_rate() const {
  // @@protoc_insertion_point(field_get:livekit.InputAudioState.sample_rate)
  return _internal_sample_rate();
}
inline void InputAudioState::_internal_set_sample_rate(uint32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void InputAudioState::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:livekit.InputAudioState.sample_rate)
}

// -------------------------------------------------------------------

// UpdateIngressRequest

// string ingress_id = 1;
inline void UpdateIngressRequest::clear_ingress_id() {
  _impl_.ingress_id_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::ingress_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_ingress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ingress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.ingress_id)
}
inline std::string* UpdateIngressRequest::mutable_ingress_id() {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.ingress_id)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_ingress_id() const {
  return _impl_.ingress_id_.Get();
}
inline void UpdateIngressRequest::_internal_set_ingress_id(const std::string& value) {
  
  _impl_.ingress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_ingress_id() {
  
  return _impl_.ingress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_ingress_id() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.ingress_id)
  return _impl_.ingress_id_.Release();
}
inline void UpdateIngressRequest::set_allocated_ingress_id(std::string* ingress_id) {
  if (ingress_id != nullptr) {
    
  } else {
    
  }
  _impl_.ingress_id_.SetAllocated(ingress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.ingress_id)
}

// string name = 2;
inline void UpdateIngressRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.name)
}
inline std::string* UpdateIngressRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UpdateIngressRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.name)
  return _impl_.name_.Release();
}
inline void UpdateIngressRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.name)
}

// string room_name = 3;
inline void UpdateIngressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.room_name)
}
inline std::string* UpdateIngressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.room_name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void UpdateIngressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void UpdateIngressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.room_name)
}

// string participant_identity = 4;
inline void UpdateIngressRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_identity)
}
inline std::string* UpdateIngressRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_identity)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void UpdateIngressRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_identity)
}

// string participant_name = 5;
inline void UpdateIngressRequest::clear_participant_name() {
  _impl_.participant_name_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::participant_name() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_name)
  return _internal_participant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_participant_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_name)
}
inline std::string* UpdateIngressRequest::mutable_participant_name() {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_name)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_name() const {
  return _impl_.participant_name_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_name(const std::string& value) {
  
  _impl_.participant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_participant_name() {
  
  return _impl_.participant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_participant_name() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_name)
  return _impl_.participant_name_.Release();
}
inline void UpdateIngressRequest::set_allocated_participant_name(std::string* participant_name) {
  if (participant_name != nullptr) {
    
  } else {
    
  }
  _impl_.participant_name_.SetAllocated(participant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_name)
}

// string participant_metadata = 9;
inline void UpdateIngressRequest::clear_participant_metadata() {
  _impl_.participant_metadata_.ClearToEmpty();
}
inline const std::string& UpdateIngressRequest::participant_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.participant_metadata)
  return _internal_participant_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateIngressRequest::set_participant_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.participant_metadata)
}
inline std::string* UpdateIngressRequest::mutable_participant_metadata() {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.participant_metadata)
  return _s;
}
inline const std::string& UpdateIngressRequest::_internal_participant_metadata() const {
  return _impl_.participant_metadata_.Get();
}
inline void UpdateIngressRequest::_internal_set_participant_metadata(const std::string& value) {
  
  _impl_.participant_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::_internal_mutable_participant_metadata() {
  
  return _impl_.participant_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateIngressRequest::release_participant_metadata() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.participant_metadata)
  return _impl_.participant_metadata_.Release();
}
inline void UpdateIngressRequest::set_allocated_participant_metadata(std::string* participant_metadata) {
  if (participant_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.participant_metadata_.SetAllocated(participant_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.participant_metadata)
}

// optional bool bypass_transcoding = 8 [deprecated = true];
inline bool UpdateIngressRequest::_internal_has_bypass_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateIngressRequest::has_bypass_transcoding() const {
  return _internal_has_bypass_transcoding();
}
inline void UpdateIngressRequest::clear_bypass_transcoding() {
  _impl_.bypass_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateIngressRequest::_internal_bypass_transcoding() const {
  return _impl_.bypass_transcoding_;
}
inline bool UpdateIngressRequest::bypass_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.bypass_transcoding)
  return _internal_bypass_transcoding();
}
inline void UpdateIngressRequest::_internal_set_bypass_transcoding(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bypass_transcoding_ = value;
}
inline void UpdateIngressRequest::set_bypass_transcoding(bool value) {
  _internal_set_bypass_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.bypass_transcoding)
}

// optional bool enable_transcoding = 10;
inline bool UpdateIngressRequest::_internal_has_enable_transcoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateIngressRequest::has_enable_transcoding() const {
  return _internal_has_enable_transcoding();
}
inline void UpdateIngressRequest::clear_enable_transcoding() {
  _impl_.enable_transcoding_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateIngressRequest::_internal_enable_transcoding() const {
  return _impl_.enable_transcoding_;
}
inline bool UpdateIngressRequest::enable_transcoding() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.enable_transcoding)
  return _internal_enable_transcoding();
}
inline void UpdateIngressRequest::_internal_set_enable_transcoding(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enable_transcoding_ = value;
}
inline void UpdateIngressRequest::set_enable_transcoding(bool value) {
  _internal_set_enable_transcoding(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.enable_transcoding)
}

// .livekit.IngressAudioOptions audio = 6;
inline bool UpdateIngressRequest::_internal_has_audio() const {
  return this != internal_default_instance() && _impl_.audio_ != nullptr;
}
inline bool UpdateIngressRequest::has_audio() const {
  return _internal_has_audio();
}
inline void UpdateIngressRequest::clear_audio() {
  if (GetArenaForAllocation() == nullptr && _impl_.audio_ != nullptr) {
    delete _impl_.audio_;
  }
  _impl_.audio_ = nullptr;
}
inline const ::livekit::IngressAudioOptions& UpdateIngressRequest::_internal_audio() const {
  const ::livekit::IngressAudioOptions* p = _impl_.audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressAudioOptions&>(
      ::livekit::_IngressAudioOptions_default_instance_);
}
inline const ::livekit::IngressAudioOptions& UpdateIngressRequest::audio() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.audio)
  return _internal_audio();
}
inline void UpdateIngressRequest::unsafe_arena_set_allocated_audio(
    ::livekit::IngressAudioOptions* audio) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_);
  }
  _impl_.audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.UpdateIngressRequest.audio)
}
inline ::livekit::IngressAudioOptions* UpdateIngressRequest::release_audio() {
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressAudioOptions* UpdateIngressRequest::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.audio)
  
  ::livekit::IngressAudioOptions* temp = _impl_.audio_;
  _impl_.audio_ = nullptr;
  return temp;
}
inline ::livekit::IngressAudioOptions* UpdateIngressRequest::_internal_mutable_audio() {
  
  if (_impl_.audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressAudioOptions>(GetArenaForAllocation());
    _impl_.audio_ = p;
  }
  return _impl_.audio_;
}
inline ::livekit::IngressAudioOptions* UpdateIngressRequest::mutable_audio() {
  ::livekit::IngressAudioOptions* _msg = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.audio)
  return _msg;
}
inline void UpdateIngressRequest::set_allocated_audio(::livekit::IngressAudioOptions* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.audio)
}

// .livekit.IngressVideoOptions video = 7;
inline bool UpdateIngressRequest::_internal_has_video() const {
  return this != internal_default_instance() && _impl_.video_ != nullptr;
}
inline bool UpdateIngressRequest::has_video() const {
  return _internal_has_video();
}
inline void UpdateIngressRequest::clear_video() {
  if (GetArenaForAllocation() == nullptr && _impl_.video_ != nullptr) {
    delete _impl_.video_;
  }
  _impl_.video_ = nullptr;
}
inline const ::livekit::IngressVideoOptions& UpdateIngressRequest::_internal_video() const {
  const ::livekit::IngressVideoOptions* p = _impl_.video_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::IngressVideoOptions&>(
      ::livekit::_IngressVideoOptions_default_instance_);
}
inline const ::livekit::IngressVideoOptions& UpdateIngressRequest::video() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.video)
  return _internal_video();
}
inline void UpdateIngressRequest::unsafe_arena_set_allocated_video(
    ::livekit::IngressVideoOptions* video) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_);
  }
  _impl_.video_ = video;
  if (video) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.UpdateIngressRequest.video)
}
inline ::livekit::IngressVideoOptions* UpdateIngressRequest::release_video() {
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::IngressVideoOptions* UpdateIngressRequest::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_release:livekit.UpdateIngressRequest.video)
  
  ::livekit::IngressVideoOptions* temp = _impl_.video_;
  _impl_.video_ = nullptr;
  return temp;
}
inline ::livekit::IngressVideoOptions* UpdateIngressRequest::_internal_mutable_video() {
  
  if (_impl_.video_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::IngressVideoOptions>(GetArenaForAllocation());
    _impl_.video_ = p;
  }
  return _impl_.video_;
}
inline ::livekit::IngressVideoOptions* UpdateIngressRequest::mutable_video() {
  ::livekit::IngressVideoOptions* _msg = _internal_mutable_video();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateIngressRequest.video)
  return _msg;
}
inline void UpdateIngressRequest::set_allocated_video(::livekit::IngressVideoOptions* video) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_;
  }
  if (video) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video);
    if (message_arena != submessage_arena) {
      video = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.video_ = video;
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateIngressRequest.video)
}

// optional bool enabled = 11;
inline bool UpdateIngressRequest::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateIngressRequest::has_enabled() const {
  return _internal_has_enabled();
}
inline void UpdateIngressRequest::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool UpdateIngressRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool UpdateIngressRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateIngressRequest.enabled)
  return _internal_enabled();
}
inline void UpdateIngressRequest::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enabled_ = value;
}
inline void UpdateIngressRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateIngressRequest.enabled)
}

// -------------------------------------------------------------------

// ListIngressRequest

// string room_name = 1;
inline void ListIngressRequest::clear_room_name() {
  _impl_.room_name_.ClearToEmpty();
}
inline const std::string& ListIngressRequest::room_name() const {
  // @@protoc_insertion_point(field_get:livekit.ListIngressRequest.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIngressRequest::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ListIngressRequest.room_name)
}
inline std::string* ListIngressRequest::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressRequest.room_name)
  return _s;
}
inline const std::string& ListIngressRequest::_internal_room_name() const {
  return _impl_.room_name_.Get();
}
inline void ListIngressRequest::_internal_set_room_name(const std::string& value) {
  
  _impl_.room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIngressRequest::_internal_mutable_room_name() {
  
  return _impl_.room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIngressRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:livekit.ListIngressRequest.room_name)
  return _impl_.room_name_.Release();
}
inline void ListIngressRequest::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  _impl_.room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.room_name_.IsDefault()) {
    _impl_.room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ListIngressRequest.room_name)
}

// string ingress_id = 2;
inline void ListIngressRequest::clear_ingress_id() {
  _impl_.ingress_id_.ClearToEmpty();
}
inline const std::string& ListIngressRequest::ingress_id() const {
  // @@protoc_insertion_point(field_get:livekit.ListIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIngressRequest::set_ingress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ingress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.ListIngressRequest.ingress_id)
}
inline std::string* ListIngressRequest::mutable_ingress_id() {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressRequest.ingress_id)
  return _s;
}
inline const std::string& ListIngressRequest::_internal_ingress_id() const {
  return _impl_.ingress_id_.Get();
}
inline void ListIngressRequest::_internal_set_ingress_id(const std::string& value) {
  
  _impl_.ingress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIngressRequest::_internal_mutable_ingress_id() {
  
  return _impl_.ingress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ListIngressRequest::release_ingress_id() {
  // @@protoc_insertion_point(field_release:livekit.ListIngressRequest.ingress_id)
  return _impl_.ingress_id_.Release();
}
inline void ListIngressRequest::set_allocated_ingress_id(std::string* ingress_id) {
  if (ingress_id != nullptr) {
    
  } else {
    
  }
  _impl_.ingress_id_.SetAllocated(ingress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.ListIngressRequest.ingress_id)
}

// -------------------------------------------------------------------

// ListIngressResponse

// repeated .livekit.IngressInfo items = 1;
inline int ListIngressResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int ListIngressResponse::items_size() const {
  return _internal_items_size();
}
inline void ListIngressResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::livekit::IngressInfo* ListIngressResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.ListIngressResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::IngressInfo >*
ListIngressResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:livekit.ListIngressResponse.items)
  return &_impl_.items_;
}
inline const ::livekit::IngressInfo& ListIngressResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::livekit::IngressInfo& ListIngressResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:livekit.ListIngressResponse.items)
  return _internal_items(index);
}
inline ::livekit::IngressInfo* ListIngressResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::livekit::IngressInfo* ListIngressResponse::add_items() {
  ::livekit::IngressInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:livekit.ListIngressResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::IngressInfo >&
ListIngressResponse::items() const {
  // @@protoc_insertion_point(field_list:livekit.ListIngressResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// DeleteIngressRequest

// string ingress_id = 1;
inline void DeleteIngressRequest::clear_ingress_id() {
  _impl_.ingress_id_.ClearToEmpty();
}
inline const std::string& DeleteIngressRequest::ingress_id() const {
  // @@protoc_insertion_point(field_get:livekit.DeleteIngressRequest.ingress_id)
  return _internal_ingress_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteIngressRequest::set_ingress_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ingress_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.DeleteIngressRequest.ingress_id)
}
inline std::string* DeleteIngressRequest::mutable_ingress_id() {
  std::string* _s = _internal_mutable_ingress_id();
  // @@protoc_insertion_point(field_mutable:livekit.DeleteIngressRequest.ingress_id)
  return _s;
}
inline const std::string& DeleteIngressRequest::_internal_ingress_id() const {
  return _impl_.ingress_id_.Get();
}
inline void DeleteIngressRequest::_internal_set_ingress_id(const std::string& value) {
  
  _impl_.ingress_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteIngressRequest::_internal_mutable_ingress_id() {
  
  return _impl_.ingress_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteIngressRequest::release_ingress_id() {
  // @@protoc_insertion_point(field_release:livekit.DeleteIngressRequest.ingress_id)
  return _impl_.ingress_id_.Release();
}
inline void DeleteIngressRequest::set_allocated_ingress_id(std::string* ingress_id) {
  if (ingress_id != nullptr) {
    
  } else {
    
  }
  _impl_.ingress_id_.SetAllocated(ingress_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ingress_id_.IsDefault()) {
    _impl_.ingress_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.DeleteIngressRequest.ingress_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::IngressState_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::IngressState_Status>() {
  return ::livekit::IngressState_Status_descriptor();
}
template <> struct is_proto_enum< ::livekit::IngressInput> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::IngressInput>() {
  return ::livekit::IngressInput_descriptor();
}
template <> struct is_proto_enum< ::livekit::IngressAudioEncodingPreset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::IngressAudioEncodingPreset>() {
  return ::livekit::IngressAudioEncodingPreset_descriptor();
}
template <> struct is_proto_enum< ::livekit::IngressVideoEncodingPreset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::IngressVideoEncodingPreset>() {
  return ::livekit::IngressVideoEncodingPreset_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5fingress_2eproto
