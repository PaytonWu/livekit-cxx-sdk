// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: room.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_room_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_room_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "e2ee.pb.h"
#include "handle.pb.h"
#include "participant.pb.h"
#include "track.pb.h"
#include "video_frame.pb.h"
#include "stats.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_room_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_room_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_room_2eproto;
namespace livekit {
namespace proto {
class ActiveSpeakersChanged;
struct ActiveSpeakersChangedDefaultTypeInternal;
extern ActiveSpeakersChangedDefaultTypeInternal _ActiveSpeakersChanged_default_instance_;
class AttributesEntry;
struct AttributesEntryDefaultTypeInternal;
extern AttributesEntryDefaultTypeInternal _AttributesEntry_default_instance_;
class AudioEncoding;
struct AudioEncodingDefaultTypeInternal;
extern AudioEncodingDefaultTypeInternal _AudioEncoding_default_instance_;
class BufferInfo;
struct BufferInfoDefaultTypeInternal;
extern BufferInfoDefaultTypeInternal _BufferInfo_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ChatMessageReceived;
struct ChatMessageReceivedDefaultTypeInternal;
extern ChatMessageReceivedDefaultTypeInternal _ChatMessageReceived_default_instance_;
class ConnectCallback;
struct ConnectCallbackDefaultTypeInternal;
extern ConnectCallbackDefaultTypeInternal _ConnectCallback_default_instance_;
class ConnectCallback_ParticipantWithTracks;
struct ConnectCallback_ParticipantWithTracksDefaultTypeInternal;
extern ConnectCallback_ParticipantWithTracksDefaultTypeInternal _ConnectCallback_ParticipantWithTracks_default_instance_;
class ConnectCallback_Result;
struct ConnectCallback_ResultDefaultTypeInternal;
extern ConnectCallback_ResultDefaultTypeInternal _ConnectCallback_Result_default_instance_;
class ConnectRequest;
struct ConnectRequestDefaultTypeInternal;
extern ConnectRequestDefaultTypeInternal _ConnectRequest_default_instance_;
class ConnectResponse;
struct ConnectResponseDefaultTypeInternal;
extern ConnectResponseDefaultTypeInternal _ConnectResponse_default_instance_;
class Connected;
struct ConnectedDefaultTypeInternal;
extern ConnectedDefaultTypeInternal _Connected_default_instance_;
class ConnectionQualityChanged;
struct ConnectionQualityChangedDefaultTypeInternal;
extern ConnectionQualityChangedDefaultTypeInternal _ConnectionQualityChanged_default_instance_;
class ConnectionStateChanged;
struct ConnectionStateChangedDefaultTypeInternal;
extern ConnectionStateChangedDefaultTypeInternal _ConnectionStateChanged_default_instance_;
class DataChannelBufferedAmountLowThresholdChanged;
struct DataChannelBufferedAmountLowThresholdChangedDefaultTypeInternal;
extern DataChannelBufferedAmountLowThresholdChangedDefaultTypeInternal _DataChannelBufferedAmountLowThresholdChanged_default_instance_;
class DataPacketReceived;
struct DataPacketReceivedDefaultTypeInternal;
extern DataPacketReceivedDefaultTypeInternal _DataPacketReceived_default_instance_;
class DataStream;
struct DataStreamDefaultTypeInternal;
extern DataStreamDefaultTypeInternal _DataStream_default_instance_;
class DataStreamChunkReceived;
struct DataStreamChunkReceivedDefaultTypeInternal;
extern DataStreamChunkReceivedDefaultTypeInternal _DataStreamChunkReceived_default_instance_;
class DataStreamHeaderReceived;
struct DataStreamHeaderReceivedDefaultTypeInternal;
extern DataStreamHeaderReceivedDefaultTypeInternal _DataStreamHeaderReceived_default_instance_;
class DataStreamTrailerReceived;
struct DataStreamTrailerReceivedDefaultTypeInternal;
extern DataStreamTrailerReceivedDefaultTypeInternal _DataStreamTrailerReceived_default_instance_;
class DataStream_ByteHeader;
struct DataStream_ByteHeaderDefaultTypeInternal;
extern DataStream_ByteHeaderDefaultTypeInternal _DataStream_ByteHeader_default_instance_;
class DataStream_Chunk;
struct DataStream_ChunkDefaultTypeInternal;
extern DataStream_ChunkDefaultTypeInternal _DataStream_Chunk_default_instance_;
class DataStream_Header;
struct DataStream_HeaderDefaultTypeInternal;
extern DataStream_HeaderDefaultTypeInternal _DataStream_Header_default_instance_;
class DataStream_Header_AttributesEntry_DoNotUse;
struct DataStream_Header_AttributesEntry_DoNotUseDefaultTypeInternal;
extern DataStream_Header_AttributesEntry_DoNotUseDefaultTypeInternal _DataStream_Header_AttributesEntry_DoNotUse_default_instance_;
class DataStream_TextHeader;
struct DataStream_TextHeaderDefaultTypeInternal;
extern DataStream_TextHeaderDefaultTypeInternal _DataStream_TextHeader_default_instance_;
class DataStream_Trailer;
struct DataStream_TrailerDefaultTypeInternal;
extern DataStream_TrailerDefaultTypeInternal _DataStream_Trailer_default_instance_;
class DataStream_Trailer_AttributesEntry_DoNotUse;
struct DataStream_Trailer_AttributesEntry_DoNotUseDefaultTypeInternal;
extern DataStream_Trailer_AttributesEntry_DoNotUseDefaultTypeInternal _DataStream_Trailer_AttributesEntry_DoNotUse_default_instance_;
class DisconnectCallback;
struct DisconnectCallbackDefaultTypeInternal;
extern DisconnectCallbackDefaultTypeInternal _DisconnectCallback_default_instance_;
class DisconnectRequest;
struct DisconnectRequestDefaultTypeInternal;
extern DisconnectRequestDefaultTypeInternal _DisconnectRequest_default_instance_;
class DisconnectResponse;
struct DisconnectResponseDefaultTypeInternal;
extern DisconnectResponseDefaultTypeInternal _DisconnectResponse_default_instance_;
class Disconnected;
struct DisconnectedDefaultTypeInternal;
extern DisconnectedDefaultTypeInternal _Disconnected_default_instance_;
class E2eeStateChanged;
struct E2eeStateChangedDefaultTypeInternal;
extern E2eeStateChangedDefaultTypeInternal _E2eeStateChanged_default_instance_;
class EditChatMessageRequest;
struct EditChatMessageRequestDefaultTypeInternal;
extern EditChatMessageRequestDefaultTypeInternal _EditChatMessageRequest_default_instance_;
class GetSessionStatsCallback;
struct GetSessionStatsCallbackDefaultTypeInternal;
extern GetSessionStatsCallbackDefaultTypeInternal _GetSessionStatsCallback_default_instance_;
class GetSessionStatsCallback_Result;
struct GetSessionStatsCallback_ResultDefaultTypeInternal;
extern GetSessionStatsCallback_ResultDefaultTypeInternal _GetSessionStatsCallback_Result_default_instance_;
class GetSessionStatsRequest;
struct GetSessionStatsRequestDefaultTypeInternal;
extern GetSessionStatsRequestDefaultTypeInternal _GetSessionStatsRequest_default_instance_;
class GetSessionStatsResponse;
struct GetSessionStatsResponseDefaultTypeInternal;
extern GetSessionStatsResponseDefaultTypeInternal _GetSessionStatsResponse_default_instance_;
class IceServer;
struct IceServerDefaultTypeInternal;
extern IceServerDefaultTypeInternal _IceServer_default_instance_;
class LocalTrackPublished;
struct LocalTrackPublishedDefaultTypeInternal;
extern LocalTrackPublishedDefaultTypeInternal _LocalTrackPublished_default_instance_;
class LocalTrackSubscribed;
struct LocalTrackSubscribedDefaultTypeInternal;
extern LocalTrackSubscribedDefaultTypeInternal _LocalTrackSubscribed_default_instance_;
class LocalTrackUnpublished;
struct LocalTrackUnpublishedDefaultTypeInternal;
extern LocalTrackUnpublishedDefaultTypeInternal _LocalTrackUnpublished_default_instance_;
class OwnedBuffer;
struct OwnedBufferDefaultTypeInternal;
extern OwnedBufferDefaultTypeInternal _OwnedBuffer_default_instance_;
class OwnedRoom;
struct OwnedRoomDefaultTypeInternal;
extern OwnedRoomDefaultTypeInternal _OwnedRoom_default_instance_;
class ParticipantAttributesChanged;
struct ParticipantAttributesChangedDefaultTypeInternal;
extern ParticipantAttributesChangedDefaultTypeInternal _ParticipantAttributesChanged_default_instance_;
class ParticipantConnected;
struct ParticipantConnectedDefaultTypeInternal;
extern ParticipantConnectedDefaultTypeInternal _ParticipantConnected_default_instance_;
class ParticipantDisconnected;
struct ParticipantDisconnectedDefaultTypeInternal;
extern ParticipantDisconnectedDefaultTypeInternal _ParticipantDisconnected_default_instance_;
class ParticipantMetadataChanged;
struct ParticipantMetadataChangedDefaultTypeInternal;
extern ParticipantMetadataChangedDefaultTypeInternal _ParticipantMetadataChanged_default_instance_;
class ParticipantNameChanged;
struct ParticipantNameChangedDefaultTypeInternal;
extern ParticipantNameChangedDefaultTypeInternal _ParticipantNameChanged_default_instance_;
class PublishDataCallback;
struct PublishDataCallbackDefaultTypeInternal;
extern PublishDataCallbackDefaultTypeInternal _PublishDataCallback_default_instance_;
class PublishDataRequest;
struct PublishDataRequestDefaultTypeInternal;
extern PublishDataRequestDefaultTypeInternal _PublishDataRequest_default_instance_;
class PublishDataResponse;
struct PublishDataResponseDefaultTypeInternal;
extern PublishDataResponseDefaultTypeInternal _PublishDataResponse_default_instance_;
class PublishSipDtmfCallback;
struct PublishSipDtmfCallbackDefaultTypeInternal;
extern PublishSipDtmfCallbackDefaultTypeInternal _PublishSipDtmfCallback_default_instance_;
class PublishSipDtmfRequest;
struct PublishSipDtmfRequestDefaultTypeInternal;
extern PublishSipDtmfRequestDefaultTypeInternal _PublishSipDtmfRequest_default_instance_;
class PublishSipDtmfResponse;
struct PublishSipDtmfResponseDefaultTypeInternal;
extern PublishSipDtmfResponseDefaultTypeInternal _PublishSipDtmfResponse_default_instance_;
class PublishTrackCallback;
struct PublishTrackCallbackDefaultTypeInternal;
extern PublishTrackCallbackDefaultTypeInternal _PublishTrackCallback_default_instance_;
class PublishTrackRequest;
struct PublishTrackRequestDefaultTypeInternal;
extern PublishTrackRequestDefaultTypeInternal _PublishTrackRequest_default_instance_;
class PublishTrackResponse;
struct PublishTrackResponseDefaultTypeInternal;
extern PublishTrackResponseDefaultTypeInternal _PublishTrackResponse_default_instance_;
class PublishTranscriptionCallback;
struct PublishTranscriptionCallbackDefaultTypeInternal;
extern PublishTranscriptionCallbackDefaultTypeInternal _PublishTranscriptionCallback_default_instance_;
class PublishTranscriptionRequest;
struct PublishTranscriptionRequestDefaultTypeInternal;
extern PublishTranscriptionRequestDefaultTypeInternal _PublishTranscriptionRequest_default_instance_;
class PublishTranscriptionResponse;
struct PublishTranscriptionResponseDefaultTypeInternal;
extern PublishTranscriptionResponseDefaultTypeInternal _PublishTranscriptionResponse_default_instance_;
class Reconnected;
struct ReconnectedDefaultTypeInternal;
extern ReconnectedDefaultTypeInternal _Reconnected_default_instance_;
class Reconnecting;
struct ReconnectingDefaultTypeInternal;
extern ReconnectingDefaultTypeInternal _Reconnecting_default_instance_;
class RoomEOS;
struct RoomEOSDefaultTypeInternal;
extern RoomEOSDefaultTypeInternal _RoomEOS_default_instance_;
class RoomEvent;
struct RoomEventDefaultTypeInternal;
extern RoomEventDefaultTypeInternal _RoomEvent_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RoomMetadataChanged;
struct RoomMetadataChangedDefaultTypeInternal;
extern RoomMetadataChangedDefaultTypeInternal _RoomMetadataChanged_default_instance_;
class RoomOptions;
struct RoomOptionsDefaultTypeInternal;
extern RoomOptionsDefaultTypeInternal _RoomOptions_default_instance_;
class RoomSidChanged;
struct RoomSidChangedDefaultTypeInternal;
extern RoomSidChangedDefaultTypeInternal _RoomSidChanged_default_instance_;
class RtcConfig;
struct RtcConfigDefaultTypeInternal;
extern RtcConfigDefaultTypeInternal _RtcConfig_default_instance_;
class SendChatMessageCallback;
struct SendChatMessageCallbackDefaultTypeInternal;
extern SendChatMessageCallbackDefaultTypeInternal _SendChatMessageCallback_default_instance_;
class SendChatMessageRequest;
struct SendChatMessageRequestDefaultTypeInternal;
extern SendChatMessageRequestDefaultTypeInternal _SendChatMessageRequest_default_instance_;
class SendChatMessageResponse;
struct SendChatMessageResponseDefaultTypeInternal;
extern SendChatMessageResponseDefaultTypeInternal _SendChatMessageResponse_default_instance_;
class SendStreamChunkCallback;
struct SendStreamChunkCallbackDefaultTypeInternal;
extern SendStreamChunkCallbackDefaultTypeInternal _SendStreamChunkCallback_default_instance_;
class SendStreamChunkRequest;
struct SendStreamChunkRequestDefaultTypeInternal;
extern SendStreamChunkRequestDefaultTypeInternal _SendStreamChunkRequest_default_instance_;
class SendStreamChunkResponse;
struct SendStreamChunkResponseDefaultTypeInternal;
extern SendStreamChunkResponseDefaultTypeInternal _SendStreamChunkResponse_default_instance_;
class SendStreamHeaderCallback;
struct SendStreamHeaderCallbackDefaultTypeInternal;
extern SendStreamHeaderCallbackDefaultTypeInternal _SendStreamHeaderCallback_default_instance_;
class SendStreamHeaderRequest;
struct SendStreamHeaderRequestDefaultTypeInternal;
extern SendStreamHeaderRequestDefaultTypeInternal _SendStreamHeaderRequest_default_instance_;
class SendStreamHeaderResponse;
struct SendStreamHeaderResponseDefaultTypeInternal;
extern SendStreamHeaderResponseDefaultTypeInternal _SendStreamHeaderResponse_default_instance_;
class SendStreamTrailerCallback;
struct SendStreamTrailerCallbackDefaultTypeInternal;
extern SendStreamTrailerCallbackDefaultTypeInternal _SendStreamTrailerCallback_default_instance_;
class SendStreamTrailerRequest;
struct SendStreamTrailerRequestDefaultTypeInternal;
extern SendStreamTrailerRequestDefaultTypeInternal _SendStreamTrailerRequest_default_instance_;
class SendStreamTrailerResponse;
struct SendStreamTrailerResponseDefaultTypeInternal;
extern SendStreamTrailerResponseDefaultTypeInternal _SendStreamTrailerResponse_default_instance_;
class SetDataChannelBufferedAmountLowThresholdRequest;
struct SetDataChannelBufferedAmountLowThresholdRequestDefaultTypeInternal;
extern SetDataChannelBufferedAmountLowThresholdRequestDefaultTypeInternal _SetDataChannelBufferedAmountLowThresholdRequest_default_instance_;
class SetDataChannelBufferedAmountLowThresholdResponse;
struct SetDataChannelBufferedAmountLowThresholdResponseDefaultTypeInternal;
extern SetDataChannelBufferedAmountLowThresholdResponseDefaultTypeInternal _SetDataChannelBufferedAmountLowThresholdResponse_default_instance_;
class SetLocalAttributesCallback;
struct SetLocalAttributesCallbackDefaultTypeInternal;
extern SetLocalAttributesCallbackDefaultTypeInternal _SetLocalAttributesCallback_default_instance_;
class SetLocalAttributesRequest;
struct SetLocalAttributesRequestDefaultTypeInternal;
extern SetLocalAttributesRequestDefaultTypeInternal _SetLocalAttributesRequest_default_instance_;
class SetLocalAttributesResponse;
struct SetLocalAttributesResponseDefaultTypeInternal;
extern SetLocalAttributesResponseDefaultTypeInternal _SetLocalAttributesResponse_default_instance_;
class SetLocalMetadataCallback;
struct SetLocalMetadataCallbackDefaultTypeInternal;
extern SetLocalMetadataCallbackDefaultTypeInternal _SetLocalMetadataCallback_default_instance_;
class SetLocalMetadataRequest;
struct SetLocalMetadataRequestDefaultTypeInternal;
extern SetLocalMetadataRequestDefaultTypeInternal _SetLocalMetadataRequest_default_instance_;
class SetLocalMetadataResponse;
struct SetLocalMetadataResponseDefaultTypeInternal;
extern SetLocalMetadataResponseDefaultTypeInternal _SetLocalMetadataResponse_default_instance_;
class SetLocalNameCallback;
struct SetLocalNameCallbackDefaultTypeInternal;
extern SetLocalNameCallbackDefaultTypeInternal _SetLocalNameCallback_default_instance_;
class SetLocalNameRequest;
struct SetLocalNameRequestDefaultTypeInternal;
extern SetLocalNameRequestDefaultTypeInternal _SetLocalNameRequest_default_instance_;
class SetLocalNameResponse;
struct SetLocalNameResponseDefaultTypeInternal;
extern SetLocalNameResponseDefaultTypeInternal _SetLocalNameResponse_default_instance_;
class SetSubscribedRequest;
struct SetSubscribedRequestDefaultTypeInternal;
extern SetSubscribedRequestDefaultTypeInternal _SetSubscribedRequest_default_instance_;
class SetSubscribedResponse;
struct SetSubscribedResponseDefaultTypeInternal;
extern SetSubscribedResponseDefaultTypeInternal _SetSubscribedResponse_default_instance_;
class SipDTMF;
struct SipDTMFDefaultTypeInternal;
extern SipDTMFDefaultTypeInternal _SipDTMF_default_instance_;
class TrackMuted;
struct TrackMutedDefaultTypeInternal;
extern TrackMutedDefaultTypeInternal _TrackMuted_default_instance_;
class TrackPublishOptions;
struct TrackPublishOptionsDefaultTypeInternal;
extern TrackPublishOptionsDefaultTypeInternal _TrackPublishOptions_default_instance_;
class TrackPublished;
struct TrackPublishedDefaultTypeInternal;
extern TrackPublishedDefaultTypeInternal _TrackPublished_default_instance_;
class TrackSubscribed;
struct TrackSubscribedDefaultTypeInternal;
extern TrackSubscribedDefaultTypeInternal _TrackSubscribed_default_instance_;
class TrackSubscriptionFailed;
struct TrackSubscriptionFailedDefaultTypeInternal;
extern TrackSubscriptionFailedDefaultTypeInternal _TrackSubscriptionFailed_default_instance_;
class TrackUnmuted;
struct TrackUnmutedDefaultTypeInternal;
extern TrackUnmutedDefaultTypeInternal _TrackUnmuted_default_instance_;
class TrackUnpublished;
struct TrackUnpublishedDefaultTypeInternal;
extern TrackUnpublishedDefaultTypeInternal _TrackUnpublished_default_instance_;
class TrackUnsubscribed;
struct TrackUnsubscribedDefaultTypeInternal;
extern TrackUnsubscribedDefaultTypeInternal _TrackUnsubscribed_default_instance_;
class TranscriptionReceived;
struct TranscriptionReceivedDefaultTypeInternal;
extern TranscriptionReceivedDefaultTypeInternal _TranscriptionReceived_default_instance_;
class TranscriptionSegment;
struct TranscriptionSegmentDefaultTypeInternal;
extern TranscriptionSegmentDefaultTypeInternal _TranscriptionSegment_default_instance_;
class UnpublishTrackCallback;
struct UnpublishTrackCallbackDefaultTypeInternal;
extern UnpublishTrackCallbackDefaultTypeInternal _UnpublishTrackCallback_default_instance_;
class UnpublishTrackRequest;
struct UnpublishTrackRequestDefaultTypeInternal;
extern UnpublishTrackRequestDefaultTypeInternal _UnpublishTrackRequest_default_instance_;
class UnpublishTrackResponse;
struct UnpublishTrackResponseDefaultTypeInternal;
extern UnpublishTrackResponseDefaultTypeInternal _UnpublishTrackResponse_default_instance_;
class UserPacket;
struct UserPacketDefaultTypeInternal;
extern UserPacketDefaultTypeInternal _UserPacket_default_instance_;
class VideoEncoding;
struct VideoEncodingDefaultTypeInternal;
extern VideoEncodingDefaultTypeInternal _VideoEncoding_default_instance_;
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::proto::ActiveSpeakersChanged* Arena::CreateMaybeMessage<::livekit::proto::ActiveSpeakersChanged>(Arena*);
template<> ::livekit::proto::AttributesEntry* Arena::CreateMaybeMessage<::livekit::proto::AttributesEntry>(Arena*);
template<> ::livekit::proto::AudioEncoding* Arena::CreateMaybeMessage<::livekit::proto::AudioEncoding>(Arena*);
template<> ::livekit::proto::BufferInfo* Arena::CreateMaybeMessage<::livekit::proto::BufferInfo>(Arena*);
template<> ::livekit::proto::ChatMessage* Arena::CreateMaybeMessage<::livekit::proto::ChatMessage>(Arena*);
template<> ::livekit::proto::ChatMessageReceived* Arena::CreateMaybeMessage<::livekit::proto::ChatMessageReceived>(Arena*);
template<> ::livekit::proto::ConnectCallback* Arena::CreateMaybeMessage<::livekit::proto::ConnectCallback>(Arena*);
template<> ::livekit::proto::ConnectCallback_ParticipantWithTracks* Arena::CreateMaybeMessage<::livekit::proto::ConnectCallback_ParticipantWithTracks>(Arena*);
template<> ::livekit::proto::ConnectCallback_Result* Arena::CreateMaybeMessage<::livekit::proto::ConnectCallback_Result>(Arena*);
template<> ::livekit::proto::ConnectRequest* Arena::CreateMaybeMessage<::livekit::proto::ConnectRequest>(Arena*);
template<> ::livekit::proto::ConnectResponse* Arena::CreateMaybeMessage<::livekit::proto::ConnectResponse>(Arena*);
template<> ::livekit::proto::Connected* Arena::CreateMaybeMessage<::livekit::proto::Connected>(Arena*);
template<> ::livekit::proto::ConnectionQualityChanged* Arena::CreateMaybeMessage<::livekit::proto::ConnectionQualityChanged>(Arena*);
template<> ::livekit::proto::ConnectionStateChanged* Arena::CreateMaybeMessage<::livekit::proto::ConnectionStateChanged>(Arena*);
template<> ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* Arena::CreateMaybeMessage<::livekit::proto::DataChannelBufferedAmountLowThresholdChanged>(Arena*);
template<> ::livekit::proto::DataPacketReceived* Arena::CreateMaybeMessage<::livekit::proto::DataPacketReceived>(Arena*);
template<> ::livekit::proto::DataStream* Arena::CreateMaybeMessage<::livekit::proto::DataStream>(Arena*);
template<> ::livekit::proto::DataStreamChunkReceived* Arena::CreateMaybeMessage<::livekit::proto::DataStreamChunkReceived>(Arena*);
template<> ::livekit::proto::DataStreamHeaderReceived* Arena::CreateMaybeMessage<::livekit::proto::DataStreamHeaderReceived>(Arena*);
template<> ::livekit::proto::DataStreamTrailerReceived* Arena::CreateMaybeMessage<::livekit::proto::DataStreamTrailerReceived>(Arena*);
template<> ::livekit::proto::DataStream_ByteHeader* Arena::CreateMaybeMessage<::livekit::proto::DataStream_ByteHeader>(Arena*);
template<> ::livekit::proto::DataStream_Chunk* Arena::CreateMaybeMessage<::livekit::proto::DataStream_Chunk>(Arena*);
template<> ::livekit::proto::DataStream_Header* Arena::CreateMaybeMessage<::livekit::proto::DataStream_Header>(Arena*);
template<> ::livekit::proto::DataStream_Header_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::proto::DataStream_Header_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::proto::DataStream_TextHeader* Arena::CreateMaybeMessage<::livekit::proto::DataStream_TextHeader>(Arena*);
template<> ::livekit::proto::DataStream_Trailer* Arena::CreateMaybeMessage<::livekit::proto::DataStream_Trailer>(Arena*);
template<> ::livekit::proto::DataStream_Trailer_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::proto::DataStream_Trailer_AttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::proto::DisconnectCallback* Arena::CreateMaybeMessage<::livekit::proto::DisconnectCallback>(Arena*);
template<> ::livekit::proto::DisconnectRequest* Arena::CreateMaybeMessage<::livekit::proto::DisconnectRequest>(Arena*);
template<> ::livekit::proto::DisconnectResponse* Arena::CreateMaybeMessage<::livekit::proto::DisconnectResponse>(Arena*);
template<> ::livekit::proto::Disconnected* Arena::CreateMaybeMessage<::livekit::proto::Disconnected>(Arena*);
template<> ::livekit::proto::E2eeStateChanged* Arena::CreateMaybeMessage<::livekit::proto::E2eeStateChanged>(Arena*);
template<> ::livekit::proto::EditChatMessageRequest* Arena::CreateMaybeMessage<::livekit::proto::EditChatMessageRequest>(Arena*);
template<> ::livekit::proto::GetSessionStatsCallback* Arena::CreateMaybeMessage<::livekit::proto::GetSessionStatsCallback>(Arena*);
template<> ::livekit::proto::GetSessionStatsCallback_Result* Arena::CreateMaybeMessage<::livekit::proto::GetSessionStatsCallback_Result>(Arena*);
template<> ::livekit::proto::GetSessionStatsRequest* Arena::CreateMaybeMessage<::livekit::proto::GetSessionStatsRequest>(Arena*);
template<> ::livekit::proto::GetSessionStatsResponse* Arena::CreateMaybeMessage<::livekit::proto::GetSessionStatsResponse>(Arena*);
template<> ::livekit::proto::IceServer* Arena::CreateMaybeMessage<::livekit::proto::IceServer>(Arena*);
template<> ::livekit::proto::LocalTrackPublished* Arena::CreateMaybeMessage<::livekit::proto::LocalTrackPublished>(Arena*);
template<> ::livekit::proto::LocalTrackSubscribed* Arena::CreateMaybeMessage<::livekit::proto::LocalTrackSubscribed>(Arena*);
template<> ::livekit::proto::LocalTrackUnpublished* Arena::CreateMaybeMessage<::livekit::proto::LocalTrackUnpublished>(Arena*);
template<> ::livekit::proto::OwnedBuffer* Arena::CreateMaybeMessage<::livekit::proto::OwnedBuffer>(Arena*);
template<> ::livekit::proto::OwnedRoom* Arena::CreateMaybeMessage<::livekit::proto::OwnedRoom>(Arena*);
template<> ::livekit::proto::ParticipantAttributesChanged* Arena::CreateMaybeMessage<::livekit::proto::ParticipantAttributesChanged>(Arena*);
template<> ::livekit::proto::ParticipantConnected* Arena::CreateMaybeMessage<::livekit::proto::ParticipantConnected>(Arena*);
template<> ::livekit::proto::ParticipantDisconnected* Arena::CreateMaybeMessage<::livekit::proto::ParticipantDisconnected>(Arena*);
template<> ::livekit::proto::ParticipantMetadataChanged* Arena::CreateMaybeMessage<::livekit::proto::ParticipantMetadataChanged>(Arena*);
template<> ::livekit::proto::ParticipantNameChanged* Arena::CreateMaybeMessage<::livekit::proto::ParticipantNameChanged>(Arena*);
template<> ::livekit::proto::PublishDataCallback* Arena::CreateMaybeMessage<::livekit::proto::PublishDataCallback>(Arena*);
template<> ::livekit::proto::PublishDataRequest* Arena::CreateMaybeMessage<::livekit::proto::PublishDataRequest>(Arena*);
template<> ::livekit::proto::PublishDataResponse* Arena::CreateMaybeMessage<::livekit::proto::PublishDataResponse>(Arena*);
template<> ::livekit::proto::PublishSipDtmfCallback* Arena::CreateMaybeMessage<::livekit::proto::PublishSipDtmfCallback>(Arena*);
template<> ::livekit::proto::PublishSipDtmfRequest* Arena::CreateMaybeMessage<::livekit::proto::PublishSipDtmfRequest>(Arena*);
template<> ::livekit::proto::PublishSipDtmfResponse* Arena::CreateMaybeMessage<::livekit::proto::PublishSipDtmfResponse>(Arena*);
template<> ::livekit::proto::PublishTrackCallback* Arena::CreateMaybeMessage<::livekit::proto::PublishTrackCallback>(Arena*);
template<> ::livekit::proto::PublishTrackRequest* Arena::CreateMaybeMessage<::livekit::proto::PublishTrackRequest>(Arena*);
template<> ::livekit::proto::PublishTrackResponse* Arena::CreateMaybeMessage<::livekit::proto::PublishTrackResponse>(Arena*);
template<> ::livekit::proto::PublishTranscriptionCallback* Arena::CreateMaybeMessage<::livekit::proto::PublishTranscriptionCallback>(Arena*);
template<> ::livekit::proto::PublishTranscriptionRequest* Arena::CreateMaybeMessage<::livekit::proto::PublishTranscriptionRequest>(Arena*);
template<> ::livekit::proto::PublishTranscriptionResponse* Arena::CreateMaybeMessage<::livekit::proto::PublishTranscriptionResponse>(Arena*);
template<> ::livekit::proto::Reconnected* Arena::CreateMaybeMessage<::livekit::proto::Reconnected>(Arena*);
template<> ::livekit::proto::Reconnecting* Arena::CreateMaybeMessage<::livekit::proto::Reconnecting>(Arena*);
template<> ::livekit::proto::RoomEOS* Arena::CreateMaybeMessage<::livekit::proto::RoomEOS>(Arena*);
template<> ::livekit::proto::RoomEvent* Arena::CreateMaybeMessage<::livekit::proto::RoomEvent>(Arena*);
template<> ::livekit::proto::RoomInfo* Arena::CreateMaybeMessage<::livekit::proto::RoomInfo>(Arena*);
template<> ::livekit::proto::RoomMetadataChanged* Arena::CreateMaybeMessage<::livekit::proto::RoomMetadataChanged>(Arena*);
template<> ::livekit::proto::RoomOptions* Arena::CreateMaybeMessage<::livekit::proto::RoomOptions>(Arena*);
template<> ::livekit::proto::RoomSidChanged* Arena::CreateMaybeMessage<::livekit::proto::RoomSidChanged>(Arena*);
template<> ::livekit::proto::RtcConfig* Arena::CreateMaybeMessage<::livekit::proto::RtcConfig>(Arena*);
template<> ::livekit::proto::SendChatMessageCallback* Arena::CreateMaybeMessage<::livekit::proto::SendChatMessageCallback>(Arena*);
template<> ::livekit::proto::SendChatMessageRequest* Arena::CreateMaybeMessage<::livekit::proto::SendChatMessageRequest>(Arena*);
template<> ::livekit::proto::SendChatMessageResponse* Arena::CreateMaybeMessage<::livekit::proto::SendChatMessageResponse>(Arena*);
template<> ::livekit::proto::SendStreamChunkCallback* Arena::CreateMaybeMessage<::livekit::proto::SendStreamChunkCallback>(Arena*);
template<> ::livekit::proto::SendStreamChunkRequest* Arena::CreateMaybeMessage<::livekit::proto::SendStreamChunkRequest>(Arena*);
template<> ::livekit::proto::SendStreamChunkResponse* Arena::CreateMaybeMessage<::livekit::proto::SendStreamChunkResponse>(Arena*);
template<> ::livekit::proto::SendStreamHeaderCallback* Arena::CreateMaybeMessage<::livekit::proto::SendStreamHeaderCallback>(Arena*);
template<> ::livekit::proto::SendStreamHeaderRequest* Arena::CreateMaybeMessage<::livekit::proto::SendStreamHeaderRequest>(Arena*);
template<> ::livekit::proto::SendStreamHeaderResponse* Arena::CreateMaybeMessage<::livekit::proto::SendStreamHeaderResponse>(Arena*);
template<> ::livekit::proto::SendStreamTrailerCallback* Arena::CreateMaybeMessage<::livekit::proto::SendStreamTrailerCallback>(Arena*);
template<> ::livekit::proto::SendStreamTrailerRequest* Arena::CreateMaybeMessage<::livekit::proto::SendStreamTrailerRequest>(Arena*);
template<> ::livekit::proto::SendStreamTrailerResponse* Arena::CreateMaybeMessage<::livekit::proto::SendStreamTrailerResponse>(Arena*);
template<> ::livekit::proto::SetDataChannelBufferedAmountLowThresholdRequest* Arena::CreateMaybeMessage<::livekit::proto::SetDataChannelBufferedAmountLowThresholdRequest>(Arena*);
template<> ::livekit::proto::SetDataChannelBufferedAmountLowThresholdResponse* Arena::CreateMaybeMessage<::livekit::proto::SetDataChannelBufferedAmountLowThresholdResponse>(Arena*);
template<> ::livekit::proto::SetLocalAttributesCallback* Arena::CreateMaybeMessage<::livekit::proto::SetLocalAttributesCallback>(Arena*);
template<> ::livekit::proto::SetLocalAttributesRequest* Arena::CreateMaybeMessage<::livekit::proto::SetLocalAttributesRequest>(Arena*);
template<> ::livekit::proto::SetLocalAttributesResponse* Arena::CreateMaybeMessage<::livekit::proto::SetLocalAttributesResponse>(Arena*);
template<> ::livekit::proto::SetLocalMetadataCallback* Arena::CreateMaybeMessage<::livekit::proto::SetLocalMetadataCallback>(Arena*);
template<> ::livekit::proto::SetLocalMetadataRequest* Arena::CreateMaybeMessage<::livekit::proto::SetLocalMetadataRequest>(Arena*);
template<> ::livekit::proto::SetLocalMetadataResponse* Arena::CreateMaybeMessage<::livekit::proto::SetLocalMetadataResponse>(Arena*);
template<> ::livekit::proto::SetLocalNameCallback* Arena::CreateMaybeMessage<::livekit::proto::SetLocalNameCallback>(Arena*);
template<> ::livekit::proto::SetLocalNameRequest* Arena::CreateMaybeMessage<::livekit::proto::SetLocalNameRequest>(Arena*);
template<> ::livekit::proto::SetLocalNameResponse* Arena::CreateMaybeMessage<::livekit::proto::SetLocalNameResponse>(Arena*);
template<> ::livekit::proto::SetSubscribedRequest* Arena::CreateMaybeMessage<::livekit::proto::SetSubscribedRequest>(Arena*);
template<> ::livekit::proto::SetSubscribedResponse* Arena::CreateMaybeMessage<::livekit::proto::SetSubscribedResponse>(Arena*);
template<> ::livekit::proto::SipDTMF* Arena::CreateMaybeMessage<::livekit::proto::SipDTMF>(Arena*);
template<> ::livekit::proto::TrackMuted* Arena::CreateMaybeMessage<::livekit::proto::TrackMuted>(Arena*);
template<> ::livekit::proto::TrackPublishOptions* Arena::CreateMaybeMessage<::livekit::proto::TrackPublishOptions>(Arena*);
template<> ::livekit::proto::TrackPublished* Arena::CreateMaybeMessage<::livekit::proto::TrackPublished>(Arena*);
template<> ::livekit::proto::TrackSubscribed* Arena::CreateMaybeMessage<::livekit::proto::TrackSubscribed>(Arena*);
template<> ::livekit::proto::TrackSubscriptionFailed* Arena::CreateMaybeMessage<::livekit::proto::TrackSubscriptionFailed>(Arena*);
template<> ::livekit::proto::TrackUnmuted* Arena::CreateMaybeMessage<::livekit::proto::TrackUnmuted>(Arena*);
template<> ::livekit::proto::TrackUnpublished* Arena::CreateMaybeMessage<::livekit::proto::TrackUnpublished>(Arena*);
template<> ::livekit::proto::TrackUnsubscribed* Arena::CreateMaybeMessage<::livekit::proto::TrackUnsubscribed>(Arena*);
template<> ::livekit::proto::TranscriptionReceived* Arena::CreateMaybeMessage<::livekit::proto::TranscriptionReceived>(Arena*);
template<> ::livekit::proto::TranscriptionSegment* Arena::CreateMaybeMessage<::livekit::proto::TranscriptionSegment>(Arena*);
template<> ::livekit::proto::UnpublishTrackCallback* Arena::CreateMaybeMessage<::livekit::proto::UnpublishTrackCallback>(Arena*);
template<> ::livekit::proto::UnpublishTrackRequest* Arena::CreateMaybeMessage<::livekit::proto::UnpublishTrackRequest>(Arena*);
template<> ::livekit::proto::UnpublishTrackResponse* Arena::CreateMaybeMessage<::livekit::proto::UnpublishTrackResponse>(Arena*);
template<> ::livekit::proto::UserPacket* Arena::CreateMaybeMessage<::livekit::proto::UserPacket>(Arena*);
template<> ::livekit::proto::VideoEncoding* Arena::CreateMaybeMessage<::livekit::proto::VideoEncoding>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {
namespace proto {

enum DataStream_OperationType : int {
  DataStream_OperationType_CREATE = 0,
  DataStream_OperationType_UPDATE = 1,
  DataStream_OperationType_DELETE = 2,
  DataStream_OperationType_REACTION = 3
};
bool DataStream_OperationType_IsValid(int value);
constexpr DataStream_OperationType DataStream_OperationType_OperationType_MIN = DataStream_OperationType_CREATE;
constexpr DataStream_OperationType DataStream_OperationType_OperationType_MAX = DataStream_OperationType_REACTION;
constexpr int DataStream_OperationType_OperationType_ARRAYSIZE = DataStream_OperationType_OperationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataStream_OperationType_descriptor();
template<typename T>
inline const std::string& DataStream_OperationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataStream_OperationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataStream_OperationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataStream_OperationType_descriptor(), enum_t_value);
}
inline bool DataStream_OperationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataStream_OperationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataStream_OperationType>(
    DataStream_OperationType_descriptor(), name, value);
}
enum IceTransportType : int {
  TRANSPORT_RELAY = 0,
  TRANSPORT_NOHOST = 1,
  TRANSPORT_ALL = 2
};
bool IceTransportType_IsValid(int value);
constexpr IceTransportType IceTransportType_MIN = TRANSPORT_RELAY;
constexpr IceTransportType IceTransportType_MAX = TRANSPORT_ALL;
constexpr int IceTransportType_ARRAYSIZE = IceTransportType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IceTransportType_descriptor();
template<typename T>
inline const std::string& IceTransportType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IceTransportType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IceTransportType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IceTransportType_descriptor(), enum_t_value);
}
inline bool IceTransportType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IceTransportType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IceTransportType>(
    IceTransportType_descriptor(), name, value);
}
enum ContinualGatheringPolicy : int {
  GATHER_ONCE = 0,
  GATHER_CONTINUALLY = 1
};
bool ContinualGatheringPolicy_IsValid(int value);
constexpr ContinualGatheringPolicy ContinualGatheringPolicy_MIN = GATHER_ONCE;
constexpr ContinualGatheringPolicy ContinualGatheringPolicy_MAX = GATHER_CONTINUALLY;
constexpr int ContinualGatheringPolicy_ARRAYSIZE = ContinualGatheringPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContinualGatheringPolicy_descriptor();
template<typename T>
inline const std::string& ContinualGatheringPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContinualGatheringPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContinualGatheringPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContinualGatheringPolicy_descriptor(), enum_t_value);
}
inline bool ContinualGatheringPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContinualGatheringPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContinualGatheringPolicy>(
    ContinualGatheringPolicy_descriptor(), name, value);
}
enum ConnectionQuality : int {
  QUALITY_POOR = 0,
  QUALITY_GOOD = 1,
  QUALITY_EXCELLENT = 2,
  QUALITY_LOST = 3
};
bool ConnectionQuality_IsValid(int value);
constexpr ConnectionQuality ConnectionQuality_MIN = QUALITY_POOR;
constexpr ConnectionQuality ConnectionQuality_MAX = QUALITY_LOST;
constexpr int ConnectionQuality_ARRAYSIZE = ConnectionQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionQuality_descriptor();
template<typename T>
inline const std::string& ConnectionQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionQuality_descriptor(), enum_t_value);
}
inline bool ConnectionQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionQuality>(
    ConnectionQuality_descriptor(), name, value);
}
enum ConnectionState : int {
  CONN_DISCONNECTED = 0,
  CONN_CONNECTED = 1,
  CONN_RECONNECTING = 2
};
bool ConnectionState_IsValid(int value);
constexpr ConnectionState ConnectionState_MIN = CONN_DISCONNECTED;
constexpr ConnectionState ConnectionState_MAX = CONN_RECONNECTING;
constexpr int ConnectionState_ARRAYSIZE = ConnectionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionState_descriptor();
template<typename T>
inline const std::string& ConnectionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionState_descriptor(), enum_t_value);
}
inline bool ConnectionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionState>(
    ConnectionState_descriptor(), name, value);
}
enum DataPacketKind : int {
  KIND_LOSSY = 0,
  KIND_RELIABLE = 1
};
bool DataPacketKind_IsValid(int value);
constexpr DataPacketKind DataPacketKind_MIN = KIND_LOSSY;
constexpr DataPacketKind DataPacketKind_MAX = KIND_RELIABLE;
constexpr int DataPacketKind_ARRAYSIZE = DataPacketKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataPacketKind_descriptor();
template<typename T>
inline const std::string& DataPacketKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataPacketKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataPacketKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataPacketKind_descriptor(), enum_t_value);
}
inline bool DataPacketKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataPacketKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataPacketKind>(
    DataPacketKind_descriptor(), name, value);
}
// ===================================================================

class ConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectRequest) */ {
 public:
  inline ConnectRequest() : ConnectRequest(nullptr) {}
  ~ConnectRequest() override;
  explicit PROTOBUF_CONSTEXPR ConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectRequest(const ConnectRequest& from);
  ConnectRequest(ConnectRequest&& from) noexcept
    : ConnectRequest() {
    *this = ::std::move(from);
  }

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectRequest& operator=(ConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectRequest*>(
               &_ConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConnectRequest& a, ConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectRequest& from) {
    ConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectRequest";
  }
  protected:
  explicit ConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTokenFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // required string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required string token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // required .livekit.proto.RoomOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::livekit::proto::RoomOptions& options() const;
  PROTOBUF_NODISCARD ::livekit::proto::RoomOptions* release_options();
  ::livekit::proto::RoomOptions* mutable_options();
  void set_allocated_options(::livekit::proto::RoomOptions* options);
  private:
  const ::livekit::proto::RoomOptions& _internal_options() const;
  ::livekit::proto::RoomOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::livekit::proto::RoomOptions* options);
  ::livekit::proto::RoomOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::livekit::proto::RoomOptions* options_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectResponse) */ {
 public:
  inline ConnectResponse() : ConnectResponse(nullptr) {}
  ~ConnectResponse() override;
  explicit PROTOBUF_CONSTEXPR ConnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectResponse(const ConnectResponse& from);
  ConnectResponse(ConnectResponse&& from) noexcept
    : ConnectResponse() {
    *this = ::std::move(from);
  }

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectResponse& operator=(ConnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectResponse*>(
               &_ConnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConnectResponse& a, ConnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectResponse& from) {
    ConnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectResponse";
  }
  protected:
  explicit ConnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectCallback_ParticipantWithTracks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectCallback.ParticipantWithTracks) */ {
 public:
  inline ConnectCallback_ParticipantWithTracks() : ConnectCallback_ParticipantWithTracks(nullptr) {}
  ~ConnectCallback_ParticipantWithTracks() override;
  explicit PROTOBUF_CONSTEXPR ConnectCallback_ParticipantWithTracks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectCallback_ParticipantWithTracks(const ConnectCallback_ParticipantWithTracks& from);
  ConnectCallback_ParticipantWithTracks(ConnectCallback_ParticipantWithTracks&& from) noexcept
    : ConnectCallback_ParticipantWithTracks() {
    *this = ::std::move(from);
  }

  inline ConnectCallback_ParticipantWithTracks& operator=(const ConnectCallback_ParticipantWithTracks& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectCallback_ParticipantWithTracks& operator=(ConnectCallback_ParticipantWithTracks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectCallback_ParticipantWithTracks& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectCallback_ParticipantWithTracks* internal_default_instance() {
    return reinterpret_cast<const ConnectCallback_ParticipantWithTracks*>(
               &_ConnectCallback_ParticipantWithTracks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConnectCallback_ParticipantWithTracks& a, ConnectCallback_ParticipantWithTracks& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectCallback_ParticipantWithTracks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectCallback_ParticipantWithTracks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectCallback_ParticipantWithTracks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectCallback_ParticipantWithTracks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectCallback_ParticipantWithTracks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectCallback_ParticipantWithTracks& from) {
    ConnectCallback_ParticipantWithTracks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectCallback_ParticipantWithTracks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectCallback.ParticipantWithTracks";
  }
  protected:
  explicit ConnectCallback_ParticipantWithTracks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicationsFieldNumber = 2,
    kParticipantFieldNumber = 1,
  };
  // repeated .livekit.proto.OwnedTrackPublication publications = 2;
  int publications_size() const;
  private:
  int _internal_publications_size() const;
  public:
  void clear_publications();
  ::livekit::proto::OwnedTrackPublication* mutable_publications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::OwnedTrackPublication >*
      mutable_publications();
  private:
  const ::livekit::proto::OwnedTrackPublication& _internal_publications(int index) const;
  ::livekit::proto::OwnedTrackPublication* _internal_add_publications();
  public:
  const ::livekit::proto::OwnedTrackPublication& publications(int index) const;
  ::livekit::proto::OwnedTrackPublication* add_publications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::OwnedTrackPublication >&
      publications() const;

  // required .livekit.proto.OwnedParticipant participant = 1;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::proto::OwnedParticipant& participant() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedParticipant* release_participant();
  ::livekit::proto::OwnedParticipant* mutable_participant();
  void set_allocated_participant(::livekit::proto::OwnedParticipant* participant);
  private:
  const ::livekit::proto::OwnedParticipant& _internal_participant() const;
  ::livekit::proto::OwnedParticipant* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::proto::OwnedParticipant* participant);
  ::livekit::proto::OwnedParticipant* unsafe_arena_release_participant();

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectCallback.ParticipantWithTracks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::OwnedTrackPublication > publications_;
    ::livekit::proto::OwnedParticipant* participant_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectCallback_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectCallback.Result) */ {
 public:
  inline ConnectCallback_Result() : ConnectCallback_Result(nullptr) {}
  ~ConnectCallback_Result() override;
  explicit PROTOBUF_CONSTEXPR ConnectCallback_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectCallback_Result(const ConnectCallback_Result& from);
  ConnectCallback_Result(ConnectCallback_Result&& from) noexcept
    : ConnectCallback_Result() {
    *this = ::std::move(from);
  }

  inline ConnectCallback_Result& operator=(const ConnectCallback_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectCallback_Result& operator=(ConnectCallback_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectCallback_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectCallback_Result* internal_default_instance() {
    return reinterpret_cast<const ConnectCallback_Result*>(
               &_ConnectCallback_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConnectCallback_Result& a, ConnectCallback_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectCallback_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectCallback_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectCallback_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectCallback_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectCallback_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectCallback_Result& from) {
    ConnectCallback_Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectCallback_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectCallback.Result";
  }
  protected:
  explicit ConnectCallback_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantsFieldNumber = 3,
    kRoomFieldNumber = 1,
    kLocalParticipantFieldNumber = 2,
  };
  // repeated .livekit.proto.ConnectCallback.ParticipantWithTracks participants = 3;
  int participants_size() const;
  private:
  int _internal_participants_size() const;
  public:
  void clear_participants();
  ::livekit::proto::ConnectCallback_ParticipantWithTracks* mutable_participants(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ConnectCallback_ParticipantWithTracks >*
      mutable_participants();
  private:
  const ::livekit::proto::ConnectCallback_ParticipantWithTracks& _internal_participants(int index) const;
  ::livekit::proto::ConnectCallback_ParticipantWithTracks* _internal_add_participants();
  public:
  const ::livekit::proto::ConnectCallback_ParticipantWithTracks& participants(int index) const;
  ::livekit::proto::ConnectCallback_ParticipantWithTracks* add_participants();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ConnectCallback_ParticipantWithTracks >&
      participants() const;

  // required .livekit.proto.OwnedRoom room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::proto::OwnedRoom& room() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedRoom* release_room();
  ::livekit::proto::OwnedRoom* mutable_room();
  void set_allocated_room(::livekit::proto::OwnedRoom* room);
  private:
  const ::livekit::proto::OwnedRoom& _internal_room() const;
  ::livekit::proto::OwnedRoom* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::proto::OwnedRoom* room);
  ::livekit::proto::OwnedRoom* unsafe_arena_release_room();

  // required .livekit.proto.OwnedParticipant local_participant = 2;
  bool has_local_participant() const;
  private:
  bool _internal_has_local_participant() const;
  public:
  void clear_local_participant();
  const ::livekit::proto::OwnedParticipant& local_participant() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedParticipant* release_local_participant();
  ::livekit::proto::OwnedParticipant* mutable_local_participant();
  void set_allocated_local_participant(::livekit::proto::OwnedParticipant* local_participant);
  private:
  const ::livekit::proto::OwnedParticipant& _internal_local_participant() const;
  ::livekit::proto::OwnedParticipant* _internal_mutable_local_participant();
  public:
  void unsafe_arena_set_allocated_local_participant(
      ::livekit::proto::OwnedParticipant* local_participant);
  ::livekit::proto::OwnedParticipant* unsafe_arena_release_local_participant();

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectCallback.Result)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ConnectCallback_ParticipantWithTracks > participants_;
    ::livekit::proto::OwnedRoom* room_;
    ::livekit::proto::OwnedParticipant* local_participant_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectCallback) */ {
 public:
  inline ConnectCallback() : ConnectCallback(nullptr) {}
  ~ConnectCallback() override;
  explicit PROTOBUF_CONSTEXPR ConnectCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectCallback(const ConnectCallback& from);
  ConnectCallback(ConnectCallback&& from) noexcept
    : ConnectCallback() {
    *this = ::std::move(from);
  }

  inline ConnectCallback& operator=(const ConnectCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectCallback& operator=(ConnectCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectCallback& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 2,
    kResult = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const ConnectCallback* internal_default_instance() {
    return reinterpret_cast<const ConnectCallback*>(
               &_ConnectCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectCallback& a, ConnectCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectCallback& from) {
    ConnectCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectCallback";
  }
  protected:
  explicit ConnectCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectCallback_ParticipantWithTracks ParticipantWithTracks;
  typedef ConnectCallback_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
    kErrorFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.proto.ConnectCallback.Result result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::livekit::proto::ConnectCallback_Result& result() const;
  PROTOBUF_NODISCARD ::livekit::proto::ConnectCallback_Result* release_result();
  ::livekit::proto::ConnectCallback_Result* mutable_result();
  void set_allocated_result(::livekit::proto::ConnectCallback_Result* result);
  private:
  const ::livekit::proto::ConnectCallback_Result& _internal_result() const;
  ::livekit::proto::ConnectCallback_Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::livekit::proto::ConnectCallback_Result* result);
  ::livekit::proto::ConnectCallback_Result* unsafe_arena_release_result();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectCallback)
 private:
  class _Internal;
  void set_has_error();
  void set_has_result();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::livekit::proto::ConnectCallback_Result* result_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DisconnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DisconnectRequest) */ {
 public:
  inline DisconnectRequest() : DisconnectRequest(nullptr) {}
  ~DisconnectRequest() override;
  explicit PROTOBUF_CONSTEXPR DisconnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectRequest(const DisconnectRequest& from);
  DisconnectRequest(DisconnectRequest&& from) noexcept
    : DisconnectRequest() {
    *this = ::std::move(from);
  }

  inline DisconnectRequest& operator=(const DisconnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectRequest& operator=(DisconnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectRequest* internal_default_instance() {
    return reinterpret_cast<const DisconnectRequest*>(
               &_DisconnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DisconnectRequest& a, DisconnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisconnectRequest& from) {
    DisconnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DisconnectRequest";
  }
  protected:
  explicit DisconnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomHandleFieldNumber = 1,
  };
  // required uint64 room_handle = 1;
  bool has_room_handle() const;
  private:
  bool _internal_has_room_handle() const;
  public:
  void clear_room_handle();
  uint64_t room_handle() const;
  void set_room_handle(uint64_t value);
  private:
  uint64_t _internal_room_handle() const;
  void _internal_set_room_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DisconnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t room_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DisconnectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DisconnectResponse) */ {
 public:
  inline DisconnectResponse() : DisconnectResponse(nullptr) {}
  ~DisconnectResponse() override;
  explicit PROTOBUF_CONSTEXPR DisconnectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectResponse(const DisconnectResponse& from);
  DisconnectResponse(DisconnectResponse&& from) noexcept
    : DisconnectResponse() {
    *this = ::std::move(from);
  }

  inline DisconnectResponse& operator=(const DisconnectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectResponse& operator=(DisconnectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectResponse* internal_default_instance() {
    return reinterpret_cast<const DisconnectResponse*>(
               &_DisconnectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DisconnectResponse& a, DisconnectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisconnectResponse& from) {
    DisconnectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DisconnectResponse";
  }
  protected:
  explicit DisconnectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DisconnectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DisconnectCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DisconnectCallback) */ {
 public:
  inline DisconnectCallback() : DisconnectCallback(nullptr) {}
  ~DisconnectCallback() override;
  explicit PROTOBUF_CONSTEXPR DisconnectCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisconnectCallback(const DisconnectCallback& from);
  DisconnectCallback(DisconnectCallback&& from) noexcept
    : DisconnectCallback() {
    *this = ::std::move(from);
  }

  inline DisconnectCallback& operator=(const DisconnectCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisconnectCallback& operator=(DisconnectCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisconnectCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisconnectCallback* internal_default_instance() {
    return reinterpret_cast<const DisconnectCallback*>(
               &_DisconnectCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DisconnectCallback& a, DisconnectCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(DisconnectCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisconnectCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisconnectCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisconnectCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisconnectCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisconnectCallback& from) {
    DisconnectCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisconnectCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DisconnectCallback";
  }
  protected:
  explicit DisconnectCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DisconnectCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTrackRequest) */ {
 public:
  inline PublishTrackRequest() : PublishTrackRequest(nullptr) {}
  ~PublishTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTrackRequest(const PublishTrackRequest& from);
  PublishTrackRequest(PublishTrackRequest&& from) noexcept
    : PublishTrackRequest() {
    *this = ::std::move(from);
  }

  inline PublishTrackRequest& operator=(const PublishTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTrackRequest& operator=(PublishTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishTrackRequest* internal_default_instance() {
    return reinterpret_cast<const PublishTrackRequest*>(
               &_PublishTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PublishTrackRequest& a, PublishTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTrackRequest& from) {
    PublishTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTrackRequest";
  }
  protected:
  explicit PublishTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 3,
    kLocalParticipantHandleFieldNumber = 1,
    kTrackHandleFieldNumber = 2,
  };
  // required .livekit.proto.TrackPublishOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::livekit::proto::TrackPublishOptions& options() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackPublishOptions* release_options();
  ::livekit::proto::TrackPublishOptions* mutable_options();
  void set_allocated_options(::livekit::proto::TrackPublishOptions* options);
  private:
  const ::livekit::proto::TrackPublishOptions& _internal_options() const;
  ::livekit::proto::TrackPublishOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::livekit::proto::TrackPublishOptions* options);
  ::livekit::proto::TrackPublishOptions* unsafe_arena_release_options();

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required uint64 track_handle = 2;
  bool has_track_handle() const;
  private:
  bool _internal_has_track_handle() const;
  public:
  void clear_track_handle();
  uint64_t track_handle() const;
  void set_track_handle(uint64_t value);
  private:
  uint64_t _internal_track_handle() const;
  void _internal_set_track_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTrackRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::TrackPublishOptions* options_;
    uint64_t local_participant_handle_;
    uint64_t track_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTrackResponse) */ {
 public:
  inline PublishTrackResponse() : PublishTrackResponse(nullptr) {}
  ~PublishTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTrackResponse(const PublishTrackResponse& from);
  PublishTrackResponse(PublishTrackResponse&& from) noexcept
    : PublishTrackResponse() {
    *this = ::std::move(from);
  }

  inline PublishTrackResponse& operator=(const PublishTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTrackResponse& operator=(PublishTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishTrackResponse* internal_default_instance() {
    return reinterpret_cast<const PublishTrackResponse*>(
               &_PublishTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PublishTrackResponse& a, PublishTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTrackResponse& from) {
    PublishTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTrackResponse";
  }
  protected:
  explicit PublishTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTrackCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTrackCallback) */ {
 public:
  inline PublishTrackCallback() : PublishTrackCallback(nullptr) {}
  ~PublishTrackCallback() override;
  explicit PROTOBUF_CONSTEXPR PublishTrackCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTrackCallback(const PublishTrackCallback& from);
  PublishTrackCallback(PublishTrackCallback&& from) noexcept
    : PublishTrackCallback() {
    *this = ::std::move(from);
  }

  inline PublishTrackCallback& operator=(const PublishTrackCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTrackCallback& operator=(PublishTrackCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTrackCallback& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 2,
    kPublication = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const PublishTrackCallback* internal_default_instance() {
    return reinterpret_cast<const PublishTrackCallback*>(
               &_PublishTrackCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PublishTrackCallback& a, PublishTrackCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTrackCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTrackCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTrackCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTrackCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTrackCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTrackCallback& from) {
    PublishTrackCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTrackCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTrackCallback";
  }
  protected:
  explicit PublishTrackCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
    kErrorFieldNumber = 2,
    kPublicationFieldNumber = 3,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.proto.OwnedTrackPublication publication = 3;
  bool has_publication() const;
  private:
  bool _internal_has_publication() const;
  public:
  void clear_publication();
  const ::livekit::proto::OwnedTrackPublication& publication() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedTrackPublication* release_publication();
  ::livekit::proto::OwnedTrackPublication* mutable_publication();
  void set_allocated_publication(::livekit::proto::OwnedTrackPublication* publication);
  private:
  const ::livekit::proto::OwnedTrackPublication& _internal_publication() const;
  ::livekit::proto::OwnedTrackPublication* _internal_mutable_publication();
  public:
  void unsafe_arena_set_allocated_publication(
      ::livekit::proto::OwnedTrackPublication* publication);
  ::livekit::proto::OwnedTrackPublication* unsafe_arena_release_publication();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTrackCallback)
 private:
  class _Internal;
  void set_has_error();
  void set_has_publication();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::livekit::proto::OwnedTrackPublication* publication_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class UnpublishTrackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.UnpublishTrackRequest) */ {
 public:
  inline UnpublishTrackRequest() : UnpublishTrackRequest(nullptr) {}
  ~UnpublishTrackRequest() override;
  explicit PROTOBUF_CONSTEXPR UnpublishTrackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpublishTrackRequest(const UnpublishTrackRequest& from);
  UnpublishTrackRequest(UnpublishTrackRequest&& from) noexcept
    : UnpublishTrackRequest() {
    *this = ::std::move(from);
  }

  inline UnpublishTrackRequest& operator=(const UnpublishTrackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpublishTrackRequest& operator=(UnpublishTrackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpublishTrackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpublishTrackRequest* internal_default_instance() {
    return reinterpret_cast<const UnpublishTrackRequest*>(
               &_UnpublishTrackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UnpublishTrackRequest& a, UnpublishTrackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpublishTrackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpublishTrackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpublishTrackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpublishTrackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpublishTrackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpublishTrackRequest& from) {
    UnpublishTrackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpublishTrackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.UnpublishTrackRequest";
  }
  protected:
  explicit UnpublishTrackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
    kStopOnUnpublishFieldNumber = 3,
  };
  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required bool stop_on_unpublish = 3;
  bool has_stop_on_unpublish() const;
  private:
  bool _internal_has_stop_on_unpublish() const;
  public:
  void clear_stop_on_unpublish();
  bool stop_on_unpublish() const;
  void set_stop_on_unpublish(bool value);
  private:
  bool _internal_stop_on_unpublish() const;
  void _internal_set_stop_on_unpublish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.UnpublishTrackRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    uint64_t local_participant_handle_;
    bool stop_on_unpublish_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class UnpublishTrackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.UnpublishTrackResponse) */ {
 public:
  inline UnpublishTrackResponse() : UnpublishTrackResponse(nullptr) {}
  ~UnpublishTrackResponse() override;
  explicit PROTOBUF_CONSTEXPR UnpublishTrackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpublishTrackResponse(const UnpublishTrackResponse& from);
  UnpublishTrackResponse(UnpublishTrackResponse&& from) noexcept
    : UnpublishTrackResponse() {
    *this = ::std::move(from);
  }

  inline UnpublishTrackResponse& operator=(const UnpublishTrackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpublishTrackResponse& operator=(UnpublishTrackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpublishTrackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpublishTrackResponse* internal_default_instance() {
    return reinterpret_cast<const UnpublishTrackResponse*>(
               &_UnpublishTrackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UnpublishTrackResponse& a, UnpublishTrackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpublishTrackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpublishTrackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpublishTrackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpublishTrackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpublishTrackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpublishTrackResponse& from) {
    UnpublishTrackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpublishTrackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.UnpublishTrackResponse";
  }
  protected:
  explicit UnpublishTrackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.UnpublishTrackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class UnpublishTrackCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.UnpublishTrackCallback) */ {
 public:
  inline UnpublishTrackCallback() : UnpublishTrackCallback(nullptr) {}
  ~UnpublishTrackCallback() override;
  explicit PROTOBUF_CONSTEXPR UnpublishTrackCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnpublishTrackCallback(const UnpublishTrackCallback& from);
  UnpublishTrackCallback(UnpublishTrackCallback&& from) noexcept
    : UnpublishTrackCallback() {
    *this = ::std::move(from);
  }

  inline UnpublishTrackCallback& operator=(const UnpublishTrackCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnpublishTrackCallback& operator=(UnpublishTrackCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnpublishTrackCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnpublishTrackCallback* internal_default_instance() {
    return reinterpret_cast<const UnpublishTrackCallback*>(
               &_UnpublishTrackCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnpublishTrackCallback& a, UnpublishTrackCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(UnpublishTrackCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnpublishTrackCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnpublishTrackCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnpublishTrackCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnpublishTrackCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnpublishTrackCallback& from) {
    UnpublishTrackCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnpublishTrackCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.UnpublishTrackCallback";
  }
  protected:
  explicit UnpublishTrackCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.UnpublishTrackCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishDataRequest) */ {
 public:
  inline PublishDataRequest() : PublishDataRequest(nullptr) {}
  ~PublishDataRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishDataRequest(const PublishDataRequest& from);
  PublishDataRequest(PublishDataRequest&& from) noexcept
    : PublishDataRequest() {
    *this = ::std::move(from);
  }

  inline PublishDataRequest& operator=(const PublishDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishDataRequest& operator=(PublishDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishDataRequest* internal_default_instance() {
    return reinterpret_cast<const PublishDataRequest*>(
               &_PublishDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PublishDataRequest& a, PublishDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishDataRequest& from) {
    PublishDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishDataRequest";
  }
  protected:
  explicit PublishDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationSidsFieldNumber = 5,
    kDestinationIdentitiesFieldNumber = 7,
    kTopicFieldNumber = 6,
    kLocalParticipantHandleFieldNumber = 1,
    kDataPtrFieldNumber = 2,
    kDataLenFieldNumber = 3,
    kReliableFieldNumber = 4,
  };
  // repeated string destination_sids = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int destination_sids_size() const;
  private:
  int _internal_destination_sids_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_destination_sids();
  PROTOBUF_DEPRECATED const std::string& destination_sids(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_destination_sids(int index);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value);
  PROTOBUF_DEPRECATED void set_destination_sids(int index, const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_destination_sids();
  PROTOBUF_DEPRECATED void add_destination_sids(const std::string& value);
  PROTOBUF_DEPRECATED void add_destination_sids(std::string&& value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value);
  PROTOBUF_DEPRECATED void add_destination_sids(const char* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_sids() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_sids();
  private:
  const std::string& _internal_destination_sids(int index) const;
  std::string* _internal_add_destination_sids();
  public:

  // repeated string destination_identities = 7;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // optional string topic = 6;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required uint64 data_ptr = 2;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint64 data_len = 3;
  bool has_data_len() const;
  private:
  bool _internal_has_data_len() const;
  public:
  void clear_data_len();
  uint64_t data_len() const;
  void set_data_len(uint64_t value);
  private:
  uint64_t _internal_data_len() const;
  void _internal_set_data_len(uint64_t value);
  public:

  // required bool reliable = 4;
  bool has_reliable() const;
  private:
  bool _internal_has_reliable() const;
  public:
  void clear_reliable();
  bool reliable() const;
  void set_reliable(bool value);
  private:
  bool _internal_reliable() const;
  void _internal_set_reliable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishDataRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_sids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    uint64_t local_participant_handle_;
    uint64_t data_ptr_;
    uint64_t data_len_;
    bool reliable_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishDataResponse) */ {
 public:
  inline PublishDataResponse() : PublishDataResponse(nullptr) {}
  ~PublishDataResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishDataResponse(const PublishDataResponse& from);
  PublishDataResponse(PublishDataResponse&& from) noexcept
    : PublishDataResponse() {
    *this = ::std::move(from);
  }

  inline PublishDataResponse& operator=(const PublishDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishDataResponse& operator=(PublishDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishDataResponse* internal_default_instance() {
    return reinterpret_cast<const PublishDataResponse*>(
               &_PublishDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PublishDataResponse& a, PublishDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishDataResponse& from) {
    PublishDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishDataResponse";
  }
  protected:
  explicit PublishDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishDataCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishDataCallback) */ {
 public:
  inline PublishDataCallback() : PublishDataCallback(nullptr) {}
  ~PublishDataCallback() override;
  explicit PROTOBUF_CONSTEXPR PublishDataCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishDataCallback(const PublishDataCallback& from);
  PublishDataCallback(PublishDataCallback&& from) noexcept
    : PublishDataCallback() {
    *this = ::std::move(from);
  }

  inline PublishDataCallback& operator=(const PublishDataCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishDataCallback& operator=(PublishDataCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishDataCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishDataCallback* internal_default_instance() {
    return reinterpret_cast<const PublishDataCallback*>(
               &_PublishDataCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PublishDataCallback& a, PublishDataCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishDataCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishDataCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishDataCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishDataCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishDataCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishDataCallback& from) {
    PublishDataCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishDataCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishDataCallback";
  }
  protected:
  explicit PublishDataCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishDataCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTranscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTranscriptionRequest) */ {
 public:
  inline PublishTranscriptionRequest() : PublishTranscriptionRequest(nullptr) {}
  ~PublishTranscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishTranscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTranscriptionRequest(const PublishTranscriptionRequest& from);
  PublishTranscriptionRequest(PublishTranscriptionRequest&& from) noexcept
    : PublishTranscriptionRequest() {
    *this = ::std::move(from);
  }

  inline PublishTranscriptionRequest& operator=(const PublishTranscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTranscriptionRequest& operator=(PublishTranscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTranscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishTranscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const PublishTranscriptionRequest*>(
               &_PublishTranscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PublishTranscriptionRequest& a, PublishTranscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTranscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTranscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTranscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTranscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTranscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTranscriptionRequest& from) {
    PublishTranscriptionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTranscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTranscriptionRequest";
  }
  protected:
  explicit PublishTranscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 4,
    kParticipantIdentityFieldNumber = 2,
    kTrackIdFieldNumber = 3,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated .livekit.proto.TranscriptionSegment segments = 4;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::livekit::proto::TranscriptionSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >*
      mutable_segments();
  private:
  const ::livekit::proto::TranscriptionSegment& _internal_segments(int index) const;
  ::livekit::proto::TranscriptionSegment* _internal_add_segments();
  public:
  const ::livekit::proto::TranscriptionSegment& segments(int index) const;
  ::livekit::proto::TranscriptionSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >&
      segments() const;

  // required string participant_identity = 2;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_id = 3;
  bool has_track_id() const;
  private:
  bool _internal_has_track_id() const;
  public:
  void clear_track_id();
  const std::string& track_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_id();
  PROTOBUF_NODISCARD std::string* release_track_id();
  void set_allocated_track_id(std::string* track_id);
  private:
  const std::string& _internal_track_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(const std::string& value);
  std::string* _internal_mutable_track_id();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTranscriptionRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment > segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_id_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTranscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTranscriptionResponse) */ {
 public:
  inline PublishTranscriptionResponse() : PublishTranscriptionResponse(nullptr) {}
  ~PublishTranscriptionResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishTranscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTranscriptionResponse(const PublishTranscriptionResponse& from);
  PublishTranscriptionResponse(PublishTranscriptionResponse&& from) noexcept
    : PublishTranscriptionResponse() {
    *this = ::std::move(from);
  }

  inline PublishTranscriptionResponse& operator=(const PublishTranscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTranscriptionResponse& operator=(PublishTranscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTranscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishTranscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const PublishTranscriptionResponse*>(
               &_PublishTranscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PublishTranscriptionResponse& a, PublishTranscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTranscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTranscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTranscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTranscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTranscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTranscriptionResponse& from) {
    PublishTranscriptionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTranscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTranscriptionResponse";
  }
  protected:
  explicit PublishTranscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTranscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishTranscriptionCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishTranscriptionCallback) */ {
 public:
  inline PublishTranscriptionCallback() : PublishTranscriptionCallback(nullptr) {}
  ~PublishTranscriptionCallback() override;
  explicit PROTOBUF_CONSTEXPR PublishTranscriptionCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishTranscriptionCallback(const PublishTranscriptionCallback& from);
  PublishTranscriptionCallback(PublishTranscriptionCallback&& from) noexcept
    : PublishTranscriptionCallback() {
    *this = ::std::move(from);
  }

  inline PublishTranscriptionCallback& operator=(const PublishTranscriptionCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishTranscriptionCallback& operator=(PublishTranscriptionCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishTranscriptionCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishTranscriptionCallback* internal_default_instance() {
    return reinterpret_cast<const PublishTranscriptionCallback*>(
               &_PublishTranscriptionCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PublishTranscriptionCallback& a, PublishTranscriptionCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishTranscriptionCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishTranscriptionCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishTranscriptionCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishTranscriptionCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishTranscriptionCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishTranscriptionCallback& from) {
    PublishTranscriptionCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishTranscriptionCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishTranscriptionCallback";
  }
  protected:
  explicit PublishTranscriptionCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishTranscriptionCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishSipDtmfRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishSipDtmfRequest) */ {
 public:
  inline PublishSipDtmfRequest() : PublishSipDtmfRequest(nullptr) {}
  ~PublishSipDtmfRequest() override;
  explicit PROTOBUF_CONSTEXPR PublishSipDtmfRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishSipDtmfRequest(const PublishSipDtmfRequest& from);
  PublishSipDtmfRequest(PublishSipDtmfRequest&& from) noexcept
    : PublishSipDtmfRequest() {
    *this = ::std::move(from);
  }

  inline PublishSipDtmfRequest& operator=(const PublishSipDtmfRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishSipDtmfRequest& operator=(PublishSipDtmfRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishSipDtmfRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishSipDtmfRequest* internal_default_instance() {
    return reinterpret_cast<const PublishSipDtmfRequest*>(
               &_PublishSipDtmfRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PublishSipDtmfRequest& a, PublishSipDtmfRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishSipDtmfRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishSipDtmfRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishSipDtmfRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishSipDtmfRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishSipDtmfRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishSipDtmfRequest& from) {
    PublishSipDtmfRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishSipDtmfRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishSipDtmfRequest";
  }
  protected:
  explicit PublishSipDtmfRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 4,
    kDigitFieldNumber = 3,
    kLocalParticipantHandleFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // repeated string destination_identities = 4;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string digit = 3;
  bool has_digit() const;
  private:
  bool _internal_has_digit() const;
  public:
  void clear_digit();
  const std::string& digit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digit();
  PROTOBUF_NODISCARD std::string* release_digit();
  void set_allocated_digit(std::string* digit);
  private:
  const std::string& _internal_digit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digit(const std::string& value);
  std::string* _internal_mutable_digit();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required uint32 code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishSipDtmfRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digit_;
    uint64_t local_participant_handle_;
    uint32_t code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishSipDtmfResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishSipDtmfResponse) */ {
 public:
  inline PublishSipDtmfResponse() : PublishSipDtmfResponse(nullptr) {}
  ~PublishSipDtmfResponse() override;
  explicit PROTOBUF_CONSTEXPR PublishSipDtmfResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishSipDtmfResponse(const PublishSipDtmfResponse& from);
  PublishSipDtmfResponse(PublishSipDtmfResponse&& from) noexcept
    : PublishSipDtmfResponse() {
    *this = ::std::move(from);
  }

  inline PublishSipDtmfResponse& operator=(const PublishSipDtmfResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishSipDtmfResponse& operator=(PublishSipDtmfResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishSipDtmfResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishSipDtmfResponse* internal_default_instance() {
    return reinterpret_cast<const PublishSipDtmfResponse*>(
               &_PublishSipDtmfResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PublishSipDtmfResponse& a, PublishSipDtmfResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishSipDtmfResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishSipDtmfResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishSipDtmfResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishSipDtmfResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishSipDtmfResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishSipDtmfResponse& from) {
    PublishSipDtmfResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishSipDtmfResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishSipDtmfResponse";
  }
  protected:
  explicit PublishSipDtmfResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishSipDtmfResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class PublishSipDtmfCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.PublishSipDtmfCallback) */ {
 public:
  inline PublishSipDtmfCallback() : PublishSipDtmfCallback(nullptr) {}
  ~PublishSipDtmfCallback() override;
  explicit PROTOBUF_CONSTEXPR PublishSipDtmfCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PublishSipDtmfCallback(const PublishSipDtmfCallback& from);
  PublishSipDtmfCallback(PublishSipDtmfCallback&& from) noexcept
    : PublishSipDtmfCallback() {
    *this = ::std::move(from);
  }

  inline PublishSipDtmfCallback& operator=(const PublishSipDtmfCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishSipDtmfCallback& operator=(PublishSipDtmfCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PublishSipDtmfCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const PublishSipDtmfCallback* internal_default_instance() {
    return reinterpret_cast<const PublishSipDtmfCallback*>(
               &_PublishSipDtmfCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PublishSipDtmfCallback& a, PublishSipDtmfCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishSipDtmfCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishSipDtmfCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PublishSipDtmfCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PublishSipDtmfCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PublishSipDtmfCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PublishSipDtmfCallback& from) {
    PublishSipDtmfCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishSipDtmfCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.PublishSipDtmfCallback";
  }
  protected:
  explicit PublishSipDtmfCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.PublishSipDtmfCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalMetadataRequest) */ {
 public:
  inline SetLocalMetadataRequest() : SetLocalMetadataRequest(nullptr) {}
  ~SetLocalMetadataRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLocalMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalMetadataRequest(const SetLocalMetadataRequest& from);
  SetLocalMetadataRequest(SetLocalMetadataRequest&& from) noexcept
    : SetLocalMetadataRequest() {
    *this = ::std::move(from);
  }

  inline SetLocalMetadataRequest& operator=(const SetLocalMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalMetadataRequest& operator=(SetLocalMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const SetLocalMetadataRequest*>(
               &_SetLocalMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetLocalMetadataRequest& a, SetLocalMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalMetadataRequest& from) {
    SetLocalMetadataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalMetadataRequest";
  }
  protected:
  explicit SetLocalMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // required string metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalMetadataRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalMetadataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalMetadataResponse) */ {
 public:
  inline SetLocalMetadataResponse() : SetLocalMetadataResponse(nullptr) {}
  ~SetLocalMetadataResponse() override;
  explicit PROTOBUF_CONSTEXPR SetLocalMetadataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalMetadataResponse(const SetLocalMetadataResponse& from);
  SetLocalMetadataResponse(SetLocalMetadataResponse&& from) noexcept
    : SetLocalMetadataResponse() {
    *this = ::std::move(from);
  }

  inline SetLocalMetadataResponse& operator=(const SetLocalMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalMetadataResponse& operator=(SetLocalMetadataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalMetadataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const SetLocalMetadataResponse*>(
               &_SetLocalMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SetLocalMetadataResponse& a, SetLocalMetadataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalMetadataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalMetadataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalMetadataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalMetadataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalMetadataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalMetadataResponse& from) {
    SetLocalMetadataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalMetadataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalMetadataResponse";
  }
  protected:
  explicit SetLocalMetadataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalMetadataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalMetadataCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalMetadataCallback) */ {
 public:
  inline SetLocalMetadataCallback() : SetLocalMetadataCallback(nullptr) {}
  ~SetLocalMetadataCallback() override;
  explicit PROTOBUF_CONSTEXPR SetLocalMetadataCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalMetadataCallback(const SetLocalMetadataCallback& from);
  SetLocalMetadataCallback(SetLocalMetadataCallback&& from) noexcept
    : SetLocalMetadataCallback() {
    *this = ::std::move(from);
  }

  inline SetLocalMetadataCallback& operator=(const SetLocalMetadataCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalMetadataCallback& operator=(SetLocalMetadataCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalMetadataCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalMetadataCallback* internal_default_instance() {
    return reinterpret_cast<const SetLocalMetadataCallback*>(
               &_SetLocalMetadataCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetLocalMetadataCallback& a, SetLocalMetadataCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalMetadataCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalMetadataCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalMetadataCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalMetadataCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalMetadataCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalMetadataCallback& from) {
    SetLocalMetadataCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalMetadataCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalMetadataCallback";
  }
  protected:
  explicit SetLocalMetadataCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalMetadataCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendChatMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendChatMessageRequest) */ {
 public:
  inline SendChatMessageRequest() : SendChatMessageRequest(nullptr) {}
  ~SendChatMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR SendChatMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatMessageRequest(const SendChatMessageRequest& from);
  SendChatMessageRequest(SendChatMessageRequest&& from) noexcept
    : SendChatMessageRequest() {
    *this = ::std::move(from);
  }

  inline SendChatMessageRequest& operator=(const SendChatMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatMessageRequest& operator=(SendChatMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChatMessageRequest* internal_default_instance() {
    return reinterpret_cast<const SendChatMessageRequest*>(
               &_SendChatMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SendChatMessageRequest& a, SendChatMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatMessageRequest& from) {
    SendChatMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendChatMessageRequest";
  }
  protected:
  explicit SendChatMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 3,
    kMessageFieldNumber = 2,
    kSenderIdentityFieldNumber = 4,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated string destination_identities = 3;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string sender_identity = 4;
  bool has_sender_identity() const;
  private:
  bool _internal_has_sender_identity() const;
  public:
  void clear_sender_identity();
  const std::string& sender_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_identity();
  PROTOBUF_NODISCARD std::string* release_sender_identity();
  void set_allocated_sender_identity(std::string* sender_identity);
  private:
  const std::string& _internal_sender_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_identity(const std::string& value);
  std::string* _internal_mutable_sender_identity();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendChatMessageRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_identity_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class EditChatMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.EditChatMessageRequest) */ {
 public:
  inline EditChatMessageRequest() : EditChatMessageRequest(nullptr) {}
  ~EditChatMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR EditChatMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditChatMessageRequest(const EditChatMessageRequest& from);
  EditChatMessageRequest(EditChatMessageRequest&& from) noexcept
    : EditChatMessageRequest() {
    *this = ::std::move(from);
  }

  inline EditChatMessageRequest& operator=(const EditChatMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditChatMessageRequest& operator=(EditChatMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditChatMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditChatMessageRequest* internal_default_instance() {
    return reinterpret_cast<const EditChatMessageRequest*>(
               &_EditChatMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(EditChatMessageRequest& a, EditChatMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditChatMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditChatMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditChatMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditChatMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditChatMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditChatMessageRequest& from) {
    EditChatMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditChatMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.EditChatMessageRequest";
  }
  protected:
  explicit EditChatMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 4,
    kEditTextFieldNumber = 2,
    kSenderIdentityFieldNumber = 5,
    kOriginalMessageFieldNumber = 3,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated string destination_identities = 4;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string edit_text = 2;
  bool has_edit_text() const;
  private:
  bool _internal_has_edit_text() const;
  public:
  void clear_edit_text();
  const std::string& edit_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_edit_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_edit_text();
  PROTOBUF_NODISCARD std::string* release_edit_text();
  void set_allocated_edit_text(std::string* edit_text);
  private:
  const std::string& _internal_edit_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_edit_text(const std::string& value);
  std::string* _internal_mutable_edit_text();
  public:

  // optional string sender_identity = 5;
  bool has_sender_identity() const;
  private:
  bool _internal_has_sender_identity() const;
  public:
  void clear_sender_identity();
  const std::string& sender_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_identity();
  PROTOBUF_NODISCARD std::string* release_sender_identity();
  void set_allocated_sender_identity(std::string* sender_identity);
  private:
  const std::string& _internal_sender_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_identity(const std::string& value);
  std::string* _internal_mutable_sender_identity();
  public:

  // required .livekit.proto.ChatMessage original_message = 3;
  bool has_original_message() const;
  private:
  bool _internal_has_original_message() const;
  public:
  void clear_original_message();
  const ::livekit::proto::ChatMessage& original_message() const;
  PROTOBUF_NODISCARD ::livekit::proto::ChatMessage* release_original_message();
  ::livekit::proto::ChatMessage* mutable_original_message();
  void set_allocated_original_message(::livekit::proto::ChatMessage* original_message);
  private:
  const ::livekit::proto::ChatMessage& _internal_original_message() const;
  ::livekit::proto::ChatMessage* _internal_mutable_original_message();
  public:
  void unsafe_arena_set_allocated_original_message(
      ::livekit::proto::ChatMessage* original_message);
  ::livekit::proto::ChatMessage* unsafe_arena_release_original_message();

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.EditChatMessageRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr edit_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_identity_;
    ::livekit::proto::ChatMessage* original_message_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendChatMessageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendChatMessageResponse) */ {
 public:
  inline SendChatMessageResponse() : SendChatMessageResponse(nullptr) {}
  ~SendChatMessageResponse() override;
  explicit PROTOBUF_CONSTEXPR SendChatMessageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatMessageResponse(const SendChatMessageResponse& from);
  SendChatMessageResponse(SendChatMessageResponse&& from) noexcept
    : SendChatMessageResponse() {
    *this = ::std::move(from);
  }

  inline SendChatMessageResponse& operator=(const SendChatMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatMessageResponse& operator=(SendChatMessageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatMessageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChatMessageResponse* internal_default_instance() {
    return reinterpret_cast<const SendChatMessageResponse*>(
               &_SendChatMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SendChatMessageResponse& a, SendChatMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatMessageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatMessageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatMessageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatMessageResponse& from) {
    SendChatMessageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatMessageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendChatMessageResponse";
  }
  protected:
  explicit SendChatMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendChatMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendChatMessageCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendChatMessageCallback) */ {
 public:
  inline SendChatMessageCallback() : SendChatMessageCallback(nullptr) {}
  ~SendChatMessageCallback() override;
  explicit PROTOBUF_CONSTEXPR SendChatMessageCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChatMessageCallback(const SendChatMessageCallback& from);
  SendChatMessageCallback(SendChatMessageCallback&& from) noexcept
    : SendChatMessageCallback() {
    *this = ::std::move(from);
  }

  inline SendChatMessageCallback& operator=(const SendChatMessageCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChatMessageCallback& operator=(SendChatMessageCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendChatMessageCallback& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 2,
    kChatMessage = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SendChatMessageCallback* internal_default_instance() {
    return reinterpret_cast<const SendChatMessageCallback*>(
               &_SendChatMessageCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SendChatMessageCallback& a, SendChatMessageCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SendChatMessageCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChatMessageCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChatMessageCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChatMessageCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendChatMessageCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendChatMessageCallback& from) {
    SendChatMessageCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendChatMessageCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendChatMessageCallback";
  }
  protected:
  explicit SendChatMessageCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
    kErrorFieldNumber = 2,
    kChatMessageFieldNumber = 3,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.proto.ChatMessage chat_message = 3;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;
  public:
  void clear_chat_message();
  const ::livekit::proto::ChatMessage& chat_message() const;
  PROTOBUF_NODISCARD ::livekit::proto::ChatMessage* release_chat_message();
  ::livekit::proto::ChatMessage* mutable_chat_message();
  void set_allocated_chat_message(::livekit::proto::ChatMessage* chat_message);
  private:
  const ::livekit::proto::ChatMessage& _internal_chat_message() const;
  ::livekit::proto::ChatMessage* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::livekit::proto::ChatMessage* chat_message);
  ::livekit::proto::ChatMessage* unsafe_arena_release_chat_message();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.SendChatMessageCallback)
 private:
  class _Internal;
  void set_has_error();
  void set_has_chat_message();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::livekit::proto::ChatMessage* chat_message_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalAttributesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalAttributesRequest) */ {
 public:
  inline SetLocalAttributesRequest() : SetLocalAttributesRequest(nullptr) {}
  ~SetLocalAttributesRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLocalAttributesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalAttributesRequest(const SetLocalAttributesRequest& from);
  SetLocalAttributesRequest(SetLocalAttributesRequest&& from) noexcept
    : SetLocalAttributesRequest() {
    *this = ::std::move(from);
  }

  inline SetLocalAttributesRequest& operator=(const SetLocalAttributesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalAttributesRequest& operator=(SetLocalAttributesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalAttributesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalAttributesRequest* internal_default_instance() {
    return reinterpret_cast<const SetLocalAttributesRequest*>(
               &_SetLocalAttributesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SetLocalAttributesRequest& a, SetLocalAttributesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalAttributesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalAttributesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalAttributesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalAttributesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalAttributesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalAttributesRequest& from) {
    SetLocalAttributesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalAttributesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalAttributesRequest";
  }
  protected:
  explicit SetLocalAttributesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated .livekit.proto.AttributesEntry attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::livekit::proto::AttributesEntry* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
      mutable_attributes();
  private:
  const ::livekit::proto::AttributesEntry& _internal_attributes(int index) const;
  ::livekit::proto::AttributesEntry* _internal_add_attributes();
  public:
  const ::livekit::proto::AttributesEntry& attributes(int index) const;
  ::livekit::proto::AttributesEntry* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
      attributes() const;

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalAttributesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry > attributes_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class AttributesEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AttributesEntry) */ {
 public:
  inline AttributesEntry() : AttributesEntry(nullptr) {}
  ~AttributesEntry() override;
  explicit PROTOBUF_CONSTEXPR AttributesEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributesEntry(const AttributesEntry& from);
  AttributesEntry(AttributesEntry&& from) noexcept
    : AttributesEntry() {
    *this = ::std::move(from);
  }

  inline AttributesEntry& operator=(const AttributesEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributesEntry& operator=(AttributesEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributesEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributesEntry* internal_default_instance() {
    return reinterpret_cast<const AttributesEntry*>(
               &_AttributesEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AttributesEntry& a, AttributesEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributesEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributesEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributesEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributesEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributesEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributesEntry& from) {
    AttributesEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributesEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AttributesEntry";
  }
  protected:
  explicit AttributesEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AttributesEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalAttributesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalAttributesResponse) */ {
 public:
  inline SetLocalAttributesResponse() : SetLocalAttributesResponse(nullptr) {}
  ~SetLocalAttributesResponse() override;
  explicit PROTOBUF_CONSTEXPR SetLocalAttributesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalAttributesResponse(const SetLocalAttributesResponse& from);
  SetLocalAttributesResponse(SetLocalAttributesResponse&& from) noexcept
    : SetLocalAttributesResponse() {
    *this = ::std::move(from);
  }

  inline SetLocalAttributesResponse& operator=(const SetLocalAttributesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalAttributesResponse& operator=(SetLocalAttributesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalAttributesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalAttributesResponse* internal_default_instance() {
    return reinterpret_cast<const SetLocalAttributesResponse*>(
               &_SetLocalAttributesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SetLocalAttributesResponse& a, SetLocalAttributesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalAttributesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalAttributesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalAttributesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalAttributesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalAttributesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalAttributesResponse& from) {
    SetLocalAttributesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalAttributesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalAttributesResponse";
  }
  protected:
  explicit SetLocalAttributesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalAttributesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalAttributesCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalAttributesCallback) */ {
 public:
  inline SetLocalAttributesCallback() : SetLocalAttributesCallback(nullptr) {}
  ~SetLocalAttributesCallback() override;
  explicit PROTOBUF_CONSTEXPR SetLocalAttributesCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalAttributesCallback(const SetLocalAttributesCallback& from);
  SetLocalAttributesCallback(SetLocalAttributesCallback&& from) noexcept
    : SetLocalAttributesCallback() {
    *this = ::std::move(from);
  }

  inline SetLocalAttributesCallback& operator=(const SetLocalAttributesCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalAttributesCallback& operator=(SetLocalAttributesCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalAttributesCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalAttributesCallback* internal_default_instance() {
    return reinterpret_cast<const SetLocalAttributesCallback*>(
               &_SetLocalAttributesCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SetLocalAttributesCallback& a, SetLocalAttributesCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalAttributesCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalAttributesCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalAttributesCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalAttributesCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalAttributesCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalAttributesCallback& from) {
    SetLocalAttributesCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalAttributesCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalAttributesCallback";
  }
  protected:
  explicit SetLocalAttributesCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalAttributesCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalNameRequest) */ {
 public:
  inline SetLocalNameRequest() : SetLocalNameRequest(nullptr) {}
  ~SetLocalNameRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLocalNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalNameRequest(const SetLocalNameRequest& from);
  SetLocalNameRequest(SetLocalNameRequest&& from) noexcept
    : SetLocalNameRequest() {
    *this = ::std::move(from);
  }

  inline SetLocalNameRequest& operator=(const SetLocalNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalNameRequest& operator=(SetLocalNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalNameRequest* internal_default_instance() {
    return reinterpret_cast<const SetLocalNameRequest*>(
               &_SetLocalNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetLocalNameRequest& a, SetLocalNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalNameRequest& from) {
    SetLocalNameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalNameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalNameRequest";
  }
  protected:
  explicit SetLocalNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalNameRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalNameResponse) */ {
 public:
  inline SetLocalNameResponse() : SetLocalNameResponse(nullptr) {}
  ~SetLocalNameResponse() override;
  explicit PROTOBUF_CONSTEXPR SetLocalNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalNameResponse(const SetLocalNameResponse& from);
  SetLocalNameResponse(SetLocalNameResponse&& from) noexcept
    : SetLocalNameResponse() {
    *this = ::std::move(from);
  }

  inline SetLocalNameResponse& operator=(const SetLocalNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalNameResponse& operator=(SetLocalNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalNameResponse* internal_default_instance() {
    return reinterpret_cast<const SetLocalNameResponse*>(
               &_SetLocalNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SetLocalNameResponse& a, SetLocalNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalNameResponse& from) {
    SetLocalNameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalNameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalNameResponse";
  }
  protected:
  explicit SetLocalNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetLocalNameCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetLocalNameCallback) */ {
 public:
  inline SetLocalNameCallback() : SetLocalNameCallback(nullptr) {}
  ~SetLocalNameCallback() override;
  explicit PROTOBUF_CONSTEXPR SetLocalNameCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLocalNameCallback(const SetLocalNameCallback& from);
  SetLocalNameCallback(SetLocalNameCallback&& from) noexcept
    : SetLocalNameCallback() {
    *this = ::std::move(from);
  }

  inline SetLocalNameCallback& operator=(const SetLocalNameCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLocalNameCallback& operator=(SetLocalNameCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLocalNameCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLocalNameCallback* internal_default_instance() {
    return reinterpret_cast<const SetLocalNameCallback*>(
               &_SetLocalNameCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SetLocalNameCallback& a, SetLocalNameCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLocalNameCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLocalNameCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLocalNameCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLocalNameCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLocalNameCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLocalNameCallback& from) {
    SetLocalNameCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLocalNameCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetLocalNameCallback";
  }
  protected:
  explicit SetLocalNameCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetLocalNameCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetSubscribedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetSubscribedRequest) */ {
 public:
  inline SetSubscribedRequest() : SetSubscribedRequest(nullptr) {}
  ~SetSubscribedRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSubscribedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSubscribedRequest(const SetSubscribedRequest& from);
  SetSubscribedRequest(SetSubscribedRequest&& from) noexcept
    : SetSubscribedRequest() {
    *this = ::std::move(from);
  }

  inline SetSubscribedRequest& operator=(const SetSubscribedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSubscribedRequest& operator=(SetSubscribedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSubscribedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSubscribedRequest* internal_default_instance() {
    return reinterpret_cast<const SetSubscribedRequest*>(
               &_SetSubscribedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(SetSubscribedRequest& a, SetSubscribedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSubscribedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSubscribedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSubscribedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSubscribedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSubscribedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSubscribedRequest& from) {
    SetSubscribedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSubscribedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetSubscribedRequest";
  }
  protected:
  explicit SetSubscribedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicationHandleFieldNumber = 2,
    kSubscribeFieldNumber = 1,
  };
  // required uint64 publication_handle = 2;
  bool has_publication_handle() const;
  private:
  bool _internal_has_publication_handle() const;
  public:
  void clear_publication_handle();
  uint64_t publication_handle() const;
  void set_publication_handle(uint64_t value);
  private:
  uint64_t _internal_publication_handle() const;
  void _internal_set_publication_handle(uint64_t value);
  public:

  // required bool subscribe = 1;
  bool has_subscribe() const;
  private:
  bool _internal_has_subscribe() const;
  public:
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetSubscribedRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t publication_handle_;
    bool subscribe_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetSubscribedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SetSubscribedResponse) */ {
 public:
  inline SetSubscribedResponse() : SetSubscribedResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetSubscribedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSubscribedResponse(const SetSubscribedResponse& from);
  SetSubscribedResponse(SetSubscribedResponse&& from) noexcept
    : SetSubscribedResponse() {
    *this = ::std::move(from);
  }

  inline SetSubscribedResponse& operator=(const SetSubscribedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSubscribedResponse& operator=(SetSubscribedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSubscribedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSubscribedResponse* internal_default_instance() {
    return reinterpret_cast<const SetSubscribedResponse*>(
               &_SetSubscribedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetSubscribedResponse& a, SetSubscribedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSubscribedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSubscribedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSubscribedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSubscribedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetSubscribedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetSubscribedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetSubscribedResponse";
  }
  protected:
  explicit SetSubscribedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SetSubscribedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class GetSessionStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSessionStatsRequest) */ {
 public:
  inline GetSessionStatsRequest() : GetSessionStatsRequest(nullptr) {}
  ~GetSessionStatsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSessionStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionStatsRequest(const GetSessionStatsRequest& from);
  GetSessionStatsRequest(GetSessionStatsRequest&& from) noexcept
    : GetSessionStatsRequest() {
    *this = ::std::move(from);
  }

  inline GetSessionStatsRequest& operator=(const GetSessionStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionStatsRequest& operator=(GetSessionStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionStatsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSessionStatsRequest*>(
               &_GetSessionStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetSessionStatsRequest& a, GetSessionStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionStatsRequest& from) {
    GetSessionStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSessionStatsRequest";
  }
  protected:
  explicit GetSessionStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomHandleFieldNumber = 1,
  };
  // required uint64 room_handle = 1;
  bool has_room_handle() const;
  private:
  bool _internal_has_room_handle() const;
  public:
  void clear_room_handle();
  uint64_t room_handle() const;
  void set_room_handle(uint64_t value);
  private:
  uint64_t _internal_room_handle() const;
  void _internal_set_room_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetSessionStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t room_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class GetSessionStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSessionStatsResponse) */ {
 public:
  inline GetSessionStatsResponse() : GetSessionStatsResponse(nullptr) {}
  ~GetSessionStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSessionStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionStatsResponse(const GetSessionStatsResponse& from);
  GetSessionStatsResponse(GetSessionStatsResponse&& from) noexcept
    : GetSessionStatsResponse() {
    *this = ::std::move(from);
  }

  inline GetSessionStatsResponse& operator=(const GetSessionStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionStatsResponse& operator=(GetSessionStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionStatsResponse* internal_default_instance() {
    return reinterpret_cast<const GetSessionStatsResponse*>(
               &_GetSessionStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetSessionStatsResponse& a, GetSessionStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionStatsResponse& from) {
    GetSessionStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSessionStatsResponse";
  }
  protected:
  explicit GetSessionStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetSessionStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class GetSessionStatsCallback_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSessionStatsCallback.Result) */ {
 public:
  inline GetSessionStatsCallback_Result() : GetSessionStatsCallback_Result(nullptr) {}
  ~GetSessionStatsCallback_Result() override;
  explicit PROTOBUF_CONSTEXPR GetSessionStatsCallback_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionStatsCallback_Result(const GetSessionStatsCallback_Result& from);
  GetSessionStatsCallback_Result(GetSessionStatsCallback_Result&& from) noexcept
    : GetSessionStatsCallback_Result() {
    *this = ::std::move(from);
  }

  inline GetSessionStatsCallback_Result& operator=(const GetSessionStatsCallback_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionStatsCallback_Result& operator=(GetSessionStatsCallback_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionStatsCallback_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionStatsCallback_Result* internal_default_instance() {
    return reinterpret_cast<const GetSessionStatsCallback_Result*>(
               &_GetSessionStatsCallback_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetSessionStatsCallback_Result& a, GetSessionStatsCallback_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionStatsCallback_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionStatsCallback_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionStatsCallback_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionStatsCallback_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionStatsCallback_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionStatsCallback_Result& from) {
    GetSessionStatsCallback_Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionStatsCallback_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSessionStatsCallback.Result";
  }
  protected:
  explicit GetSessionStatsCallback_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherStatsFieldNumber = 1,
    kSubscriberStatsFieldNumber = 2,
  };
  // repeated .livekit.proto.RtcStats publisher_stats = 1;
  int publisher_stats_size() const;
  private:
  int _internal_publisher_stats_size() const;
  public:
  void clear_publisher_stats();
  ::livekit::proto::RtcStats* mutable_publisher_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
      mutable_publisher_stats();
  private:
  const ::livekit::proto::RtcStats& _internal_publisher_stats(int index) const;
  ::livekit::proto::RtcStats* _internal_add_publisher_stats();
  public:
  const ::livekit::proto::RtcStats& publisher_stats(int index) const;
  ::livekit::proto::RtcStats* add_publisher_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
      publisher_stats() const;

  // repeated .livekit.proto.RtcStats subscriber_stats = 2;
  int subscriber_stats_size() const;
  private:
  int _internal_subscriber_stats_size() const;
  public:
  void clear_subscriber_stats();
  ::livekit::proto::RtcStats* mutable_subscriber_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
      mutable_subscriber_stats();
  private:
  const ::livekit::proto::RtcStats& _internal_subscriber_stats(int index) const;
  ::livekit::proto::RtcStats* _internal_add_subscriber_stats();
  public:
  const ::livekit::proto::RtcStats& subscriber_stats(int index) const;
  ::livekit::proto::RtcStats* add_subscriber_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
      subscriber_stats() const;

  // @@protoc_insertion_point(class_scope:livekit.proto.GetSessionStatsCallback.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats > publisher_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats > subscriber_stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class GetSessionStatsCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSessionStatsCallback) */ {
 public:
  inline GetSessionStatsCallback() : GetSessionStatsCallback(nullptr) {}
  ~GetSessionStatsCallback() override;
  explicit PROTOBUF_CONSTEXPR GetSessionStatsCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionStatsCallback(const GetSessionStatsCallback& from);
  GetSessionStatsCallback(GetSessionStatsCallback&& from) noexcept
    : GetSessionStatsCallback() {
    *this = ::std::move(from);
  }

  inline GetSessionStatsCallback& operator=(const GetSessionStatsCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionStatsCallback& operator=(GetSessionStatsCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionStatsCallback& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kError = 2,
    kResult = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const GetSessionStatsCallback* internal_default_instance() {
    return reinterpret_cast<const GetSessionStatsCallback*>(
               &_GetSessionStatsCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetSessionStatsCallback& a, GetSessionStatsCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionStatsCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionStatsCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionStatsCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionStatsCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionStatsCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSessionStatsCallback& from) {
    GetSessionStatsCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionStatsCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSessionStatsCallback";
  }
  protected:
  explicit GetSessionStatsCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetSessionStatsCallback_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
    kErrorFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.proto.GetSessionStatsCallback.Result result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::livekit::proto::GetSessionStatsCallback_Result& result() const;
  PROTOBUF_NODISCARD ::livekit::proto::GetSessionStatsCallback_Result* release_result();
  ::livekit::proto::GetSessionStatsCallback_Result* mutable_result();
  void set_allocated_result(::livekit::proto::GetSessionStatsCallback_Result* result);
  private:
  const ::livekit::proto::GetSessionStatsCallback_Result& _internal_result() const;
  ::livekit::proto::GetSessionStatsCallback_Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::livekit::proto::GetSessionStatsCallback_Result* result);
  ::livekit::proto::GetSessionStatsCallback_Result* unsafe_arena_release_result();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.GetSessionStatsCallback)
 private:
  class _Internal;
  void set_has_error();
  void set_has_result();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
      ::livekit::proto::GetSessionStatsCallback_Result* result_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class VideoEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.VideoEncoding) */ {
 public:
  inline VideoEncoding() : VideoEncoding(nullptr) {}
  ~VideoEncoding() override;
  explicit PROTOBUF_CONSTEXPR VideoEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoEncoding(const VideoEncoding& from);
  VideoEncoding(VideoEncoding&& from) noexcept
    : VideoEncoding() {
    *this = ::std::move(from);
  }

  inline VideoEncoding& operator=(const VideoEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoEncoding& operator=(VideoEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoEncoding* internal_default_instance() {
    return reinterpret_cast<const VideoEncoding*>(
               &_VideoEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(VideoEncoding& a, VideoEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoEncoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoEncoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoEncoding& from) {
    VideoEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.VideoEncoding";
  }
  protected:
  explicit VideoEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxBitrateFieldNumber = 1,
    kMaxFramerateFieldNumber = 2,
  };
  // required uint64 max_bitrate = 1;
  bool has_max_bitrate() const;
  private:
  bool _internal_has_max_bitrate() const;
  public:
  void clear_max_bitrate();
  uint64_t max_bitrate() const;
  void set_max_bitrate(uint64_t value);
  private:
  uint64_t _internal_max_bitrate() const;
  void _internal_set_max_bitrate(uint64_t value);
  public:

  // required double max_framerate = 2;
  bool has_max_framerate() const;
  private:
  bool _internal_has_max_framerate() const;
  public:
  void clear_max_framerate();
  double max_framerate() const;
  void set_max_framerate(double value);
  private:
  double _internal_max_framerate() const;
  void _internal_set_max_framerate(double value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.VideoEncoding)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t max_bitrate_;
    double max_framerate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class AudioEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.AudioEncoding) */ {
 public:
  inline AudioEncoding() : AudioEncoding(nullptr) {}
  ~AudioEncoding() override;
  explicit PROTOBUF_CONSTEXPR AudioEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioEncoding(const AudioEncoding& from);
  AudioEncoding(AudioEncoding&& from) noexcept
    : AudioEncoding() {
    *this = ::std::move(from);
  }

  inline AudioEncoding& operator=(const AudioEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioEncoding& operator=(AudioEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioEncoding* internal_default_instance() {
    return reinterpret_cast<const AudioEncoding*>(
               &_AudioEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AudioEncoding& a, AudioEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioEncoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioEncoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioEncoding& from) {
    AudioEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.AudioEncoding";
  }
  protected:
  explicit AudioEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxBitrateFieldNumber = 1,
  };
  // required uint64 max_bitrate = 1;
  bool has_max_bitrate() const;
  private:
  bool _internal_has_max_bitrate() const;
  public:
  void clear_max_bitrate();
  uint64_t max_bitrate() const;
  void set_max_bitrate(uint64_t value);
  private:
  uint64_t _internal_max_bitrate() const;
  void _internal_set_max_bitrate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.AudioEncoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t max_bitrate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackPublishOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackPublishOptions) */ {
 public:
  inline TrackPublishOptions() : TrackPublishOptions(nullptr) {}
  ~TrackPublishOptions() override;
  explicit PROTOBUF_CONSTEXPR TrackPublishOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPublishOptions(const TrackPublishOptions& from);
  TrackPublishOptions(TrackPublishOptions&& from) noexcept
    : TrackPublishOptions() {
    *this = ::std::move(from);
  }

  inline TrackPublishOptions& operator=(const TrackPublishOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublishOptions& operator=(TrackPublishOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublishOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPublishOptions* internal_default_instance() {
    return reinterpret_cast<const TrackPublishOptions*>(
               &_TrackPublishOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(TrackPublishOptions& a, TrackPublishOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPublishOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublishOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublishOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPublishOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPublishOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPublishOptions& from) {
    TrackPublishOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPublishOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackPublishOptions";
  }
  protected:
  explicit TrackPublishOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 8,
    kVideoEncodingFieldNumber = 1,
    kAudioEncodingFieldNumber = 2,
    kVideoCodecFieldNumber = 3,
    kDtxFieldNumber = 4,
    kRedFieldNumber = 5,
    kSimulcastFieldNumber = 6,
    kSourceFieldNumber = 7,
  };
  // optional string stream = 8;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_NODISCARD std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // optional .livekit.proto.VideoEncoding video_encoding = 1;
  bool has_video_encoding() const;
  private:
  bool _internal_has_video_encoding() const;
  public:
  void clear_video_encoding();
  const ::livekit::proto::VideoEncoding& video_encoding() const;
  PROTOBUF_NODISCARD ::livekit::proto::VideoEncoding* release_video_encoding();
  ::livekit::proto::VideoEncoding* mutable_video_encoding();
  void set_allocated_video_encoding(::livekit::proto::VideoEncoding* video_encoding);
  private:
  const ::livekit::proto::VideoEncoding& _internal_video_encoding() const;
  ::livekit::proto::VideoEncoding* _internal_mutable_video_encoding();
  public:
  void unsafe_arena_set_allocated_video_encoding(
      ::livekit::proto::VideoEncoding* video_encoding);
  ::livekit::proto::VideoEncoding* unsafe_arena_release_video_encoding();

  // optional .livekit.proto.AudioEncoding audio_encoding = 2;
  bool has_audio_encoding() const;
  private:
  bool _internal_has_audio_encoding() const;
  public:
  void clear_audio_encoding();
  const ::livekit::proto::AudioEncoding& audio_encoding() const;
  PROTOBUF_NODISCARD ::livekit::proto::AudioEncoding* release_audio_encoding();
  ::livekit::proto::AudioEncoding* mutable_audio_encoding();
  void set_allocated_audio_encoding(::livekit::proto::AudioEncoding* audio_encoding);
  private:
  const ::livekit::proto::AudioEncoding& _internal_audio_encoding() const;
  ::livekit::proto::AudioEncoding* _internal_mutable_audio_encoding();
  public:
  void unsafe_arena_set_allocated_audio_encoding(
      ::livekit::proto::AudioEncoding* audio_encoding);
  ::livekit::proto::AudioEncoding* unsafe_arena_release_audio_encoding();

  // optional .livekit.proto.VideoCodec video_codec = 3;
  bool has_video_codec() const;
  private:
  bool _internal_has_video_codec() const;
  public:
  void clear_video_codec();
  ::livekit::proto::VideoCodec video_codec() const;
  void set_video_codec(::livekit::proto::VideoCodec value);
  private:
  ::livekit::proto::VideoCodec _internal_video_codec() const;
  void _internal_set_video_codec(::livekit::proto::VideoCodec value);
  public:

  // optional bool dtx = 4;
  bool has_dtx() const;
  private:
  bool _internal_has_dtx() const;
  public:
  void clear_dtx();
  bool dtx() const;
  void set_dtx(bool value);
  private:
  bool _internal_dtx() const;
  void _internal_set_dtx(bool value);
  public:

  // optional bool red = 5;
  bool has_red() const;
  private:
  bool _internal_has_red() const;
  public:
  void clear_red();
  bool red() const;
  void set_red(bool value);
  private:
  bool _internal_red() const;
  void _internal_set_red(bool value);
  public:

  // optional bool simulcast = 6;
  bool has_simulcast() const;
  private:
  bool _internal_has_simulcast() const;
  public:
  void clear_simulcast();
  bool simulcast() const;
  void set_simulcast(bool value);
  private:
  bool _internal_simulcast() const;
  void _internal_set_simulcast(bool value);
  public:

  // optional .livekit.proto.TrackSource source = 7;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::livekit::proto::TrackSource source() const;
  void set_source(::livekit::proto::TrackSource value);
  private:
  ::livekit::proto::TrackSource _internal_source() const;
  void _internal_set_source(::livekit::proto::TrackSource value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackPublishOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
    ::livekit::proto::VideoEncoding* video_encoding_;
    ::livekit::proto::AudioEncoding* audio_encoding_;
    int video_codec_;
    bool dtx_;
    bool red_;
    bool simulcast_;
    int source_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class IceServer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.IceServer) */ {
 public:
  inline IceServer() : IceServer(nullptr) {}
  ~IceServer() override;
  explicit PROTOBUF_CONSTEXPR IceServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IceServer(const IceServer& from);
  IceServer(IceServer&& from) noexcept
    : IceServer() {
    *this = ::std::move(from);
  }

  inline IceServer& operator=(const IceServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceServer& operator=(IceServer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IceServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceServer* internal_default_instance() {
    return reinterpret_cast<const IceServer*>(
               &_IceServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(IceServer& a, IceServer& b) {
    a.Swap(&b);
  }
  inline void Swap(IceServer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceServer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IceServer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IceServer& from) {
    IceServer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IceServer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.IceServer";
  }
  protected:
  explicit IceServer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlsFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // repeated string urls = 1;
  int urls_size() const;
  private:
  int _internal_urls_size() const;
  public:
  void clear_urls();
  const std::string& urls(int index) const;
  std::string* mutable_urls(int index);
  void set_urls(int index, const std::string& value);
  void set_urls(int index, std::string&& value);
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  std::string* add_urls();
  void add_urls(const std::string& value);
  void add_urls(std::string&& value);
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_urls();
  private:
  const std::string& _internal_urls(int index) const;
  std::string* _internal_add_urls();
  public:

  // optional string username = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 3;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.IceServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> urls_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RtcConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RtcConfig) */ {
 public:
  inline RtcConfig() : RtcConfig(nullptr) {}
  ~RtcConfig() override;
  explicit PROTOBUF_CONSTEXPR RtcConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcConfig(const RtcConfig& from);
  RtcConfig(RtcConfig&& from) noexcept
    : RtcConfig() {
    *this = ::std::move(from);
  }

  inline RtcConfig& operator=(const RtcConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcConfig& operator=(RtcConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcConfig* internal_default_instance() {
    return reinterpret_cast<const RtcConfig*>(
               &_RtcConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(RtcConfig& a, RtcConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtcConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtcConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RtcConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RtcConfig& from) {
    RtcConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RtcConfig";
  }
  protected:
  explicit RtcConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIceServersFieldNumber = 3,
    kIceTransportTypeFieldNumber = 1,
    kContinualGatheringPolicyFieldNumber = 2,
  };
  // repeated .livekit.proto.IceServer ice_servers = 3;
  int ice_servers_size() const;
  private:
  int _internal_ice_servers_size() const;
  public:
  void clear_ice_servers();
  ::livekit::proto::IceServer* mutable_ice_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::IceServer >*
      mutable_ice_servers();
  private:
  const ::livekit::proto::IceServer& _internal_ice_servers(int index) const;
  ::livekit::proto::IceServer* _internal_add_ice_servers();
  public:
  const ::livekit::proto::IceServer& ice_servers(int index) const;
  ::livekit::proto::IceServer* add_ice_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::IceServer >&
      ice_servers() const;

  // optional .livekit.proto.IceTransportType ice_transport_type = 1;
  bool has_ice_transport_type() const;
  private:
  bool _internal_has_ice_transport_type() const;
  public:
  void clear_ice_transport_type();
  ::livekit::proto::IceTransportType ice_transport_type() const;
  void set_ice_transport_type(::livekit::proto::IceTransportType value);
  private:
  ::livekit::proto::IceTransportType _internal_ice_transport_type() const;
  void _internal_set_ice_transport_type(::livekit::proto::IceTransportType value);
  public:

  // optional .livekit.proto.ContinualGatheringPolicy continual_gathering_policy = 2;
  bool has_continual_gathering_policy() const;
  private:
  bool _internal_has_continual_gathering_policy() const;
  public:
  void clear_continual_gathering_policy();
  ::livekit::proto::ContinualGatheringPolicy continual_gathering_policy() const;
  void set_continual_gathering_policy(::livekit::proto::ContinualGatheringPolicy value);
  private:
  ::livekit::proto::ContinualGatheringPolicy _internal_continual_gathering_policy() const;
  void _internal_set_continual_gathering_policy(::livekit::proto::ContinualGatheringPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RtcConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::IceServer > ice_servers_;
    int ice_transport_type_;
    int continual_gathering_policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RoomOptions) */ {
 public:
  inline RoomOptions() : RoomOptions(nullptr) {}
  ~RoomOptions() override;
  explicit PROTOBUF_CONSTEXPR RoomOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomOptions(const RoomOptions& from);
  RoomOptions(RoomOptions&& from) noexcept
    : RoomOptions() {
    *this = ::std::move(from);
  }

  inline RoomOptions& operator=(const RoomOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomOptions& operator=(RoomOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomOptions* internal_default_instance() {
    return reinterpret_cast<const RoomOptions*>(
               &_RoomOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(RoomOptions& a, RoomOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomOptions& from) {
    RoomOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomOptions";
  }
  protected:
  explicit RoomOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kE2EeFieldNumber = 4,
    kRtcConfigFieldNumber = 5,
    kAutoSubscribeFieldNumber = 1,
    kAdaptiveStreamFieldNumber = 2,
    kDynacastFieldNumber = 3,
    kJoinRetriesFieldNumber = 6,
  };
  // optional .livekit.proto.E2eeOptions e2ee = 4;
  bool has_e2ee() const;
  private:
  bool _internal_has_e2ee() const;
  public:
  void clear_e2ee();
  const ::livekit::proto::E2eeOptions& e2ee() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeOptions* release_e2ee();
  ::livekit::proto::E2eeOptions* mutable_e2ee();
  void set_allocated_e2ee(::livekit::proto::E2eeOptions* e2ee);
  private:
  const ::livekit::proto::E2eeOptions& _internal_e2ee() const;
  ::livekit::proto::E2eeOptions* _internal_mutable_e2ee();
  public:
  void unsafe_arena_set_allocated_e2ee(
      ::livekit::proto::E2eeOptions* e2ee);
  ::livekit::proto::E2eeOptions* unsafe_arena_release_e2ee();

  // optional .livekit.proto.RtcConfig rtc_config = 5;
  bool has_rtc_config() const;
  private:
  bool _internal_has_rtc_config() const;
  public:
  void clear_rtc_config();
  const ::livekit::proto::RtcConfig& rtc_config() const;
  PROTOBUF_NODISCARD ::livekit::proto::RtcConfig* release_rtc_config();
  ::livekit::proto::RtcConfig* mutable_rtc_config();
  void set_allocated_rtc_config(::livekit::proto::RtcConfig* rtc_config);
  private:
  const ::livekit::proto::RtcConfig& _internal_rtc_config() const;
  ::livekit::proto::RtcConfig* _internal_mutable_rtc_config();
  public:
  void unsafe_arena_set_allocated_rtc_config(
      ::livekit::proto::RtcConfig* rtc_config);
  ::livekit::proto::RtcConfig* unsafe_arena_release_rtc_config();

  // optional bool auto_subscribe = 1;
  bool has_auto_subscribe() const;
  private:
  bool _internal_has_auto_subscribe() const;
  public:
  void clear_auto_subscribe();
  bool auto_subscribe() const;
  void set_auto_subscribe(bool value);
  private:
  bool _internal_auto_subscribe() const;
  void _internal_set_auto_subscribe(bool value);
  public:

  // optional bool adaptive_stream = 2;
  bool has_adaptive_stream() const;
  private:
  bool _internal_has_adaptive_stream() const;
  public:
  void clear_adaptive_stream();
  bool adaptive_stream() const;
  void set_adaptive_stream(bool value);
  private:
  bool _internal_adaptive_stream() const;
  void _internal_set_adaptive_stream(bool value);
  public:

  // optional bool dynacast = 3;
  bool has_dynacast() const;
  private:
  bool _internal_has_dynacast() const;
  public:
  void clear_dynacast();
  bool dynacast() const;
  void set_dynacast(bool value);
  private:
  bool _internal_dynacast() const;
  void _internal_set_dynacast(bool value);
  public:

  // optional uint32 join_retries = 6;
  bool has_join_retries() const;
  private:
  bool _internal_has_join_retries() const;
  public:
  void clear_join_retries();
  uint32_t join_retries() const;
  void set_join_retries(uint32_t value);
  private:
  uint32_t _internal_join_retries() const;
  void _internal_set_join_retries(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RoomOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::E2eeOptions* e2ee_;
    ::livekit::proto::RtcConfig* rtc_config_;
    bool auto_subscribe_;
    bool adaptive_stream_;
    bool dynacast_;
    uint32_t join_retries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TranscriptionSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TranscriptionSegment) */ {
 public:
  inline TranscriptionSegment() : TranscriptionSegment(nullptr) {}
  ~TranscriptionSegment() override;
  explicit PROTOBUF_CONSTEXPR TranscriptionSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscriptionSegment(const TranscriptionSegment& from);
  TranscriptionSegment(TranscriptionSegment&& from) noexcept
    : TranscriptionSegment() {
    *this = ::std::move(from);
  }

  inline TranscriptionSegment& operator=(const TranscriptionSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscriptionSegment& operator=(TranscriptionSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscriptionSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscriptionSegment* internal_default_instance() {
    return reinterpret_cast<const TranscriptionSegment*>(
               &_TranscriptionSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TranscriptionSegment& a, TranscriptionSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscriptionSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscriptionSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranscriptionSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranscriptionSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscriptionSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranscriptionSegment& from) {
    TranscriptionSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptionSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TranscriptionSegment";
  }
  protected:
  explicit TranscriptionSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kLanguageFieldNumber = 6,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kFinalFieldNumber = 5,
  };
  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // required string language = 6;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // required uint64 start_time = 3;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint64_t start_time() const;
  void set_start_time(uint64_t value);
  private:
  uint64_t _internal_start_time() const;
  void _internal_set_start_time(uint64_t value);
  public:

  // required uint64 end_time = 4;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  uint64_t end_time() const;
  void set_end_time(uint64_t value);
  private:
  uint64_t _internal_end_time() const;
  void _internal_set_end_time(uint64_t value);
  public:

  // required bool final = 5;
  bool has_final() const;
  private:
  bool _internal_has_final() const;
  public:
  void clear_final();
  bool final() const;
  void set_final(bool value);
  private:
  bool _internal_final() const;
  void _internal_set_final(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TranscriptionSegment)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    uint64_t start_time_;
    uint64_t end_time_;
    bool final_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class BufferInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.BufferInfo) */ {
 public:
  inline BufferInfo() : BufferInfo(nullptr) {}
  ~BufferInfo() override;
  explicit PROTOBUF_CONSTEXPR BufferInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferInfo(const BufferInfo& from);
  BufferInfo(BufferInfo&& from) noexcept
    : BufferInfo() {
    *this = ::std::move(from);
  }

  inline BufferInfo& operator=(const BufferInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferInfo& operator=(BufferInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferInfo* internal_default_instance() {
    return reinterpret_cast<const BufferInfo*>(
               &_BufferInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(BufferInfo& a, BufferInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferInfo& from) {
    BufferInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.BufferInfo";
  }
  protected:
  explicit BufferInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataPtrFieldNumber = 1,
    kDataLenFieldNumber = 2,
  };
  // required uint64 data_ptr = 1;
  bool has_data_ptr() const;
  private:
  bool _internal_has_data_ptr() const;
  public:
  void clear_data_ptr();
  uint64_t data_ptr() const;
  void set_data_ptr(uint64_t value);
  private:
  uint64_t _internal_data_ptr() const;
  void _internal_set_data_ptr(uint64_t value);
  public:

  // required uint64 data_len = 2;
  bool has_data_len() const;
  private:
  bool _internal_has_data_len() const;
  public:
  void clear_data_len();
  uint64_t data_len() const;
  void set_data_len(uint64_t value);
  private:
  uint64_t _internal_data_len() const;
  void _internal_set_data_len(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.BufferInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t data_ptr_;
    uint64_t data_len_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class OwnedBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedBuffer) */ {
 public:
  inline OwnedBuffer() : OwnedBuffer(nullptr) {}
  ~OwnedBuffer() override;
  explicit PROTOBUF_CONSTEXPR OwnedBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedBuffer(const OwnedBuffer& from);
  OwnedBuffer(OwnedBuffer&& from) noexcept
    : OwnedBuffer() {
    *this = ::std::move(from);
  }

  inline OwnedBuffer& operator=(const OwnedBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedBuffer& operator=(OwnedBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedBuffer* internal_default_instance() {
    return reinterpret_cast<const OwnedBuffer*>(
               &_OwnedBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(OwnedBuffer& a, OwnedBuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedBuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedBuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedBuffer& from) {
    OwnedBuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedBuffer";
  }
  protected:
  explicit OwnedBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.BufferInfo data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::livekit::proto::BufferInfo& data() const;
  PROTOBUF_NODISCARD ::livekit::proto::BufferInfo* release_data();
  ::livekit::proto::BufferInfo* mutable_data();
  void set_allocated_data(::livekit::proto::BufferInfo* data);
  private:
  const ::livekit::proto::BufferInfo& _internal_data() const;
  ::livekit::proto::BufferInfo* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::livekit::proto::BufferInfo* data);
  ::livekit::proto::BufferInfo* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedBuffer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::BufferInfo* data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RoomEvent) */ {
 public:
  inline RoomEvent() : RoomEvent(nullptr) {}
  ~RoomEvent() override;
  explicit PROTOBUF_CONSTEXPR RoomEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomEvent(const RoomEvent& from);
  RoomEvent(RoomEvent&& from) noexcept
    : RoomEvent() {
    *this = ::std::move(from);
  }

  inline RoomEvent& operator=(const RoomEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomEvent& operator=(RoomEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomEvent& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kParticipantConnected = 2,
    kParticipantDisconnected = 3,
    kLocalTrackPublished = 4,
    kLocalTrackUnpublished = 5,
    kLocalTrackSubscribed = 6,
    kTrackPublished = 7,
    kTrackUnpublished = 8,
    kTrackSubscribed = 9,
    kTrackUnsubscribed = 10,
    kTrackSubscriptionFailed = 11,
    kTrackMuted = 12,
    kTrackUnmuted = 13,
    kActiveSpeakersChanged = 14,
    kRoomMetadataChanged = 15,
    kRoomSidChanged = 16,
    kParticipantMetadataChanged = 17,
    kParticipantNameChanged = 18,
    kParticipantAttributesChanged = 19,
    kConnectionQualityChanged = 20,
    kConnectionStateChanged = 21,
    kDisconnected = 22,
    kReconnecting = 23,
    kReconnected = 24,
    kE2EeStateChanged = 25,
    kEos = 26,
    kDataPacketReceived = 27,
    kTranscriptionReceived = 28,
    kChatMessage = 29,
    kStreamHeaderReceived = 30,
    kStreamChunkReceived = 31,
    kStreamTrailerReceived = 32,
    kDataChannelLowThresholdChanged = 33,
    MESSAGE_NOT_SET = 0,
  };

  static inline const RoomEvent* internal_default_instance() {
    return reinterpret_cast<const RoomEvent*>(
               &_RoomEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(RoomEvent& a, RoomEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomEvent& from) {
    RoomEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomEvent";
  }
  protected:
  explicit RoomEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomHandleFieldNumber = 1,
    kParticipantConnectedFieldNumber = 2,
    kParticipantDisconnectedFieldNumber = 3,
    kLocalTrackPublishedFieldNumber = 4,
    kLocalTrackUnpublishedFieldNumber = 5,
    kLocalTrackSubscribedFieldNumber = 6,
    kTrackPublishedFieldNumber = 7,
    kTrackUnpublishedFieldNumber = 8,
    kTrackSubscribedFieldNumber = 9,
    kTrackUnsubscribedFieldNumber = 10,
    kTrackSubscriptionFailedFieldNumber = 11,
    kTrackMutedFieldNumber = 12,
    kTrackUnmutedFieldNumber = 13,
    kActiveSpeakersChangedFieldNumber = 14,
    kRoomMetadataChangedFieldNumber = 15,
    kRoomSidChangedFieldNumber = 16,
    kParticipantMetadataChangedFieldNumber = 17,
    kParticipantNameChangedFieldNumber = 18,
    kParticipantAttributesChangedFieldNumber = 19,
    kConnectionQualityChangedFieldNumber = 20,
    kConnectionStateChangedFieldNumber = 21,
    kDisconnectedFieldNumber = 22,
    kReconnectingFieldNumber = 23,
    kReconnectedFieldNumber = 24,
    kE2EeStateChangedFieldNumber = 25,
    kEosFieldNumber = 26,
    kDataPacketReceivedFieldNumber = 27,
    kTranscriptionReceivedFieldNumber = 28,
    kChatMessageFieldNumber = 29,
    kStreamHeaderReceivedFieldNumber = 30,
    kStreamChunkReceivedFieldNumber = 31,
    kStreamTrailerReceivedFieldNumber = 32,
    kDataChannelLowThresholdChangedFieldNumber = 33,
  };
  // required uint64 room_handle = 1;
  bool has_room_handle() const;
  private:
  bool _internal_has_room_handle() const;
  public:
  void clear_room_handle();
  uint64_t room_handle() const;
  void set_room_handle(uint64_t value);
  private:
  uint64_t _internal_room_handle() const;
  void _internal_set_room_handle(uint64_t value);
  public:

  // .livekit.proto.ParticipantConnected participant_connected = 2;
  bool has_participant_connected() const;
  private:
  bool _internal_has_participant_connected() const;
  public:
  void clear_participant_connected();
  const ::livekit::proto::ParticipantConnected& participant_connected() const;
  PROTOBUF_NODISCARD ::livekit::proto::ParticipantConnected* release_participant_connected();
  ::livekit::proto::ParticipantConnected* mutable_participant_connected();
  void set_allocated_participant_connected(::livekit::proto::ParticipantConnected* participant_connected);
  private:
  const ::livekit::proto::ParticipantConnected& _internal_participant_connected() const;
  ::livekit::proto::ParticipantConnected* _internal_mutable_participant_connected();
  public:
  void unsafe_arena_set_allocated_participant_connected(
      ::livekit::proto::ParticipantConnected* participant_connected);
  ::livekit::proto::ParticipantConnected* unsafe_arena_release_participant_connected();

  // .livekit.proto.ParticipantDisconnected participant_disconnected = 3;
  bool has_participant_disconnected() const;
  private:
  bool _internal_has_participant_disconnected() const;
  public:
  void clear_participant_disconnected();
  const ::livekit::proto::ParticipantDisconnected& participant_disconnected() const;
  PROTOBUF_NODISCARD ::livekit::proto::ParticipantDisconnected* release_participant_disconnected();
  ::livekit::proto::ParticipantDisconnected* mutable_participant_disconnected();
  void set_allocated_participant_disconnected(::livekit::proto::ParticipantDisconnected* participant_disconnected);
  private:
  const ::livekit::proto::ParticipantDisconnected& _internal_participant_disconnected() const;
  ::livekit::proto::ParticipantDisconnected* _internal_mutable_participant_disconnected();
  public:
  void unsafe_arena_set_allocated_participant_disconnected(
      ::livekit::proto::ParticipantDisconnected* participant_disconnected);
  ::livekit::proto::ParticipantDisconnected* unsafe_arena_release_participant_disconnected();

  // .livekit.proto.LocalTrackPublished local_track_published = 4;
  bool has_local_track_published() const;
  private:
  bool _internal_has_local_track_published() const;
  public:
  void clear_local_track_published();
  const ::livekit::proto::LocalTrackPublished& local_track_published() const;
  PROTOBUF_NODISCARD ::livekit::proto::LocalTrackPublished* release_local_track_published();
  ::livekit::proto::LocalTrackPublished* mutable_local_track_published();
  void set_allocated_local_track_published(::livekit::proto::LocalTrackPublished* local_track_published);
  private:
  const ::livekit::proto::LocalTrackPublished& _internal_local_track_published() const;
  ::livekit::proto::LocalTrackPublished* _internal_mutable_local_track_published();
  public:
  void unsafe_arena_set_allocated_local_track_published(
      ::livekit::proto::LocalTrackPublished* local_track_published);
  ::livekit::proto::LocalTrackPublished* unsafe_arena_release_local_track_published();

  // .livekit.proto.LocalTrackUnpublished local_track_unpublished = 5;
  bool has_local_track_unpublished() const;
  private:
  bool _internal_has_local_track_unpublished() const;
  public:
  void clear_local_track_unpublished();
  const ::livekit::proto::LocalTrackUnpublished& local_track_unpublished() const;
  PROTOBUF_NODISCARD ::livekit::proto::LocalTrackUnpublished* release_local_track_unpublished();
  ::livekit::proto::LocalTrackUnpublished* mutable_local_track_unpublished();
  void set_allocated_local_track_unpublished(::livekit::proto::LocalTrackUnpublished* local_track_unpublished);
  private:
  const ::livekit::proto::LocalTrackUnpublished& _internal_local_track_unpublished() const;
  ::livekit::proto::LocalTrackUnpublished* _internal_mutable_local_track_unpublished();
  public:
  void unsafe_arena_set_allocated_local_track_unpublished(
      ::livekit::proto::LocalTrackUnpublished* local_track_unpublished);
  ::livekit::proto::LocalTrackUnpublished* unsafe_arena_release_local_track_unpublished();

  // .livekit.proto.LocalTrackSubscribed local_track_subscribed = 6;
  bool has_local_track_subscribed() const;
  private:
  bool _internal_has_local_track_subscribed() const;
  public:
  void clear_local_track_subscribed();
  const ::livekit::proto::LocalTrackSubscribed& local_track_subscribed() const;
  PROTOBUF_NODISCARD ::livekit::proto::LocalTrackSubscribed* release_local_track_subscribed();
  ::livekit::proto::LocalTrackSubscribed* mutable_local_track_subscribed();
  void set_allocated_local_track_subscribed(::livekit::proto::LocalTrackSubscribed* local_track_subscribed);
  private:
  const ::livekit::proto::LocalTrackSubscribed& _internal_local_track_subscribed() const;
  ::livekit::proto::LocalTrackSubscribed* _internal_mutable_local_track_subscribed();
  public:
  void unsafe_arena_set_allocated_local_track_subscribed(
      ::livekit::proto::LocalTrackSubscribed* local_track_subscribed);
  ::livekit::proto::LocalTrackSubscribed* unsafe_arena_release_local_track_subscribed();

  // .livekit.proto.TrackPublished track_published = 7;
  bool has_track_published() const;
  private:
  bool _internal_has_track_published() const;
  public:
  void clear_track_published();
  const ::livekit::proto::TrackPublished& track_published() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackPublished* release_track_published();
  ::livekit::proto::TrackPublished* mutable_track_published();
  void set_allocated_track_published(::livekit::proto::TrackPublished* track_published);
  private:
  const ::livekit::proto::TrackPublished& _internal_track_published() const;
  ::livekit::proto::TrackPublished* _internal_mutable_track_published();
  public:
  void unsafe_arena_set_allocated_track_published(
      ::livekit::proto::TrackPublished* track_published);
  ::livekit::proto::TrackPublished* unsafe_arena_release_track_published();

  // .livekit.proto.TrackUnpublished track_unpublished = 8;
  bool has_track_unpublished() const;
  private:
  bool _internal_has_track_unpublished() const;
  public:
  void clear_track_unpublished();
  const ::livekit::proto::TrackUnpublished& track_unpublished() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackUnpublished* release_track_unpublished();
  ::livekit::proto::TrackUnpublished* mutable_track_unpublished();
  void set_allocated_track_unpublished(::livekit::proto::TrackUnpublished* track_unpublished);
  private:
  const ::livekit::proto::TrackUnpublished& _internal_track_unpublished() const;
  ::livekit::proto::TrackUnpublished* _internal_mutable_track_unpublished();
  public:
  void unsafe_arena_set_allocated_track_unpublished(
      ::livekit::proto::TrackUnpublished* track_unpublished);
  ::livekit::proto::TrackUnpublished* unsafe_arena_release_track_unpublished();

  // .livekit.proto.TrackSubscribed track_subscribed = 9;
  bool has_track_subscribed() const;
  private:
  bool _internal_has_track_subscribed() const;
  public:
  void clear_track_subscribed();
  const ::livekit::proto::TrackSubscribed& track_subscribed() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackSubscribed* release_track_subscribed();
  ::livekit::proto::TrackSubscribed* mutable_track_subscribed();
  void set_allocated_track_subscribed(::livekit::proto::TrackSubscribed* track_subscribed);
  private:
  const ::livekit::proto::TrackSubscribed& _internal_track_subscribed() const;
  ::livekit::proto::TrackSubscribed* _internal_mutable_track_subscribed();
  public:
  void unsafe_arena_set_allocated_track_subscribed(
      ::livekit::proto::TrackSubscribed* track_subscribed);
  ::livekit::proto::TrackSubscribed* unsafe_arena_release_track_subscribed();

  // .livekit.proto.TrackUnsubscribed track_unsubscribed = 10;
  bool has_track_unsubscribed() const;
  private:
  bool _internal_has_track_unsubscribed() const;
  public:
  void clear_track_unsubscribed();
  const ::livekit::proto::TrackUnsubscribed& track_unsubscribed() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackUnsubscribed* release_track_unsubscribed();
  ::livekit::proto::TrackUnsubscribed* mutable_track_unsubscribed();
  void set_allocated_track_unsubscribed(::livekit::proto::TrackUnsubscribed* track_unsubscribed);
  private:
  const ::livekit::proto::TrackUnsubscribed& _internal_track_unsubscribed() const;
  ::livekit::proto::TrackUnsubscribed* _internal_mutable_track_unsubscribed();
  public:
  void unsafe_arena_set_allocated_track_unsubscribed(
      ::livekit::proto::TrackUnsubscribed* track_unsubscribed);
  ::livekit::proto::TrackUnsubscribed* unsafe_arena_release_track_unsubscribed();

  // .livekit.proto.TrackSubscriptionFailed track_subscription_failed = 11;
  bool has_track_subscription_failed() const;
  private:
  bool _internal_has_track_subscription_failed() const;
  public:
  void clear_track_subscription_failed();
  const ::livekit::proto::TrackSubscriptionFailed& track_subscription_failed() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackSubscriptionFailed* release_track_subscription_failed();
  ::livekit::proto::TrackSubscriptionFailed* mutable_track_subscription_failed();
  void set_allocated_track_subscription_failed(::livekit::proto::TrackSubscriptionFailed* track_subscription_failed);
  private:
  const ::livekit::proto::TrackSubscriptionFailed& _internal_track_subscription_failed() const;
  ::livekit::proto::TrackSubscriptionFailed* _internal_mutable_track_subscription_failed();
  public:
  void unsafe_arena_set_allocated_track_subscription_failed(
      ::livekit::proto::TrackSubscriptionFailed* track_subscription_failed);
  ::livekit::proto::TrackSubscriptionFailed* unsafe_arena_release_track_subscription_failed();

  // .livekit.proto.TrackMuted track_muted = 12;
  bool has_track_muted() const;
  private:
  bool _internal_has_track_muted() const;
  public:
  void clear_track_muted();
  const ::livekit::proto::TrackMuted& track_muted() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackMuted* release_track_muted();
  ::livekit::proto::TrackMuted* mutable_track_muted();
  void set_allocated_track_muted(::livekit::proto::TrackMuted* track_muted);
  private:
  const ::livekit::proto::TrackMuted& _internal_track_muted() const;
  ::livekit::proto::TrackMuted* _internal_mutable_track_muted();
  public:
  void unsafe_arena_set_allocated_track_muted(
      ::livekit::proto::TrackMuted* track_muted);
  ::livekit::proto::TrackMuted* unsafe_arena_release_track_muted();

  // .livekit.proto.TrackUnmuted track_unmuted = 13;
  bool has_track_unmuted() const;
  private:
  bool _internal_has_track_unmuted() const;
  public:
  void clear_track_unmuted();
  const ::livekit::proto::TrackUnmuted& track_unmuted() const;
  PROTOBUF_NODISCARD ::livekit::proto::TrackUnmuted* release_track_unmuted();
  ::livekit::proto::TrackUnmuted* mutable_track_unmuted();
  void set_allocated_track_unmuted(::livekit::proto::TrackUnmuted* track_unmuted);
  private:
  const ::livekit::proto::TrackUnmuted& _internal_track_unmuted() const;
  ::livekit::proto::TrackUnmuted* _internal_mutable_track_unmuted();
  public:
  void unsafe_arena_set_allocated_track_unmuted(
      ::livekit::proto::TrackUnmuted* track_unmuted);
  ::livekit::proto::TrackUnmuted* unsafe_arena_release_track_unmuted();

  // .livekit.proto.ActiveSpeakersChanged active_speakers_changed = 14;
  bool has_active_speakers_changed() const;
  private:
  bool _internal_has_active_speakers_changed() const;
  public:
  void clear_active_speakers_changed();
  const ::livekit::proto::ActiveSpeakersChanged& active_speakers_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ActiveSpeakersChanged* release_active_speakers_changed();
  ::livekit::proto::ActiveSpeakersChanged* mutable_active_speakers_changed();
  void set_allocated_active_speakers_changed(::livekit::proto::ActiveSpeakersChanged* active_speakers_changed);
  private:
  const ::livekit::proto::ActiveSpeakersChanged& _internal_active_speakers_changed() const;
  ::livekit::proto::ActiveSpeakersChanged* _internal_mutable_active_speakers_changed();
  public:
  void unsafe_arena_set_allocated_active_speakers_changed(
      ::livekit::proto::ActiveSpeakersChanged* active_speakers_changed);
  ::livekit::proto::ActiveSpeakersChanged* unsafe_arena_release_active_speakers_changed();

  // .livekit.proto.RoomMetadataChanged room_metadata_changed = 15;
  bool has_room_metadata_changed() const;
  private:
  bool _internal_has_room_metadata_changed() const;
  public:
  void clear_room_metadata_changed();
  const ::livekit::proto::RoomMetadataChanged& room_metadata_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::RoomMetadataChanged* release_room_metadata_changed();
  ::livekit::proto::RoomMetadataChanged* mutable_room_metadata_changed();
  void set_allocated_room_metadata_changed(::livekit::proto::RoomMetadataChanged* room_metadata_changed);
  private:
  const ::livekit::proto::RoomMetadataChanged& _internal_room_metadata_changed() const;
  ::livekit::proto::RoomMetadataChanged* _internal_mutable_room_metadata_changed();
  public:
  void unsafe_arena_set_allocated_room_metadata_changed(
      ::livekit::proto::RoomMetadataChanged* room_metadata_changed);
  ::livekit::proto::RoomMetadataChanged* unsafe_arena_release_room_metadata_changed();

  // .livekit.proto.RoomSidChanged room_sid_changed = 16;
  bool has_room_sid_changed() const;
  private:
  bool _internal_has_room_sid_changed() const;
  public:
  void clear_room_sid_changed();
  const ::livekit::proto::RoomSidChanged& room_sid_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::RoomSidChanged* release_room_sid_changed();
  ::livekit::proto::RoomSidChanged* mutable_room_sid_changed();
  void set_allocated_room_sid_changed(::livekit::proto::RoomSidChanged* room_sid_changed);
  private:
  const ::livekit::proto::RoomSidChanged& _internal_room_sid_changed() const;
  ::livekit::proto::RoomSidChanged* _internal_mutable_room_sid_changed();
  public:
  void unsafe_arena_set_allocated_room_sid_changed(
      ::livekit::proto::RoomSidChanged* room_sid_changed);
  ::livekit::proto::RoomSidChanged* unsafe_arena_release_room_sid_changed();

  // .livekit.proto.ParticipantMetadataChanged participant_metadata_changed = 17;
  bool has_participant_metadata_changed() const;
  private:
  bool _internal_has_participant_metadata_changed() const;
  public:
  void clear_participant_metadata_changed();
  const ::livekit::proto::ParticipantMetadataChanged& participant_metadata_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ParticipantMetadataChanged* release_participant_metadata_changed();
  ::livekit::proto::ParticipantMetadataChanged* mutable_participant_metadata_changed();
  void set_allocated_participant_metadata_changed(::livekit::proto::ParticipantMetadataChanged* participant_metadata_changed);
  private:
  const ::livekit::proto::ParticipantMetadataChanged& _internal_participant_metadata_changed() const;
  ::livekit::proto::ParticipantMetadataChanged* _internal_mutable_participant_metadata_changed();
  public:
  void unsafe_arena_set_allocated_participant_metadata_changed(
      ::livekit::proto::ParticipantMetadataChanged* participant_metadata_changed);
  ::livekit::proto::ParticipantMetadataChanged* unsafe_arena_release_participant_metadata_changed();

  // .livekit.proto.ParticipantNameChanged participant_name_changed = 18;
  bool has_participant_name_changed() const;
  private:
  bool _internal_has_participant_name_changed() const;
  public:
  void clear_participant_name_changed();
  const ::livekit::proto::ParticipantNameChanged& participant_name_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ParticipantNameChanged* release_participant_name_changed();
  ::livekit::proto::ParticipantNameChanged* mutable_participant_name_changed();
  void set_allocated_participant_name_changed(::livekit::proto::ParticipantNameChanged* participant_name_changed);
  private:
  const ::livekit::proto::ParticipantNameChanged& _internal_participant_name_changed() const;
  ::livekit::proto::ParticipantNameChanged* _internal_mutable_participant_name_changed();
  public:
  void unsafe_arena_set_allocated_participant_name_changed(
      ::livekit::proto::ParticipantNameChanged* participant_name_changed);
  ::livekit::proto::ParticipantNameChanged* unsafe_arena_release_participant_name_changed();

  // .livekit.proto.ParticipantAttributesChanged participant_attributes_changed = 19;
  bool has_participant_attributes_changed() const;
  private:
  bool _internal_has_participant_attributes_changed() const;
  public:
  void clear_participant_attributes_changed();
  const ::livekit::proto::ParticipantAttributesChanged& participant_attributes_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ParticipantAttributesChanged* release_participant_attributes_changed();
  ::livekit::proto::ParticipantAttributesChanged* mutable_participant_attributes_changed();
  void set_allocated_participant_attributes_changed(::livekit::proto::ParticipantAttributesChanged* participant_attributes_changed);
  private:
  const ::livekit::proto::ParticipantAttributesChanged& _internal_participant_attributes_changed() const;
  ::livekit::proto::ParticipantAttributesChanged* _internal_mutable_participant_attributes_changed();
  public:
  void unsafe_arena_set_allocated_participant_attributes_changed(
      ::livekit::proto::ParticipantAttributesChanged* participant_attributes_changed);
  ::livekit::proto::ParticipantAttributesChanged* unsafe_arena_release_participant_attributes_changed();

  // .livekit.proto.ConnectionQualityChanged connection_quality_changed = 20;
  bool has_connection_quality_changed() const;
  private:
  bool _internal_has_connection_quality_changed() const;
  public:
  void clear_connection_quality_changed();
  const ::livekit::proto::ConnectionQualityChanged& connection_quality_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ConnectionQualityChanged* release_connection_quality_changed();
  ::livekit::proto::ConnectionQualityChanged* mutable_connection_quality_changed();
  void set_allocated_connection_quality_changed(::livekit::proto::ConnectionQualityChanged* connection_quality_changed);
  private:
  const ::livekit::proto::ConnectionQualityChanged& _internal_connection_quality_changed() const;
  ::livekit::proto::ConnectionQualityChanged* _internal_mutable_connection_quality_changed();
  public:
  void unsafe_arena_set_allocated_connection_quality_changed(
      ::livekit::proto::ConnectionQualityChanged* connection_quality_changed);
  ::livekit::proto::ConnectionQualityChanged* unsafe_arena_release_connection_quality_changed();

  // .livekit.proto.ConnectionStateChanged connection_state_changed = 21;
  bool has_connection_state_changed() const;
  private:
  bool _internal_has_connection_state_changed() const;
  public:
  void clear_connection_state_changed();
  const ::livekit::proto::ConnectionStateChanged& connection_state_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::ConnectionStateChanged* release_connection_state_changed();
  ::livekit::proto::ConnectionStateChanged* mutable_connection_state_changed();
  void set_allocated_connection_state_changed(::livekit::proto::ConnectionStateChanged* connection_state_changed);
  private:
  const ::livekit::proto::ConnectionStateChanged& _internal_connection_state_changed() const;
  ::livekit::proto::ConnectionStateChanged* _internal_mutable_connection_state_changed();
  public:
  void unsafe_arena_set_allocated_connection_state_changed(
      ::livekit::proto::ConnectionStateChanged* connection_state_changed);
  ::livekit::proto::ConnectionStateChanged* unsafe_arena_release_connection_state_changed();

  // .livekit.proto.Disconnected disconnected = 22;
  bool has_disconnected() const;
  private:
  bool _internal_has_disconnected() const;
  public:
  void clear_disconnected();
  const ::livekit::proto::Disconnected& disconnected() const;
  PROTOBUF_NODISCARD ::livekit::proto::Disconnected* release_disconnected();
  ::livekit::proto::Disconnected* mutable_disconnected();
  void set_allocated_disconnected(::livekit::proto::Disconnected* disconnected);
  private:
  const ::livekit::proto::Disconnected& _internal_disconnected() const;
  ::livekit::proto::Disconnected* _internal_mutable_disconnected();
  public:
  void unsafe_arena_set_allocated_disconnected(
      ::livekit::proto::Disconnected* disconnected);
  ::livekit::proto::Disconnected* unsafe_arena_release_disconnected();

  // .livekit.proto.Reconnecting reconnecting = 23;
  bool has_reconnecting() const;
  private:
  bool _internal_has_reconnecting() const;
  public:
  void clear_reconnecting();
  const ::livekit::proto::Reconnecting& reconnecting() const;
  PROTOBUF_NODISCARD ::livekit::proto::Reconnecting* release_reconnecting();
  ::livekit::proto::Reconnecting* mutable_reconnecting();
  void set_allocated_reconnecting(::livekit::proto::Reconnecting* reconnecting);
  private:
  const ::livekit::proto::Reconnecting& _internal_reconnecting() const;
  ::livekit::proto::Reconnecting* _internal_mutable_reconnecting();
  public:
  void unsafe_arena_set_allocated_reconnecting(
      ::livekit::proto::Reconnecting* reconnecting);
  ::livekit::proto::Reconnecting* unsafe_arena_release_reconnecting();

  // .livekit.proto.Reconnected reconnected = 24;
  bool has_reconnected() const;
  private:
  bool _internal_has_reconnected() const;
  public:
  void clear_reconnected();
  const ::livekit::proto::Reconnected& reconnected() const;
  PROTOBUF_NODISCARD ::livekit::proto::Reconnected* release_reconnected();
  ::livekit::proto::Reconnected* mutable_reconnected();
  void set_allocated_reconnected(::livekit::proto::Reconnected* reconnected);
  private:
  const ::livekit::proto::Reconnected& _internal_reconnected() const;
  ::livekit::proto::Reconnected* _internal_mutable_reconnected();
  public:
  void unsafe_arena_set_allocated_reconnected(
      ::livekit::proto::Reconnected* reconnected);
  ::livekit::proto::Reconnected* unsafe_arena_release_reconnected();

  // .livekit.proto.E2eeStateChanged e2ee_state_changed = 25;
  bool has_e2ee_state_changed() const;
  private:
  bool _internal_has_e2ee_state_changed() const;
  public:
  void clear_e2ee_state_changed();
  const ::livekit::proto::E2eeStateChanged& e2ee_state_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeStateChanged* release_e2ee_state_changed();
  ::livekit::proto::E2eeStateChanged* mutable_e2ee_state_changed();
  void set_allocated_e2ee_state_changed(::livekit::proto::E2eeStateChanged* e2ee_state_changed);
  private:
  const ::livekit::proto::E2eeStateChanged& _internal_e2ee_state_changed() const;
  ::livekit::proto::E2eeStateChanged* _internal_mutable_e2ee_state_changed();
  public:
  void unsafe_arena_set_allocated_e2ee_state_changed(
      ::livekit::proto::E2eeStateChanged* e2ee_state_changed);
  ::livekit::proto::E2eeStateChanged* unsafe_arena_release_e2ee_state_changed();

  // .livekit.proto.RoomEOS eos = 26;
  bool has_eos() const;
  private:
  bool _internal_has_eos() const;
  public:
  void clear_eos();
  const ::livekit::proto::RoomEOS& eos() const;
  PROTOBUF_NODISCARD ::livekit::proto::RoomEOS* release_eos();
  ::livekit::proto::RoomEOS* mutable_eos();
  void set_allocated_eos(::livekit::proto::RoomEOS* eos);
  private:
  const ::livekit::proto::RoomEOS& _internal_eos() const;
  ::livekit::proto::RoomEOS* _internal_mutable_eos();
  public:
  void unsafe_arena_set_allocated_eos(
      ::livekit::proto::RoomEOS* eos);
  ::livekit::proto::RoomEOS* unsafe_arena_release_eos();

  // .livekit.proto.DataPacketReceived data_packet_received = 27;
  bool has_data_packet_received() const;
  private:
  bool _internal_has_data_packet_received() const;
  public:
  void clear_data_packet_received();
  const ::livekit::proto::DataPacketReceived& data_packet_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataPacketReceived* release_data_packet_received();
  ::livekit::proto::DataPacketReceived* mutable_data_packet_received();
  void set_allocated_data_packet_received(::livekit::proto::DataPacketReceived* data_packet_received);
  private:
  const ::livekit::proto::DataPacketReceived& _internal_data_packet_received() const;
  ::livekit::proto::DataPacketReceived* _internal_mutable_data_packet_received();
  public:
  void unsafe_arena_set_allocated_data_packet_received(
      ::livekit::proto::DataPacketReceived* data_packet_received);
  ::livekit::proto::DataPacketReceived* unsafe_arena_release_data_packet_received();

  // .livekit.proto.TranscriptionReceived transcription_received = 28;
  bool has_transcription_received() const;
  private:
  bool _internal_has_transcription_received() const;
  public:
  void clear_transcription_received();
  const ::livekit::proto::TranscriptionReceived& transcription_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::TranscriptionReceived* release_transcription_received();
  ::livekit::proto::TranscriptionReceived* mutable_transcription_received();
  void set_allocated_transcription_received(::livekit::proto::TranscriptionReceived* transcription_received);
  private:
  const ::livekit::proto::TranscriptionReceived& _internal_transcription_received() const;
  ::livekit::proto::TranscriptionReceived* _internal_mutable_transcription_received();
  public:
  void unsafe_arena_set_allocated_transcription_received(
      ::livekit::proto::TranscriptionReceived* transcription_received);
  ::livekit::proto::TranscriptionReceived* unsafe_arena_release_transcription_received();

  // .livekit.proto.ChatMessageReceived chat_message = 29;
  bool has_chat_message() const;
  private:
  bool _internal_has_chat_message() const;
  public:
  void clear_chat_message();
  const ::livekit::proto::ChatMessageReceived& chat_message() const;
  PROTOBUF_NODISCARD ::livekit::proto::ChatMessageReceived* release_chat_message();
  ::livekit::proto::ChatMessageReceived* mutable_chat_message();
  void set_allocated_chat_message(::livekit::proto::ChatMessageReceived* chat_message);
  private:
  const ::livekit::proto::ChatMessageReceived& _internal_chat_message() const;
  ::livekit::proto::ChatMessageReceived* _internal_mutable_chat_message();
  public:
  void unsafe_arena_set_allocated_chat_message(
      ::livekit::proto::ChatMessageReceived* chat_message);
  ::livekit::proto::ChatMessageReceived* unsafe_arena_release_chat_message();

  // .livekit.proto.DataStreamHeaderReceived stream_header_received = 30;
  bool has_stream_header_received() const;
  private:
  bool _internal_has_stream_header_received() const;
  public:
  void clear_stream_header_received();
  const ::livekit::proto::DataStreamHeaderReceived& stream_header_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStreamHeaderReceived* release_stream_header_received();
  ::livekit::proto::DataStreamHeaderReceived* mutable_stream_header_received();
  void set_allocated_stream_header_received(::livekit::proto::DataStreamHeaderReceived* stream_header_received);
  private:
  const ::livekit::proto::DataStreamHeaderReceived& _internal_stream_header_received() const;
  ::livekit::proto::DataStreamHeaderReceived* _internal_mutable_stream_header_received();
  public:
  void unsafe_arena_set_allocated_stream_header_received(
      ::livekit::proto::DataStreamHeaderReceived* stream_header_received);
  ::livekit::proto::DataStreamHeaderReceived* unsafe_arena_release_stream_header_received();

  // .livekit.proto.DataStreamChunkReceived stream_chunk_received = 31;
  bool has_stream_chunk_received() const;
  private:
  bool _internal_has_stream_chunk_received() const;
  public:
  void clear_stream_chunk_received();
  const ::livekit::proto::DataStreamChunkReceived& stream_chunk_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStreamChunkReceived* release_stream_chunk_received();
  ::livekit::proto::DataStreamChunkReceived* mutable_stream_chunk_received();
  void set_allocated_stream_chunk_received(::livekit::proto::DataStreamChunkReceived* stream_chunk_received);
  private:
  const ::livekit::proto::DataStreamChunkReceived& _internal_stream_chunk_received() const;
  ::livekit::proto::DataStreamChunkReceived* _internal_mutable_stream_chunk_received();
  public:
  void unsafe_arena_set_allocated_stream_chunk_received(
      ::livekit::proto::DataStreamChunkReceived* stream_chunk_received);
  ::livekit::proto::DataStreamChunkReceived* unsafe_arena_release_stream_chunk_received();

  // .livekit.proto.DataStreamTrailerReceived stream_trailer_received = 32;
  bool has_stream_trailer_received() const;
  private:
  bool _internal_has_stream_trailer_received() const;
  public:
  void clear_stream_trailer_received();
  const ::livekit::proto::DataStreamTrailerReceived& stream_trailer_received() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStreamTrailerReceived* release_stream_trailer_received();
  ::livekit::proto::DataStreamTrailerReceived* mutable_stream_trailer_received();
  void set_allocated_stream_trailer_received(::livekit::proto::DataStreamTrailerReceived* stream_trailer_received);
  private:
  const ::livekit::proto::DataStreamTrailerReceived& _internal_stream_trailer_received() const;
  ::livekit::proto::DataStreamTrailerReceived* _internal_mutable_stream_trailer_received();
  public:
  void unsafe_arena_set_allocated_stream_trailer_received(
      ::livekit::proto::DataStreamTrailerReceived* stream_trailer_received);
  ::livekit::proto::DataStreamTrailerReceived* unsafe_arena_release_stream_trailer_received();

  // .livekit.proto.DataChannelBufferedAmountLowThresholdChanged data_channel_low_threshold_changed = 33;
  bool has_data_channel_low_threshold_changed() const;
  private:
  bool _internal_has_data_channel_low_threshold_changed() const;
  public:
  void clear_data_channel_low_threshold_changed();
  const ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged& data_channel_low_threshold_changed() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* release_data_channel_low_threshold_changed();
  ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* mutable_data_channel_low_threshold_changed();
  void set_allocated_data_channel_low_threshold_changed(::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* data_channel_low_threshold_changed);
  private:
  const ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged& _internal_data_channel_low_threshold_changed() const;
  ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* _internal_mutable_data_channel_low_threshold_changed();
  public:
  void unsafe_arena_set_allocated_data_channel_low_threshold_changed(
      ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* data_channel_low_threshold_changed);
  ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* unsafe_arena_release_data_channel_low_threshold_changed();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.RoomEvent)
 private:
  class _Internal;
  void set_has_participant_connected();
  void set_has_participant_disconnected();
  void set_has_local_track_published();
  void set_has_local_track_unpublished();
  void set_has_local_track_subscribed();
  void set_has_track_published();
  void set_has_track_unpublished();
  void set_has_track_subscribed();
  void set_has_track_unsubscribed();
  void set_has_track_subscription_failed();
  void set_has_track_muted();
  void set_has_track_unmuted();
  void set_has_active_speakers_changed();
  void set_has_room_metadata_changed();
  void set_has_room_sid_changed();
  void set_has_participant_metadata_changed();
  void set_has_participant_name_changed();
  void set_has_participant_attributes_changed();
  void set_has_connection_quality_changed();
  void set_has_connection_state_changed();
  void set_has_disconnected();
  void set_has_reconnecting();
  void set_has_reconnected();
  void set_has_e2ee_state_changed();
  void set_has_eos();
  void set_has_data_packet_received();
  void set_has_transcription_received();
  void set_has_chat_message();
  void set_has_stream_header_received();
  void set_has_stream_chunk_received();
  void set_has_stream_trailer_received();
  void set_has_data_channel_low_threshold_changed();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t room_handle_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::ParticipantConnected* participant_connected_;
      ::livekit::proto::ParticipantDisconnected* participant_disconnected_;
      ::livekit::proto::LocalTrackPublished* local_track_published_;
      ::livekit::proto::LocalTrackUnpublished* local_track_unpublished_;
      ::livekit::proto::LocalTrackSubscribed* local_track_subscribed_;
      ::livekit::proto::TrackPublished* track_published_;
      ::livekit::proto::TrackUnpublished* track_unpublished_;
      ::livekit::proto::TrackSubscribed* track_subscribed_;
      ::livekit::proto::TrackUnsubscribed* track_unsubscribed_;
      ::livekit::proto::TrackSubscriptionFailed* track_subscription_failed_;
      ::livekit::proto::TrackMuted* track_muted_;
      ::livekit::proto::TrackUnmuted* track_unmuted_;
      ::livekit::proto::ActiveSpeakersChanged* active_speakers_changed_;
      ::livekit::proto::RoomMetadataChanged* room_metadata_changed_;
      ::livekit::proto::RoomSidChanged* room_sid_changed_;
      ::livekit::proto::ParticipantMetadataChanged* participant_metadata_changed_;
      ::livekit::proto::ParticipantNameChanged* participant_name_changed_;
      ::livekit::proto::ParticipantAttributesChanged* participant_attributes_changed_;
      ::livekit::proto::ConnectionQualityChanged* connection_quality_changed_;
      ::livekit::proto::ConnectionStateChanged* connection_state_changed_;
      ::livekit::proto::Disconnected* disconnected_;
      ::livekit::proto::Reconnecting* reconnecting_;
      ::livekit::proto::Reconnected* reconnected_;
      ::livekit::proto::E2eeStateChanged* e2ee_state_changed_;
      ::livekit::proto::RoomEOS* eos_;
      ::livekit::proto::DataPacketReceived* data_packet_received_;
      ::livekit::proto::TranscriptionReceived* transcription_received_;
      ::livekit::proto::ChatMessageReceived* chat_message_;
      ::livekit::proto::DataStreamHeaderReceived* stream_header_received_;
      ::livekit::proto::DataStreamChunkReceived* stream_chunk_received_;
      ::livekit::proto::DataStreamTrailerReceived* stream_trailer_received_;
      ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* data_channel_low_threshold_changed_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomInfo& from) {
    RoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
    kNameFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kLossyDcBufferedAmountLowThresholdFieldNumber = 4,
    kReliableDcBufferedAmountLowThresholdFieldNumber = 5,
  };
  // optional string sid = 1;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string metadata = 3;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // required uint64 lossy_dc_buffered_amount_low_threshold = 4;
  bool has_lossy_dc_buffered_amount_low_threshold() const;
  private:
  bool _internal_has_lossy_dc_buffered_amount_low_threshold() const;
  public:
  void clear_lossy_dc_buffered_amount_low_threshold();
  uint64_t lossy_dc_buffered_amount_low_threshold() const;
  void set_lossy_dc_buffered_amount_low_threshold(uint64_t value);
  private:
  uint64_t _internal_lossy_dc_buffered_amount_low_threshold() const;
  void _internal_set_lossy_dc_buffered_amount_low_threshold(uint64_t value);
  public:

  // required uint64 reliable_dc_buffered_amount_low_threshold = 5;
  bool has_reliable_dc_buffered_amount_low_threshold() const;
  private:
  bool _internal_has_reliable_dc_buffered_amount_low_threshold() const;
  public:
  void clear_reliable_dc_buffered_amount_low_threshold();
  uint64_t reliable_dc_buffered_amount_low_threshold() const;
  void set_reliable_dc_buffered_amount_low_threshold(uint64_t value);
  private:
  uint64_t _internal_reliable_dc_buffered_amount_low_threshold() const;
  void _internal_set_reliable_dc_buffered_amount_low_threshold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RoomInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    uint64_t lossy_dc_buffered_amount_low_threshold_;
    uint64_t reliable_dc_buffered_amount_low_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class OwnedRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.OwnedRoom) */ {
 public:
  inline OwnedRoom() : OwnedRoom(nullptr) {}
  ~OwnedRoom() override;
  explicit PROTOBUF_CONSTEXPR OwnedRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnedRoom(const OwnedRoom& from);
  OwnedRoom(OwnedRoom&& from) noexcept
    : OwnedRoom() {
    *this = ::std::move(from);
  }

  inline OwnedRoom& operator=(const OwnedRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnedRoom& operator=(OwnedRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnedRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnedRoom* internal_default_instance() {
    return reinterpret_cast<const OwnedRoom*>(
               &_OwnedRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(OwnedRoom& a, OwnedRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnedRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnedRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnedRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnedRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnedRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnedRoom& from) {
    OwnedRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnedRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.OwnedRoom";
  }
  protected:
  explicit OwnedRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // required .livekit.proto.FfiOwnedHandle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::livekit::proto::FfiOwnedHandle& handle() const;
  PROTOBUF_NODISCARD ::livekit::proto::FfiOwnedHandle* release_handle();
  ::livekit::proto::FfiOwnedHandle* mutable_handle();
  void set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle);
  private:
  const ::livekit::proto::FfiOwnedHandle& _internal_handle() const;
  ::livekit::proto::FfiOwnedHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::livekit::proto::FfiOwnedHandle* handle);
  ::livekit::proto::FfiOwnedHandle* unsafe_arena_release_handle();

  // required .livekit.proto.RoomInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::RoomInfo& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::RoomInfo* release_info();
  ::livekit::proto::RoomInfo* mutable_info();
  void set_allocated_info(::livekit::proto::RoomInfo* info);
  private:
  const ::livekit::proto::RoomInfo& _internal_info() const;
  ::livekit::proto::RoomInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::RoomInfo* info);
  ::livekit::proto::RoomInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.OwnedRoom)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::FfiOwnedHandle* handle_;
    ::livekit::proto::RoomInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ParticipantConnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantConnected) */ {
 public:
  inline ParticipantConnected() : ParticipantConnected(nullptr) {}
  ~ParticipantConnected() override;
  explicit PROTOBUF_CONSTEXPR ParticipantConnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantConnected(const ParticipantConnected& from);
  ParticipantConnected(ParticipantConnected&& from) noexcept
    : ParticipantConnected() {
    *this = ::std::move(from);
  }

  inline ParticipantConnected& operator=(const ParticipantConnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantConnected& operator=(ParticipantConnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantConnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantConnected* internal_default_instance() {
    return reinterpret_cast<const ParticipantConnected*>(
               &_ParticipantConnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ParticipantConnected& a, ParticipantConnected& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantConnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantConnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantConnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantConnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantConnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantConnected& from) {
    ParticipantConnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantConnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantConnected";
  }
  protected:
  explicit ParticipantConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // required .livekit.proto.OwnedParticipant info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::livekit::proto::OwnedParticipant& info() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedParticipant* release_info();
  ::livekit::proto::OwnedParticipant* mutable_info();
  void set_allocated_info(::livekit::proto::OwnedParticipant* info);
  private:
  const ::livekit::proto::OwnedParticipant& _internal_info() const;
  ::livekit::proto::OwnedParticipant* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::livekit::proto::OwnedParticipant* info);
  ::livekit::proto::OwnedParticipant* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantConnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::OwnedParticipant* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ParticipantDisconnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantDisconnected) */ {
 public:
  inline ParticipantDisconnected() : ParticipantDisconnected(nullptr) {}
  ~ParticipantDisconnected() override;
  explicit PROTOBUF_CONSTEXPR ParticipantDisconnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantDisconnected(const ParticipantDisconnected& from);
  ParticipantDisconnected(ParticipantDisconnected&& from) noexcept
    : ParticipantDisconnected() {
    *this = ::std::move(from);
  }

  inline ParticipantDisconnected& operator=(const ParticipantDisconnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantDisconnected& operator=(ParticipantDisconnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantDisconnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantDisconnected* internal_default_instance() {
    return reinterpret_cast<const ParticipantDisconnected*>(
               &_ParticipantDisconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ParticipantDisconnected& a, ParticipantDisconnected& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantDisconnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantDisconnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantDisconnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantDisconnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantDisconnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantDisconnected& from) {
    ParticipantDisconnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantDisconnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantDisconnected";
  }
  protected:
  explicit ParticipantDisconnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kDisconnectReasonFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.DisconnectReason disconnect_reason = 2;
  bool has_disconnect_reason() const;
  private:
  bool _internal_has_disconnect_reason() const;
  public:
  void clear_disconnect_reason();
  ::livekit::proto::DisconnectReason disconnect_reason() const;
  void set_disconnect_reason(::livekit::proto::DisconnectReason value);
  private:
  ::livekit::proto::DisconnectReason _internal_disconnect_reason() const;
  void _internal_set_disconnect_reason(::livekit::proto::DisconnectReason value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantDisconnected)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int disconnect_reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class LocalTrackPublished final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LocalTrackPublished) */ {
 public:
  inline LocalTrackPublished() : LocalTrackPublished(nullptr) {}
  ~LocalTrackPublished() override;
  explicit PROTOBUF_CONSTEXPR LocalTrackPublished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTrackPublished(const LocalTrackPublished& from);
  LocalTrackPublished(LocalTrackPublished&& from) noexcept
    : LocalTrackPublished() {
    *this = ::std::move(from);
  }

  inline LocalTrackPublished& operator=(const LocalTrackPublished& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTrackPublished& operator=(LocalTrackPublished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTrackPublished& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTrackPublished* internal_default_instance() {
    return reinterpret_cast<const LocalTrackPublished*>(
               &_LocalTrackPublished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(LocalTrackPublished& a, LocalTrackPublished& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTrackPublished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTrackPublished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTrackPublished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTrackPublished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTrackPublished& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTrackPublished& from) {
    LocalTrackPublished::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTrackPublished* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LocalTrackPublished";
  }
  protected:
  explicit LocalTrackPublished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 1,
  };
  // required string track_sid = 1;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LocalTrackPublished)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class LocalTrackUnpublished final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LocalTrackUnpublished) */ {
 public:
  inline LocalTrackUnpublished() : LocalTrackUnpublished(nullptr) {}
  ~LocalTrackUnpublished() override;
  explicit PROTOBUF_CONSTEXPR LocalTrackUnpublished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTrackUnpublished(const LocalTrackUnpublished& from);
  LocalTrackUnpublished(LocalTrackUnpublished&& from) noexcept
    : LocalTrackUnpublished() {
    *this = ::std::move(from);
  }

  inline LocalTrackUnpublished& operator=(const LocalTrackUnpublished& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTrackUnpublished& operator=(LocalTrackUnpublished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTrackUnpublished& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTrackUnpublished* internal_default_instance() {
    return reinterpret_cast<const LocalTrackUnpublished*>(
               &_LocalTrackUnpublished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(LocalTrackUnpublished& a, LocalTrackUnpublished& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTrackUnpublished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTrackUnpublished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTrackUnpublished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTrackUnpublished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTrackUnpublished& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTrackUnpublished& from) {
    LocalTrackUnpublished::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTrackUnpublished* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LocalTrackUnpublished";
  }
  protected:
  explicit LocalTrackUnpublished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicationSidFieldNumber = 1,
  };
  // required string publication_sid = 1;
  bool has_publication_sid() const;
  private:
  bool _internal_has_publication_sid() const;
  public:
  void clear_publication_sid();
  const std::string& publication_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publication_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publication_sid();
  PROTOBUF_NODISCARD std::string* release_publication_sid();
  void set_allocated_publication_sid(std::string* publication_sid);
  private:
  const std::string& _internal_publication_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publication_sid(const std::string& value);
  std::string* _internal_mutable_publication_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LocalTrackUnpublished)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publication_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class LocalTrackSubscribed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.LocalTrackSubscribed) */ {
 public:
  inline LocalTrackSubscribed() : LocalTrackSubscribed(nullptr) {}
  ~LocalTrackSubscribed() override;
  explicit PROTOBUF_CONSTEXPR LocalTrackSubscribed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTrackSubscribed(const LocalTrackSubscribed& from);
  LocalTrackSubscribed(LocalTrackSubscribed&& from) noexcept
    : LocalTrackSubscribed() {
    *this = ::std::move(from);
  }

  inline LocalTrackSubscribed& operator=(const LocalTrackSubscribed& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTrackSubscribed& operator=(LocalTrackSubscribed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTrackSubscribed& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTrackSubscribed* internal_default_instance() {
    return reinterpret_cast<const LocalTrackSubscribed*>(
               &_LocalTrackSubscribed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(LocalTrackSubscribed& a, LocalTrackSubscribed& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTrackSubscribed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTrackSubscribed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalTrackSubscribed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalTrackSubscribed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTrackSubscribed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocalTrackSubscribed& from) {
    LocalTrackSubscribed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTrackSubscribed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.LocalTrackSubscribed";
  }
  protected:
  explicit LocalTrackSubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrackSidFieldNumber = 2,
  };
  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.LocalTrackSubscribed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackPublished final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackPublished) */ {
 public:
  inline TrackPublished() : TrackPublished(nullptr) {}
  ~TrackPublished() override;
  explicit PROTOBUF_CONSTEXPR TrackPublished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackPublished(const TrackPublished& from);
  TrackPublished(TrackPublished&& from) noexcept
    : TrackPublished() {
    *this = ::std::move(from);
  }

  inline TrackPublished& operator=(const TrackPublished& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackPublished& operator=(TrackPublished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackPublished& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackPublished* internal_default_instance() {
    return reinterpret_cast<const TrackPublished*>(
               &_TrackPublished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(TrackPublished& a, TrackPublished& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackPublished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackPublished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackPublished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackPublished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackPublished& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackPublished& from) {
    TrackPublished::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackPublished* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackPublished";
  }
  protected:
  explicit TrackPublished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kPublicationFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.OwnedTrackPublication publication = 2;
  bool has_publication() const;
  private:
  bool _internal_has_publication() const;
  public:
  void clear_publication();
  const ::livekit::proto::OwnedTrackPublication& publication() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedTrackPublication* release_publication();
  ::livekit::proto::OwnedTrackPublication* mutable_publication();
  void set_allocated_publication(::livekit::proto::OwnedTrackPublication* publication);
  private:
  const ::livekit::proto::OwnedTrackPublication& _internal_publication() const;
  ::livekit::proto::OwnedTrackPublication* _internal_mutable_publication();
  public:
  void unsafe_arena_set_allocated_publication(
      ::livekit::proto::OwnedTrackPublication* publication);
  ::livekit::proto::OwnedTrackPublication* unsafe_arena_release_publication();

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackPublished)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::OwnedTrackPublication* publication_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackUnpublished final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackUnpublished) */ {
 public:
  inline TrackUnpublished() : TrackUnpublished(nullptr) {}
  ~TrackUnpublished() override;
  explicit PROTOBUF_CONSTEXPR TrackUnpublished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUnpublished(const TrackUnpublished& from);
  TrackUnpublished(TrackUnpublished&& from) noexcept
    : TrackUnpublished() {
    *this = ::std::move(from);
  }

  inline TrackUnpublished& operator=(const TrackUnpublished& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnpublished& operator=(TrackUnpublished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnpublished& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUnpublished* internal_default_instance() {
    return reinterpret_cast<const TrackUnpublished*>(
               &_TrackUnpublished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(TrackUnpublished& a, TrackUnpublished& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUnpublished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnpublished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnpublished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUnpublished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUnpublished& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackUnpublished& from) {
    TrackUnpublished::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUnpublished* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackUnpublished";
  }
  protected:
  explicit TrackUnpublished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kPublicationSidFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string publication_sid = 2;
  bool has_publication_sid() const;
  private:
  bool _internal_has_publication_sid() const;
  public:
  void clear_publication_sid();
  const std::string& publication_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publication_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publication_sid();
  PROTOBUF_NODISCARD std::string* release_publication_sid();
  void set_allocated_publication_sid(std::string* publication_sid);
  private:
  const std::string& _internal_publication_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publication_sid(const std::string& value);
  std::string* _internal_mutable_publication_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackUnpublished)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publication_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackSubscribed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackSubscribed) */ {
 public:
  inline TrackSubscribed() : TrackSubscribed(nullptr) {}
  ~TrackSubscribed() override;
  explicit PROTOBUF_CONSTEXPR TrackSubscribed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSubscribed(const TrackSubscribed& from);
  TrackSubscribed(TrackSubscribed&& from) noexcept
    : TrackSubscribed() {
    *this = ::std::move(from);
  }

  inline TrackSubscribed& operator=(const TrackSubscribed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSubscribed& operator=(TrackSubscribed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSubscribed& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackSubscribed* internal_default_instance() {
    return reinterpret_cast<const TrackSubscribed*>(
               &_TrackSubscribed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(TrackSubscribed& a, TrackSubscribed& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSubscribed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSubscribed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSubscribed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSubscribed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSubscribed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackSubscribed& from) {
    TrackSubscribed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSubscribed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackSubscribed";
  }
  protected:
  explicit TrackSubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.OwnedTrack track = 2;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::livekit::proto::OwnedTrack& track() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedTrack* release_track();
  ::livekit::proto::OwnedTrack* mutable_track();
  void set_allocated_track(::livekit::proto::OwnedTrack* track);
  private:
  const ::livekit::proto::OwnedTrack& _internal_track() const;
  ::livekit::proto::OwnedTrack* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::livekit::proto::OwnedTrack* track);
  ::livekit::proto::OwnedTrack* unsafe_arena_release_track();

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackSubscribed)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::OwnedTrack* track_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackUnsubscribed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackUnsubscribed) */ {
 public:
  inline TrackUnsubscribed() : TrackUnsubscribed(nullptr) {}
  ~TrackUnsubscribed() override;
  explicit PROTOBUF_CONSTEXPR TrackUnsubscribed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUnsubscribed(const TrackUnsubscribed& from);
  TrackUnsubscribed(TrackUnsubscribed&& from) noexcept
    : TrackUnsubscribed() {
    *this = ::std::move(from);
  }

  inline TrackUnsubscribed& operator=(const TrackUnsubscribed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnsubscribed& operator=(TrackUnsubscribed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnsubscribed& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUnsubscribed* internal_default_instance() {
    return reinterpret_cast<const TrackUnsubscribed*>(
               &_TrackUnsubscribed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(TrackUnsubscribed& a, TrackUnsubscribed& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUnsubscribed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnsubscribed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnsubscribed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUnsubscribed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUnsubscribed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackUnsubscribed& from) {
    TrackUnsubscribed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUnsubscribed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackUnsubscribed";
  }
  protected:
  explicit TrackUnsubscribed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackUnsubscribed)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackSubscriptionFailed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackSubscriptionFailed) */ {
 public:
  inline TrackSubscriptionFailed() : TrackSubscriptionFailed(nullptr) {}
  ~TrackSubscriptionFailed() override;
  explicit PROTOBUF_CONSTEXPR TrackSubscriptionFailed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackSubscriptionFailed(const TrackSubscriptionFailed& from);
  TrackSubscriptionFailed(TrackSubscriptionFailed&& from) noexcept
    : TrackSubscriptionFailed() {
    *this = ::std::move(from);
  }

  inline TrackSubscriptionFailed& operator=(const TrackSubscriptionFailed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackSubscriptionFailed& operator=(TrackSubscriptionFailed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackSubscriptionFailed& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackSubscriptionFailed* internal_default_instance() {
    return reinterpret_cast<const TrackSubscriptionFailed*>(
               &_TrackSubscriptionFailed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(TrackSubscriptionFailed& a, TrackSubscriptionFailed& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackSubscriptionFailed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackSubscriptionFailed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackSubscriptionFailed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackSubscriptionFailed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackSubscriptionFailed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackSubscriptionFailed& from) {
    TrackSubscriptionFailed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackSubscriptionFailed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackSubscriptionFailed";
  }
  protected:
  explicit TrackSubscriptionFailed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kErrorFieldNumber = 3,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // required string error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackSubscriptionFailed)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackMuted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackMuted) */ {
 public:
  inline TrackMuted() : TrackMuted(nullptr) {}
  ~TrackMuted() override;
  explicit PROTOBUF_CONSTEXPR TrackMuted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackMuted(const TrackMuted& from);
  TrackMuted(TrackMuted&& from) noexcept
    : TrackMuted() {
    *this = ::std::move(from);
  }

  inline TrackMuted& operator=(const TrackMuted& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackMuted& operator=(TrackMuted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackMuted& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackMuted* internal_default_instance() {
    return reinterpret_cast<const TrackMuted*>(
               &_TrackMuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(TrackMuted& a, TrackMuted& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackMuted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackMuted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackMuted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackMuted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackMuted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackMuted& from) {
    TrackMuted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackMuted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackMuted";
  }
  protected:
  explicit TrackMuted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackMuted)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TrackUnmuted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TrackUnmuted) */ {
 public:
  inline TrackUnmuted() : TrackUnmuted(nullptr) {}
  ~TrackUnmuted() override;
  explicit PROTOBUF_CONSTEXPR TrackUnmuted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUnmuted(const TrackUnmuted& from);
  TrackUnmuted(TrackUnmuted&& from) noexcept
    : TrackUnmuted() {
    *this = ::std::move(from);
  }

  inline TrackUnmuted& operator=(const TrackUnmuted& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUnmuted& operator=(TrackUnmuted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUnmuted& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUnmuted* internal_default_instance() {
    return reinterpret_cast<const TrackUnmuted*>(
               &_TrackUnmuted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(TrackUnmuted& a, TrackUnmuted& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUnmuted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUnmuted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUnmuted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUnmuted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUnmuted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackUnmuted& from) {
    TrackUnmuted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUnmuted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TrackUnmuted";
  }
  protected:
  explicit TrackUnmuted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TrackUnmuted)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class E2eeStateChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeStateChanged) */ {
 public:
  inline E2eeStateChanged() : E2eeStateChanged(nullptr) {}
  ~E2eeStateChanged() override;
  explicit PROTOBUF_CONSTEXPR E2eeStateChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeStateChanged(const E2eeStateChanged& from);
  E2eeStateChanged(E2eeStateChanged&& from) noexcept
    : E2eeStateChanged() {
    *this = ::std::move(from);
  }

  inline E2eeStateChanged& operator=(const E2eeStateChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeStateChanged& operator=(E2eeStateChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeStateChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeStateChanged* internal_default_instance() {
    return reinterpret_cast<const E2eeStateChanged*>(
               &_E2eeStateChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(E2eeStateChanged& a, E2eeStateChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeStateChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeStateChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeStateChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeStateChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeStateChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeStateChanged& from) {
    E2eeStateChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeStateChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeStateChanged";
  }
  protected:
  explicit E2eeStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.EncryptionState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::livekit::proto::EncryptionState state() const;
  void set_state(::livekit::proto::EncryptionState value);
  private:
  ::livekit::proto::EncryptionState _internal_state() const;
  void _internal_set_state(::livekit::proto::EncryptionState value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeStateChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ActiveSpeakersChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ActiveSpeakersChanged) */ {
 public:
  inline ActiveSpeakersChanged() : ActiveSpeakersChanged(nullptr) {}
  ~ActiveSpeakersChanged() override;
  explicit PROTOBUF_CONSTEXPR ActiveSpeakersChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActiveSpeakersChanged(const ActiveSpeakersChanged& from);
  ActiveSpeakersChanged(ActiveSpeakersChanged&& from) noexcept
    : ActiveSpeakersChanged() {
    *this = ::std::move(from);
  }

  inline ActiveSpeakersChanged& operator=(const ActiveSpeakersChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActiveSpeakersChanged& operator=(ActiveSpeakersChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActiveSpeakersChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActiveSpeakersChanged* internal_default_instance() {
    return reinterpret_cast<const ActiveSpeakersChanged*>(
               &_ActiveSpeakersChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(ActiveSpeakersChanged& a, ActiveSpeakersChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ActiveSpeakersChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActiveSpeakersChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActiveSpeakersChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActiveSpeakersChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActiveSpeakersChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActiveSpeakersChanged& from) {
    ActiveSpeakersChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveSpeakersChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ActiveSpeakersChanged";
  }
  protected:
  explicit ActiveSpeakersChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentitiesFieldNumber = 1,
  };
  // repeated string participant_identities = 1;
  int participant_identities_size() const;
  private:
  int _internal_participant_identities_size() const;
  public:
  void clear_participant_identities();
  const std::string& participant_identities(int index) const;
  std::string* mutable_participant_identities(int index);
  void set_participant_identities(int index, const std::string& value);
  void set_participant_identities(int index, std::string&& value);
  void set_participant_identities(int index, const char* value);
  void set_participant_identities(int index, const char* value, size_t size);
  std::string* add_participant_identities();
  void add_participant_identities(const std::string& value);
  void add_participant_identities(std::string&& value);
  void add_participant_identities(const char* value);
  void add_participant_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& participant_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_participant_identities();
  private:
  const std::string& _internal_participant_identities(int index) const;
  std::string* _internal_add_participant_identities();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ActiveSpeakersChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> participant_identities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomMetadataChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RoomMetadataChanged) */ {
 public:
  inline RoomMetadataChanged() : RoomMetadataChanged(nullptr) {}
  ~RoomMetadataChanged() override;
  explicit PROTOBUF_CONSTEXPR RoomMetadataChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomMetadataChanged(const RoomMetadataChanged& from);
  RoomMetadataChanged(RoomMetadataChanged&& from) noexcept
    : RoomMetadataChanged() {
    *this = ::std::move(from);
  }

  inline RoomMetadataChanged& operator=(const RoomMetadataChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMetadataChanged& operator=(RoomMetadataChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomMetadataChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomMetadataChanged* internal_default_instance() {
    return reinterpret_cast<const RoomMetadataChanged*>(
               &_RoomMetadataChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(RoomMetadataChanged& a, RoomMetadataChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMetadataChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomMetadataChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomMetadataChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomMetadataChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomMetadataChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomMetadataChanged& from) {
    RoomMetadataChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMetadataChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomMetadataChanged";
  }
  protected:
  explicit RoomMetadataChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
  };
  // required string metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RoomMetadataChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomSidChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RoomSidChanged) */ {
 public:
  inline RoomSidChanged() : RoomSidChanged(nullptr) {}
  ~RoomSidChanged() override;
  explicit PROTOBUF_CONSTEXPR RoomSidChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomSidChanged(const RoomSidChanged& from);
  RoomSidChanged(RoomSidChanged&& from) noexcept
    : RoomSidChanged() {
    *this = ::std::move(from);
  }

  inline RoomSidChanged& operator=(const RoomSidChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomSidChanged& operator=(RoomSidChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomSidChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomSidChanged* internal_default_instance() {
    return reinterpret_cast<const RoomSidChanged*>(
               &_RoomSidChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(RoomSidChanged& a, RoomSidChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomSidChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomSidChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomSidChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomSidChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomSidChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomSidChanged& from) {
    RoomSidChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomSidChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomSidChanged";
  }
  protected:
  explicit RoomSidChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSidFieldNumber = 1,
  };
  // required string sid = 1;
  bool has_sid() const;
  private:
  bool _internal_has_sid() const;
  public:
  void clear_sid();
  const std::string& sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sid();
  PROTOBUF_NODISCARD std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RoomSidChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ParticipantMetadataChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantMetadataChanged) */ {
 public:
  inline ParticipantMetadataChanged() : ParticipantMetadataChanged(nullptr) {}
  ~ParticipantMetadataChanged() override;
  explicit PROTOBUF_CONSTEXPR ParticipantMetadataChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantMetadataChanged(const ParticipantMetadataChanged& from);
  ParticipantMetadataChanged(ParticipantMetadataChanged&& from) noexcept
    : ParticipantMetadataChanged() {
    *this = ::std::move(from);
  }

  inline ParticipantMetadataChanged& operator=(const ParticipantMetadataChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantMetadataChanged& operator=(ParticipantMetadataChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantMetadataChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantMetadataChanged* internal_default_instance() {
    return reinterpret_cast<const ParticipantMetadataChanged*>(
               &_ParticipantMetadataChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ParticipantMetadataChanged& a, ParticipantMetadataChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantMetadataChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantMetadataChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantMetadataChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantMetadataChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantMetadataChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantMetadataChanged& from) {
    ParticipantMetadataChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantMetadataChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantMetadataChanged";
  }
  protected:
  explicit ParticipantMetadataChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantMetadataChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ParticipantAttributesChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantAttributesChanged) */ {
 public:
  inline ParticipantAttributesChanged() : ParticipantAttributesChanged(nullptr) {}
  ~ParticipantAttributesChanged() override;
  explicit PROTOBUF_CONSTEXPR ParticipantAttributesChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantAttributesChanged(const ParticipantAttributesChanged& from);
  ParticipantAttributesChanged(ParticipantAttributesChanged&& from) noexcept
    : ParticipantAttributesChanged() {
    *this = ::std::move(from);
  }

  inline ParticipantAttributesChanged& operator=(const ParticipantAttributesChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantAttributesChanged& operator=(ParticipantAttributesChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantAttributesChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantAttributesChanged* internal_default_instance() {
    return reinterpret_cast<const ParticipantAttributesChanged*>(
               &_ParticipantAttributesChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(ParticipantAttributesChanged& a, ParticipantAttributesChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantAttributesChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantAttributesChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantAttributesChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantAttributesChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantAttributesChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantAttributesChanged& from) {
    ParticipantAttributesChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantAttributesChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantAttributesChanged";
  }
  protected:
  explicit ParticipantAttributesChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kChangedAttributesFieldNumber = 3,
    kParticipantIdentityFieldNumber = 1,
  };
  // repeated .livekit.proto.AttributesEntry attributes = 2;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::livekit::proto::AttributesEntry* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
      mutable_attributes();
  private:
  const ::livekit::proto::AttributesEntry& _internal_attributes(int index) const;
  ::livekit::proto::AttributesEntry* _internal_add_attributes();
  public:
  const ::livekit::proto::AttributesEntry& attributes(int index) const;
  ::livekit::proto::AttributesEntry* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
      attributes() const;

  // repeated .livekit.proto.AttributesEntry changed_attributes = 3;
  int changed_attributes_size() const;
  private:
  int _internal_changed_attributes_size() const;
  public:
  void clear_changed_attributes();
  ::livekit::proto::AttributesEntry* mutable_changed_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
      mutable_changed_attributes();
  private:
  const ::livekit::proto::AttributesEntry& _internal_changed_attributes(int index) const;
  ::livekit::proto::AttributesEntry* _internal_add_changed_attributes();
  public:
  const ::livekit::proto::AttributesEntry& changed_attributes(int index) const;
  ::livekit::proto::AttributesEntry* add_changed_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
      changed_attributes() const;

  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantAttributesChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry > attributes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry > changed_attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ParticipantNameChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ParticipantNameChanged) */ {
 public:
  inline ParticipantNameChanged() : ParticipantNameChanged(nullptr) {}
  ~ParticipantNameChanged() override;
  explicit PROTOBUF_CONSTEXPR ParticipantNameChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParticipantNameChanged(const ParticipantNameChanged& from);
  ParticipantNameChanged(ParticipantNameChanged&& from) noexcept
    : ParticipantNameChanged() {
    *this = ::std::move(from);
  }

  inline ParticipantNameChanged& operator=(const ParticipantNameChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParticipantNameChanged& operator=(ParticipantNameChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParticipantNameChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParticipantNameChanged* internal_default_instance() {
    return reinterpret_cast<const ParticipantNameChanged*>(
               &_ParticipantNameChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ParticipantNameChanged& a, ParticipantNameChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ParticipantNameChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParticipantNameChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParticipantNameChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParticipantNameChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParticipantNameChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParticipantNameChanged& from) {
    ParticipantNameChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParticipantNameChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ParticipantNameChanged";
  }
  protected:
  explicit ParticipantNameChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ParticipantNameChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectionQualityChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectionQualityChanged) */ {
 public:
  inline ConnectionQualityChanged() : ConnectionQualityChanged(nullptr) {}
  ~ConnectionQualityChanged() override;
  explicit PROTOBUF_CONSTEXPR ConnectionQualityChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionQualityChanged(const ConnectionQualityChanged& from);
  ConnectionQualityChanged(ConnectionQualityChanged&& from) noexcept
    : ConnectionQualityChanged() {
    *this = ::std::move(from);
  }

  inline ConnectionQualityChanged& operator=(const ConnectionQualityChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionQualityChanged& operator=(ConnectionQualityChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionQualityChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionQualityChanged* internal_default_instance() {
    return reinterpret_cast<const ConnectionQualityChanged*>(
               &_ConnectionQualityChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ConnectionQualityChanged& a, ConnectionQualityChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionQualityChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionQualityChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionQualityChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionQualityChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionQualityChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionQualityChanged& from) {
    ConnectionQualityChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionQualityChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectionQualityChanged";
  }
  protected:
  explicit ConnectionQualityChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kQualityFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.ConnectionQuality quality = 2;
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  ::livekit::proto::ConnectionQuality quality() const;
  void set_quality(::livekit::proto::ConnectionQuality value);
  private:
  ::livekit::proto::ConnectionQuality _internal_quality() const;
  void _internal_set_quality(::livekit::proto::ConnectionQuality value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectionQualityChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int quality_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class UserPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.UserPacket) */ {
 public:
  inline UserPacket() : UserPacket(nullptr) {}
  ~UserPacket() override;
  explicit PROTOBUF_CONSTEXPR UserPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPacket(const UserPacket& from);
  UserPacket(UserPacket&& from) noexcept
    : UserPacket() {
    *this = ::std::move(from);
  }

  inline UserPacket& operator=(const UserPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPacket& operator=(UserPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPacket* internal_default_instance() {
    return reinterpret_cast<const UserPacket*>(
               &_UserPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(UserPacket& a, UserPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserPacket& from) {
    UserPacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.UserPacket";
  }
  protected:
  explicit UserPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 2,
    kDataFieldNumber = 1,
  };
  // optional string topic = 2;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required .livekit.proto.OwnedBuffer data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::livekit::proto::OwnedBuffer& data() const;
  PROTOBUF_NODISCARD ::livekit::proto::OwnedBuffer* release_data();
  ::livekit::proto::OwnedBuffer* mutable_data();
  void set_allocated_data(::livekit::proto::OwnedBuffer* data);
  private:
  const ::livekit::proto::OwnedBuffer& _internal_data() const;
  ::livekit::proto::OwnedBuffer* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::livekit::proto::OwnedBuffer* data);
  ::livekit::proto::OwnedBuffer* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:livekit.proto.UserPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    ::livekit::proto::OwnedBuffer* data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kEditTimestampFieldNumber = 4,
    kDeletedFieldNumber = 5,
    kGeneratedFieldNumber = 6,
  };
  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int64 edit_timestamp = 4;
  bool has_edit_timestamp() const;
  private:
  bool _internal_has_edit_timestamp() const;
  public:
  void clear_edit_timestamp();
  int64_t edit_timestamp() const;
  void set_edit_timestamp(int64_t value);
  private:
  int64_t _internal_edit_timestamp() const;
  void _internal_set_edit_timestamp(int64_t value);
  public:

  // optional bool deleted = 5;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool generated = 6;
  bool has_generated() const;
  private:
  bool _internal_has_generated() const;
  public:
  void clear_generated();
  bool generated() const;
  void set_generated(bool value);
  private:
  bool _internal_generated() const;
  void _internal_set_generated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ChatMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t timestamp_;
    int64_t edit_timestamp_;
    bool deleted_;
    bool generated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ChatMessageReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ChatMessageReceived) */ {
 public:
  inline ChatMessageReceived() : ChatMessageReceived(nullptr) {}
  ~ChatMessageReceived() override;
  explicit PROTOBUF_CONSTEXPR ChatMessageReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessageReceived(const ChatMessageReceived& from);
  ChatMessageReceived(ChatMessageReceived&& from) noexcept
    : ChatMessageReceived() {
    *this = ::std::move(from);
  }

  inline ChatMessageReceived& operator=(const ChatMessageReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessageReceived& operator=(ChatMessageReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessageReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessageReceived* internal_default_instance() {
    return reinterpret_cast<const ChatMessageReceived*>(
               &_ChatMessageReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ChatMessageReceived& a, ChatMessageReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessageReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessageReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessageReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessageReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessageReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessageReceived& from) {
    ChatMessageReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessageReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ChatMessageReceived";
  }
  protected:
  explicit ChatMessageReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 2,
    kMessageFieldNumber = 1,
  };
  // required string participant_identity = 2;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.ChatMessage message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::livekit::proto::ChatMessage& message() const;
  PROTOBUF_NODISCARD ::livekit::proto::ChatMessage* release_message();
  ::livekit::proto::ChatMessage* mutable_message();
  void set_allocated_message(::livekit::proto::ChatMessage* message);
  private:
  const ::livekit::proto::ChatMessage& _internal_message() const;
  ::livekit::proto::ChatMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::livekit::proto::ChatMessage* message);
  ::livekit::proto::ChatMessage* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:livekit.proto.ChatMessageReceived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::ChatMessage* message_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SipDTMF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SipDTMF) */ {
 public:
  inline SipDTMF() : SipDTMF(nullptr) {}
  ~SipDTMF() override;
  explicit PROTOBUF_CONSTEXPR SipDTMF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SipDTMF(const SipDTMF& from);
  SipDTMF(SipDTMF&& from) noexcept
    : SipDTMF() {
    *this = ::std::move(from);
  }

  inline SipDTMF& operator=(const SipDTMF& from) {
    CopyFrom(from);
    return *this;
  }
  inline SipDTMF& operator=(SipDTMF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SipDTMF& default_instance() {
    return *internal_default_instance();
  }
  static inline const SipDTMF* internal_default_instance() {
    return reinterpret_cast<const SipDTMF*>(
               &_SipDTMF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(SipDTMF& a, SipDTMF& b) {
    a.Swap(&b);
  }
  inline void Swap(SipDTMF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SipDTMF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SipDTMF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SipDTMF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SipDTMF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SipDTMF& from) {
    SipDTMF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipDTMF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SipDTMF";
  }
  protected:
  explicit SipDTMF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigitFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // optional string digit = 2;
  bool has_digit() const;
  private:
  bool _internal_has_digit() const;
  public:
  void clear_digit();
  const std::string& digit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digit();
  PROTOBUF_NODISCARD std::string* release_digit();
  void set_allocated_digit(std::string* digit);
  private:
  const std::string& _internal_digit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digit(const std::string& value);
  std::string* _internal_mutable_digit();
  public:

  // required uint32 code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SipDTMF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digit_;
    uint32_t code_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataPacketReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataPacketReceived) */ {
 public:
  inline DataPacketReceived() : DataPacketReceived(nullptr) {}
  ~DataPacketReceived() override;
  explicit PROTOBUF_CONSTEXPR DataPacketReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataPacketReceived(const DataPacketReceived& from);
  DataPacketReceived(DataPacketReceived&& from) noexcept
    : DataPacketReceived() {
    *this = ::std::move(from);
  }

  inline DataPacketReceived& operator=(const DataPacketReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataPacketReceived& operator=(DataPacketReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataPacketReceived& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUser = 4,
    kSipDtmf = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const DataPacketReceived* internal_default_instance() {
    return reinterpret_cast<const DataPacketReceived*>(
               &_DataPacketReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(DataPacketReceived& a, DataPacketReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(DataPacketReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataPacketReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataPacketReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataPacketReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataPacketReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataPacketReceived& from) {
    DataPacketReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataPacketReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataPacketReceived";
  }
  protected:
  explicit DataPacketReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 2,
    kKindFieldNumber = 1,
    kUserFieldNumber = 4,
    kSipDtmfFieldNumber = 5,
  };
  // required string participant_identity = 2;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.DataPacketKind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::livekit::proto::DataPacketKind kind() const;
  void set_kind(::livekit::proto::DataPacketKind value);
  private:
  ::livekit::proto::DataPacketKind _internal_kind() const;
  void _internal_set_kind(::livekit::proto::DataPacketKind value);
  public:

  // .livekit.proto.UserPacket user = 4;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::livekit::proto::UserPacket& user() const;
  PROTOBUF_NODISCARD ::livekit::proto::UserPacket* release_user();
  ::livekit::proto::UserPacket* mutable_user();
  void set_allocated_user(::livekit::proto::UserPacket* user);
  private:
  const ::livekit::proto::UserPacket& _internal_user() const;
  ::livekit::proto::UserPacket* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::livekit::proto::UserPacket* user);
  ::livekit::proto::UserPacket* unsafe_arena_release_user();

  // .livekit.proto.SipDTMF sip_dtmf = 5;
  bool has_sip_dtmf() const;
  private:
  bool _internal_has_sip_dtmf() const;
  public:
  void clear_sip_dtmf();
  const ::livekit::proto::SipDTMF& sip_dtmf() const;
  PROTOBUF_NODISCARD ::livekit::proto::SipDTMF* release_sip_dtmf();
  ::livekit::proto::SipDTMF* mutable_sip_dtmf();
  void set_allocated_sip_dtmf(::livekit::proto::SipDTMF* sip_dtmf);
  private:
  const ::livekit::proto::SipDTMF& _internal_sip_dtmf() const;
  ::livekit::proto::SipDTMF* _internal_mutable_sip_dtmf();
  public:
  void unsafe_arena_set_allocated_sip_dtmf(
      ::livekit::proto::SipDTMF* sip_dtmf);
  ::livekit::proto::SipDTMF* unsafe_arena_release_sip_dtmf();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.DataPacketReceived)
 private:
  class _Internal;
  void set_has_user();
  void set_has_sip_dtmf();

  inline bool has_value() const;
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int kind_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::UserPacket* user_;
      ::livekit::proto::SipDTMF* sip_dtmf_;
    } value_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class TranscriptionReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.TranscriptionReceived) */ {
 public:
  inline TranscriptionReceived() : TranscriptionReceived(nullptr) {}
  ~TranscriptionReceived() override;
  explicit PROTOBUF_CONSTEXPR TranscriptionReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TranscriptionReceived(const TranscriptionReceived& from);
  TranscriptionReceived(TranscriptionReceived&& from) noexcept
    : TranscriptionReceived() {
    *this = ::std::move(from);
  }

  inline TranscriptionReceived& operator=(const TranscriptionReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranscriptionReceived& operator=(TranscriptionReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranscriptionReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranscriptionReceived* internal_default_instance() {
    return reinterpret_cast<const TranscriptionReceived*>(
               &_TranscriptionReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(TranscriptionReceived& a, TranscriptionReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(TranscriptionReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranscriptionReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranscriptionReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TranscriptionReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TranscriptionReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TranscriptionReceived& from) {
    TranscriptionReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TranscriptionReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.TranscriptionReceived";
  }
  protected:
  explicit TranscriptionReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 3,
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
  };
  // repeated .livekit.proto.TranscriptionSegment segments = 3;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::livekit::proto::TranscriptionSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >*
      mutable_segments();
  private:
  const ::livekit::proto::TranscriptionSegment& _internal_segments(int index) const;
  ::livekit::proto::TranscriptionSegment* _internal_add_segments();
  public:
  const ::livekit::proto::TranscriptionSegment& segments(int index) const;
  ::livekit::proto::TranscriptionSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >&
      segments() const;

  // optional string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // optional string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.TranscriptionReceived)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment > segments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class ConnectionStateChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.ConnectionStateChanged) */ {
 public:
  inline ConnectionStateChanged() : ConnectionStateChanged(nullptr) {}
  ~ConnectionStateChanged() override;
  explicit PROTOBUF_CONSTEXPR ConnectionStateChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionStateChanged(const ConnectionStateChanged& from);
  ConnectionStateChanged(ConnectionStateChanged&& from) noexcept
    : ConnectionStateChanged() {
    *this = ::std::move(from);
  }

  inline ConnectionStateChanged& operator=(const ConnectionStateChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionStateChanged& operator=(ConnectionStateChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionStateChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionStateChanged* internal_default_instance() {
    return reinterpret_cast<const ConnectionStateChanged*>(
               &_ConnectionStateChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ConnectionStateChanged& a, ConnectionStateChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionStateChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionStateChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionStateChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionStateChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionStateChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionStateChanged& from) {
    ConnectionStateChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionStateChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.ConnectionStateChanged";
  }
  protected:
  explicit ConnectionStateChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .livekit.proto.ConnectionState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::livekit::proto::ConnectionState state() const;
  void set_state(::livekit::proto::ConnectionState value);
  private:
  ::livekit::proto::ConnectionState _internal_state() const;
  void _internal_set_state(::livekit::proto::ConnectionState value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.ConnectionStateChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class Connected final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.Connected) */ {
 public:
  inline Connected() : Connected(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Connected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connected(const Connected& from);
  Connected(Connected&& from) noexcept
    : Connected() {
    *this = ::std::move(from);
  }

  inline Connected& operator=(const Connected& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connected& operator=(Connected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connected& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connected* internal_default_instance() {
    return reinterpret_cast<const Connected*>(
               &_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(Connected& a, Connected& b) {
    a.Swap(&b);
  }
  inline void Swap(Connected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Connected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.Connected";
  }
  protected:
  explicit Connected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.Connected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class Disconnected final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.Disconnected) */ {
 public:
  inline Disconnected() : Disconnected(nullptr) {}
  ~Disconnected() override;
  explicit PROTOBUF_CONSTEXPR Disconnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disconnected(const Disconnected& from);
  Disconnected(Disconnected&& from) noexcept
    : Disconnected() {
    *this = ::std::move(from);
  }

  inline Disconnected& operator=(const Disconnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disconnected& operator=(Disconnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disconnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disconnected* internal_default_instance() {
    return reinterpret_cast<const Disconnected*>(
               &_Disconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(Disconnected& a, Disconnected& b) {
    a.Swap(&b);
  }
  inline void Swap(Disconnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disconnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disconnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Disconnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Disconnected& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Disconnected& from) {
    Disconnected::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Disconnected* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.Disconnected";
  }
  protected:
  explicit Disconnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // required .livekit.proto.DisconnectReason reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::livekit::proto::DisconnectReason reason() const;
  void set_reason(::livekit::proto::DisconnectReason value);
  private:
  ::livekit::proto::DisconnectReason _internal_reason() const;
  void _internal_set_reason(::livekit::proto::DisconnectReason value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.Disconnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class Reconnecting final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.Reconnecting) */ {
 public:
  inline Reconnecting() : Reconnecting(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Reconnecting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reconnecting(const Reconnecting& from);
  Reconnecting(Reconnecting&& from) noexcept
    : Reconnecting() {
    *this = ::std::move(from);
  }

  inline Reconnecting& operator=(const Reconnecting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reconnecting& operator=(Reconnecting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reconnecting& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reconnecting* internal_default_instance() {
    return reinterpret_cast<const Reconnecting*>(
               &_Reconnecting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(Reconnecting& a, Reconnecting& b) {
    a.Swap(&b);
  }
  inline void Swap(Reconnecting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reconnecting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reconnecting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reconnecting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Reconnecting& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Reconnecting& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.Reconnecting";
  }
  protected:
  explicit Reconnecting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.Reconnecting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class Reconnected final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.Reconnected) */ {
 public:
  inline Reconnected() : Reconnected(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Reconnected(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reconnected(const Reconnected& from);
  Reconnected(Reconnected&& from) noexcept
    : Reconnected() {
    *this = ::std::move(from);
  }

  inline Reconnected& operator=(const Reconnected& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reconnected& operator=(Reconnected&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reconnected& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reconnected* internal_default_instance() {
    return reinterpret_cast<const Reconnected*>(
               &_Reconnected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(Reconnected& a, Reconnected& b) {
    a.Swap(&b);
  }
  inline void Swap(Reconnected* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reconnected* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reconnected* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reconnected>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Reconnected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Reconnected& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.Reconnected";
  }
  protected:
  explicit Reconnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.Reconnected)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class RoomEOS final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.RoomEOS) */ {
 public:
  inline RoomEOS() : RoomEOS(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RoomEOS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomEOS(const RoomEOS& from);
  RoomEOS(RoomEOS&& from) noexcept
    : RoomEOS() {
    *this = ::std::move(from);
  }

  inline RoomEOS& operator=(const RoomEOS& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomEOS& operator=(RoomEOS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomEOS& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomEOS* internal_default_instance() {
    return reinterpret_cast<const RoomEOS*>(
               &_RoomEOS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(RoomEOS& a, RoomEOS& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomEOS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomEOS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomEOS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomEOS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RoomEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RoomEOS& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RoomEOS";
  }
  protected:
  explicit RoomEOS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.RoomEOS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream_TextHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream.TextHeader) */ {
 public:
  inline DataStream_TextHeader() : DataStream_TextHeader(nullptr) {}
  ~DataStream_TextHeader() override;
  explicit PROTOBUF_CONSTEXPR DataStream_TextHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_TextHeader(const DataStream_TextHeader& from);
  DataStream_TextHeader(DataStream_TextHeader&& from) noexcept
    : DataStream_TextHeader() {
    *this = ::std::move(from);
  }

  inline DataStream_TextHeader& operator=(const DataStream_TextHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_TextHeader& operator=(DataStream_TextHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_TextHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_TextHeader* internal_default_instance() {
    return reinterpret_cast<const DataStream_TextHeader*>(
               &_DataStream_TextHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(DataStream_TextHeader& a, DataStream_TextHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_TextHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_TextHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_TextHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_TextHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_TextHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_TextHeader& from) {
    DataStream_TextHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_TextHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream.TextHeader";
  }
  protected:
  explicit DataStream_TextHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedStreamIdsFieldNumber = 4,
    kReplyToStreamIdFieldNumber = 3,
    kOperationTypeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kGeneratedFieldNumber = 5,
  };
  // repeated string attached_stream_ids = 4;
  int attached_stream_ids_size() const;
  private:
  int _internal_attached_stream_ids_size() const;
  public:
  void clear_attached_stream_ids();
  const std::string& attached_stream_ids(int index) const;
  std::string* mutable_attached_stream_ids(int index);
  void set_attached_stream_ids(int index, const std::string& value);
  void set_attached_stream_ids(int index, std::string&& value);
  void set_attached_stream_ids(int index, const char* value);
  void set_attached_stream_ids(int index, const char* value, size_t size);
  std::string* add_attached_stream_ids();
  void add_attached_stream_ids(const std::string& value);
  void add_attached_stream_ids(std::string&& value);
  void add_attached_stream_ids(const char* value);
  void add_attached_stream_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attached_stream_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attached_stream_ids();
  private:
  const std::string& _internal_attached_stream_ids(int index) const;
  std::string* _internal_add_attached_stream_ids();
  public:

  // optional string reply_to_stream_id = 3;
  bool has_reply_to_stream_id() const;
  private:
  bool _internal_has_reply_to_stream_id() const;
  public:
  void clear_reply_to_stream_id();
  const std::string& reply_to_stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to_stream_id();
  PROTOBUF_NODISCARD std::string* release_reply_to_stream_id();
  void set_allocated_reply_to_stream_id(std::string* reply_to_stream_id);
  private:
  const std::string& _internal_reply_to_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to_stream_id(const std::string& value);
  std::string* _internal_mutable_reply_to_stream_id();
  public:

  // required .livekit.proto.DataStream.OperationType operation_type = 1;
  bool has_operation_type() const;
  private:
  bool _internal_has_operation_type() const;
  public:
  void clear_operation_type();
  ::livekit::proto::DataStream_OperationType operation_type() const;
  void set_operation_type(::livekit::proto::DataStream_OperationType value);
  private:
  ::livekit::proto::DataStream_OperationType _internal_operation_type() const;
  void _internal_set_operation_type(::livekit::proto::DataStream_OperationType value);
  public:

  // optional int32 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // optional bool generated = 5;
  bool has_generated() const;
  private:
  bool _internal_has_generated() const;
  public:
  void clear_generated();
  bool generated() const;
  void set_generated(bool value);
  private:
  bool _internal_generated() const;
  void _internal_set_generated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream.TextHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attached_stream_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_stream_id_;
    int operation_type_;
    int32_t version_;
    bool generated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream_ByteHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream.ByteHeader) */ {
 public:
  inline DataStream_ByteHeader() : DataStream_ByteHeader(nullptr) {}
  ~DataStream_ByteHeader() override;
  explicit PROTOBUF_CONSTEXPR DataStream_ByteHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_ByteHeader(const DataStream_ByteHeader& from);
  DataStream_ByteHeader(DataStream_ByteHeader&& from) noexcept
    : DataStream_ByteHeader() {
    *this = ::std::move(from);
  }

  inline DataStream_ByteHeader& operator=(const DataStream_ByteHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_ByteHeader& operator=(DataStream_ByteHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_ByteHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_ByteHeader* internal_default_instance() {
    return reinterpret_cast<const DataStream_ByteHeader*>(
               &_DataStream_ByteHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(DataStream_ByteHeader& a, DataStream_ByteHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_ByteHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_ByteHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_ByteHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_ByteHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_ByteHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_ByteHeader& from) {
    DataStream_ByteHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_ByteHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream.ByteHeader";
  }
  protected:
  explicit DataStream_ByteHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream.ByteHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Header_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Header_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Header_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DataStream_Header_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataStream_Header_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataStream_Header_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataStream_Header_AttributesEntry_DoNotUse& other);
  static const DataStream_Header_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataStream_Header_AttributesEntry_DoNotUse*>(&_DataStream_Header_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.proto.DataStream.Header.AttributesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.proto.DataStream.Header.AttributesEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_room_2eproto;
};

// -------------------------------------------------------------------

class DataStream_Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream.Header) */ {
 public:
  inline DataStream_Header() : DataStream_Header(nullptr) {}
  ~DataStream_Header() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Header(const DataStream_Header& from);
  DataStream_Header(DataStream_Header&& from) noexcept
    : DataStream_Header() {
    *this = ::std::move(from);
  }

  inline DataStream_Header& operator=(const DataStream_Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Header& operator=(DataStream_Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Header& default_instance() {
    return *internal_default_instance();
  }
  enum ContentHeaderCase {
    kTextHeader = 7,
    kByteHeader = 8,
    CONTENT_HEADER_NOT_SET = 0,
  };

  static inline const DataStream_Header* internal_default_instance() {
    return reinterpret_cast<const DataStream_Header*>(
               &_DataStream_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(DataStream_Header& a, DataStream_Header& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Header& from) {
    DataStream_Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream.Header";
  }
  protected:
  explicit DataStream_Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kStreamIdFieldNumber = 1,
    kMimeTypeFieldNumber = 3,
    kTopicFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kTotalLengthFieldNumber = 5,
    kTextHeaderFieldNumber = 7,
    kByteHeaderFieldNumber = 8,
  };
  // map<string, string> attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // required string stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // required string mime_type = 3;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // required string topic = 4;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional uint64 total_length = 5;
  bool has_total_length() const;
  private:
  bool _internal_has_total_length() const;
  public:
  void clear_total_length();
  uint64_t total_length() const;
  void set_total_length(uint64_t value);
  private:
  uint64_t _internal_total_length() const;
  void _internal_set_total_length(uint64_t value);
  public:

  // .livekit.proto.DataStream.TextHeader text_header = 7;
  bool has_text_header() const;
  private:
  bool _internal_has_text_header() const;
  public:
  void clear_text_header();
  const ::livekit::proto::DataStream_TextHeader& text_header() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_TextHeader* release_text_header();
  ::livekit::proto::DataStream_TextHeader* mutable_text_header();
  void set_allocated_text_header(::livekit::proto::DataStream_TextHeader* text_header);
  private:
  const ::livekit::proto::DataStream_TextHeader& _internal_text_header() const;
  ::livekit::proto::DataStream_TextHeader* _internal_mutable_text_header();
  public:
  void unsafe_arena_set_allocated_text_header(
      ::livekit::proto::DataStream_TextHeader* text_header);
  ::livekit::proto::DataStream_TextHeader* unsafe_arena_release_text_header();

  // .livekit.proto.DataStream.ByteHeader byte_header = 8;
  bool has_byte_header() const;
  private:
  bool _internal_has_byte_header() const;
  public:
  void clear_byte_header();
  const ::livekit::proto::DataStream_ByteHeader& byte_header() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_ByteHeader* release_byte_header();
  ::livekit::proto::DataStream_ByteHeader* mutable_byte_header();
  void set_allocated_byte_header(::livekit::proto::DataStream_ByteHeader* byte_header);
  private:
  const ::livekit::proto::DataStream_ByteHeader& _internal_byte_header() const;
  ::livekit::proto::DataStream_ByteHeader* _internal_mutable_byte_header();
  public:
  void unsafe_arena_set_allocated_byte_header(
      ::livekit::proto::DataStream_ByteHeader* byte_header);
  ::livekit::proto::DataStream_ByteHeader* unsafe_arena_release_byte_header();

  void clear_content_header();
  ContentHeaderCase content_header_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream.Header)
 private:
  class _Internal;
  void set_has_text_header();
  void set_has_byte_header();

  inline bool has_content_header() const;
  inline void clear_has_content_header();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DataStream_Header_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    int64_t timestamp_;
    uint64_t total_length_;
    union ContentHeaderUnion {
      constexpr ContentHeaderUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::DataStream_TextHeader* text_header_;
      ::livekit::proto::DataStream_ByteHeader* byte_header_;
    } content_header_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream.Chunk) */ {
 public:
  inline DataStream_Chunk() : DataStream_Chunk(nullptr) {}
  ~DataStream_Chunk() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Chunk(const DataStream_Chunk& from);
  DataStream_Chunk(DataStream_Chunk&& from) noexcept
    : DataStream_Chunk() {
    *this = ::std::move(from);
  }

  inline DataStream_Chunk& operator=(const DataStream_Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Chunk& operator=(DataStream_Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Chunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_Chunk* internal_default_instance() {
    return reinterpret_cast<const DataStream_Chunk*>(
               &_DataStream_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(DataStream_Chunk& a, DataStream_Chunk& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Chunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Chunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Chunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Chunk& from) {
    DataStream_Chunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Chunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream.Chunk";
  }
  protected:
  explicit DataStream_Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamIdFieldNumber = 1,
    kContentFieldNumber = 3,
    kIvFieldNumber = 5,
    kChunkIndexFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // required string stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // required bytes content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional bytes iv = 5;
  bool has_iv() const;
  private:
  bool _internal_has_iv() const;
  public:
  void clear_iv();
  const std::string& iv() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iv(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iv();
  PROTOBUF_NODISCARD std::string* release_iv();
  void set_allocated_iv(std::string* iv);
  private:
  const std::string& _internal_iv() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iv(const std::string& value);
  std::string* _internal_mutable_iv();
  public:

  // required uint64 chunk_index = 2;
  bool has_chunk_index() const;
  private:
  bool _internal_has_chunk_index() const;
  public:
  void clear_chunk_index();
  uint64_t chunk_index() const;
  void set_chunk_index(uint64_t value);
  private:
  uint64_t _internal_chunk_index() const;
  void _internal_set_chunk_index(uint64_t value);
  public:

  // optional int32 version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream.Chunk)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iv_;
    uint64_t chunk_index_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream_Trailer_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Trailer_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DataStream_Trailer_AttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DataStream_Trailer_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DataStream_Trailer_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DataStream_Trailer_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DataStream_Trailer_AttributesEntry_DoNotUse& other);
  static const DataStream_Trailer_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataStream_Trailer_AttributesEntry_DoNotUse*>(&_DataStream_Trailer_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.proto.DataStream.Trailer.AttributesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.proto.DataStream.Trailer.AttributesEntry.value");
#else
    (void) s;
#endif
    return true;
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_room_2eproto;
};

// -------------------------------------------------------------------

class DataStream_Trailer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream.Trailer) */ {
 public:
  inline DataStream_Trailer() : DataStream_Trailer(nullptr) {}
  ~DataStream_Trailer() override;
  explicit PROTOBUF_CONSTEXPR DataStream_Trailer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream_Trailer(const DataStream_Trailer& from);
  DataStream_Trailer(DataStream_Trailer&& from) noexcept
    : DataStream_Trailer() {
    *this = ::std::move(from);
  }

  inline DataStream_Trailer& operator=(const DataStream_Trailer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream_Trailer& operator=(DataStream_Trailer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream_Trailer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream_Trailer* internal_default_instance() {
    return reinterpret_cast<const DataStream_Trailer*>(
               &_DataStream_Trailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(DataStream_Trailer& a, DataStream_Trailer& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream_Trailer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream_Trailer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream_Trailer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream_Trailer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStream_Trailer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStream_Trailer& from) {
    DataStream_Trailer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStream_Trailer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream.Trailer";
  }
  protected:
  explicit DataStream_Trailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 3,
    kStreamIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // map<string, string> attributes = 3;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attributes();

  // required string stream_id = 1;
  bool has_stream_id() const;
  private:
  bool _internal_has_stream_id() const;
  public:
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // required string reason = 2;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream.Trailer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DataStream_Trailer_AttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStream final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.DataStream) */ {
 public:
  inline DataStream() : DataStream(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DataStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStream(const DataStream& from);
  DataStream(DataStream&& from) noexcept
    : DataStream() {
    *this = ::std::move(from);
  }

  inline DataStream& operator=(const DataStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStream& operator=(DataStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStream* internal_default_instance() {
    return reinterpret_cast<const DataStream*>(
               &_DataStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(DataStream& a, DataStream& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DataStream& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DataStream& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStream";
  }
  protected:
  explicit DataStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataStream_TextHeader TextHeader;
  typedef DataStream_ByteHeader ByteHeader;
  typedef DataStream_Header Header;
  typedef DataStream_Chunk Chunk;
  typedef DataStream_Trailer Trailer;

  typedef DataStream_OperationType OperationType;
  static constexpr OperationType CREATE =
    DataStream_OperationType_CREATE;
  static constexpr OperationType UPDATE =
    DataStream_OperationType_UPDATE;
  static constexpr OperationType DELETE =
    DataStream_OperationType_DELETE;
  static constexpr OperationType REACTION =
    DataStream_OperationType_REACTION;
  static inline bool OperationType_IsValid(int value) {
    return DataStream_OperationType_IsValid(value);
  }
  static constexpr OperationType OperationType_MIN =
    DataStream_OperationType_OperationType_MIN;
  static constexpr OperationType OperationType_MAX =
    DataStream_OperationType_OperationType_MAX;
  static constexpr int OperationType_ARRAYSIZE =
    DataStream_OperationType_OperationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperationType_descriptor() {
    return DataStream_OperationType_descriptor();
  }
  template<typename T>
  static inline const std::string& OperationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperationType_Name.");
    return DataStream_OperationType_Name(enum_t_value);
  }
  static inline bool OperationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperationType* value) {
    return DataStream_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStreamHeaderReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStreamHeaderReceived) */ {
 public:
  inline DataStreamHeaderReceived() : DataStreamHeaderReceived(nullptr) {}
  ~DataStreamHeaderReceived() override;
  explicit PROTOBUF_CONSTEXPR DataStreamHeaderReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStreamHeaderReceived(const DataStreamHeaderReceived& from);
  DataStreamHeaderReceived(DataStreamHeaderReceived&& from) noexcept
    : DataStreamHeaderReceived() {
    *this = ::std::move(from);
  }

  inline DataStreamHeaderReceived& operator=(const DataStreamHeaderReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStreamHeaderReceived& operator=(DataStreamHeaderReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStreamHeaderReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStreamHeaderReceived* internal_default_instance() {
    return reinterpret_cast<const DataStreamHeaderReceived*>(
               &_DataStreamHeaderReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(DataStreamHeaderReceived& a, DataStreamHeaderReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStreamHeaderReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStreamHeaderReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStreamHeaderReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStreamHeaderReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStreamHeaderReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStreamHeaderReceived& from) {
    DataStreamHeaderReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStreamHeaderReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStreamHeaderReceived";
  }
  protected:
  explicit DataStreamHeaderReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kHeaderFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.DataStream.Header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::livekit::proto::DataStream_Header& header() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Header* release_header();
  ::livekit::proto::DataStream_Header* mutable_header();
  void set_allocated_header(::livekit::proto::DataStream_Header* header);
  private:
  const ::livekit::proto::DataStream_Header& _internal_header() const;
  ::livekit::proto::DataStream_Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::livekit::proto::DataStream_Header* header);
  ::livekit::proto::DataStream_Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStreamHeaderReceived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::DataStream_Header* header_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStreamChunkReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStreamChunkReceived) */ {
 public:
  inline DataStreamChunkReceived() : DataStreamChunkReceived(nullptr) {}
  ~DataStreamChunkReceived() override;
  explicit PROTOBUF_CONSTEXPR DataStreamChunkReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStreamChunkReceived(const DataStreamChunkReceived& from);
  DataStreamChunkReceived(DataStreamChunkReceived&& from) noexcept
    : DataStreamChunkReceived() {
    *this = ::std::move(from);
  }

  inline DataStreamChunkReceived& operator=(const DataStreamChunkReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStreamChunkReceived& operator=(DataStreamChunkReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStreamChunkReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStreamChunkReceived* internal_default_instance() {
    return reinterpret_cast<const DataStreamChunkReceived*>(
               &_DataStreamChunkReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(DataStreamChunkReceived& a, DataStreamChunkReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStreamChunkReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStreamChunkReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStreamChunkReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStreamChunkReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStreamChunkReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStreamChunkReceived& from) {
    DataStreamChunkReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStreamChunkReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStreamChunkReceived";
  }
  protected:
  explicit DataStreamChunkReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kChunkFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.DataStream.Chunk chunk = 2;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::livekit::proto::DataStream_Chunk& chunk() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Chunk* release_chunk();
  ::livekit::proto::DataStream_Chunk* mutable_chunk();
  void set_allocated_chunk(::livekit::proto::DataStream_Chunk* chunk);
  private:
  const ::livekit::proto::DataStream_Chunk& _internal_chunk() const;
  ::livekit::proto::DataStream_Chunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::livekit::proto::DataStream_Chunk* chunk);
  ::livekit::proto::DataStream_Chunk* unsafe_arena_release_chunk();

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStreamChunkReceived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::DataStream_Chunk* chunk_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataStreamTrailerReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataStreamTrailerReceived) */ {
 public:
  inline DataStreamTrailerReceived() : DataStreamTrailerReceived(nullptr) {}
  ~DataStreamTrailerReceived() override;
  explicit PROTOBUF_CONSTEXPR DataStreamTrailerReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStreamTrailerReceived(const DataStreamTrailerReceived& from);
  DataStreamTrailerReceived(DataStreamTrailerReceived&& from) noexcept
    : DataStreamTrailerReceived() {
    *this = ::std::move(from);
  }

  inline DataStreamTrailerReceived& operator=(const DataStreamTrailerReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStreamTrailerReceived& operator=(DataStreamTrailerReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStreamTrailerReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStreamTrailerReceived* internal_default_instance() {
    return reinterpret_cast<const DataStreamTrailerReceived*>(
               &_DataStreamTrailerReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(DataStreamTrailerReceived& a, DataStreamTrailerReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStreamTrailerReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStreamTrailerReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStreamTrailerReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStreamTrailerReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStreamTrailerReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStreamTrailerReceived& from) {
    DataStreamTrailerReceived::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStreamTrailerReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataStreamTrailerReceived";
  }
  protected:
  explicit DataStreamTrailerReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrailerFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required .livekit.proto.DataStream.Trailer trailer = 2;
  bool has_trailer() const;
  private:
  bool _internal_has_trailer() const;
  public:
  void clear_trailer();
  const ::livekit::proto::DataStream_Trailer& trailer() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Trailer* release_trailer();
  ::livekit::proto::DataStream_Trailer* mutable_trailer();
  void set_allocated_trailer(::livekit::proto::DataStream_Trailer* trailer);
  private:
  const ::livekit::proto::DataStream_Trailer& _internal_trailer() const;
  ::livekit::proto::DataStream_Trailer* _internal_mutable_trailer();
  public:
  void unsafe_arena_set_allocated_trailer(
      ::livekit::proto::DataStream_Trailer* trailer);
  ::livekit::proto::DataStream_Trailer* unsafe_arena_release_trailer();

  // @@protoc_insertion_point(class_scope:livekit.proto.DataStreamTrailerReceived)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::livekit::proto::DataStream_Trailer* trailer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamHeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamHeaderRequest) */ {
 public:
  inline SendStreamHeaderRequest() : SendStreamHeaderRequest(nullptr) {}
  ~SendStreamHeaderRequest() override;
  explicit PROTOBUF_CONSTEXPR SendStreamHeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamHeaderRequest(const SendStreamHeaderRequest& from);
  SendStreamHeaderRequest(SendStreamHeaderRequest&& from) noexcept
    : SendStreamHeaderRequest() {
    *this = ::std::move(from);
  }

  inline SendStreamHeaderRequest& operator=(const SendStreamHeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamHeaderRequest& operator=(SendStreamHeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamHeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamHeaderRequest* internal_default_instance() {
    return reinterpret_cast<const SendStreamHeaderRequest*>(
               &_SendStreamHeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(SendStreamHeaderRequest& a, SendStreamHeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamHeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamHeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamHeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamHeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamHeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamHeaderRequest& from) {
    SendStreamHeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamHeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamHeaderRequest";
  }
  protected:
  explicit SendStreamHeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 3,
    kSenderIdentityFieldNumber = 4,
    kHeaderFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated string destination_identities = 3;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string sender_identity = 4;
  bool has_sender_identity() const;
  private:
  bool _internal_has_sender_identity() const;
  public:
  void clear_sender_identity();
  const std::string& sender_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_identity();
  PROTOBUF_NODISCARD std::string* release_sender_identity();
  void set_allocated_sender_identity(std::string* sender_identity);
  private:
  const std::string& _internal_sender_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_identity(const std::string& value);
  std::string* _internal_mutable_sender_identity();
  public:

  // required .livekit.proto.DataStream.Header header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::livekit::proto::DataStream_Header& header() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Header* release_header();
  ::livekit::proto::DataStream_Header* mutable_header();
  void set_allocated_header(::livekit::proto::DataStream_Header* header);
  private:
  const ::livekit::proto::DataStream_Header& _internal_header() const;
  ::livekit::proto::DataStream_Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::livekit::proto::DataStream_Header* header);
  ::livekit::proto::DataStream_Header* unsafe_arena_release_header();

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamHeaderRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_identity_;
    ::livekit::proto::DataStream_Header* header_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamChunkRequest) */ {
 public:
  inline SendStreamChunkRequest() : SendStreamChunkRequest(nullptr) {}
  ~SendStreamChunkRequest() override;
  explicit PROTOBUF_CONSTEXPR SendStreamChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamChunkRequest(const SendStreamChunkRequest& from);
  SendStreamChunkRequest(SendStreamChunkRequest&& from) noexcept
    : SendStreamChunkRequest() {
    *this = ::std::move(from);
  }

  inline SendStreamChunkRequest& operator=(const SendStreamChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamChunkRequest& operator=(SendStreamChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamChunkRequest* internal_default_instance() {
    return reinterpret_cast<const SendStreamChunkRequest*>(
               &_SendStreamChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(SendStreamChunkRequest& a, SendStreamChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamChunkRequest& from) {
    SendStreamChunkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamChunkRequest";
  }
  protected:
  explicit SendStreamChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 3,
    kSenderIdentityFieldNumber = 4,
    kChunkFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated string destination_identities = 3;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string sender_identity = 4;
  bool has_sender_identity() const;
  private:
  bool _internal_has_sender_identity() const;
  public:
  void clear_sender_identity();
  const std::string& sender_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_identity();
  PROTOBUF_NODISCARD std::string* release_sender_identity();
  void set_allocated_sender_identity(std::string* sender_identity);
  private:
  const std::string& _internal_sender_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_identity(const std::string& value);
  std::string* _internal_mutable_sender_identity();
  public:

  // required .livekit.proto.DataStream.Chunk chunk = 2;
  bool has_chunk() const;
  private:
  bool _internal_has_chunk() const;
  public:
  void clear_chunk();
  const ::livekit::proto::DataStream_Chunk& chunk() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Chunk* release_chunk();
  ::livekit::proto::DataStream_Chunk* mutable_chunk();
  void set_allocated_chunk(::livekit::proto::DataStream_Chunk* chunk);
  private:
  const ::livekit::proto::DataStream_Chunk& _internal_chunk() const;
  ::livekit::proto::DataStream_Chunk* _internal_mutable_chunk();
  public:
  void unsafe_arena_set_allocated_chunk(
      ::livekit::proto::DataStream_Chunk* chunk);
  ::livekit::proto::DataStream_Chunk* unsafe_arena_release_chunk();

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamChunkRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_identity_;
    ::livekit::proto::DataStream_Chunk* chunk_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamTrailerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamTrailerRequest) */ {
 public:
  inline SendStreamTrailerRequest() : SendStreamTrailerRequest(nullptr) {}
  ~SendStreamTrailerRequest() override;
  explicit PROTOBUF_CONSTEXPR SendStreamTrailerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamTrailerRequest(const SendStreamTrailerRequest& from);
  SendStreamTrailerRequest(SendStreamTrailerRequest&& from) noexcept
    : SendStreamTrailerRequest() {
    *this = ::std::move(from);
  }

  inline SendStreamTrailerRequest& operator=(const SendStreamTrailerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamTrailerRequest& operator=(SendStreamTrailerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamTrailerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamTrailerRequest* internal_default_instance() {
    return reinterpret_cast<const SendStreamTrailerRequest*>(
               &_SendStreamTrailerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(SendStreamTrailerRequest& a, SendStreamTrailerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamTrailerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamTrailerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamTrailerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamTrailerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamTrailerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamTrailerRequest& from) {
    SendStreamTrailerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamTrailerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamTrailerRequest";
  }
  protected:
  explicit SendStreamTrailerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestinationIdentitiesFieldNumber = 3,
    kSenderIdentityFieldNumber = 4,
    kTrailerFieldNumber = 2,
    kLocalParticipantHandleFieldNumber = 1,
  };
  // repeated string destination_identities = 3;
  int destination_identities_size() const;
  private:
  int _internal_destination_identities_size() const;
  public:
  void clear_destination_identities();
  const std::string& destination_identities(int index) const;
  std::string* mutable_destination_identities(int index);
  void set_destination_identities(int index, const std::string& value);
  void set_destination_identities(int index, std::string&& value);
  void set_destination_identities(int index, const char* value);
  void set_destination_identities(int index, const char* value, size_t size);
  std::string* add_destination_identities();
  void add_destination_identities(const std::string& value);
  void add_destination_identities(std::string&& value);
  void add_destination_identities(const char* value);
  void add_destination_identities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& destination_identities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_destination_identities();
  private:
  const std::string& _internal_destination_identities(int index) const;
  std::string* _internal_add_destination_identities();
  public:

  // required string sender_identity = 4;
  bool has_sender_identity() const;
  private:
  bool _internal_has_sender_identity() const;
  public:
  void clear_sender_identity();
  const std::string& sender_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_identity();
  PROTOBUF_NODISCARD std::string* release_sender_identity();
  void set_allocated_sender_identity(std::string* sender_identity);
  private:
  const std::string& _internal_sender_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_identity(const std::string& value);
  std::string* _internal_mutable_sender_identity();
  public:

  // required .livekit.proto.DataStream.Trailer trailer = 2;
  bool has_trailer() const;
  private:
  bool _internal_has_trailer() const;
  public:
  void clear_trailer();
  const ::livekit::proto::DataStream_Trailer& trailer() const;
  PROTOBUF_NODISCARD ::livekit::proto::DataStream_Trailer* release_trailer();
  ::livekit::proto::DataStream_Trailer* mutable_trailer();
  void set_allocated_trailer(::livekit::proto::DataStream_Trailer* trailer);
  private:
  const ::livekit::proto::DataStream_Trailer& _internal_trailer() const;
  ::livekit::proto::DataStream_Trailer* _internal_mutable_trailer();
  public:
  void unsafe_arena_set_allocated_trailer(
      ::livekit::proto::DataStream_Trailer* trailer);
  ::livekit::proto::DataStream_Trailer* unsafe_arena_release_trailer();

  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamTrailerRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> destination_identities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_identity_;
    ::livekit::proto::DataStream_Trailer* trailer_;
    uint64_t local_participant_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamHeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamHeaderResponse) */ {
 public:
  inline SendStreamHeaderResponse() : SendStreamHeaderResponse(nullptr) {}
  ~SendStreamHeaderResponse() override;
  explicit PROTOBUF_CONSTEXPR SendStreamHeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamHeaderResponse(const SendStreamHeaderResponse& from);
  SendStreamHeaderResponse(SendStreamHeaderResponse&& from) noexcept
    : SendStreamHeaderResponse() {
    *this = ::std::move(from);
  }

  inline SendStreamHeaderResponse& operator=(const SendStreamHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamHeaderResponse& operator=(SendStreamHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const SendStreamHeaderResponse*>(
               &_SendStreamHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(SendStreamHeaderResponse& a, SendStreamHeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamHeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamHeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamHeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamHeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamHeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamHeaderResponse& from) {
    SendStreamHeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamHeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamHeaderResponse";
  }
  protected:
  explicit SendStreamHeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamHeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamChunkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamChunkResponse) */ {
 public:
  inline SendStreamChunkResponse() : SendStreamChunkResponse(nullptr) {}
  ~SendStreamChunkResponse() override;
  explicit PROTOBUF_CONSTEXPR SendStreamChunkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamChunkResponse(const SendStreamChunkResponse& from);
  SendStreamChunkResponse(SendStreamChunkResponse&& from) noexcept
    : SendStreamChunkResponse() {
    *this = ::std::move(from);
  }

  inline SendStreamChunkResponse& operator=(const SendStreamChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamChunkResponse& operator=(SendStreamChunkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamChunkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamChunkResponse* internal_default_instance() {
    return reinterpret_cast<const SendStreamChunkResponse*>(
               &_SendStreamChunkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(SendStreamChunkResponse& a, SendStreamChunkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamChunkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamChunkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamChunkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamChunkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamChunkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamChunkResponse& from) {
    SendStreamChunkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamChunkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamChunkResponse";
  }
  protected:
  explicit SendStreamChunkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamChunkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamTrailerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamTrailerResponse) */ {
 public:
  inline SendStreamTrailerResponse() : SendStreamTrailerResponse(nullptr) {}
  ~SendStreamTrailerResponse() override;
  explicit PROTOBUF_CONSTEXPR SendStreamTrailerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamTrailerResponse(const SendStreamTrailerResponse& from);
  SendStreamTrailerResponse(SendStreamTrailerResponse&& from) noexcept
    : SendStreamTrailerResponse() {
    *this = ::std::move(from);
  }

  inline SendStreamTrailerResponse& operator=(const SendStreamTrailerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamTrailerResponse& operator=(SendStreamTrailerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamTrailerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamTrailerResponse* internal_default_instance() {
    return reinterpret_cast<const SendStreamTrailerResponse*>(
               &_SendStreamTrailerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(SendStreamTrailerResponse& a, SendStreamTrailerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamTrailerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamTrailerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamTrailerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamTrailerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamTrailerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamTrailerResponse& from) {
    SendStreamTrailerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamTrailerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamTrailerResponse";
  }
  protected:
  explicit SendStreamTrailerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsyncIdFieldNumber = 1,
  };
  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamTrailerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamHeaderCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamHeaderCallback) */ {
 public:
  inline SendStreamHeaderCallback() : SendStreamHeaderCallback(nullptr) {}
  ~SendStreamHeaderCallback() override;
  explicit PROTOBUF_CONSTEXPR SendStreamHeaderCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamHeaderCallback(const SendStreamHeaderCallback& from);
  SendStreamHeaderCallback(SendStreamHeaderCallback&& from) noexcept
    : SendStreamHeaderCallback() {
    *this = ::std::move(from);
  }

  inline SendStreamHeaderCallback& operator=(const SendStreamHeaderCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamHeaderCallback& operator=(SendStreamHeaderCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamHeaderCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamHeaderCallback* internal_default_instance() {
    return reinterpret_cast<const SendStreamHeaderCallback*>(
               &_SendStreamHeaderCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(SendStreamHeaderCallback& a, SendStreamHeaderCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamHeaderCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamHeaderCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamHeaderCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamHeaderCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamHeaderCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamHeaderCallback& from) {
    SendStreamHeaderCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamHeaderCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamHeaderCallback";
  }
  protected:
  explicit SendStreamHeaderCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamHeaderCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamChunkCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamChunkCallback) */ {
 public:
  inline SendStreamChunkCallback() : SendStreamChunkCallback(nullptr) {}
  ~SendStreamChunkCallback() override;
  explicit PROTOBUF_CONSTEXPR SendStreamChunkCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamChunkCallback(const SendStreamChunkCallback& from);
  SendStreamChunkCallback(SendStreamChunkCallback&& from) noexcept
    : SendStreamChunkCallback() {
    *this = ::std::move(from);
  }

  inline SendStreamChunkCallback& operator=(const SendStreamChunkCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamChunkCallback& operator=(SendStreamChunkCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamChunkCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamChunkCallback* internal_default_instance() {
    return reinterpret_cast<const SendStreamChunkCallback*>(
               &_SendStreamChunkCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(SendStreamChunkCallback& a, SendStreamChunkCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamChunkCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamChunkCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamChunkCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamChunkCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamChunkCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamChunkCallback& from) {
    SendStreamChunkCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamChunkCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamChunkCallback";
  }
  protected:
  explicit SendStreamChunkCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamChunkCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SendStreamTrailerCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SendStreamTrailerCallback) */ {
 public:
  inline SendStreamTrailerCallback() : SendStreamTrailerCallback(nullptr) {}
  ~SendStreamTrailerCallback() override;
  explicit PROTOBUF_CONSTEXPR SendStreamTrailerCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendStreamTrailerCallback(const SendStreamTrailerCallback& from);
  SendStreamTrailerCallback(SendStreamTrailerCallback&& from) noexcept
    : SendStreamTrailerCallback() {
    *this = ::std::move(from);
  }

  inline SendStreamTrailerCallback& operator=(const SendStreamTrailerCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendStreamTrailerCallback& operator=(SendStreamTrailerCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendStreamTrailerCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendStreamTrailerCallback* internal_default_instance() {
    return reinterpret_cast<const SendStreamTrailerCallback*>(
               &_SendStreamTrailerCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(SendStreamTrailerCallback& a, SendStreamTrailerCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(SendStreamTrailerCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendStreamTrailerCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendStreamTrailerCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendStreamTrailerCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendStreamTrailerCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendStreamTrailerCallback& from) {
    SendStreamTrailerCallback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendStreamTrailerCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SendStreamTrailerCallback";
  }
  protected:
  explicit SendStreamTrailerCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kAsyncIdFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required uint64 async_id = 1;
  bool has_async_id() const;
  private:
  bool _internal_has_async_id() const;
  public:
  void clear_async_id();
  uint64_t async_id() const;
  void set_async_id(uint64_t value);
  private:
  uint64_t _internal_async_id() const;
  void _internal_set_async_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SendStreamTrailerCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t async_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetDataChannelBufferedAmountLowThresholdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest) */ {
 public:
  inline SetDataChannelBufferedAmountLowThresholdRequest() : SetDataChannelBufferedAmountLowThresholdRequest(nullptr) {}
  ~SetDataChannelBufferedAmountLowThresholdRequest() override;
  explicit PROTOBUF_CONSTEXPR SetDataChannelBufferedAmountLowThresholdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDataChannelBufferedAmountLowThresholdRequest(const SetDataChannelBufferedAmountLowThresholdRequest& from);
  SetDataChannelBufferedAmountLowThresholdRequest(SetDataChannelBufferedAmountLowThresholdRequest&& from) noexcept
    : SetDataChannelBufferedAmountLowThresholdRequest() {
    *this = ::std::move(from);
  }

  inline SetDataChannelBufferedAmountLowThresholdRequest& operator=(const SetDataChannelBufferedAmountLowThresholdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDataChannelBufferedAmountLowThresholdRequest& operator=(SetDataChannelBufferedAmountLowThresholdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDataChannelBufferedAmountLowThresholdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDataChannelBufferedAmountLowThresholdRequest* internal_default_instance() {
    return reinterpret_cast<const SetDataChannelBufferedAmountLowThresholdRequest*>(
               &_SetDataChannelBufferedAmountLowThresholdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(SetDataChannelBufferedAmountLowThresholdRequest& a, SetDataChannelBufferedAmountLowThresholdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDataChannelBufferedAmountLowThresholdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDataChannelBufferedAmountLowThresholdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDataChannelBufferedAmountLowThresholdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDataChannelBufferedAmountLowThresholdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDataChannelBufferedAmountLowThresholdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetDataChannelBufferedAmountLowThresholdRequest& from) {
    SetDataChannelBufferedAmountLowThresholdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDataChannelBufferedAmountLowThresholdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest";
  }
  protected:
  explicit SetDataChannelBufferedAmountLowThresholdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalParticipantHandleFieldNumber = 1,
    kThresholdFieldNumber = 2,
    kKindFieldNumber = 3,
  };
  // required uint64 local_participant_handle = 1;
  bool has_local_participant_handle() const;
  private:
  bool _internal_has_local_participant_handle() const;
  public:
  void clear_local_participant_handle();
  uint64_t local_participant_handle() const;
  void set_local_participant_handle(uint64_t value);
  private:
  uint64_t _internal_local_participant_handle() const;
  void _internal_set_local_participant_handle(uint64_t value);
  public:

  // required uint64 threshold = 2;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  uint64_t threshold() const;
  void set_threshold(uint64_t value);
  private:
  uint64_t _internal_threshold() const;
  void _internal_set_threshold(uint64_t value);
  public:

  // required .livekit.proto.DataPacketKind kind = 3;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::livekit::proto::DataPacketKind kind() const;
  void set_kind(::livekit::proto::DataPacketKind value);
  private:
  ::livekit::proto::DataPacketKind _internal_kind() const;
  void _internal_set_kind(::livekit::proto::DataPacketKind value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t local_participant_handle_;
    uint64_t threshold_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class SetDataChannelBufferedAmountLowThresholdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SetDataChannelBufferedAmountLowThresholdResponse) */ {
 public:
  inline SetDataChannelBufferedAmountLowThresholdResponse() : SetDataChannelBufferedAmountLowThresholdResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetDataChannelBufferedAmountLowThresholdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDataChannelBufferedAmountLowThresholdResponse(const SetDataChannelBufferedAmountLowThresholdResponse& from);
  SetDataChannelBufferedAmountLowThresholdResponse(SetDataChannelBufferedAmountLowThresholdResponse&& from) noexcept
    : SetDataChannelBufferedAmountLowThresholdResponse() {
    *this = ::std::move(from);
  }

  inline SetDataChannelBufferedAmountLowThresholdResponse& operator=(const SetDataChannelBufferedAmountLowThresholdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDataChannelBufferedAmountLowThresholdResponse& operator=(SetDataChannelBufferedAmountLowThresholdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDataChannelBufferedAmountLowThresholdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDataChannelBufferedAmountLowThresholdResponse* internal_default_instance() {
    return reinterpret_cast<const SetDataChannelBufferedAmountLowThresholdResponse*>(
               &_SetDataChannelBufferedAmountLowThresholdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(SetDataChannelBufferedAmountLowThresholdResponse& a, SetDataChannelBufferedAmountLowThresholdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDataChannelBufferedAmountLowThresholdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDataChannelBufferedAmountLowThresholdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDataChannelBufferedAmountLowThresholdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDataChannelBufferedAmountLowThresholdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetDataChannelBufferedAmountLowThresholdResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetDataChannelBufferedAmountLowThresholdResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetDataChannelBufferedAmountLowThresholdResponse";
  }
  protected:
  explicit SetDataChannelBufferedAmountLowThresholdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SetDataChannelBufferedAmountLowThresholdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_room_2eproto;
};
// -------------------------------------------------------------------

class DataChannelBufferedAmountLowThresholdChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.DataChannelBufferedAmountLowThresholdChanged) */ {
 public:
  inline DataChannelBufferedAmountLowThresholdChanged() : DataChannelBufferedAmountLowThresholdChanged(nullptr) {}
  ~DataChannelBufferedAmountLowThresholdChanged() override;
  explicit PROTOBUF_CONSTEXPR DataChannelBufferedAmountLowThresholdChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataChannelBufferedAmountLowThresholdChanged(const DataChannelBufferedAmountLowThresholdChanged& from);
  DataChannelBufferedAmountLowThresholdChanged(DataChannelBufferedAmountLowThresholdChanged&& from) noexcept
    : DataChannelBufferedAmountLowThresholdChanged() {
    *this = ::std::move(from);
  }

  inline DataChannelBufferedAmountLowThresholdChanged& operator=(const DataChannelBufferedAmountLowThresholdChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataChannelBufferedAmountLowThresholdChanged& operator=(DataChannelBufferedAmountLowThresholdChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataChannelBufferedAmountLowThresholdChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataChannelBufferedAmountLowThresholdChanged* internal_default_instance() {
    return reinterpret_cast<const DataChannelBufferedAmountLowThresholdChanged*>(
               &_DataChannelBufferedAmountLowThresholdChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(DataChannelBufferedAmountLowThresholdChanged& a, DataChannelBufferedAmountLowThresholdChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(DataChannelBufferedAmountLowThresholdChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataChannelBufferedAmountLowThresholdChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataChannelBufferedAmountLowThresholdChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataChannelBufferedAmountLowThresholdChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataChannelBufferedAmountLowThresholdChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataChannelBufferedAmountLowThresholdChanged& from) {
    DataChannelBufferedAmountLowThresholdChanged::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataChannelBufferedAmountLowThresholdChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.DataChannelBufferedAmountLowThresholdChanged";
  }
  protected:
  explicit DataChannelBufferedAmountLowThresholdChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 2,
    kKindFieldNumber = 1,
  };
  // required uint64 threshold = 2;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  uint64_t threshold() const;
  void set_threshold(uint64_t value);
  private:
  uint64_t _internal_threshold() const;
  void _internal_set_threshold(uint64_t value);
  public:

  // required .livekit.proto.DataPacketKind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::livekit::proto::DataPacketKind kind() const;
  void set_kind(::livekit::proto::DataPacketKind value);
  private:
  ::livekit::proto::DataPacketKind _internal_kind() const;
  void _internal_set_kind(::livekit::proto::DataPacketKind value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.DataChannelBufferedAmountLowThresholdChanged)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t threshold_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_room_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConnectRequest

// required string url = 1;
inline bool ConnectRequest::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectRequest::has_url() const {
  return _internal_has_url();
}
inline void ConnectRequest::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectRequest::url() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectRequest::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectRequest.url)
}
inline std::string* ConnectRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectRequest.url)
  return _s;
}
inline const std::string& ConnectRequest::_internal_url() const {
  return _impl_.url_.Get();
}
inline void ConnectRequest::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectRequest::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectRequest::release_url() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectRequest.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectRequest.url)
}

// required string token = 2;
inline bool ConnectRequest::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectRequest::has_token() const {
  return _internal_has_token();
}
inline void ConnectRequest::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectRequest::token() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectRequest.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectRequest::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectRequest.token)
}
inline std::string* ConnectRequest::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectRequest.token)
  return _s;
}
inline const std::string& ConnectRequest::_internal_token() const {
  return _impl_.token_.Get();
}
inline void ConnectRequest::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectRequest::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectRequest::release_token() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectRequest.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectRequest.token)
}

// required .livekit.proto.RoomOptions options = 3;
inline bool ConnectRequest::_internal_has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline bool ConnectRequest::has_options() const {
  return _internal_has_options();
}
inline void ConnectRequest::clear_options() {
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::proto::RoomOptions& ConnectRequest::_internal_options() const {
  const ::livekit::proto::RoomOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::RoomOptions&>(
      ::livekit::proto::_RoomOptions_default_instance_);
}
inline const ::livekit::proto::RoomOptions& ConnectRequest::options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectRequest.options)
  return _internal_options();
}
inline void ConnectRequest::unsafe_arena_set_allocated_options(
    ::livekit::proto::RoomOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ConnectRequest.options)
}
inline ::livekit::proto::RoomOptions* ConnectRequest::release_options() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::RoomOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::RoomOptions* ConnectRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectRequest.options)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::RoomOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::livekit::proto::RoomOptions* ConnectRequest::_internal_mutable_options() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::RoomOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::livekit::proto::RoomOptions* ConnectRequest::mutable_options() {
  ::livekit::proto::RoomOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectRequest.options)
  return _msg;
}
inline void ConnectRequest::set_allocated_options(::livekit::proto::RoomOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectRequest.options)
}

// -------------------------------------------------------------------

// ConnectResponse

// required uint64 async_id = 1;
inline bool ConnectResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void ConnectResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ConnectResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t ConnectResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectResponse.async_id)
  return _internal_async_id();
}
inline void ConnectResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void ConnectResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectResponse.async_id)
}

// -------------------------------------------------------------------

// ConnectCallback_ParticipantWithTracks

// required .livekit.proto.OwnedParticipant participant = 1;
inline bool ConnectCallback_ParticipantWithTracks::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.participant_ != nullptr);
  return value;
}
inline bool ConnectCallback_ParticipantWithTracks::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::proto::OwnedParticipant& ConnectCallback_ParticipantWithTracks::_internal_participant() const {
  const ::livekit::proto::OwnedParticipant* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedParticipant&>(
      ::livekit::proto::_OwnedParticipant_default_instance_);
}
inline const ::livekit::proto::OwnedParticipant& ConnectCallback_ParticipantWithTracks::participant() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.ParticipantWithTracks.participant)
  return _internal_participant();
}
inline void ConnectCallback_ParticipantWithTracks::unsafe_arena_set_allocated_participant(
    ::livekit::proto::OwnedParticipant* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = participant;
  if (participant) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ConnectCallback.ParticipantWithTracks.participant)
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_ParticipantWithTracks::release_participant() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_ParticipantWithTracks::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectCallback.ParticipantWithTracks.participant)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_ParticipantWithTracks::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedParticipant>(GetArenaForAllocation());
    _impl_.participant_ = p;
  }
  return _impl_.participant_;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_ParticipantWithTracks::mutable_participant() {
  ::livekit::proto::OwnedParticipant* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.ParticipantWithTracks.participant)
  return _msg;
}
inline void ConnectCallback_ParticipantWithTracks::set_allocated_participant(::livekit::proto::OwnedParticipant* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectCallback.ParticipantWithTracks.participant)
}

// repeated .livekit.proto.OwnedTrackPublication publications = 2;
inline int ConnectCallback_ParticipantWithTracks::_internal_publications_size() const {
  return _impl_.publications_.size();
}
inline int ConnectCallback_ParticipantWithTracks::publications_size() const {
  return _internal_publications_size();
}
inline ::livekit::proto::OwnedTrackPublication* ConnectCallback_ParticipantWithTracks::mutable_publications(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.ParticipantWithTracks.publications)
  return _impl_.publications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::OwnedTrackPublication >*
ConnectCallback_ParticipantWithTracks::mutable_publications() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ConnectCallback.ParticipantWithTracks.publications)
  return &_impl_.publications_;
}
inline const ::livekit::proto::OwnedTrackPublication& ConnectCallback_ParticipantWithTracks::_internal_publications(int index) const {
  return _impl_.publications_.Get(index);
}
inline const ::livekit::proto::OwnedTrackPublication& ConnectCallback_ParticipantWithTracks::publications(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.ParticipantWithTracks.publications)
  return _internal_publications(index);
}
inline ::livekit::proto::OwnedTrackPublication* ConnectCallback_ParticipantWithTracks::_internal_add_publications() {
  return _impl_.publications_.Add();
}
inline ::livekit::proto::OwnedTrackPublication* ConnectCallback_ParticipantWithTracks::add_publications() {
  ::livekit::proto::OwnedTrackPublication* _add = _internal_add_publications();
  // @@protoc_insertion_point(field_add:livekit.proto.ConnectCallback.ParticipantWithTracks.publications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::OwnedTrackPublication >&
ConnectCallback_ParticipantWithTracks::publications() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ConnectCallback.ParticipantWithTracks.publications)
  return _impl_.publications_;
}

// -------------------------------------------------------------------

// ConnectCallback_Result

// required .livekit.proto.OwnedRoom room = 1;
inline bool ConnectCallback_Result::_internal_has_room() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.room_ != nullptr);
  return value;
}
inline bool ConnectCallback_Result::has_room() const {
  return _internal_has_room();
}
inline void ConnectCallback_Result::clear_room() {
  if (_impl_.room_ != nullptr) _impl_.room_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::OwnedRoom& ConnectCallback_Result::_internal_room() const {
  const ::livekit::proto::OwnedRoom* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedRoom&>(
      ::livekit::proto::_OwnedRoom_default_instance_);
}
inline const ::livekit::proto::OwnedRoom& ConnectCallback_Result::room() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.Result.room)
  return _internal_room();
}
inline void ConnectCallback_Result::unsafe_arena_set_allocated_room(
    ::livekit::proto::OwnedRoom* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ConnectCallback.Result.room)
}
inline ::livekit::proto::OwnedRoom* ConnectCallback_Result::release_room() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedRoom* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedRoom* ConnectCallback_Result::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectCallback.Result.room)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedRoom* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedRoom* ConnectCallback_Result::_internal_mutable_room() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedRoom>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::proto::OwnedRoom* ConnectCallback_Result::mutable_room() {
  ::livekit::proto::OwnedRoom* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.Result.room)
  return _msg;
}
inline void ConnectCallback_Result::set_allocated_room(::livekit::proto::OwnedRoom* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.room_;
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(room);
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectCallback.Result.room)
}

// required .livekit.proto.OwnedParticipant local_participant = 2;
inline bool ConnectCallback_Result::_internal_has_local_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.local_participant_ != nullptr);
  return value;
}
inline bool ConnectCallback_Result::has_local_participant() const {
  return _internal_has_local_participant();
}
inline const ::livekit::proto::OwnedParticipant& ConnectCallback_Result::_internal_local_participant() const {
  const ::livekit::proto::OwnedParticipant* p = _impl_.local_participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedParticipant&>(
      ::livekit::proto::_OwnedParticipant_default_instance_);
}
inline const ::livekit::proto::OwnedParticipant& ConnectCallback_Result::local_participant() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.Result.local_participant)
  return _internal_local_participant();
}
inline void ConnectCallback_Result::unsafe_arena_set_allocated_local_participant(
    ::livekit::proto::OwnedParticipant* local_participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_participant_);
  }
  _impl_.local_participant_ = local_participant;
  if (local_participant) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ConnectCallback.Result.local_participant)
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_Result::release_local_participant() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.local_participant_;
  _impl_.local_participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_Result::unsafe_arena_release_local_participant() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectCallback.Result.local_participant)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.local_participant_;
  _impl_.local_participant_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_Result::_internal_mutable_local_participant() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.local_participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedParticipant>(GetArenaForAllocation());
    _impl_.local_participant_ = p;
  }
  return _impl_.local_participant_;
}
inline ::livekit::proto::OwnedParticipant* ConnectCallback_Result::mutable_local_participant() {
  ::livekit::proto::OwnedParticipant* _msg = _internal_mutable_local_participant();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.Result.local_participant)
  return _msg;
}
inline void ConnectCallback_Result::set_allocated_local_participant(::livekit::proto::OwnedParticipant* local_participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_participant_);
  }
  if (local_participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(local_participant));
    if (message_arena != submessage_arena) {
      local_participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_participant, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.local_participant_ = local_participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectCallback.Result.local_participant)
}

// repeated .livekit.proto.ConnectCallback.ParticipantWithTracks participants = 3;
inline int ConnectCallback_Result::_internal_participants_size() const {
  return _impl_.participants_.size();
}
inline int ConnectCallback_Result::participants_size() const {
  return _internal_participants_size();
}
inline void ConnectCallback_Result::clear_participants() {
  _impl_.participants_.Clear();
}
inline ::livekit::proto::ConnectCallback_ParticipantWithTracks* ConnectCallback_Result::mutable_participants(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.Result.participants)
  return _impl_.participants_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ConnectCallback_ParticipantWithTracks >*
ConnectCallback_Result::mutable_participants() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ConnectCallback.Result.participants)
  return &_impl_.participants_;
}
inline const ::livekit::proto::ConnectCallback_ParticipantWithTracks& ConnectCallback_Result::_internal_participants(int index) const {
  return _impl_.participants_.Get(index);
}
inline const ::livekit::proto::ConnectCallback_ParticipantWithTracks& ConnectCallback_Result::participants(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.Result.participants)
  return _internal_participants(index);
}
inline ::livekit::proto::ConnectCallback_ParticipantWithTracks* ConnectCallback_Result::_internal_add_participants() {
  return _impl_.participants_.Add();
}
inline ::livekit::proto::ConnectCallback_ParticipantWithTracks* ConnectCallback_Result::add_participants() {
  ::livekit::proto::ConnectCallback_ParticipantWithTracks* _add = _internal_add_participants();
  // @@protoc_insertion_point(field_add:livekit.proto.ConnectCallback.Result.participants)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::ConnectCallback_ParticipantWithTracks >&
ConnectCallback_Result::participants() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ConnectCallback.Result.participants)
  return _impl_.participants_;
}

// -------------------------------------------------------------------

// ConnectCallback

// required uint64 async_id = 1;
inline bool ConnectCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void ConnectCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ConnectCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t ConnectCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.async_id)
  return _internal_async_id();
}
inline void ConnectCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void ConnectCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectCallback.async_id)
}

// string error = 2;
inline bool ConnectCallback::_internal_has_error() const {
  return message_case() == kError;
}
inline bool ConnectCallback::has_error() const {
  return _internal_has_error();
}
inline void ConnectCallback::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void ConnectCallback::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& ConnectCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void ConnectCallback::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectCallback.error)
}
inline std::string* ConnectCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.error)
  return _s;
}
inline const std::string& ConnectCallback::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ConnectCallback::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectCallback::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* ConnectCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectCallback.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void ConnectCallback::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectCallback.error)
}

// .livekit.proto.ConnectCallback.Result result = 3;
inline bool ConnectCallback::_internal_has_result() const {
  return message_case() == kResult;
}
inline bool ConnectCallback::has_result() const {
  return _internal_has_result();
}
inline void ConnectCallback::set_has_result() {
  _impl_._oneof_case_[0] = kResult;
}
inline void ConnectCallback::clear_result() {
  if (_internal_has_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.result_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ConnectCallback_Result* ConnectCallback::release_result() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectCallback.result)
  if (_internal_has_result()) {
    clear_has_message();
    ::livekit::proto::ConnectCallback_Result* temp = _impl_.message_.result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ConnectCallback_Result& ConnectCallback::_internal_result() const {
  return _internal_has_result()
      ? *_impl_.message_.result_
      : reinterpret_cast< ::livekit::proto::ConnectCallback_Result&>(::livekit::proto::_ConnectCallback_Result_default_instance_);
}
inline const ::livekit::proto::ConnectCallback_Result& ConnectCallback::result() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectCallback.result)
  return _internal_result();
}
inline ::livekit::proto::ConnectCallback_Result* ConnectCallback::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.ConnectCallback.result)
  if (_internal_has_result()) {
    clear_has_message();
    ::livekit::proto::ConnectCallback_Result* temp = _impl_.message_.result_;
    _impl_.message_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConnectCallback::unsafe_arena_set_allocated_result(::livekit::proto::ConnectCallback_Result* result) {
  clear_message();
  if (result) {
    set_has_result();
    _impl_.message_.result_ = result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ConnectCallback.result)
}
inline ::livekit::proto::ConnectCallback_Result* ConnectCallback::_internal_mutable_result() {
  if (!_internal_has_result()) {
    clear_message();
    set_has_result();
    _impl_.message_.result_ = CreateMaybeMessage< ::livekit::proto::ConnectCallback_Result >(GetArenaForAllocation());
  }
  return _impl_.message_.result_;
}
inline ::livekit::proto::ConnectCallback_Result* ConnectCallback::mutable_result() {
  ::livekit::proto::ConnectCallback_Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectCallback.result)
  return _msg;
}

inline bool ConnectCallback::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ConnectCallback::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ConnectCallback::MessageCase ConnectCallback::message_case() const {
  return ConnectCallback::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DisconnectRequest

// required uint64 room_handle = 1;
inline bool DisconnectRequest::_internal_has_room_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisconnectRequest::has_room_handle() const {
  return _internal_has_room_handle();
}
inline void DisconnectRequest::clear_room_handle() {
  _impl_.room_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DisconnectRequest::_internal_room_handle() const {
  return _impl_.room_handle_;
}
inline uint64_t DisconnectRequest::room_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DisconnectRequest.room_handle)
  return _internal_room_handle();
}
inline void DisconnectRequest::_internal_set_room_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_handle_ = value;
}
inline void DisconnectRequest::set_room_handle(uint64_t value) {
  _internal_set_room_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DisconnectRequest.room_handle)
}

// -------------------------------------------------------------------

// DisconnectResponse

// required uint64 async_id = 1;
inline bool DisconnectResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisconnectResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void DisconnectResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DisconnectResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t DisconnectResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DisconnectResponse.async_id)
  return _internal_async_id();
}
inline void DisconnectResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void DisconnectResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DisconnectResponse.async_id)
}

// -------------------------------------------------------------------

// DisconnectCallback

// required uint64 async_id = 1;
inline bool DisconnectCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DisconnectCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void DisconnectCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DisconnectCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t DisconnectCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DisconnectCallback.async_id)
  return _internal_async_id();
}
inline void DisconnectCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void DisconnectCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DisconnectCallback.async_id)
}

// -------------------------------------------------------------------

// PublishTrackRequest

// required uint64 local_participant_handle = 1;
inline bool PublishTrackRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishTrackRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void PublishTrackRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishTrackRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t PublishTrackRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void PublishTrackRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void PublishTrackRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTrackRequest.local_participant_handle)
}

// required uint64 track_handle = 2;
inline bool PublishTrackRequest::_internal_has_track_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishTrackRequest::has_track_handle() const {
  return _internal_has_track_handle();
}
inline void PublishTrackRequest::clear_track_handle() {
  _impl_.track_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PublishTrackRequest::_internal_track_handle() const {
  return _impl_.track_handle_;
}
inline uint64_t PublishTrackRequest::track_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackRequest.track_handle)
  return _internal_track_handle();
}
inline void PublishTrackRequest::_internal_set_track_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.track_handle_ = value;
}
inline void PublishTrackRequest::set_track_handle(uint64_t value) {
  _internal_set_track_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTrackRequest.track_handle)
}

// required .livekit.proto.TrackPublishOptions options = 3;
inline bool PublishTrackRequest::_internal_has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline bool PublishTrackRequest::has_options() const {
  return _internal_has_options();
}
inline void PublishTrackRequest::clear_options() {
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::TrackPublishOptions& PublishTrackRequest::_internal_options() const {
  const ::livekit::proto::TrackPublishOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::TrackPublishOptions&>(
      ::livekit::proto::_TrackPublishOptions_default_instance_);
}
inline const ::livekit::proto::TrackPublishOptions& PublishTrackRequest::options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackRequest.options)
  return _internal_options();
}
inline void PublishTrackRequest::unsafe_arena_set_allocated_options(
    ::livekit::proto::TrackPublishOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.PublishTrackRequest.options)
}
inline ::livekit::proto::TrackPublishOptions* PublishTrackRequest::release_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::TrackPublishOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::TrackPublishOptions* PublishTrackRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTrackRequest.options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::TrackPublishOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::livekit::proto::TrackPublishOptions* PublishTrackRequest::_internal_mutable_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::TrackPublishOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::livekit::proto::TrackPublishOptions* PublishTrackRequest::mutable_options() {
  ::livekit::proto::TrackPublishOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTrackRequest.options)
  return _msg;
}
inline void PublishTrackRequest::set_allocated_options(::livekit::proto::TrackPublishOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishTrackRequest.options)
}

// -------------------------------------------------------------------

// PublishTrackResponse

// required uint64 async_id = 1;
inline bool PublishTrackResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishTrackResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishTrackResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PublishTrackResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishTrackResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackResponse.async_id)
  return _internal_async_id();
}
inline void PublishTrackResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void PublishTrackResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTrackResponse.async_id)
}

// -------------------------------------------------------------------

// PublishTrackCallback

// required uint64 async_id = 1;
inline bool PublishTrackCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishTrackCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishTrackCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PublishTrackCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishTrackCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackCallback.async_id)
  return _internal_async_id();
}
inline void PublishTrackCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void PublishTrackCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTrackCallback.async_id)
}

// string error = 2;
inline bool PublishTrackCallback::_internal_has_error() const {
  return message_case() == kError;
}
inline bool PublishTrackCallback::has_error() const {
  return _internal_has_error();
}
inline void PublishTrackCallback::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void PublishTrackCallback::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& PublishTrackCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void PublishTrackCallback::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTrackCallback.error)
}
inline std::string* PublishTrackCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTrackCallback.error)
  return _s;
}
inline const std::string& PublishTrackCallback::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PublishTrackCallback::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishTrackCallback::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* PublishTrackCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTrackCallback.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void PublishTrackCallback::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishTrackCallback.error)
}

// .livekit.proto.OwnedTrackPublication publication = 3;
inline bool PublishTrackCallback::_internal_has_publication() const {
  return message_case() == kPublication;
}
inline bool PublishTrackCallback::has_publication() const {
  return _internal_has_publication();
}
inline void PublishTrackCallback::set_has_publication() {
  _impl_._oneof_case_[0] = kPublication;
}
inline ::livekit::proto::OwnedTrackPublication* PublishTrackCallback::release_publication() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTrackCallback.publication)
  if (_internal_has_publication()) {
    clear_has_message();
    ::livekit::proto::OwnedTrackPublication* temp = _impl_.message_.publication_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.publication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::OwnedTrackPublication& PublishTrackCallback::_internal_publication() const {
  return _internal_has_publication()
      ? *_impl_.message_.publication_
      : reinterpret_cast< ::livekit::proto::OwnedTrackPublication&>(::livekit::proto::_OwnedTrackPublication_default_instance_);
}
inline const ::livekit::proto::OwnedTrackPublication& PublishTrackCallback::publication() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTrackCallback.publication)
  return _internal_publication();
}
inline ::livekit::proto::OwnedTrackPublication* PublishTrackCallback::unsafe_arena_release_publication() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.PublishTrackCallback.publication)
  if (_internal_has_publication()) {
    clear_has_message();
    ::livekit::proto::OwnedTrackPublication* temp = _impl_.message_.publication_;
    _impl_.message_.publication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PublishTrackCallback::unsafe_arena_set_allocated_publication(::livekit::proto::OwnedTrackPublication* publication) {
  clear_message();
  if (publication) {
    set_has_publication();
    _impl_.message_.publication_ = publication;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.PublishTrackCallback.publication)
}
inline ::livekit::proto::OwnedTrackPublication* PublishTrackCallback::_internal_mutable_publication() {
  if (!_internal_has_publication()) {
    clear_message();
    set_has_publication();
    _impl_.message_.publication_ = CreateMaybeMessage< ::livekit::proto::OwnedTrackPublication >(GetArenaForAllocation());
  }
  return _impl_.message_.publication_;
}
inline ::livekit::proto::OwnedTrackPublication* PublishTrackCallback::mutable_publication() {
  ::livekit::proto::OwnedTrackPublication* _msg = _internal_mutable_publication();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTrackCallback.publication)
  return _msg;
}

inline bool PublishTrackCallback::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void PublishTrackCallback::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline PublishTrackCallback::MessageCase PublishTrackCallback::message_case() const {
  return PublishTrackCallback::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnpublishTrackRequest

// required uint64 local_participant_handle = 1;
inline bool UnpublishTrackRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnpublishTrackRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void UnpublishTrackRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UnpublishTrackRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t UnpublishTrackRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void UnpublishTrackRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void UnpublishTrackRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackRequest.local_participant_handle)
}

// required string track_sid = 2;
inline bool UnpublishTrackRequest::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnpublishTrackRequest::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void UnpublishTrackRequest::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnpublishTrackRequest::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackRequest.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnpublishTrackRequest::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackRequest.track_sid)
}
inline std::string* UnpublishTrackRequest::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.UnpublishTrackRequest.track_sid)
  return _s;
}
inline const std::string& UnpublishTrackRequest::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void UnpublishTrackRequest::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpublishTrackRequest::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* UnpublishTrackRequest::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.UnpublishTrackRequest.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnpublishTrackRequest::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.UnpublishTrackRequest.track_sid)
}

// required bool stop_on_unpublish = 3;
inline bool UnpublishTrackRequest::_internal_has_stop_on_unpublish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UnpublishTrackRequest::has_stop_on_unpublish() const {
  return _internal_has_stop_on_unpublish();
}
inline void UnpublishTrackRequest::clear_stop_on_unpublish() {
  _impl_.stop_on_unpublish_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool UnpublishTrackRequest::_internal_stop_on_unpublish() const {
  return _impl_.stop_on_unpublish_;
}
inline bool UnpublishTrackRequest::stop_on_unpublish() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackRequest.stop_on_unpublish)
  return _internal_stop_on_unpublish();
}
inline void UnpublishTrackRequest::_internal_set_stop_on_unpublish(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_on_unpublish_ = value;
}
inline void UnpublishTrackRequest::set_stop_on_unpublish(bool value) {
  _internal_set_stop_on_unpublish(value);
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackRequest.stop_on_unpublish)
}

// -------------------------------------------------------------------

// UnpublishTrackResponse

// required uint64 async_id = 1;
inline bool UnpublishTrackResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnpublishTrackResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void UnpublishTrackResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t UnpublishTrackResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t UnpublishTrackResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackResponse.async_id)
  return _internal_async_id();
}
inline void UnpublishTrackResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void UnpublishTrackResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackResponse.async_id)
}

// -------------------------------------------------------------------

// UnpublishTrackCallback

// required uint64 async_id = 1;
inline bool UnpublishTrackCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnpublishTrackCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void UnpublishTrackCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UnpublishTrackCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t UnpublishTrackCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackCallback.async_id)
  return _internal_async_id();
}
inline void UnpublishTrackCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void UnpublishTrackCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackCallback.async_id)
}

// optional string error = 2;
inline bool UnpublishTrackCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnpublishTrackCallback::has_error() const {
  return _internal_has_error();
}
inline void UnpublishTrackCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnpublishTrackCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UnpublishTrackCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnpublishTrackCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.UnpublishTrackCallback.error)
}
inline std::string* UnpublishTrackCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.UnpublishTrackCallback.error)
  return _s;
}
inline const std::string& UnpublishTrackCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void UnpublishTrackCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* UnpublishTrackCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* UnpublishTrackCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.UnpublishTrackCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UnpublishTrackCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.UnpublishTrackCallback.error)
}

// -------------------------------------------------------------------

// PublishDataRequest

// required uint64 local_participant_handle = 1;
inline bool PublishDataRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishDataRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void PublishDataRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishDataRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t PublishDataRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void PublishDataRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void PublishDataRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.local_participant_handle)
}

// required uint64 data_ptr = 2;
inline bool PublishDataRequest::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishDataRequest::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void PublishDataRequest::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PublishDataRequest::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t PublishDataRequest::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.data_ptr)
  return _internal_data_ptr();
}
inline void PublishDataRequest::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.data_ptr_ = value;
}
inline void PublishDataRequest::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.data_ptr)
}

// required uint64 data_len = 3;
inline bool PublishDataRequest::_internal_has_data_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PublishDataRequest::has_data_len() const {
  return _internal_has_data_len();
}
inline void PublishDataRequest::clear_data_len() {
  _impl_.data_len_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t PublishDataRequest::_internal_data_len() const {
  return _impl_.data_len_;
}
inline uint64_t PublishDataRequest::data_len() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.data_len)
  return _internal_data_len();
}
inline void PublishDataRequest::_internal_set_data_len(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.data_len_ = value;
}
inline void PublishDataRequest::set_data_len(uint64_t value) {
  _internal_set_data_len(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.data_len)
}

// required bool reliable = 4;
inline bool PublishDataRequest::_internal_has_reliable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PublishDataRequest::has_reliable() const {
  return _internal_has_reliable();
}
inline void PublishDataRequest::clear_reliable() {
  _impl_.reliable_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool PublishDataRequest::_internal_reliable() const {
  return _impl_.reliable_;
}
inline bool PublishDataRequest::reliable() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.reliable)
  return _internal_reliable();
}
inline void PublishDataRequest::_internal_set_reliable(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.reliable_ = value;
}
inline void PublishDataRequest::set_reliable(bool value) {
  _internal_set_reliable(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.reliable)
}

// repeated string destination_sids = 5 [deprecated = true];
inline int PublishDataRequest::_internal_destination_sids_size() const {
  return _impl_.destination_sids_.size();
}
inline int PublishDataRequest::destination_sids_size() const {
  return _internal_destination_sids_size();
}
inline void PublishDataRequest::clear_destination_sids() {
  _impl_.destination_sids_.Clear();
}
inline std::string* PublishDataRequest::add_destination_sids() {
  std::string* _s = _internal_add_destination_sids();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.PublishDataRequest.destination_sids)
  return _s;
}
inline const std::string& PublishDataRequest::_internal_destination_sids(int index) const {
  return _impl_.destination_sids_.Get(index);
}
inline const std::string& PublishDataRequest::destination_sids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.destination_sids)
  return _internal_destination_sids(index);
}
inline std::string* PublishDataRequest::mutable_destination_sids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishDataRequest.destination_sids)
  return _impl_.destination_sids_.Mutable(index);
}
inline void PublishDataRequest::set_destination_sids(int index, const std::string& value) {
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::set_destination_sids(int index, std::string&& value) {
  _impl_.destination_sids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::set_destination_sids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::set_destination_sids(int index, const char* value, size_t size) {
  _impl_.destination_sids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.PublishDataRequest.destination_sids)
}
inline std::string* PublishDataRequest::_internal_add_destination_sids() {
  return _impl_.destination_sids_.Add();
}
inline void PublishDataRequest::add_destination_sids(const std::string& value) {
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::add_destination_sids(std::string&& value) {
  _impl_.destination_sids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::add_destination_sids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_sids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.PublishDataRequest.destination_sids)
}
inline void PublishDataRequest::add_destination_sids(const char* value, size_t size) {
  _impl_.destination_sids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.PublishDataRequest.destination_sids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PublishDataRequest::destination_sids() const {
  // @@protoc_insertion_point(field_list:livekit.proto.PublishDataRequest.destination_sids)
  return _impl_.destination_sids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PublishDataRequest::mutable_destination_sids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.PublishDataRequest.destination_sids)
  return &_impl_.destination_sids_;
}

// optional string topic = 6;
inline bool PublishDataRequest::_internal_has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishDataRequest::has_topic() const {
  return _internal_has_topic();
}
inline void PublishDataRequest::clear_topic() {
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishDataRequest::topic() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishDataRequest::set_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.topic)
}
inline std::string* PublishDataRequest::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishDataRequest.topic)
  return _s;
}
inline const std::string& PublishDataRequest::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void PublishDataRequest::_internal_set_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishDataRequest::_internal_mutable_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishDataRequest::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishDataRequest.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishDataRequest::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishDataRequest.topic)
}

// repeated string destination_identities = 7;
inline int PublishDataRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int PublishDataRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void PublishDataRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* PublishDataRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.PublishDataRequest.destination_identities)
  return _s;
}
inline const std::string& PublishDataRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& PublishDataRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* PublishDataRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishDataRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void PublishDataRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.PublishDataRequest.destination_identities)
}
inline std::string* PublishDataRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void PublishDataRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.PublishDataRequest.destination_identities)
}
inline void PublishDataRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.PublishDataRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PublishDataRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.PublishDataRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PublishDataRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.PublishDataRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// -------------------------------------------------------------------

// PublishDataResponse

// required uint64 async_id = 1;
inline bool PublishDataResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishDataResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishDataResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PublishDataResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishDataResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataResponse.async_id)
  return _internal_async_id();
}
inline void PublishDataResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void PublishDataResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataResponse.async_id)
}

// -------------------------------------------------------------------

// PublishDataCallback

// required uint64 async_id = 1;
inline bool PublishDataCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishDataCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishDataCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishDataCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishDataCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataCallback.async_id)
  return _internal_async_id();
}
inline void PublishDataCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void PublishDataCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataCallback.async_id)
}

// optional string error = 2;
inline bool PublishDataCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishDataCallback::has_error() const {
  return _internal_has_error();
}
inline void PublishDataCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishDataCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishDataCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishDataCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishDataCallback.error)
}
inline std::string* PublishDataCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishDataCallback.error)
  return _s;
}
inline const std::string& PublishDataCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PublishDataCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishDataCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishDataCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishDataCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishDataCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishDataCallback.error)
}

// -------------------------------------------------------------------

// PublishTranscriptionRequest

// required uint64 local_participant_handle = 1;
inline bool PublishTranscriptionRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishTranscriptionRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void PublishTranscriptionRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PublishTranscriptionRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t PublishTranscriptionRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void PublishTranscriptionRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.local_participant_handle_ = value;
}
inline void PublishTranscriptionRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionRequest.local_participant_handle)
}

// required string participant_identity = 2;
inline bool PublishTranscriptionRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishTranscriptionRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void PublishTranscriptionRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishTranscriptionRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishTranscriptionRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionRequest.participant_identity)
}
inline std::string* PublishTranscriptionRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTranscriptionRequest.participant_identity)
  return _s;
}
inline const std::string& PublishTranscriptionRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void PublishTranscriptionRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishTranscriptionRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishTranscriptionRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTranscriptionRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishTranscriptionRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishTranscriptionRequest.participant_identity)
}

// required string track_id = 3;
inline bool PublishTranscriptionRequest::_internal_has_track_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishTranscriptionRequest::has_track_id() const {
  return _internal_has_track_id();
}
inline void PublishTranscriptionRequest::clear_track_id() {
  _impl_.track_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PublishTranscriptionRequest::track_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionRequest.track_id)
  return _internal_track_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishTranscriptionRequest::set_track_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionRequest.track_id)
}
inline std::string* PublishTranscriptionRequest::mutable_track_id() {
  std::string* _s = _internal_mutable_track_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTranscriptionRequest.track_id)
  return _s;
}
inline const std::string& PublishTranscriptionRequest::_internal_track_id() const {
  return _impl_.track_id_.Get();
}
inline void PublishTranscriptionRequest::_internal_set_track_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishTranscriptionRequest::_internal_mutable_track_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishTranscriptionRequest::release_track_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTranscriptionRequest.track_id)
  if (!_internal_has_track_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishTranscriptionRequest::set_allocated_track_id(std::string* track_id) {
  if (track_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_id_.SetAllocated(track_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_id_.IsDefault()) {
    _impl_.track_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishTranscriptionRequest.track_id)
}

// repeated .livekit.proto.TranscriptionSegment segments = 4;
inline int PublishTranscriptionRequest::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int PublishTranscriptionRequest::segments_size() const {
  return _internal_segments_size();
}
inline void PublishTranscriptionRequest::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::livekit::proto::TranscriptionSegment* PublishTranscriptionRequest::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTranscriptionRequest.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >*
PublishTranscriptionRequest::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.PublishTranscriptionRequest.segments)
  return &_impl_.segments_;
}
inline const ::livekit::proto::TranscriptionSegment& PublishTranscriptionRequest::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::livekit::proto::TranscriptionSegment& PublishTranscriptionRequest::segments(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionRequest.segments)
  return _internal_segments(index);
}
inline ::livekit::proto::TranscriptionSegment* PublishTranscriptionRequest::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::livekit::proto::TranscriptionSegment* PublishTranscriptionRequest::add_segments() {
  ::livekit::proto::TranscriptionSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:livekit.proto.PublishTranscriptionRequest.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >&
PublishTranscriptionRequest::segments() const {
  // @@protoc_insertion_point(field_list:livekit.proto.PublishTranscriptionRequest.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// PublishTranscriptionResponse

// required uint64 async_id = 1;
inline bool PublishTranscriptionResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishTranscriptionResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishTranscriptionResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PublishTranscriptionResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishTranscriptionResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionResponse.async_id)
  return _internal_async_id();
}
inline void PublishTranscriptionResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void PublishTranscriptionResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionResponse.async_id)
}

// -------------------------------------------------------------------

// PublishTranscriptionCallback

// required uint64 async_id = 1;
inline bool PublishTranscriptionCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishTranscriptionCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishTranscriptionCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishTranscriptionCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishTranscriptionCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionCallback.async_id)
  return _internal_async_id();
}
inline void PublishTranscriptionCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void PublishTranscriptionCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionCallback.async_id)
}

// optional string error = 2;
inline bool PublishTranscriptionCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishTranscriptionCallback::has_error() const {
  return _internal_has_error();
}
inline void PublishTranscriptionCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishTranscriptionCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishTranscriptionCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishTranscriptionCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishTranscriptionCallback.error)
}
inline std::string* PublishTranscriptionCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishTranscriptionCallback.error)
  return _s;
}
inline const std::string& PublishTranscriptionCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PublishTranscriptionCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishTranscriptionCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishTranscriptionCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishTranscriptionCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishTranscriptionCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishTranscriptionCallback.error)
}

// -------------------------------------------------------------------

// PublishSipDtmfRequest

// required uint64 local_participant_handle = 1;
inline bool PublishSipDtmfRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishSipDtmfRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void PublishSipDtmfRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishSipDtmfRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t PublishSipDtmfRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void PublishSipDtmfRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void PublishSipDtmfRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfRequest.local_participant_handle)
}

// required uint32 code = 2;
inline bool PublishSipDtmfRequest::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PublishSipDtmfRequest::has_code() const {
  return _internal_has_code();
}
inline void PublishSipDtmfRequest::clear_code() {
  _impl_.code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PublishSipDtmfRequest::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t PublishSipDtmfRequest::code() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfRequest.code)
  return _internal_code();
}
inline void PublishSipDtmfRequest::_internal_set_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.code_ = value;
}
inline void PublishSipDtmfRequest::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfRequest.code)
}

// required string digit = 3;
inline bool PublishSipDtmfRequest::_internal_has_digit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishSipDtmfRequest::has_digit() const {
  return _internal_has_digit();
}
inline void PublishSipDtmfRequest::clear_digit() {
  _impl_.digit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishSipDtmfRequest::digit() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfRequest.digit)
  return _internal_digit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishSipDtmfRequest::set_digit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.digit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfRequest.digit)
}
inline std::string* PublishSipDtmfRequest::mutable_digit() {
  std::string* _s = _internal_mutable_digit();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishSipDtmfRequest.digit)
  return _s;
}
inline const std::string& PublishSipDtmfRequest::_internal_digit() const {
  return _impl_.digit_.Get();
}
inline void PublishSipDtmfRequest::_internal_set_digit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.digit_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishSipDtmfRequest::_internal_mutable_digit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.digit_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishSipDtmfRequest::release_digit() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishSipDtmfRequest.digit)
  if (!_internal_has_digit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.digit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digit_.IsDefault()) {
    _impl_.digit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishSipDtmfRequest::set_allocated_digit(std::string* digit) {
  if (digit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.digit_.SetAllocated(digit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digit_.IsDefault()) {
    _impl_.digit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishSipDtmfRequest.digit)
}

// repeated string destination_identities = 4;
inline int PublishSipDtmfRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int PublishSipDtmfRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void PublishSipDtmfRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* PublishSipDtmfRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.PublishSipDtmfRequest.destination_identities)
  return _s;
}
inline const std::string& PublishSipDtmfRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& PublishSipDtmfRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* PublishSipDtmfRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishSipDtmfRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void PublishSipDtmfRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline std::string* PublishSipDtmfRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void PublishSipDtmfRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline void PublishSipDtmfRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.PublishSipDtmfRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PublishSipDtmfRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.PublishSipDtmfRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PublishSipDtmfRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.PublishSipDtmfRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// -------------------------------------------------------------------

// PublishSipDtmfResponse

// required uint64 async_id = 1;
inline bool PublishSipDtmfResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishSipDtmfResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishSipDtmfResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t PublishSipDtmfResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishSipDtmfResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfResponse.async_id)
  return _internal_async_id();
}
inline void PublishSipDtmfResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void PublishSipDtmfResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfResponse.async_id)
}

// -------------------------------------------------------------------

// PublishSipDtmfCallback

// required uint64 async_id = 1;
inline bool PublishSipDtmfCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PublishSipDtmfCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void PublishSipDtmfCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t PublishSipDtmfCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t PublishSipDtmfCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfCallback.async_id)
  return _internal_async_id();
}
inline void PublishSipDtmfCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void PublishSipDtmfCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfCallback.async_id)
}

// optional string error = 2;
inline bool PublishSipDtmfCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PublishSipDtmfCallback::has_error() const {
  return _internal_has_error();
}
inline void PublishSipDtmfCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PublishSipDtmfCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.PublishSipDtmfCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PublishSipDtmfCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.PublishSipDtmfCallback.error)
}
inline std::string* PublishSipDtmfCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.PublishSipDtmfCallback.error)
  return _s;
}
inline const std::string& PublishSipDtmfCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PublishSipDtmfCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PublishSipDtmfCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PublishSipDtmfCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.PublishSipDtmfCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PublishSipDtmfCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.PublishSipDtmfCallback.error)
}

// -------------------------------------------------------------------

// SetLocalMetadataRequest

// required uint64 local_participant_handle = 1;
inline bool SetLocalMetadataRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLocalMetadataRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SetLocalMetadataRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetLocalMetadataRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SetLocalMetadataRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalMetadataRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SetLocalMetadataRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void SetLocalMetadataRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalMetadataRequest.local_participant_handle)
}

// required string metadata = 2;
inline bool SetLocalMetadataRequest::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalMetadataRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void SetLocalMetadataRequest::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLocalMetadataRequest::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalMetadataRequest.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalMetadataRequest::set_metadata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalMetadataRequest.metadata)
}
inline std::string* SetLocalMetadataRequest::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalMetadataRequest.metadata)
  return _s;
}
inline const std::string& SetLocalMetadataRequest::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void SetLocalMetadataRequest::_internal_set_metadata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalMetadataRequest::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalMetadataRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetLocalMetadataRequest.metadata)
  if (!_internal_has_metadata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.metadata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetLocalMetadataRequest::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetLocalMetadataRequest.metadata)
}

// -------------------------------------------------------------------

// SetLocalMetadataResponse

// required uint64 async_id = 1;
inline bool SetLocalMetadataResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalMetadataResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalMetadataResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetLocalMetadataResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalMetadataResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalMetadataResponse.async_id)
  return _internal_async_id();
}
inline void SetLocalMetadataResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SetLocalMetadataResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalMetadataResponse.async_id)
}

// -------------------------------------------------------------------

// SetLocalMetadataCallback

// required uint64 async_id = 1;
inline bool SetLocalMetadataCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLocalMetadataCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalMetadataCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetLocalMetadataCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalMetadataCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalMetadataCallback.async_id)
  return _internal_async_id();
}
inline void SetLocalMetadataCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SetLocalMetadataCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalMetadataCallback.async_id)
}

// optional string error = 2;
inline bool SetLocalMetadataCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalMetadataCallback::has_error() const {
  return _internal_has_error();
}
inline void SetLocalMetadataCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLocalMetadataCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalMetadataCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalMetadataCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalMetadataCallback.error)
}
inline std::string* SetLocalMetadataCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalMetadataCallback.error)
  return _s;
}
inline const std::string& SetLocalMetadataCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SetLocalMetadataCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalMetadataCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalMetadataCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetLocalMetadataCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetLocalMetadataCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetLocalMetadataCallback.error)
}

// -------------------------------------------------------------------

// SendChatMessageRequest

// required uint64 local_participant_handle = 1;
inline bool SendChatMessageRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendChatMessageRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SendChatMessageRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t SendChatMessageRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SendChatMessageRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SendChatMessageRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.local_participant_handle_ = value;
}
inline void SendChatMessageRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageRequest.local_participant_handle)
}

// required string message = 2;
inline bool SendChatMessageRequest::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendChatMessageRequest::has_message() const {
  return _internal_has_message();
}
inline void SendChatMessageRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendChatMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageRequest.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChatMessageRequest::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageRequest.message)
}
inline std::string* SendChatMessageRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendChatMessageRequest.message)
  return _s;
}
inline const std::string& SendChatMessageRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SendChatMessageRequest::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SendChatMessageRequest::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SendChatMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendChatMessageRequest.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChatMessageRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendChatMessageRequest.message)
}

// repeated string destination_identities = 3;
inline int SendChatMessageRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int SendChatMessageRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void SendChatMessageRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* SendChatMessageRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.SendChatMessageRequest.destination_identities)
  return _s;
}
inline const std::string& SendChatMessageRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& SendChatMessageRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* SendChatMessageRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendChatMessageRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void SendChatMessageRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline std::string* SendChatMessageRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void SendChatMessageRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline void SendChatMessageRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.SendChatMessageRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendChatMessageRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SendChatMessageRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendChatMessageRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SendChatMessageRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// optional string sender_identity = 4;
inline bool SendChatMessageRequest::_internal_has_sender_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendChatMessageRequest::has_sender_identity() const {
  return _internal_has_sender_identity();
}
inline void SendChatMessageRequest::clear_sender_identity() {
  _impl_.sender_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SendChatMessageRequest::sender_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageRequest.sender_identity)
  return _internal_sender_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendChatMessageRequest::set_sender_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sender_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageRequest.sender_identity)
}
inline std::string* SendChatMessageRequest::mutable_sender_identity() {
  std::string* _s = _internal_mutable_sender_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendChatMessageRequest.sender_identity)
  return _s;
}
inline const std::string& SendChatMessageRequest::_internal_sender_identity() const {
  return _impl_.sender_identity_.Get();
}
inline void SendChatMessageRequest::_internal_set_sender_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sender_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendChatMessageRequest::_internal_mutable_sender_identity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sender_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendChatMessageRequest::release_sender_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendChatMessageRequest.sender_identity)
  if (!_internal_has_sender_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sender_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendChatMessageRequest::set_allocated_sender_identity(std::string* sender_identity) {
  if (sender_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sender_identity_.SetAllocated(sender_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendChatMessageRequest.sender_identity)
}

// -------------------------------------------------------------------

// EditChatMessageRequest

// required uint64 local_participant_handle = 1;
inline bool EditChatMessageRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EditChatMessageRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void EditChatMessageRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t EditChatMessageRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t EditChatMessageRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EditChatMessageRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void EditChatMessageRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.local_participant_handle_ = value;
}
inline void EditChatMessageRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.EditChatMessageRequest.local_participant_handle)
}

// required string edit_text = 2;
inline bool EditChatMessageRequest::_internal_has_edit_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EditChatMessageRequest::has_edit_text() const {
  return _internal_has_edit_text();
}
inline void EditChatMessageRequest::clear_edit_text() {
  _impl_.edit_text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EditChatMessageRequest::edit_text() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EditChatMessageRequest.edit_text)
  return _internal_edit_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditChatMessageRequest::set_edit_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.edit_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.EditChatMessageRequest.edit_text)
}
inline std::string* EditChatMessageRequest::mutable_edit_text() {
  std::string* _s = _internal_mutable_edit_text();
  // @@protoc_insertion_point(field_mutable:livekit.proto.EditChatMessageRequest.edit_text)
  return _s;
}
inline const std::string& EditChatMessageRequest::_internal_edit_text() const {
  return _impl_.edit_text_.Get();
}
inline void EditChatMessageRequest::_internal_set_edit_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.edit_text_.Set(value, GetArenaForAllocation());
}
inline std::string* EditChatMessageRequest::_internal_mutable_edit_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.edit_text_.Mutable(GetArenaForAllocation());
}
inline std::string* EditChatMessageRequest::release_edit_text() {
  // @@protoc_insertion_point(field_release:livekit.proto.EditChatMessageRequest.edit_text)
  if (!_internal_has_edit_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.edit_text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.edit_text_.IsDefault()) {
    _impl_.edit_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditChatMessageRequest::set_allocated_edit_text(std::string* edit_text) {
  if (edit_text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.edit_text_.SetAllocated(edit_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.edit_text_.IsDefault()) {
    _impl_.edit_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.EditChatMessageRequest.edit_text)
}

// required .livekit.proto.ChatMessage original_message = 3;
inline bool EditChatMessageRequest::_internal_has_original_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.original_message_ != nullptr);
  return value;
}
inline bool EditChatMessageRequest::has_original_message() const {
  return _internal_has_original_message();
}
inline void EditChatMessageRequest::clear_original_message() {
  if (_impl_.original_message_ != nullptr) _impl_.original_message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::proto::ChatMessage& EditChatMessageRequest::_internal_original_message() const {
  const ::livekit::proto::ChatMessage* p = _impl_.original_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::ChatMessage&>(
      ::livekit::proto::_ChatMessage_default_instance_);
}
inline const ::livekit::proto::ChatMessage& EditChatMessageRequest::original_message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EditChatMessageRequest.original_message)
  return _internal_original_message();
}
inline void EditChatMessageRequest::unsafe_arena_set_allocated_original_message(
    ::livekit::proto::ChatMessage* original_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.original_message_);
  }
  _impl_.original_message_ = original_message;
  if (original_message) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.EditChatMessageRequest.original_message)
}
inline ::livekit::proto::ChatMessage* EditChatMessageRequest::release_original_message() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::ChatMessage* temp = _impl_.original_message_;
  _impl_.original_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::ChatMessage* EditChatMessageRequest::unsafe_arena_release_original_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.EditChatMessageRequest.original_message)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::ChatMessage* temp = _impl_.original_message_;
  _impl_.original_message_ = nullptr;
  return temp;
}
inline ::livekit::proto::ChatMessage* EditChatMessageRequest::_internal_mutable_original_message() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.original_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::ChatMessage>(GetArenaForAllocation());
    _impl_.original_message_ = p;
  }
  return _impl_.original_message_;
}
inline ::livekit::proto::ChatMessage* EditChatMessageRequest::mutable_original_message() {
  ::livekit::proto::ChatMessage* _msg = _internal_mutable_original_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.EditChatMessageRequest.original_message)
  return _msg;
}
inline void EditChatMessageRequest::set_allocated_original_message(::livekit::proto::ChatMessage* original_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.original_message_;
  }
  if (original_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(original_message);
    if (message_arena != submessage_arena) {
      original_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, original_message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.original_message_ = original_message;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.EditChatMessageRequest.original_message)
}

// repeated string destination_identities = 4;
inline int EditChatMessageRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int EditChatMessageRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void EditChatMessageRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* EditChatMessageRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.EditChatMessageRequest.destination_identities)
  return _s;
}
inline const std::string& EditChatMessageRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& EditChatMessageRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.EditChatMessageRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* EditChatMessageRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.EditChatMessageRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void EditChatMessageRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline std::string* EditChatMessageRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void EditChatMessageRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline void EditChatMessageRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.EditChatMessageRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EditChatMessageRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.EditChatMessageRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EditChatMessageRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.EditChatMessageRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// optional string sender_identity = 5;
inline bool EditChatMessageRequest::_internal_has_sender_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EditChatMessageRequest::has_sender_identity() const {
  return _internal_has_sender_identity();
}
inline void EditChatMessageRequest::clear_sender_identity() {
  _impl_.sender_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EditChatMessageRequest::sender_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.EditChatMessageRequest.sender_identity)
  return _internal_sender_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditChatMessageRequest::set_sender_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sender_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.EditChatMessageRequest.sender_identity)
}
inline std::string* EditChatMessageRequest::mutable_sender_identity() {
  std::string* _s = _internal_mutable_sender_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.EditChatMessageRequest.sender_identity)
  return _s;
}
inline const std::string& EditChatMessageRequest::_internal_sender_identity() const {
  return _impl_.sender_identity_.Get();
}
inline void EditChatMessageRequest::_internal_set_sender_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sender_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* EditChatMessageRequest::_internal_mutable_sender_identity() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sender_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* EditChatMessageRequest::release_sender_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.EditChatMessageRequest.sender_identity)
  if (!_internal_has_sender_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sender_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EditChatMessageRequest::set_allocated_sender_identity(std::string* sender_identity) {
  if (sender_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sender_identity_.SetAllocated(sender_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.EditChatMessageRequest.sender_identity)
}

// -------------------------------------------------------------------

// SendChatMessageResponse

// required uint64 async_id = 1;
inline bool SendChatMessageResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendChatMessageResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendChatMessageResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SendChatMessageResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendChatMessageResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageResponse.async_id)
  return _internal_async_id();
}
inline void SendChatMessageResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SendChatMessageResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageResponse.async_id)
}

// -------------------------------------------------------------------

// SendChatMessageCallback

// required uint64 async_id = 1;
inline bool SendChatMessageCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendChatMessageCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendChatMessageCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SendChatMessageCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendChatMessageCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageCallback.async_id)
  return _internal_async_id();
}
inline void SendChatMessageCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SendChatMessageCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageCallback.async_id)
}

// string error = 2;
inline bool SendChatMessageCallback::_internal_has_error() const {
  return message_case() == kError;
}
inline bool SendChatMessageCallback::has_error() const {
  return _internal_has_error();
}
inline void SendChatMessageCallback::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void SendChatMessageCallback::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& SendChatMessageCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void SendChatMessageCallback::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendChatMessageCallback.error)
}
inline std::string* SendChatMessageCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendChatMessageCallback.error)
  return _s;
}
inline const std::string& SendChatMessageCallback::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SendChatMessageCallback::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SendChatMessageCallback::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* SendChatMessageCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendChatMessageCallback.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void SendChatMessageCallback::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendChatMessageCallback.error)
}

// .livekit.proto.ChatMessage chat_message = 3;
inline bool SendChatMessageCallback::_internal_has_chat_message() const {
  return message_case() == kChatMessage;
}
inline bool SendChatMessageCallback::has_chat_message() const {
  return _internal_has_chat_message();
}
inline void SendChatMessageCallback::set_has_chat_message() {
  _impl_._oneof_case_[0] = kChatMessage;
}
inline void SendChatMessageCallback::clear_chat_message() {
  if (_internal_has_chat_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.chat_message_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ChatMessage* SendChatMessageCallback::release_chat_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendChatMessageCallback.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
    ::livekit::proto::ChatMessage* temp = _impl_.message_.chat_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ChatMessage& SendChatMessageCallback::_internal_chat_message() const {
  return _internal_has_chat_message()
      ? *_impl_.message_.chat_message_
      : reinterpret_cast< ::livekit::proto::ChatMessage&>(::livekit::proto::_ChatMessage_default_instance_);
}
inline const ::livekit::proto::ChatMessage& SendChatMessageCallback::chat_message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendChatMessageCallback.chat_message)
  return _internal_chat_message();
}
inline ::livekit::proto::ChatMessage* SendChatMessageCallback::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.SendChatMessageCallback.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
    ::livekit::proto::ChatMessage* temp = _impl_.message_.chat_message_;
    _impl_.message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SendChatMessageCallback::unsafe_arena_set_allocated_chat_message(::livekit::proto::ChatMessage* chat_message) {
  clear_message();
  if (chat_message) {
    set_has_chat_message();
    _impl_.message_.chat_message_ = chat_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.SendChatMessageCallback.chat_message)
}
inline ::livekit::proto::ChatMessage* SendChatMessageCallback::_internal_mutable_chat_message() {
  if (!_internal_has_chat_message()) {
    clear_message();
    set_has_chat_message();
    _impl_.message_.chat_message_ = CreateMaybeMessage< ::livekit::proto::ChatMessage >(GetArenaForAllocation());
  }
  return _impl_.message_.chat_message_;
}
inline ::livekit::proto::ChatMessage* SendChatMessageCallback::mutable_chat_message() {
  ::livekit::proto::ChatMessage* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendChatMessageCallback.chat_message)
  return _msg;
}

inline bool SendChatMessageCallback::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SendChatMessageCallback::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SendChatMessageCallback::MessageCase SendChatMessageCallback::message_case() const {
  return SendChatMessageCallback::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetLocalAttributesRequest

// required uint64 local_participant_handle = 1;
inline bool SetLocalAttributesRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalAttributesRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SetLocalAttributesRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetLocalAttributesRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SetLocalAttributesRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalAttributesRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SetLocalAttributesRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.local_participant_handle_ = value;
}
inline void SetLocalAttributesRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalAttributesRequest.local_participant_handle)
}

// repeated .livekit.proto.AttributesEntry attributes = 2;
inline int SetLocalAttributesRequest::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SetLocalAttributesRequest::attributes_size() const {
  return _internal_attributes_size();
}
inline void SetLocalAttributesRequest::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline ::livekit::proto::AttributesEntry* SetLocalAttributesRequest::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalAttributesRequest.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
SetLocalAttributesRequest::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SetLocalAttributesRequest.attributes)
  return &_impl_.attributes_;
}
inline const ::livekit::proto::AttributesEntry& SetLocalAttributesRequest::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const ::livekit::proto::AttributesEntry& SetLocalAttributesRequest::attributes(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalAttributesRequest.attributes)
  return _internal_attributes(index);
}
inline ::livekit::proto::AttributesEntry* SetLocalAttributesRequest::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline ::livekit::proto::AttributesEntry* SetLocalAttributesRequest::add_attributes() {
  ::livekit::proto::AttributesEntry* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:livekit.proto.SetLocalAttributesRequest.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
SetLocalAttributesRequest::attributes() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SetLocalAttributesRequest.attributes)
  return _impl_.attributes_;
}

// -------------------------------------------------------------------

// AttributesEntry

// required string key = 1;
inline bool AttributesEntry::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AttributesEntry::has_key() const {
  return _internal_has_key();
}
inline void AttributesEntry::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AttributesEntry::key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AttributesEntry.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttributesEntry::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.AttributesEntry.key)
}
inline std::string* AttributesEntry::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AttributesEntry.key)
  return _s;
}
inline const std::string& AttributesEntry::_internal_key() const {
  return _impl_.key_.Get();
}
inline void AttributesEntry::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributesEntry::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* AttributesEntry::release_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.AttributesEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttributesEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AttributesEntry.key)
}

// required string value = 2;
inline bool AttributesEntry::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AttributesEntry::has_value() const {
  return _internal_has_value();
}
inline void AttributesEntry::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AttributesEntry::value() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AttributesEntry.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttributesEntry::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.AttributesEntry.value)
}
inline std::string* AttributesEntry::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:livekit.proto.AttributesEntry.value)
  return _s;
}
inline const std::string& AttributesEntry::_internal_value() const {
  return _impl_.value_.Get();
}
inline void AttributesEntry::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributesEntry::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* AttributesEntry::release_value() {
  // @@protoc_insertion_point(field_release:livekit.proto.AttributesEntry.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AttributesEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.AttributesEntry.value)
}

// -------------------------------------------------------------------

// SetLocalAttributesResponse

// required uint64 async_id = 1;
inline bool SetLocalAttributesResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalAttributesResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalAttributesResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetLocalAttributesResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalAttributesResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalAttributesResponse.async_id)
  return _internal_async_id();
}
inline void SetLocalAttributesResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SetLocalAttributesResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalAttributesResponse.async_id)
}

// -------------------------------------------------------------------

// SetLocalAttributesCallback

// required uint64 async_id = 1;
inline bool SetLocalAttributesCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLocalAttributesCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalAttributesCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetLocalAttributesCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalAttributesCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalAttributesCallback.async_id)
  return _internal_async_id();
}
inline void SetLocalAttributesCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SetLocalAttributesCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalAttributesCallback.async_id)
}

// optional string error = 2;
inline bool SetLocalAttributesCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalAttributesCallback::has_error() const {
  return _internal_has_error();
}
inline void SetLocalAttributesCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLocalAttributesCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalAttributesCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalAttributesCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalAttributesCallback.error)
}
inline std::string* SetLocalAttributesCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalAttributesCallback.error)
  return _s;
}
inline const std::string& SetLocalAttributesCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SetLocalAttributesCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalAttributesCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalAttributesCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetLocalAttributesCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetLocalAttributesCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetLocalAttributesCallback.error)
}

// -------------------------------------------------------------------

// SetLocalNameRequest

// required uint64 local_participant_handle = 1;
inline bool SetLocalNameRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLocalNameRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SetLocalNameRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetLocalNameRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SetLocalNameRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalNameRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SetLocalNameRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_participant_handle_ = value;
}
inline void SetLocalNameRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalNameRequest.local_participant_handle)
}

// required string name = 2;
inline bool SetLocalNameRequest::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalNameRequest::has_name() const {
  return _internal_has_name();
}
inline void SetLocalNameRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLocalNameRequest::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalNameRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalNameRequest::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalNameRequest.name)
}
inline std::string* SetLocalNameRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalNameRequest.name)
  return _s;
}
inline const std::string& SetLocalNameRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SetLocalNameRequest::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalNameRequest::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalNameRequest::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetLocalNameRequest.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetLocalNameRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetLocalNameRequest.name)
}

// -------------------------------------------------------------------

// SetLocalNameResponse

// required uint64 async_id = 1;
inline bool SetLocalNameResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalNameResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalNameResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetLocalNameResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalNameResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalNameResponse.async_id)
  return _internal_async_id();
}
inline void SetLocalNameResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SetLocalNameResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalNameResponse.async_id)
}

// -------------------------------------------------------------------

// SetLocalNameCallback

// required uint64 async_id = 1;
inline bool SetLocalNameCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetLocalNameCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SetLocalNameCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetLocalNameCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SetLocalNameCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalNameCallback.async_id)
  return _internal_async_id();
}
inline void SetLocalNameCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SetLocalNameCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalNameCallback.async_id)
}

// optional string error = 2;
inline bool SetLocalNameCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetLocalNameCallback::has_error() const {
  return _internal_has_error();
}
inline void SetLocalNameCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetLocalNameCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetLocalNameCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLocalNameCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetLocalNameCallback.error)
}
inline std::string* SetLocalNameCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetLocalNameCallback.error)
  return _s;
}
inline const std::string& SetLocalNameCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SetLocalNameCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLocalNameCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLocalNameCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetLocalNameCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetLocalNameCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetLocalNameCallback.error)
}

// -------------------------------------------------------------------

// SetSubscribedRequest

// required bool subscribe = 1;
inline bool SetSubscribedRequest::_internal_has_subscribe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetSubscribedRequest::has_subscribe() const {
  return _internal_has_subscribe();
}
inline void SetSubscribedRequest::clear_subscribe() {
  _impl_.subscribe_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SetSubscribedRequest::_internal_subscribe() const {
  return _impl_.subscribe_;
}
inline bool SetSubscribedRequest::subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetSubscribedRequest.subscribe)
  return _internal_subscribe();
}
inline void SetSubscribedRequest::_internal_set_subscribe(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscribe_ = value;
}
inline void SetSubscribedRequest::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetSubscribedRequest.subscribe)
}

// required uint64 publication_handle = 2;
inline bool SetSubscribedRequest::_internal_has_publication_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetSubscribedRequest::has_publication_handle() const {
  return _internal_has_publication_handle();
}
inline void SetSubscribedRequest::clear_publication_handle() {
  _impl_.publication_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetSubscribedRequest::_internal_publication_handle() const {
  return _impl_.publication_handle_;
}
inline uint64_t SetSubscribedRequest::publication_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetSubscribedRequest.publication_handle)
  return _internal_publication_handle();
}
inline void SetSubscribedRequest::_internal_set_publication_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publication_handle_ = value;
}
inline void SetSubscribedRequest::set_publication_handle(uint64_t value) {
  _internal_set_publication_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetSubscribedRequest.publication_handle)
}

// -------------------------------------------------------------------

// SetSubscribedResponse

// -------------------------------------------------------------------

// GetSessionStatsRequest

// required uint64 room_handle = 1;
inline bool GetSessionStatsRequest::_internal_has_room_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSessionStatsRequest::has_room_handle() const {
  return _internal_has_room_handle();
}
inline void GetSessionStatsRequest::clear_room_handle() {
  _impl_.room_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetSessionStatsRequest::_internal_room_handle() const {
  return _impl_.room_handle_;
}
inline uint64_t GetSessionStatsRequest::room_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsRequest.room_handle)
  return _internal_room_handle();
}
inline void GetSessionStatsRequest::_internal_set_room_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_handle_ = value;
}
inline void GetSessionStatsRequest::set_room_handle(uint64_t value) {
  _internal_set_room_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetSessionStatsRequest.room_handle)
}

// -------------------------------------------------------------------

// GetSessionStatsResponse

// required uint64 async_id = 1;
inline bool GetSessionStatsResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSessionStatsResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void GetSessionStatsResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetSessionStatsResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t GetSessionStatsResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsResponse.async_id)
  return _internal_async_id();
}
inline void GetSessionStatsResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void GetSessionStatsResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetSessionStatsResponse.async_id)
}

// -------------------------------------------------------------------

// GetSessionStatsCallback_Result

// repeated .livekit.proto.RtcStats publisher_stats = 1;
inline int GetSessionStatsCallback_Result::_internal_publisher_stats_size() const {
  return _impl_.publisher_stats_.size();
}
inline int GetSessionStatsCallback_Result::publisher_stats_size() const {
  return _internal_publisher_stats_size();
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::mutable_publisher_stats(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetSessionStatsCallback.Result.publisher_stats)
  return _impl_.publisher_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
GetSessionStatsCallback_Result::mutable_publisher_stats() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.GetSessionStatsCallback.Result.publisher_stats)
  return &_impl_.publisher_stats_;
}
inline const ::livekit::proto::RtcStats& GetSessionStatsCallback_Result::_internal_publisher_stats(int index) const {
  return _impl_.publisher_stats_.Get(index);
}
inline const ::livekit::proto::RtcStats& GetSessionStatsCallback_Result::publisher_stats(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsCallback.Result.publisher_stats)
  return _internal_publisher_stats(index);
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::_internal_add_publisher_stats() {
  return _impl_.publisher_stats_.Add();
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::add_publisher_stats() {
  ::livekit::proto::RtcStats* _add = _internal_add_publisher_stats();
  // @@protoc_insertion_point(field_add:livekit.proto.GetSessionStatsCallback.Result.publisher_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
GetSessionStatsCallback_Result::publisher_stats() const {
  // @@protoc_insertion_point(field_list:livekit.proto.GetSessionStatsCallback.Result.publisher_stats)
  return _impl_.publisher_stats_;
}

// repeated .livekit.proto.RtcStats subscriber_stats = 2;
inline int GetSessionStatsCallback_Result::_internal_subscriber_stats_size() const {
  return _impl_.subscriber_stats_.size();
}
inline int GetSessionStatsCallback_Result::subscriber_stats_size() const {
  return _internal_subscriber_stats_size();
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::mutable_subscriber_stats(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetSessionStatsCallback.Result.subscriber_stats)
  return _impl_.subscriber_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >*
GetSessionStatsCallback_Result::mutable_subscriber_stats() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.GetSessionStatsCallback.Result.subscriber_stats)
  return &_impl_.subscriber_stats_;
}
inline const ::livekit::proto::RtcStats& GetSessionStatsCallback_Result::_internal_subscriber_stats(int index) const {
  return _impl_.subscriber_stats_.Get(index);
}
inline const ::livekit::proto::RtcStats& GetSessionStatsCallback_Result::subscriber_stats(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsCallback.Result.subscriber_stats)
  return _internal_subscriber_stats(index);
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::_internal_add_subscriber_stats() {
  return _impl_.subscriber_stats_.Add();
}
inline ::livekit::proto::RtcStats* GetSessionStatsCallback_Result::add_subscriber_stats() {
  ::livekit::proto::RtcStats* _add = _internal_add_subscriber_stats();
  // @@protoc_insertion_point(field_add:livekit.proto.GetSessionStatsCallback.Result.subscriber_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::RtcStats >&
GetSessionStatsCallback_Result::subscriber_stats() const {
  // @@protoc_insertion_point(field_list:livekit.proto.GetSessionStatsCallback.Result.subscriber_stats)
  return _impl_.subscriber_stats_;
}

// -------------------------------------------------------------------

// GetSessionStatsCallback

// required uint64 async_id = 1;
inline bool GetSessionStatsCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSessionStatsCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void GetSessionStatsCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t GetSessionStatsCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t GetSessionStatsCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsCallback.async_id)
  return _internal_async_id();
}
inline void GetSessionStatsCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void GetSessionStatsCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetSessionStatsCallback.async_id)
}

// string error = 2;
inline bool GetSessionStatsCallback::_internal_has_error() const {
  return message_case() == kError;
}
inline bool GetSessionStatsCallback::has_error() const {
  return _internal_has_error();
}
inline void GetSessionStatsCallback::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void GetSessionStatsCallback::clear_error() {
  if (_internal_has_error()) {
    _impl_.message_.error_.Destroy();
    clear_has_message();
  }
}
inline const std::string& GetSessionStatsCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline void GetSessionStatsCallback::set_error(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.GetSessionStatsCallback.error)
}
inline std::string* GetSessionStatsCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetSessionStatsCallback.error)
  return _s;
}
inline const std::string& GetSessionStatsCallback::_internal_error() const {
  if (_internal_has_error()) {
    return _impl_.message_.error_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetSessionStatsCallback::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  _impl_.message_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSessionStatsCallback::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_message();
    set_has_error();
    _impl_.message_.error_.InitDefault();
  }
  return _impl_.message_.error_.Mutable(      GetArenaForAllocation());
}
inline std::string* GetSessionStatsCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetSessionStatsCallback.error)
  if (_internal_has_error()) {
    clear_has_message();
    return _impl_.message_.error_.Release();
  } else {
    return nullptr;
  }
}
inline void GetSessionStatsCallback::set_allocated_error(std::string* error) {
  if (has_message()) {
    clear_message();
  }
  if (error != nullptr) {
    set_has_error();
    _impl_.message_.error_.InitAllocated(error, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.GetSessionStatsCallback.error)
}

// .livekit.proto.GetSessionStatsCallback.Result result = 3;
inline bool GetSessionStatsCallback::_internal_has_result() const {
  return message_case() == kResult;
}
inline bool GetSessionStatsCallback::has_result() const {
  return _internal_has_result();
}
inline void GetSessionStatsCallback::set_has_result() {
  _impl_._oneof_case_[0] = kResult;
}
inline void GetSessionStatsCallback::clear_result() {
  if (_internal_has_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.result_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::GetSessionStatsCallback_Result* GetSessionStatsCallback::release_result() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetSessionStatsCallback.result)
  if (_internal_has_result()) {
    clear_has_message();
    ::livekit::proto::GetSessionStatsCallback_Result* temp = _impl_.message_.result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::GetSessionStatsCallback_Result& GetSessionStatsCallback::_internal_result() const {
  return _internal_has_result()
      ? *_impl_.message_.result_
      : reinterpret_cast< ::livekit::proto::GetSessionStatsCallback_Result&>(::livekit::proto::_GetSessionStatsCallback_Result_default_instance_);
}
inline const ::livekit::proto::GetSessionStatsCallback_Result& GetSessionStatsCallback::result() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSessionStatsCallback.result)
  return _internal_result();
}
inline ::livekit::proto::GetSessionStatsCallback_Result* GetSessionStatsCallback::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.GetSessionStatsCallback.result)
  if (_internal_has_result()) {
    clear_has_message();
    ::livekit::proto::GetSessionStatsCallback_Result* temp = _impl_.message_.result_;
    _impl_.message_.result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetSessionStatsCallback::unsafe_arena_set_allocated_result(::livekit::proto::GetSessionStatsCallback_Result* result) {
  clear_message();
  if (result) {
    set_has_result();
    _impl_.message_.result_ = result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.GetSessionStatsCallback.result)
}
inline ::livekit::proto::GetSessionStatsCallback_Result* GetSessionStatsCallback::_internal_mutable_result() {
  if (!_internal_has_result()) {
    clear_message();
    set_has_result();
    _impl_.message_.result_ = CreateMaybeMessage< ::livekit::proto::GetSessionStatsCallback_Result >(GetArenaForAllocation());
  }
  return _impl_.message_.result_;
}
inline ::livekit::proto::GetSessionStatsCallback_Result* GetSessionStatsCallback::mutable_result() {
  ::livekit::proto::GetSessionStatsCallback_Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetSessionStatsCallback.result)
  return _msg;
}

inline bool GetSessionStatsCallback::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void GetSessionStatsCallback::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline GetSessionStatsCallback::MessageCase GetSessionStatsCallback::message_case() const {
  return GetSessionStatsCallback::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VideoEncoding

// required uint64 max_bitrate = 1;
inline bool VideoEncoding::_internal_has_max_bitrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoEncoding::has_max_bitrate() const {
  return _internal_has_max_bitrate();
}
inline void VideoEncoding::clear_max_bitrate() {
  _impl_.max_bitrate_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t VideoEncoding::_internal_max_bitrate() const {
  return _impl_.max_bitrate_;
}
inline uint64_t VideoEncoding::max_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoEncoding.max_bitrate)
  return _internal_max_bitrate();
}
inline void VideoEncoding::_internal_set_max_bitrate(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_bitrate_ = value;
}
inline void VideoEncoding::set_max_bitrate(uint64_t value) {
  _internal_set_max_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoEncoding.max_bitrate)
}

// required double max_framerate = 2;
inline bool VideoEncoding::_internal_has_max_framerate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoEncoding::has_max_framerate() const {
  return _internal_has_max_framerate();
}
inline void VideoEncoding::clear_max_framerate() {
  _impl_.max_framerate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double VideoEncoding::_internal_max_framerate() const {
  return _impl_.max_framerate_;
}
inline double VideoEncoding::max_framerate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.VideoEncoding.max_framerate)
  return _internal_max_framerate();
}
inline void VideoEncoding::_internal_set_max_framerate(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_framerate_ = value;
}
inline void VideoEncoding::set_max_framerate(double value) {
  _internal_set_max_framerate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.VideoEncoding.max_framerate)
}

// -------------------------------------------------------------------

// AudioEncoding

// required uint64 max_bitrate = 1;
inline bool AudioEncoding::_internal_has_max_bitrate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioEncoding::has_max_bitrate() const {
  return _internal_has_max_bitrate();
}
inline void AudioEncoding::clear_max_bitrate() {
  _impl_.max_bitrate_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AudioEncoding::_internal_max_bitrate() const {
  return _impl_.max_bitrate_;
}
inline uint64_t AudioEncoding::max_bitrate() const {
  // @@protoc_insertion_point(field_get:livekit.proto.AudioEncoding.max_bitrate)
  return _internal_max_bitrate();
}
inline void AudioEncoding::_internal_set_max_bitrate(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_bitrate_ = value;
}
inline void AudioEncoding::set_max_bitrate(uint64_t value) {
  _internal_set_max_bitrate(value);
  // @@protoc_insertion_point(field_set:livekit.proto.AudioEncoding.max_bitrate)
}

// -------------------------------------------------------------------

// TrackPublishOptions

// optional .livekit.proto.VideoEncoding video_encoding = 1;
inline bool TrackPublishOptions::_internal_has_video_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_encoding_ != nullptr);
  return value;
}
inline bool TrackPublishOptions::has_video_encoding() const {
  return _internal_has_video_encoding();
}
inline void TrackPublishOptions::clear_video_encoding() {
  if (_impl_.video_encoding_ != nullptr) _impl_.video_encoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::VideoEncoding& TrackPublishOptions::_internal_video_encoding() const {
  const ::livekit::proto::VideoEncoding* p = _impl_.video_encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::VideoEncoding&>(
      ::livekit::proto::_VideoEncoding_default_instance_);
}
inline const ::livekit::proto::VideoEncoding& TrackPublishOptions::video_encoding() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.video_encoding)
  return _internal_video_encoding();
}
inline void TrackPublishOptions::unsafe_arena_set_allocated_video_encoding(
    ::livekit::proto::VideoEncoding* video_encoding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_encoding_);
  }
  _impl_.video_encoding_ = video_encoding;
  if (video_encoding) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.TrackPublishOptions.video_encoding)
}
inline ::livekit::proto::VideoEncoding* TrackPublishOptions::release_video_encoding() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoEncoding* temp = _impl_.video_encoding_;
  _impl_.video_encoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::VideoEncoding* TrackPublishOptions::unsafe_arena_release_video_encoding() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublishOptions.video_encoding)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::VideoEncoding* temp = _impl_.video_encoding_;
  _impl_.video_encoding_ = nullptr;
  return temp;
}
inline ::livekit::proto::VideoEncoding* TrackPublishOptions::_internal_mutable_video_encoding() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.video_encoding_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::VideoEncoding>(GetArenaForAllocation());
    _impl_.video_encoding_ = p;
  }
  return _impl_.video_encoding_;
}
inline ::livekit::proto::VideoEncoding* TrackPublishOptions::mutable_video_encoding() {
  ::livekit::proto::VideoEncoding* _msg = _internal_mutable_video_encoding();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublishOptions.video_encoding)
  return _msg;
}
inline void TrackPublishOptions::set_allocated_video_encoding(::livekit::proto::VideoEncoding* video_encoding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_encoding_;
  }
  if (video_encoding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_encoding);
    if (message_arena != submessage_arena) {
      video_encoding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_encoding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.video_encoding_ = video_encoding;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublishOptions.video_encoding)
}

// optional .livekit.proto.AudioEncoding audio_encoding = 2;
inline bool TrackPublishOptions::_internal_has_audio_encoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_encoding_ != nullptr);
  return value;
}
inline bool TrackPublishOptions::has_audio_encoding() const {
  return _internal_has_audio_encoding();
}
inline void TrackPublishOptions::clear_audio_encoding() {
  if (_impl_.audio_encoding_ != nullptr) _impl_.audio_encoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::livekit::proto::AudioEncoding& TrackPublishOptions::_internal_audio_encoding() const {
  const ::livekit::proto::AudioEncoding* p = _impl_.audio_encoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::AudioEncoding&>(
      ::livekit::proto::_AudioEncoding_default_instance_);
}
inline const ::livekit::proto::AudioEncoding& TrackPublishOptions::audio_encoding() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.audio_encoding)
  return _internal_audio_encoding();
}
inline void TrackPublishOptions::unsafe_arena_set_allocated_audio_encoding(
    ::livekit::proto::AudioEncoding* audio_encoding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_encoding_);
  }
  _impl_.audio_encoding_ = audio_encoding;
  if (audio_encoding) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.TrackPublishOptions.audio_encoding)
}
inline ::livekit::proto::AudioEncoding* TrackPublishOptions::release_audio_encoding() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::AudioEncoding* temp = _impl_.audio_encoding_;
  _impl_.audio_encoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::AudioEncoding* TrackPublishOptions::unsafe_arena_release_audio_encoding() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublishOptions.audio_encoding)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::livekit::proto::AudioEncoding* temp = _impl_.audio_encoding_;
  _impl_.audio_encoding_ = nullptr;
  return temp;
}
inline ::livekit::proto::AudioEncoding* TrackPublishOptions::_internal_mutable_audio_encoding() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.audio_encoding_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::AudioEncoding>(GetArenaForAllocation());
    _impl_.audio_encoding_ = p;
  }
  return _impl_.audio_encoding_;
}
inline ::livekit::proto::AudioEncoding* TrackPublishOptions::mutable_audio_encoding() {
  ::livekit::proto::AudioEncoding* _msg = _internal_mutable_audio_encoding();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublishOptions.audio_encoding)
  return _msg;
}
inline void TrackPublishOptions::set_allocated_audio_encoding(::livekit::proto::AudioEncoding* audio_encoding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_encoding_;
  }
  if (audio_encoding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_encoding);
    if (message_arena != submessage_arena) {
      audio_encoding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_encoding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.audio_encoding_ = audio_encoding;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublishOptions.audio_encoding)
}

// optional .livekit.proto.VideoCodec video_codec = 3;
inline bool TrackPublishOptions::_internal_has_video_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_video_codec() const {
  return _internal_has_video_codec();
}
inline void TrackPublishOptions::clear_video_codec() {
  _impl_.video_codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::livekit::proto::VideoCodec TrackPublishOptions::_internal_video_codec() const {
  return static_cast< ::livekit::proto::VideoCodec >(_impl_.video_codec_);
}
inline ::livekit::proto::VideoCodec TrackPublishOptions::video_codec() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.video_codec)
  return _internal_video_codec();
}
inline void TrackPublishOptions::_internal_set_video_codec(::livekit::proto::VideoCodec value) {
  assert(::livekit::proto::VideoCodec_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.video_codec_ = value;
}
inline void TrackPublishOptions::set_video_codec(::livekit::proto::VideoCodec value) {
  _internal_set_video_codec(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.video_codec)
}

// optional bool dtx = 4;
inline bool TrackPublishOptions::_internal_has_dtx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_dtx() const {
  return _internal_has_dtx();
}
inline void TrackPublishOptions::clear_dtx() {
  _impl_.dtx_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool TrackPublishOptions::_internal_dtx() const {
  return _impl_.dtx_;
}
inline bool TrackPublishOptions::dtx() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.dtx)
  return _internal_dtx();
}
inline void TrackPublishOptions::_internal_set_dtx(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dtx_ = value;
}
inline void TrackPublishOptions::set_dtx(bool value) {
  _internal_set_dtx(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.dtx)
}

// optional bool red = 5;
inline bool TrackPublishOptions::_internal_has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_red() const {
  return _internal_has_red();
}
inline void TrackPublishOptions::clear_red() {
  _impl_.red_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TrackPublishOptions::_internal_red() const {
  return _impl_.red_;
}
inline bool TrackPublishOptions::red() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.red)
  return _internal_red();
}
inline void TrackPublishOptions::_internal_set_red(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.red_ = value;
}
inline void TrackPublishOptions::set_red(bool value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.red)
}

// optional bool simulcast = 6;
inline bool TrackPublishOptions::_internal_has_simulcast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_simulcast() const {
  return _internal_has_simulcast();
}
inline void TrackPublishOptions::clear_simulcast() {
  _impl_.simulcast_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TrackPublishOptions::_internal_simulcast() const {
  return _impl_.simulcast_;
}
inline bool TrackPublishOptions::simulcast() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.simulcast)
  return _internal_simulcast();
}
inline void TrackPublishOptions::_internal_set_simulcast(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.simulcast_ = value;
}
inline void TrackPublishOptions::set_simulcast(bool value) {
  _internal_set_simulcast(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.simulcast)
}

// optional .livekit.proto.TrackSource source = 7;
inline bool TrackPublishOptions::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_source() const {
  return _internal_has_source();
}
inline void TrackPublishOptions::clear_source() {
  _impl_.source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::livekit::proto::TrackSource TrackPublishOptions::_internal_source() const {
  return static_cast< ::livekit::proto::TrackSource >(_impl_.source_);
}
inline ::livekit::proto::TrackSource TrackPublishOptions::source() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.source)
  return _internal_source();
}
inline void TrackPublishOptions::_internal_set_source(::livekit::proto::TrackSource value) {
  assert(::livekit::proto::TrackSource_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.source_ = value;
}
inline void TrackPublishOptions::set_source(::livekit::proto::TrackSource value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.source)
}

// optional string stream = 8;
inline bool TrackPublishOptions::_internal_has_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackPublishOptions::has_stream() const {
  return _internal_has_stream();
}
inline void TrackPublishOptions::clear_stream() {
  _impl_.stream_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackPublishOptions::stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublishOptions.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublishOptions::set_stream(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublishOptions.stream)
}
inline std::string* TrackPublishOptions::mutable_stream() {
  std::string* _s = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublishOptions.stream)
  return _s;
}
inline const std::string& TrackPublishOptions::_internal_stream() const {
  return _impl_.stream_.Get();
}
inline void TrackPublishOptions::_internal_set_stream(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublishOptions::_internal_mutable_stream() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublishOptions::release_stream() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublishOptions.stream)
  if (!_internal_has_stream()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackPublishOptions::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_.SetAllocated(stream, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_.IsDefault()) {
    _impl_.stream_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublishOptions.stream)
}

// -------------------------------------------------------------------

// IceServer

// repeated string urls = 1;
inline int IceServer::_internal_urls_size() const {
  return _impl_.urls_.size();
}
inline int IceServer::urls_size() const {
  return _internal_urls_size();
}
inline void IceServer::clear_urls() {
  _impl_.urls_.Clear();
}
inline std::string* IceServer::add_urls() {
  std::string* _s = _internal_add_urls();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.IceServer.urls)
  return _s;
}
inline const std::string& IceServer::_internal_urls(int index) const {
  return _impl_.urls_.Get(index);
}
inline const std::string& IceServer::urls(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.IceServer.urls)
  return _internal_urls(index);
}
inline std::string* IceServer::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.IceServer.urls)
  return _impl_.urls_.Mutable(index);
}
inline void IceServer::set_urls(int index, const std::string& value) {
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.IceServer.urls)
}
inline void IceServer::set_urls(int index, std::string&& value) {
  _impl_.urls_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.IceServer.urls)
}
inline void IceServer::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.IceServer.urls)
}
inline void IceServer::set_urls(int index, const char* value, size_t size) {
  _impl_.urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.IceServer.urls)
}
inline std::string* IceServer::_internal_add_urls() {
  return _impl_.urls_.Add();
}
inline void IceServer::add_urls(const std::string& value) {
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.IceServer.urls)
}
inline void IceServer::add_urls(std::string&& value) {
  _impl_.urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.IceServer.urls)
}
inline void IceServer::add_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.IceServer.urls)
}
inline void IceServer::add_urls(const char* value, size_t size) {
  _impl_.urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.IceServer.urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IceServer::urls() const {
  // @@protoc_insertion_point(field_list:livekit.proto.IceServer.urls)
  return _impl_.urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IceServer::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.IceServer.urls)
  return &_impl_.urls_;
}

// optional string username = 2;
inline bool IceServer::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IceServer::has_username() const {
  return _internal_has_username();
}
inline void IceServer::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IceServer::username() const {
  // @@protoc_insertion_point(field_get:livekit.proto.IceServer.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IceServer::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.IceServer.username)
}
inline std::string* IceServer::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:livekit.proto.IceServer.username)
  return _s;
}
inline const std::string& IceServer::_internal_username() const {
  return _impl_.username_.Get();
}
inline void IceServer::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* IceServer::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* IceServer::release_username() {
  // @@protoc_insertion_point(field_release:livekit.proto.IceServer.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IceServer::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.IceServer.username)
}

// optional string password = 3;
inline bool IceServer::_internal_has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IceServer::has_password() const {
  return _internal_has_password();
}
inline void IceServer::clear_password() {
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IceServer::password() const {
  // @@protoc_insertion_point(field_get:livekit.proto.IceServer.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IceServer::set_password(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.IceServer.password)
}
inline std::string* IceServer::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:livekit.proto.IceServer.password)
  return _s;
}
inline const std::string& IceServer::_internal_password() const {
  return _impl_.password_.Get();
}
inline void IceServer::_internal_set_password(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* IceServer::_internal_mutable_password() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* IceServer::release_password() {
  // @@protoc_insertion_point(field_release:livekit.proto.IceServer.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.password_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IceServer::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.IceServer.password)
}

// -------------------------------------------------------------------

// RtcConfig

// optional .livekit.proto.IceTransportType ice_transport_type = 1;
inline bool RtcConfig::_internal_has_ice_transport_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RtcConfig::has_ice_transport_type() const {
  return _internal_has_ice_transport_type();
}
inline void RtcConfig::clear_ice_transport_type() {
  _impl_.ice_transport_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::IceTransportType RtcConfig::_internal_ice_transport_type() const {
  return static_cast< ::livekit::proto::IceTransportType >(_impl_.ice_transport_type_);
}
inline ::livekit::proto::IceTransportType RtcConfig::ice_transport_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RtcConfig.ice_transport_type)
  return _internal_ice_transport_type();
}
inline void RtcConfig::_internal_set_ice_transport_type(::livekit::proto::IceTransportType value) {
  assert(::livekit::proto::IceTransportType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ice_transport_type_ = value;
}
inline void RtcConfig::set_ice_transport_type(::livekit::proto::IceTransportType value) {
  _internal_set_ice_transport_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RtcConfig.ice_transport_type)
}

// optional .livekit.proto.ContinualGatheringPolicy continual_gathering_policy = 2;
inline bool RtcConfig::_internal_has_continual_gathering_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RtcConfig::has_continual_gathering_policy() const {
  return _internal_has_continual_gathering_policy();
}
inline void RtcConfig::clear_continual_gathering_policy() {
  _impl_.continual_gathering_policy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::ContinualGatheringPolicy RtcConfig::_internal_continual_gathering_policy() const {
  return static_cast< ::livekit::proto::ContinualGatheringPolicy >(_impl_.continual_gathering_policy_);
}
inline ::livekit::proto::ContinualGatheringPolicy RtcConfig::continual_gathering_policy() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RtcConfig.continual_gathering_policy)
  return _internal_continual_gathering_policy();
}
inline void RtcConfig::_internal_set_continual_gathering_policy(::livekit::proto::ContinualGatheringPolicy value) {
  assert(::livekit::proto::ContinualGatheringPolicy_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.continual_gathering_policy_ = value;
}
inline void RtcConfig::set_continual_gathering_policy(::livekit::proto::ContinualGatheringPolicy value) {
  _internal_set_continual_gathering_policy(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RtcConfig.continual_gathering_policy)
}

// repeated .livekit.proto.IceServer ice_servers = 3;
inline int RtcConfig::_internal_ice_servers_size() const {
  return _impl_.ice_servers_.size();
}
inline int RtcConfig::ice_servers_size() const {
  return _internal_ice_servers_size();
}
inline void RtcConfig::clear_ice_servers() {
  _impl_.ice_servers_.Clear();
}
inline ::livekit::proto::IceServer* RtcConfig::mutable_ice_servers(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.RtcConfig.ice_servers)
  return _impl_.ice_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::IceServer >*
RtcConfig::mutable_ice_servers() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.RtcConfig.ice_servers)
  return &_impl_.ice_servers_;
}
inline const ::livekit::proto::IceServer& RtcConfig::_internal_ice_servers(int index) const {
  return _impl_.ice_servers_.Get(index);
}
inline const ::livekit::proto::IceServer& RtcConfig::ice_servers(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.RtcConfig.ice_servers)
  return _internal_ice_servers(index);
}
inline ::livekit::proto::IceServer* RtcConfig::_internal_add_ice_servers() {
  return _impl_.ice_servers_.Add();
}
inline ::livekit::proto::IceServer* RtcConfig::add_ice_servers() {
  ::livekit::proto::IceServer* _add = _internal_add_ice_servers();
  // @@protoc_insertion_point(field_add:livekit.proto.RtcConfig.ice_servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::IceServer >&
RtcConfig::ice_servers() const {
  // @@protoc_insertion_point(field_list:livekit.proto.RtcConfig.ice_servers)
  return _impl_.ice_servers_;
}

// -------------------------------------------------------------------

// RoomOptions

// optional bool auto_subscribe = 1;
inline bool RoomOptions::_internal_has_auto_subscribe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoomOptions::has_auto_subscribe() const {
  return _internal_has_auto_subscribe();
}
inline void RoomOptions::clear_auto_subscribe() {
  _impl_.auto_subscribe_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool RoomOptions::_internal_auto_subscribe() const {
  return _impl_.auto_subscribe_;
}
inline bool RoomOptions::auto_subscribe() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.auto_subscribe)
  return _internal_auto_subscribe();
}
inline void RoomOptions::_internal_set_auto_subscribe(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auto_subscribe_ = value;
}
inline void RoomOptions::set_auto_subscribe(bool value) {
  _internal_set_auto_subscribe(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomOptions.auto_subscribe)
}

// optional bool adaptive_stream = 2;
inline bool RoomOptions::_internal_has_adaptive_stream() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoomOptions::has_adaptive_stream() const {
  return _internal_has_adaptive_stream();
}
inline void RoomOptions::clear_adaptive_stream() {
  _impl_.adaptive_stream_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RoomOptions::_internal_adaptive_stream() const {
  return _impl_.adaptive_stream_;
}
inline bool RoomOptions::adaptive_stream() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.adaptive_stream)
  return _internal_adaptive_stream();
}
inline void RoomOptions::_internal_set_adaptive_stream(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.adaptive_stream_ = value;
}
inline void RoomOptions::set_adaptive_stream(bool value) {
  _internal_set_adaptive_stream(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomOptions.adaptive_stream)
}

// optional bool dynacast = 3;
inline bool RoomOptions::_internal_has_dynacast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RoomOptions::has_dynacast() const {
  return _internal_has_dynacast();
}
inline void RoomOptions::clear_dynacast() {
  _impl_.dynacast_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RoomOptions::_internal_dynacast() const {
  return _impl_.dynacast_;
}
inline bool RoomOptions::dynacast() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.dynacast)
  return _internal_dynacast();
}
inline void RoomOptions::_internal_set_dynacast(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dynacast_ = value;
}
inline void RoomOptions::set_dynacast(bool value) {
  _internal_set_dynacast(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomOptions.dynacast)
}

// optional .livekit.proto.E2eeOptions e2ee = 4;
inline bool RoomOptions::_internal_has_e2ee() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.e2ee_ != nullptr);
  return value;
}
inline bool RoomOptions::has_e2ee() const {
  return _internal_has_e2ee();
}
inline const ::livekit::proto::E2eeOptions& RoomOptions::_internal_e2ee() const {
  const ::livekit::proto::E2eeOptions* p = _impl_.e2ee_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::E2eeOptions&>(
      ::livekit::proto::_E2eeOptions_default_instance_);
}
inline const ::livekit::proto::E2eeOptions& RoomOptions::e2ee() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.e2ee)
  return _internal_e2ee();
}
inline void RoomOptions::unsafe_arena_set_allocated_e2ee(
    ::livekit::proto::E2eeOptions* e2ee) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2ee_);
  }
  _impl_.e2ee_ = e2ee;
  if (e2ee) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomOptions.e2ee)
}
inline ::livekit::proto::E2eeOptions* RoomOptions::release_e2ee() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::E2eeOptions* temp = _impl_.e2ee_;
  _impl_.e2ee_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::E2eeOptions* RoomOptions::unsafe_arena_release_e2ee() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomOptions.e2ee)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::E2eeOptions* temp = _impl_.e2ee_;
  _impl_.e2ee_ = nullptr;
  return temp;
}
inline ::livekit::proto::E2eeOptions* RoomOptions::_internal_mutable_e2ee() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.e2ee_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::E2eeOptions>(GetArenaForAllocation());
    _impl_.e2ee_ = p;
  }
  return _impl_.e2ee_;
}
inline ::livekit::proto::E2eeOptions* RoomOptions::mutable_e2ee() {
  ::livekit::proto::E2eeOptions* _msg = _internal_mutable_e2ee();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomOptions.e2ee)
  return _msg;
}
inline void RoomOptions::set_allocated_e2ee(::livekit::proto::E2eeOptions* e2ee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.e2ee_);
  }
  if (e2ee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(e2ee));
    if (message_arena != submessage_arena) {
      e2ee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, e2ee, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.e2ee_ = e2ee;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomOptions.e2ee)
}

// optional .livekit.proto.RtcConfig rtc_config = 5;
inline bool RoomOptions::_internal_has_rtc_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rtc_config_ != nullptr);
  return value;
}
inline bool RoomOptions::has_rtc_config() const {
  return _internal_has_rtc_config();
}
inline void RoomOptions::clear_rtc_config() {
  if (_impl_.rtc_config_ != nullptr) _impl_.rtc_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::RtcConfig& RoomOptions::_internal_rtc_config() const {
  const ::livekit::proto::RtcConfig* p = _impl_.rtc_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::RtcConfig&>(
      ::livekit::proto::_RtcConfig_default_instance_);
}
inline const ::livekit::proto::RtcConfig& RoomOptions::rtc_config() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.rtc_config)
  return _internal_rtc_config();
}
inline void RoomOptions::unsafe_arena_set_allocated_rtc_config(
    ::livekit::proto::RtcConfig* rtc_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rtc_config_);
  }
  _impl_.rtc_config_ = rtc_config;
  if (rtc_config) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomOptions.rtc_config)
}
inline ::livekit::proto::RtcConfig* RoomOptions::release_rtc_config() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::RtcConfig* temp = _impl_.rtc_config_;
  _impl_.rtc_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::RtcConfig* RoomOptions::unsafe_arena_release_rtc_config() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomOptions.rtc_config)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::RtcConfig* temp = _impl_.rtc_config_;
  _impl_.rtc_config_ = nullptr;
  return temp;
}
inline ::livekit::proto::RtcConfig* RoomOptions::_internal_mutable_rtc_config() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rtc_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::RtcConfig>(GetArenaForAllocation());
    _impl_.rtc_config_ = p;
  }
  return _impl_.rtc_config_;
}
inline ::livekit::proto::RtcConfig* RoomOptions::mutable_rtc_config() {
  ::livekit::proto::RtcConfig* _msg = _internal_mutable_rtc_config();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomOptions.rtc_config)
  return _msg;
}
inline void RoomOptions::set_allocated_rtc_config(::livekit::proto::RtcConfig* rtc_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rtc_config_;
  }
  if (rtc_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rtc_config);
    if (message_arena != submessage_arena) {
      rtc_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtc_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rtc_config_ = rtc_config;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomOptions.rtc_config)
}

// optional uint32 join_retries = 6;
inline bool RoomOptions::_internal_has_join_retries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RoomOptions::has_join_retries() const {
  return _internal_has_join_retries();
}
inline void RoomOptions::clear_join_retries() {
  _impl_.join_retries_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t RoomOptions::_internal_join_retries() const {
  return _impl_.join_retries_;
}
inline uint32_t RoomOptions::join_retries() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomOptions.join_retries)
  return _internal_join_retries();
}
inline void RoomOptions::_internal_set_join_retries(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.join_retries_ = value;
}
inline void RoomOptions::set_join_retries(uint32_t value) {
  _internal_set_join_retries(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomOptions.join_retries)
}

// -------------------------------------------------------------------

// TranscriptionSegment

// required string id = 1;
inline bool TranscriptionSegment::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_id() const {
  return _internal_has_id();
}
inline void TranscriptionSegment::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranscriptionSegment::id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.id)
}
inline std::string* TranscriptionSegment::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionSegment.id)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TranscriptionSegment::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.TranscriptionSegment.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranscriptionSegment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TranscriptionSegment.id)
}

// required string text = 2;
inline bool TranscriptionSegment::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_text() const {
  return _internal_has_text();
}
inline void TranscriptionSegment::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranscriptionSegment::text() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.text)
}
inline std::string* TranscriptionSegment::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionSegment.text)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_text() const {
  return _impl_.text_.Get();
}
inline void TranscriptionSegment::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_text() {
  // @@protoc_insertion_point(field_release:livekit.proto.TranscriptionSegment.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranscriptionSegment::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TranscriptionSegment.text)
}

// required uint64 start_time = 3;
inline bool TranscriptionSegment::_internal_has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_start_time() const {
  return _internal_has_start_time();
}
inline void TranscriptionSegment::clear_start_time() {
  _impl_.start_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t TranscriptionSegment::_internal_start_time() const {
  return _impl_.start_time_;
}
inline uint64_t TranscriptionSegment::start_time() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.start_time)
  return _internal_start_time();
}
inline void TranscriptionSegment::_internal_set_start_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.start_time_ = value;
}
inline void TranscriptionSegment::set_start_time(uint64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.start_time)
}

// required uint64 end_time = 4;
inline bool TranscriptionSegment::_internal_has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_end_time() const {
  return _internal_has_end_time();
}
inline void TranscriptionSegment::clear_end_time() {
  _impl_.end_time_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t TranscriptionSegment::_internal_end_time() const {
  return _impl_.end_time_;
}
inline uint64_t TranscriptionSegment::end_time() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.end_time)
  return _internal_end_time();
}
inline void TranscriptionSegment::_internal_set_end_time(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.end_time_ = value;
}
inline void TranscriptionSegment::set_end_time(uint64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.end_time)
}

// required bool final = 5;
inline bool TranscriptionSegment::_internal_has_final() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_final() const {
  return _internal_has_final();
}
inline void TranscriptionSegment::clear_final() {
  _impl_.final_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool TranscriptionSegment::_internal_final() const {
  return _impl_.final_;
}
inline bool TranscriptionSegment::final() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.final)
  return _internal_final();
}
inline void TranscriptionSegment::_internal_set_final(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.final_ = value;
}
inline void TranscriptionSegment::set_final(bool value) {
  _internal_set_final(value);
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.final)
}

// required string language = 6;
inline bool TranscriptionSegment::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TranscriptionSegment::has_language() const {
  return _internal_has_language();
}
inline void TranscriptionSegment::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TranscriptionSegment::language() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionSegment.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionSegment::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionSegment.language)
}
inline std::string* TranscriptionSegment::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionSegment.language)
  return _s;
}
inline const std::string& TranscriptionSegment::_internal_language() const {
  return _impl_.language_.Get();
}
inline void TranscriptionSegment::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionSegment::release_language() {
  // @@protoc_insertion_point(field_release:livekit.proto.TranscriptionSegment.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranscriptionSegment::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TranscriptionSegment.language)
}

// -------------------------------------------------------------------

// BufferInfo

// required uint64 data_ptr = 1;
inline bool BufferInfo::_internal_has_data_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BufferInfo::has_data_ptr() const {
  return _internal_has_data_ptr();
}
inline void BufferInfo::clear_data_ptr() {
  _impl_.data_ptr_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t BufferInfo::_internal_data_ptr() const {
  return _impl_.data_ptr_;
}
inline uint64_t BufferInfo::data_ptr() const {
  // @@protoc_insertion_point(field_get:livekit.proto.BufferInfo.data_ptr)
  return _internal_data_ptr();
}
inline void BufferInfo::_internal_set_data_ptr(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_ptr_ = value;
}
inline void BufferInfo::set_data_ptr(uint64_t value) {
  _internal_set_data_ptr(value);
  // @@protoc_insertion_point(field_set:livekit.proto.BufferInfo.data_ptr)
}

// required uint64 data_len = 2;
inline bool BufferInfo::_internal_has_data_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BufferInfo::has_data_len() const {
  return _internal_has_data_len();
}
inline void BufferInfo::clear_data_len() {
  _impl_.data_len_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t BufferInfo::_internal_data_len() const {
  return _impl_.data_len_;
}
inline uint64_t BufferInfo::data_len() const {
  // @@protoc_insertion_point(field_get:livekit.proto.BufferInfo.data_len)
  return _internal_data_len();
}
inline void BufferInfo::_internal_set_data_len(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_len_ = value;
}
inline void BufferInfo::set_data_len(uint64_t value) {
  _internal_set_data_len(value);
  // @@protoc_insertion_point(field_set:livekit.proto.BufferInfo.data_len)
}

// -------------------------------------------------------------------

// OwnedBuffer

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedBuffer::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedBuffer::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedBuffer::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedBuffer::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedBuffer.handle)
  return _internal_handle();
}
inline void OwnedBuffer::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedBuffer.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedBuffer::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedBuffer::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedBuffer.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedBuffer::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedBuffer::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedBuffer.handle)
  return _msg;
}
inline void OwnedBuffer::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedBuffer.handle)
}

// required .livekit.proto.BufferInfo data = 2;
inline bool OwnedBuffer::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline bool OwnedBuffer::has_data() const {
  return _internal_has_data();
}
inline void OwnedBuffer::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::BufferInfo& OwnedBuffer::_internal_data() const {
  const ::livekit::proto::BufferInfo* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::BufferInfo&>(
      ::livekit::proto::_BufferInfo_default_instance_);
}
inline const ::livekit::proto::BufferInfo& OwnedBuffer::data() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedBuffer.data)
  return _internal_data();
}
inline void OwnedBuffer::unsafe_arena_set_allocated_data(
    ::livekit::proto::BufferInfo* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedBuffer.data)
}
inline ::livekit::proto::BufferInfo* OwnedBuffer::release_data() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::BufferInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::BufferInfo* OwnedBuffer::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedBuffer.data)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::BufferInfo* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::livekit::proto::BufferInfo* OwnedBuffer::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::BufferInfo>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::livekit::proto::BufferInfo* OwnedBuffer::mutable_data() {
  ::livekit::proto::BufferInfo* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedBuffer.data)
  return _msg;
}
inline void OwnedBuffer::set_allocated_data(::livekit::proto::BufferInfo* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedBuffer.data)
}

// -------------------------------------------------------------------

// RoomEvent

// required uint64 room_handle = 1;
inline bool RoomEvent::_internal_has_room_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoomEvent::has_room_handle() const {
  return _internal_has_room_handle();
}
inline void RoomEvent::clear_room_handle() {
  _impl_.room_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t RoomEvent::_internal_room_handle() const {
  return _impl_.room_handle_;
}
inline uint64_t RoomEvent::room_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.room_handle)
  return _internal_room_handle();
}
inline void RoomEvent::_internal_set_room_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_handle_ = value;
}
inline void RoomEvent::set_room_handle(uint64_t value) {
  _internal_set_room_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomEvent.room_handle)
}

// .livekit.proto.ParticipantConnected participant_connected = 2;
inline bool RoomEvent::_internal_has_participant_connected() const {
  return message_case() == kParticipantConnected;
}
inline bool RoomEvent::has_participant_connected() const {
  return _internal_has_participant_connected();
}
inline void RoomEvent::set_has_participant_connected() {
  _impl_._oneof_case_[0] = kParticipantConnected;
}
inline void RoomEvent::clear_participant_connected() {
  if (_internal_has_participant_connected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.participant_connected_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ParticipantConnected* RoomEvent::release_participant_connected() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.participant_connected)
  if (_internal_has_participant_connected()) {
    clear_has_message();
    ::livekit::proto::ParticipantConnected* temp = _impl_.message_.participant_connected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.participant_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ParticipantConnected& RoomEvent::_internal_participant_connected() const {
  return _internal_has_participant_connected()
      ? *_impl_.message_.participant_connected_
      : reinterpret_cast< ::livekit::proto::ParticipantConnected&>(::livekit::proto::_ParticipantConnected_default_instance_);
}
inline const ::livekit::proto::ParticipantConnected& RoomEvent::participant_connected() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.participant_connected)
  return _internal_participant_connected();
}
inline ::livekit::proto::ParticipantConnected* RoomEvent::unsafe_arena_release_participant_connected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.participant_connected)
  if (_internal_has_participant_connected()) {
    clear_has_message();
    ::livekit::proto::ParticipantConnected* temp = _impl_.message_.participant_connected_;
    _impl_.message_.participant_connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_participant_connected(::livekit::proto::ParticipantConnected* participant_connected) {
  clear_message();
  if (participant_connected) {
    set_has_participant_connected();
    _impl_.message_.participant_connected_ = participant_connected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.participant_connected)
}
inline ::livekit::proto::ParticipantConnected* RoomEvent::_internal_mutable_participant_connected() {
  if (!_internal_has_participant_connected()) {
    clear_message();
    set_has_participant_connected();
    _impl_.message_.participant_connected_ = CreateMaybeMessage< ::livekit::proto::ParticipantConnected >(GetArenaForAllocation());
  }
  return _impl_.message_.participant_connected_;
}
inline ::livekit::proto::ParticipantConnected* RoomEvent::mutable_participant_connected() {
  ::livekit::proto::ParticipantConnected* _msg = _internal_mutable_participant_connected();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.participant_connected)
  return _msg;
}

// .livekit.proto.ParticipantDisconnected participant_disconnected = 3;
inline bool RoomEvent::_internal_has_participant_disconnected() const {
  return message_case() == kParticipantDisconnected;
}
inline bool RoomEvent::has_participant_disconnected() const {
  return _internal_has_participant_disconnected();
}
inline void RoomEvent::set_has_participant_disconnected() {
  _impl_._oneof_case_[0] = kParticipantDisconnected;
}
inline void RoomEvent::clear_participant_disconnected() {
  if (_internal_has_participant_disconnected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.participant_disconnected_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ParticipantDisconnected* RoomEvent::release_participant_disconnected() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.participant_disconnected)
  if (_internal_has_participant_disconnected()) {
    clear_has_message();
    ::livekit::proto::ParticipantDisconnected* temp = _impl_.message_.participant_disconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.participant_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ParticipantDisconnected& RoomEvent::_internal_participant_disconnected() const {
  return _internal_has_participant_disconnected()
      ? *_impl_.message_.participant_disconnected_
      : reinterpret_cast< ::livekit::proto::ParticipantDisconnected&>(::livekit::proto::_ParticipantDisconnected_default_instance_);
}
inline const ::livekit::proto::ParticipantDisconnected& RoomEvent::participant_disconnected() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.participant_disconnected)
  return _internal_participant_disconnected();
}
inline ::livekit::proto::ParticipantDisconnected* RoomEvent::unsafe_arena_release_participant_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.participant_disconnected)
  if (_internal_has_participant_disconnected()) {
    clear_has_message();
    ::livekit::proto::ParticipantDisconnected* temp = _impl_.message_.participant_disconnected_;
    _impl_.message_.participant_disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_participant_disconnected(::livekit::proto::ParticipantDisconnected* participant_disconnected) {
  clear_message();
  if (participant_disconnected) {
    set_has_participant_disconnected();
    _impl_.message_.participant_disconnected_ = participant_disconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.participant_disconnected)
}
inline ::livekit::proto::ParticipantDisconnected* RoomEvent::_internal_mutable_participant_disconnected() {
  if (!_internal_has_participant_disconnected()) {
    clear_message();
    set_has_participant_disconnected();
    _impl_.message_.participant_disconnected_ = CreateMaybeMessage< ::livekit::proto::ParticipantDisconnected >(GetArenaForAllocation());
  }
  return _impl_.message_.participant_disconnected_;
}
inline ::livekit::proto::ParticipantDisconnected* RoomEvent::mutable_participant_disconnected() {
  ::livekit::proto::ParticipantDisconnected* _msg = _internal_mutable_participant_disconnected();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.participant_disconnected)
  return _msg;
}

// .livekit.proto.LocalTrackPublished local_track_published = 4;
inline bool RoomEvent::_internal_has_local_track_published() const {
  return message_case() == kLocalTrackPublished;
}
inline bool RoomEvent::has_local_track_published() const {
  return _internal_has_local_track_published();
}
inline void RoomEvent::set_has_local_track_published() {
  _impl_._oneof_case_[0] = kLocalTrackPublished;
}
inline void RoomEvent::clear_local_track_published() {
  if (_internal_has_local_track_published()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.local_track_published_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::LocalTrackPublished* RoomEvent::release_local_track_published() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.local_track_published)
  if (_internal_has_local_track_published()) {
    clear_has_message();
    ::livekit::proto::LocalTrackPublished* temp = _impl_.message_.local_track_published_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.local_track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::LocalTrackPublished& RoomEvent::_internal_local_track_published() const {
  return _internal_has_local_track_published()
      ? *_impl_.message_.local_track_published_
      : reinterpret_cast< ::livekit::proto::LocalTrackPublished&>(::livekit::proto::_LocalTrackPublished_default_instance_);
}
inline const ::livekit::proto::LocalTrackPublished& RoomEvent::local_track_published() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.local_track_published)
  return _internal_local_track_published();
}
inline ::livekit::proto::LocalTrackPublished* RoomEvent::unsafe_arena_release_local_track_published() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.local_track_published)
  if (_internal_has_local_track_published()) {
    clear_has_message();
    ::livekit::proto::LocalTrackPublished* temp = _impl_.message_.local_track_published_;
    _impl_.message_.local_track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_local_track_published(::livekit::proto::LocalTrackPublished* local_track_published) {
  clear_message();
  if (local_track_published) {
    set_has_local_track_published();
    _impl_.message_.local_track_published_ = local_track_published;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.local_track_published)
}
inline ::livekit::proto::LocalTrackPublished* RoomEvent::_internal_mutable_local_track_published() {
  if (!_internal_has_local_track_published()) {
    clear_message();
    set_has_local_track_published();
    _impl_.message_.local_track_published_ = CreateMaybeMessage< ::livekit::proto::LocalTrackPublished >(GetArenaForAllocation());
  }
  return _impl_.message_.local_track_published_;
}
inline ::livekit::proto::LocalTrackPublished* RoomEvent::mutable_local_track_published() {
  ::livekit::proto::LocalTrackPublished* _msg = _internal_mutable_local_track_published();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.local_track_published)
  return _msg;
}

// .livekit.proto.LocalTrackUnpublished local_track_unpublished = 5;
inline bool RoomEvent::_internal_has_local_track_unpublished() const {
  return message_case() == kLocalTrackUnpublished;
}
inline bool RoomEvent::has_local_track_unpublished() const {
  return _internal_has_local_track_unpublished();
}
inline void RoomEvent::set_has_local_track_unpublished() {
  _impl_._oneof_case_[0] = kLocalTrackUnpublished;
}
inline void RoomEvent::clear_local_track_unpublished() {
  if (_internal_has_local_track_unpublished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.local_track_unpublished_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::LocalTrackUnpublished* RoomEvent::release_local_track_unpublished() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.local_track_unpublished)
  if (_internal_has_local_track_unpublished()) {
    clear_has_message();
    ::livekit::proto::LocalTrackUnpublished* temp = _impl_.message_.local_track_unpublished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.local_track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::LocalTrackUnpublished& RoomEvent::_internal_local_track_unpublished() const {
  return _internal_has_local_track_unpublished()
      ? *_impl_.message_.local_track_unpublished_
      : reinterpret_cast< ::livekit::proto::LocalTrackUnpublished&>(::livekit::proto::_LocalTrackUnpublished_default_instance_);
}
inline const ::livekit::proto::LocalTrackUnpublished& RoomEvent::local_track_unpublished() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.local_track_unpublished)
  return _internal_local_track_unpublished();
}
inline ::livekit::proto::LocalTrackUnpublished* RoomEvent::unsafe_arena_release_local_track_unpublished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.local_track_unpublished)
  if (_internal_has_local_track_unpublished()) {
    clear_has_message();
    ::livekit::proto::LocalTrackUnpublished* temp = _impl_.message_.local_track_unpublished_;
    _impl_.message_.local_track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_local_track_unpublished(::livekit::proto::LocalTrackUnpublished* local_track_unpublished) {
  clear_message();
  if (local_track_unpublished) {
    set_has_local_track_unpublished();
    _impl_.message_.local_track_unpublished_ = local_track_unpublished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.local_track_unpublished)
}
inline ::livekit::proto::LocalTrackUnpublished* RoomEvent::_internal_mutable_local_track_unpublished() {
  if (!_internal_has_local_track_unpublished()) {
    clear_message();
    set_has_local_track_unpublished();
    _impl_.message_.local_track_unpublished_ = CreateMaybeMessage< ::livekit::proto::LocalTrackUnpublished >(GetArenaForAllocation());
  }
  return _impl_.message_.local_track_unpublished_;
}
inline ::livekit::proto::LocalTrackUnpublished* RoomEvent::mutable_local_track_unpublished() {
  ::livekit::proto::LocalTrackUnpublished* _msg = _internal_mutable_local_track_unpublished();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.local_track_unpublished)
  return _msg;
}

// .livekit.proto.LocalTrackSubscribed local_track_subscribed = 6;
inline bool RoomEvent::_internal_has_local_track_subscribed() const {
  return message_case() == kLocalTrackSubscribed;
}
inline bool RoomEvent::has_local_track_subscribed() const {
  return _internal_has_local_track_subscribed();
}
inline void RoomEvent::set_has_local_track_subscribed() {
  _impl_._oneof_case_[0] = kLocalTrackSubscribed;
}
inline void RoomEvent::clear_local_track_subscribed() {
  if (_internal_has_local_track_subscribed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.local_track_subscribed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::LocalTrackSubscribed* RoomEvent::release_local_track_subscribed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.local_track_subscribed)
  if (_internal_has_local_track_subscribed()) {
    clear_has_message();
    ::livekit::proto::LocalTrackSubscribed* temp = _impl_.message_.local_track_subscribed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.local_track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::LocalTrackSubscribed& RoomEvent::_internal_local_track_subscribed() const {
  return _internal_has_local_track_subscribed()
      ? *_impl_.message_.local_track_subscribed_
      : reinterpret_cast< ::livekit::proto::LocalTrackSubscribed&>(::livekit::proto::_LocalTrackSubscribed_default_instance_);
}
inline const ::livekit::proto::LocalTrackSubscribed& RoomEvent::local_track_subscribed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.local_track_subscribed)
  return _internal_local_track_subscribed();
}
inline ::livekit::proto::LocalTrackSubscribed* RoomEvent::unsafe_arena_release_local_track_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.local_track_subscribed)
  if (_internal_has_local_track_subscribed()) {
    clear_has_message();
    ::livekit::proto::LocalTrackSubscribed* temp = _impl_.message_.local_track_subscribed_;
    _impl_.message_.local_track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_local_track_subscribed(::livekit::proto::LocalTrackSubscribed* local_track_subscribed) {
  clear_message();
  if (local_track_subscribed) {
    set_has_local_track_subscribed();
    _impl_.message_.local_track_subscribed_ = local_track_subscribed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.local_track_subscribed)
}
inline ::livekit::proto::LocalTrackSubscribed* RoomEvent::_internal_mutable_local_track_subscribed() {
  if (!_internal_has_local_track_subscribed()) {
    clear_message();
    set_has_local_track_subscribed();
    _impl_.message_.local_track_subscribed_ = CreateMaybeMessage< ::livekit::proto::LocalTrackSubscribed >(GetArenaForAllocation());
  }
  return _impl_.message_.local_track_subscribed_;
}
inline ::livekit::proto::LocalTrackSubscribed* RoomEvent::mutable_local_track_subscribed() {
  ::livekit::proto::LocalTrackSubscribed* _msg = _internal_mutable_local_track_subscribed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.local_track_subscribed)
  return _msg;
}

// .livekit.proto.TrackPublished track_published = 7;
inline bool RoomEvent::_internal_has_track_published() const {
  return message_case() == kTrackPublished;
}
inline bool RoomEvent::has_track_published() const {
  return _internal_has_track_published();
}
inline void RoomEvent::set_has_track_published() {
  _impl_._oneof_case_[0] = kTrackPublished;
}
inline void RoomEvent::clear_track_published() {
  if (_internal_has_track_published()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_published_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackPublished* RoomEvent::release_track_published() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
    ::livekit::proto::TrackPublished* temp = _impl_.message_.track_published_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackPublished& RoomEvent::_internal_track_published() const {
  return _internal_has_track_published()
      ? *_impl_.message_.track_published_
      : reinterpret_cast< ::livekit::proto::TrackPublished&>(::livekit::proto::_TrackPublished_default_instance_);
}
inline const ::livekit::proto::TrackPublished& RoomEvent::track_published() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_published)
  return _internal_track_published();
}
inline ::livekit::proto::TrackPublished* RoomEvent::unsafe_arena_release_track_published() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_published)
  if (_internal_has_track_published()) {
    clear_has_message();
    ::livekit::proto::TrackPublished* temp = _impl_.message_.track_published_;
    _impl_.message_.track_published_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_published(::livekit::proto::TrackPublished* track_published) {
  clear_message();
  if (track_published) {
    set_has_track_published();
    _impl_.message_.track_published_ = track_published;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_published)
}
inline ::livekit::proto::TrackPublished* RoomEvent::_internal_mutable_track_published() {
  if (!_internal_has_track_published()) {
    clear_message();
    set_has_track_published();
    _impl_.message_.track_published_ = CreateMaybeMessage< ::livekit::proto::TrackPublished >(GetArenaForAllocation());
  }
  return _impl_.message_.track_published_;
}
inline ::livekit::proto::TrackPublished* RoomEvent::mutable_track_published() {
  ::livekit::proto::TrackPublished* _msg = _internal_mutable_track_published();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_published)
  return _msg;
}

// .livekit.proto.TrackUnpublished track_unpublished = 8;
inline bool RoomEvent::_internal_has_track_unpublished() const {
  return message_case() == kTrackUnpublished;
}
inline bool RoomEvent::has_track_unpublished() const {
  return _internal_has_track_unpublished();
}
inline void RoomEvent::set_has_track_unpublished() {
  _impl_._oneof_case_[0] = kTrackUnpublished;
}
inline void RoomEvent::clear_track_unpublished() {
  if (_internal_has_track_unpublished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_unpublished_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackUnpublished* RoomEvent::release_track_unpublished() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
    ::livekit::proto::TrackUnpublished* temp = _impl_.message_.track_unpublished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackUnpublished& RoomEvent::_internal_track_unpublished() const {
  return _internal_has_track_unpublished()
      ? *_impl_.message_.track_unpublished_
      : reinterpret_cast< ::livekit::proto::TrackUnpublished&>(::livekit::proto::_TrackUnpublished_default_instance_);
}
inline const ::livekit::proto::TrackUnpublished& RoomEvent::track_unpublished() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_unpublished)
  return _internal_track_unpublished();
}
inline ::livekit::proto::TrackUnpublished* RoomEvent::unsafe_arena_release_track_unpublished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_unpublished)
  if (_internal_has_track_unpublished()) {
    clear_has_message();
    ::livekit::proto::TrackUnpublished* temp = _impl_.message_.track_unpublished_;
    _impl_.message_.track_unpublished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_unpublished(::livekit::proto::TrackUnpublished* track_unpublished) {
  clear_message();
  if (track_unpublished) {
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = track_unpublished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_unpublished)
}
inline ::livekit::proto::TrackUnpublished* RoomEvent::_internal_mutable_track_unpublished() {
  if (!_internal_has_track_unpublished()) {
    clear_message();
    set_has_track_unpublished();
    _impl_.message_.track_unpublished_ = CreateMaybeMessage< ::livekit::proto::TrackUnpublished >(GetArenaForAllocation());
  }
  return _impl_.message_.track_unpublished_;
}
inline ::livekit::proto::TrackUnpublished* RoomEvent::mutable_track_unpublished() {
  ::livekit::proto::TrackUnpublished* _msg = _internal_mutable_track_unpublished();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_unpublished)
  return _msg;
}

// .livekit.proto.TrackSubscribed track_subscribed = 9;
inline bool RoomEvent::_internal_has_track_subscribed() const {
  return message_case() == kTrackSubscribed;
}
inline bool RoomEvent::has_track_subscribed() const {
  return _internal_has_track_subscribed();
}
inline void RoomEvent::set_has_track_subscribed() {
  _impl_._oneof_case_[0] = kTrackSubscribed;
}
inline void RoomEvent::clear_track_subscribed() {
  if (_internal_has_track_subscribed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_subscribed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackSubscribed* RoomEvent::release_track_subscribed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_subscribed)
  if (_internal_has_track_subscribed()) {
    clear_has_message();
    ::livekit::proto::TrackSubscribed* temp = _impl_.message_.track_subscribed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackSubscribed& RoomEvent::_internal_track_subscribed() const {
  return _internal_has_track_subscribed()
      ? *_impl_.message_.track_subscribed_
      : reinterpret_cast< ::livekit::proto::TrackSubscribed&>(::livekit::proto::_TrackSubscribed_default_instance_);
}
inline const ::livekit::proto::TrackSubscribed& RoomEvent::track_subscribed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_subscribed)
  return _internal_track_subscribed();
}
inline ::livekit::proto::TrackSubscribed* RoomEvent::unsafe_arena_release_track_subscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_subscribed)
  if (_internal_has_track_subscribed()) {
    clear_has_message();
    ::livekit::proto::TrackSubscribed* temp = _impl_.message_.track_subscribed_;
    _impl_.message_.track_subscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_subscribed(::livekit::proto::TrackSubscribed* track_subscribed) {
  clear_message();
  if (track_subscribed) {
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = track_subscribed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_subscribed)
}
inline ::livekit::proto::TrackSubscribed* RoomEvent::_internal_mutable_track_subscribed() {
  if (!_internal_has_track_subscribed()) {
    clear_message();
    set_has_track_subscribed();
    _impl_.message_.track_subscribed_ = CreateMaybeMessage< ::livekit::proto::TrackSubscribed >(GetArenaForAllocation());
  }
  return _impl_.message_.track_subscribed_;
}
inline ::livekit::proto::TrackSubscribed* RoomEvent::mutable_track_subscribed() {
  ::livekit::proto::TrackSubscribed* _msg = _internal_mutable_track_subscribed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_subscribed)
  return _msg;
}

// .livekit.proto.TrackUnsubscribed track_unsubscribed = 10;
inline bool RoomEvent::_internal_has_track_unsubscribed() const {
  return message_case() == kTrackUnsubscribed;
}
inline bool RoomEvent::has_track_unsubscribed() const {
  return _internal_has_track_unsubscribed();
}
inline void RoomEvent::set_has_track_unsubscribed() {
  _impl_._oneof_case_[0] = kTrackUnsubscribed;
}
inline void RoomEvent::clear_track_unsubscribed() {
  if (_internal_has_track_unsubscribed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_unsubscribed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackUnsubscribed* RoomEvent::release_track_unsubscribed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_unsubscribed)
  if (_internal_has_track_unsubscribed()) {
    clear_has_message();
    ::livekit::proto::TrackUnsubscribed* temp = _impl_.message_.track_unsubscribed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_unsubscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackUnsubscribed& RoomEvent::_internal_track_unsubscribed() const {
  return _internal_has_track_unsubscribed()
      ? *_impl_.message_.track_unsubscribed_
      : reinterpret_cast< ::livekit::proto::TrackUnsubscribed&>(::livekit::proto::_TrackUnsubscribed_default_instance_);
}
inline const ::livekit::proto::TrackUnsubscribed& RoomEvent::track_unsubscribed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_unsubscribed)
  return _internal_track_unsubscribed();
}
inline ::livekit::proto::TrackUnsubscribed* RoomEvent::unsafe_arena_release_track_unsubscribed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_unsubscribed)
  if (_internal_has_track_unsubscribed()) {
    clear_has_message();
    ::livekit::proto::TrackUnsubscribed* temp = _impl_.message_.track_unsubscribed_;
    _impl_.message_.track_unsubscribed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_unsubscribed(::livekit::proto::TrackUnsubscribed* track_unsubscribed) {
  clear_message();
  if (track_unsubscribed) {
    set_has_track_unsubscribed();
    _impl_.message_.track_unsubscribed_ = track_unsubscribed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_unsubscribed)
}
inline ::livekit::proto::TrackUnsubscribed* RoomEvent::_internal_mutable_track_unsubscribed() {
  if (!_internal_has_track_unsubscribed()) {
    clear_message();
    set_has_track_unsubscribed();
    _impl_.message_.track_unsubscribed_ = CreateMaybeMessage< ::livekit::proto::TrackUnsubscribed >(GetArenaForAllocation());
  }
  return _impl_.message_.track_unsubscribed_;
}
inline ::livekit::proto::TrackUnsubscribed* RoomEvent::mutable_track_unsubscribed() {
  ::livekit::proto::TrackUnsubscribed* _msg = _internal_mutable_track_unsubscribed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_unsubscribed)
  return _msg;
}

// .livekit.proto.TrackSubscriptionFailed track_subscription_failed = 11;
inline bool RoomEvent::_internal_has_track_subscription_failed() const {
  return message_case() == kTrackSubscriptionFailed;
}
inline bool RoomEvent::has_track_subscription_failed() const {
  return _internal_has_track_subscription_failed();
}
inline void RoomEvent::set_has_track_subscription_failed() {
  _impl_._oneof_case_[0] = kTrackSubscriptionFailed;
}
inline void RoomEvent::clear_track_subscription_failed() {
  if (_internal_has_track_subscription_failed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_subscription_failed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackSubscriptionFailed* RoomEvent::release_track_subscription_failed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_subscription_failed)
  if (_internal_has_track_subscription_failed()) {
    clear_has_message();
    ::livekit::proto::TrackSubscriptionFailed* temp = _impl_.message_.track_subscription_failed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_subscription_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackSubscriptionFailed& RoomEvent::_internal_track_subscription_failed() const {
  return _internal_has_track_subscription_failed()
      ? *_impl_.message_.track_subscription_failed_
      : reinterpret_cast< ::livekit::proto::TrackSubscriptionFailed&>(::livekit::proto::_TrackSubscriptionFailed_default_instance_);
}
inline const ::livekit::proto::TrackSubscriptionFailed& RoomEvent::track_subscription_failed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_subscription_failed)
  return _internal_track_subscription_failed();
}
inline ::livekit::proto::TrackSubscriptionFailed* RoomEvent::unsafe_arena_release_track_subscription_failed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_subscription_failed)
  if (_internal_has_track_subscription_failed()) {
    clear_has_message();
    ::livekit::proto::TrackSubscriptionFailed* temp = _impl_.message_.track_subscription_failed_;
    _impl_.message_.track_subscription_failed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_subscription_failed(::livekit::proto::TrackSubscriptionFailed* track_subscription_failed) {
  clear_message();
  if (track_subscription_failed) {
    set_has_track_subscription_failed();
    _impl_.message_.track_subscription_failed_ = track_subscription_failed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_subscription_failed)
}
inline ::livekit::proto::TrackSubscriptionFailed* RoomEvent::_internal_mutable_track_subscription_failed() {
  if (!_internal_has_track_subscription_failed()) {
    clear_message();
    set_has_track_subscription_failed();
    _impl_.message_.track_subscription_failed_ = CreateMaybeMessage< ::livekit::proto::TrackSubscriptionFailed >(GetArenaForAllocation());
  }
  return _impl_.message_.track_subscription_failed_;
}
inline ::livekit::proto::TrackSubscriptionFailed* RoomEvent::mutable_track_subscription_failed() {
  ::livekit::proto::TrackSubscriptionFailed* _msg = _internal_mutable_track_subscription_failed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_subscription_failed)
  return _msg;
}

// .livekit.proto.TrackMuted track_muted = 12;
inline bool RoomEvent::_internal_has_track_muted() const {
  return message_case() == kTrackMuted;
}
inline bool RoomEvent::has_track_muted() const {
  return _internal_has_track_muted();
}
inline void RoomEvent::set_has_track_muted() {
  _impl_._oneof_case_[0] = kTrackMuted;
}
inline void RoomEvent::clear_track_muted() {
  if (_internal_has_track_muted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_muted_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackMuted* RoomEvent::release_track_muted() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_muted)
  if (_internal_has_track_muted()) {
    clear_has_message();
    ::livekit::proto::TrackMuted* temp = _impl_.message_.track_muted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_muted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackMuted& RoomEvent::_internal_track_muted() const {
  return _internal_has_track_muted()
      ? *_impl_.message_.track_muted_
      : reinterpret_cast< ::livekit::proto::TrackMuted&>(::livekit::proto::_TrackMuted_default_instance_);
}
inline const ::livekit::proto::TrackMuted& RoomEvent::track_muted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_muted)
  return _internal_track_muted();
}
inline ::livekit::proto::TrackMuted* RoomEvent::unsafe_arena_release_track_muted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_muted)
  if (_internal_has_track_muted()) {
    clear_has_message();
    ::livekit::proto::TrackMuted* temp = _impl_.message_.track_muted_;
    _impl_.message_.track_muted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_muted(::livekit::proto::TrackMuted* track_muted) {
  clear_message();
  if (track_muted) {
    set_has_track_muted();
    _impl_.message_.track_muted_ = track_muted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_muted)
}
inline ::livekit::proto::TrackMuted* RoomEvent::_internal_mutable_track_muted() {
  if (!_internal_has_track_muted()) {
    clear_message();
    set_has_track_muted();
    _impl_.message_.track_muted_ = CreateMaybeMessage< ::livekit::proto::TrackMuted >(GetArenaForAllocation());
  }
  return _impl_.message_.track_muted_;
}
inline ::livekit::proto::TrackMuted* RoomEvent::mutable_track_muted() {
  ::livekit::proto::TrackMuted* _msg = _internal_mutable_track_muted();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_muted)
  return _msg;
}

// .livekit.proto.TrackUnmuted track_unmuted = 13;
inline bool RoomEvent::_internal_has_track_unmuted() const {
  return message_case() == kTrackUnmuted;
}
inline bool RoomEvent::has_track_unmuted() const {
  return _internal_has_track_unmuted();
}
inline void RoomEvent::set_has_track_unmuted() {
  _impl_._oneof_case_[0] = kTrackUnmuted;
}
inline void RoomEvent::clear_track_unmuted() {
  if (_internal_has_track_unmuted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.track_unmuted_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TrackUnmuted* RoomEvent::release_track_unmuted() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.track_unmuted)
  if (_internal_has_track_unmuted()) {
    clear_has_message();
    ::livekit::proto::TrackUnmuted* temp = _impl_.message_.track_unmuted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.track_unmuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TrackUnmuted& RoomEvent::_internal_track_unmuted() const {
  return _internal_has_track_unmuted()
      ? *_impl_.message_.track_unmuted_
      : reinterpret_cast< ::livekit::proto::TrackUnmuted&>(::livekit::proto::_TrackUnmuted_default_instance_);
}
inline const ::livekit::proto::TrackUnmuted& RoomEvent::track_unmuted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.track_unmuted)
  return _internal_track_unmuted();
}
inline ::livekit::proto::TrackUnmuted* RoomEvent::unsafe_arena_release_track_unmuted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.track_unmuted)
  if (_internal_has_track_unmuted()) {
    clear_has_message();
    ::livekit::proto::TrackUnmuted* temp = _impl_.message_.track_unmuted_;
    _impl_.message_.track_unmuted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_track_unmuted(::livekit::proto::TrackUnmuted* track_unmuted) {
  clear_message();
  if (track_unmuted) {
    set_has_track_unmuted();
    _impl_.message_.track_unmuted_ = track_unmuted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.track_unmuted)
}
inline ::livekit::proto::TrackUnmuted* RoomEvent::_internal_mutable_track_unmuted() {
  if (!_internal_has_track_unmuted()) {
    clear_message();
    set_has_track_unmuted();
    _impl_.message_.track_unmuted_ = CreateMaybeMessage< ::livekit::proto::TrackUnmuted >(GetArenaForAllocation());
  }
  return _impl_.message_.track_unmuted_;
}
inline ::livekit::proto::TrackUnmuted* RoomEvent::mutable_track_unmuted() {
  ::livekit::proto::TrackUnmuted* _msg = _internal_mutable_track_unmuted();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.track_unmuted)
  return _msg;
}

// .livekit.proto.ActiveSpeakersChanged active_speakers_changed = 14;
inline bool RoomEvent::_internal_has_active_speakers_changed() const {
  return message_case() == kActiveSpeakersChanged;
}
inline bool RoomEvent::has_active_speakers_changed() const {
  return _internal_has_active_speakers_changed();
}
inline void RoomEvent::set_has_active_speakers_changed() {
  _impl_._oneof_case_[0] = kActiveSpeakersChanged;
}
inline void RoomEvent::clear_active_speakers_changed() {
  if (_internal_has_active_speakers_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.active_speakers_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ActiveSpeakersChanged* RoomEvent::release_active_speakers_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.active_speakers_changed)
  if (_internal_has_active_speakers_changed()) {
    clear_has_message();
    ::livekit::proto::ActiveSpeakersChanged* temp = _impl_.message_.active_speakers_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.active_speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ActiveSpeakersChanged& RoomEvent::_internal_active_speakers_changed() const {
  return _internal_has_active_speakers_changed()
      ? *_impl_.message_.active_speakers_changed_
      : reinterpret_cast< ::livekit::proto::ActiveSpeakersChanged&>(::livekit::proto::_ActiveSpeakersChanged_default_instance_);
}
inline const ::livekit::proto::ActiveSpeakersChanged& RoomEvent::active_speakers_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.active_speakers_changed)
  return _internal_active_speakers_changed();
}
inline ::livekit::proto::ActiveSpeakersChanged* RoomEvent::unsafe_arena_release_active_speakers_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.active_speakers_changed)
  if (_internal_has_active_speakers_changed()) {
    clear_has_message();
    ::livekit::proto::ActiveSpeakersChanged* temp = _impl_.message_.active_speakers_changed_;
    _impl_.message_.active_speakers_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_active_speakers_changed(::livekit::proto::ActiveSpeakersChanged* active_speakers_changed) {
  clear_message();
  if (active_speakers_changed) {
    set_has_active_speakers_changed();
    _impl_.message_.active_speakers_changed_ = active_speakers_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.active_speakers_changed)
}
inline ::livekit::proto::ActiveSpeakersChanged* RoomEvent::_internal_mutable_active_speakers_changed() {
  if (!_internal_has_active_speakers_changed()) {
    clear_message();
    set_has_active_speakers_changed();
    _impl_.message_.active_speakers_changed_ = CreateMaybeMessage< ::livekit::proto::ActiveSpeakersChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.active_speakers_changed_;
}
inline ::livekit::proto::ActiveSpeakersChanged* RoomEvent::mutable_active_speakers_changed() {
  ::livekit::proto::ActiveSpeakersChanged* _msg = _internal_mutable_active_speakers_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.active_speakers_changed)
  return _msg;
}

// .livekit.proto.RoomMetadataChanged room_metadata_changed = 15;
inline bool RoomEvent::_internal_has_room_metadata_changed() const {
  return message_case() == kRoomMetadataChanged;
}
inline bool RoomEvent::has_room_metadata_changed() const {
  return _internal_has_room_metadata_changed();
}
inline void RoomEvent::set_has_room_metadata_changed() {
  _impl_._oneof_case_[0] = kRoomMetadataChanged;
}
inline void RoomEvent::clear_room_metadata_changed() {
  if (_internal_has_room_metadata_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.room_metadata_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RoomMetadataChanged* RoomEvent::release_room_metadata_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.room_metadata_changed)
  if (_internal_has_room_metadata_changed()) {
    clear_has_message();
    ::livekit::proto::RoomMetadataChanged* temp = _impl_.message_.room_metadata_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.room_metadata_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RoomMetadataChanged& RoomEvent::_internal_room_metadata_changed() const {
  return _internal_has_room_metadata_changed()
      ? *_impl_.message_.room_metadata_changed_
      : reinterpret_cast< ::livekit::proto::RoomMetadataChanged&>(::livekit::proto::_RoomMetadataChanged_default_instance_);
}
inline const ::livekit::proto::RoomMetadataChanged& RoomEvent::room_metadata_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.room_metadata_changed)
  return _internal_room_metadata_changed();
}
inline ::livekit::proto::RoomMetadataChanged* RoomEvent::unsafe_arena_release_room_metadata_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.room_metadata_changed)
  if (_internal_has_room_metadata_changed()) {
    clear_has_message();
    ::livekit::proto::RoomMetadataChanged* temp = _impl_.message_.room_metadata_changed_;
    _impl_.message_.room_metadata_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_room_metadata_changed(::livekit::proto::RoomMetadataChanged* room_metadata_changed) {
  clear_message();
  if (room_metadata_changed) {
    set_has_room_metadata_changed();
    _impl_.message_.room_metadata_changed_ = room_metadata_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.room_metadata_changed)
}
inline ::livekit::proto::RoomMetadataChanged* RoomEvent::_internal_mutable_room_metadata_changed() {
  if (!_internal_has_room_metadata_changed()) {
    clear_message();
    set_has_room_metadata_changed();
    _impl_.message_.room_metadata_changed_ = CreateMaybeMessage< ::livekit::proto::RoomMetadataChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.room_metadata_changed_;
}
inline ::livekit::proto::RoomMetadataChanged* RoomEvent::mutable_room_metadata_changed() {
  ::livekit::proto::RoomMetadataChanged* _msg = _internal_mutable_room_metadata_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.room_metadata_changed)
  return _msg;
}

// .livekit.proto.RoomSidChanged room_sid_changed = 16;
inline bool RoomEvent::_internal_has_room_sid_changed() const {
  return message_case() == kRoomSidChanged;
}
inline bool RoomEvent::has_room_sid_changed() const {
  return _internal_has_room_sid_changed();
}
inline void RoomEvent::set_has_room_sid_changed() {
  _impl_._oneof_case_[0] = kRoomSidChanged;
}
inline void RoomEvent::clear_room_sid_changed() {
  if (_internal_has_room_sid_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.room_sid_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RoomSidChanged* RoomEvent::release_room_sid_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.room_sid_changed)
  if (_internal_has_room_sid_changed()) {
    clear_has_message();
    ::livekit::proto::RoomSidChanged* temp = _impl_.message_.room_sid_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.room_sid_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RoomSidChanged& RoomEvent::_internal_room_sid_changed() const {
  return _internal_has_room_sid_changed()
      ? *_impl_.message_.room_sid_changed_
      : reinterpret_cast< ::livekit::proto::RoomSidChanged&>(::livekit::proto::_RoomSidChanged_default_instance_);
}
inline const ::livekit::proto::RoomSidChanged& RoomEvent::room_sid_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.room_sid_changed)
  return _internal_room_sid_changed();
}
inline ::livekit::proto::RoomSidChanged* RoomEvent::unsafe_arena_release_room_sid_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.room_sid_changed)
  if (_internal_has_room_sid_changed()) {
    clear_has_message();
    ::livekit::proto::RoomSidChanged* temp = _impl_.message_.room_sid_changed_;
    _impl_.message_.room_sid_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_room_sid_changed(::livekit::proto::RoomSidChanged* room_sid_changed) {
  clear_message();
  if (room_sid_changed) {
    set_has_room_sid_changed();
    _impl_.message_.room_sid_changed_ = room_sid_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.room_sid_changed)
}
inline ::livekit::proto::RoomSidChanged* RoomEvent::_internal_mutable_room_sid_changed() {
  if (!_internal_has_room_sid_changed()) {
    clear_message();
    set_has_room_sid_changed();
    _impl_.message_.room_sid_changed_ = CreateMaybeMessage< ::livekit::proto::RoomSidChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.room_sid_changed_;
}
inline ::livekit::proto::RoomSidChanged* RoomEvent::mutable_room_sid_changed() {
  ::livekit::proto::RoomSidChanged* _msg = _internal_mutable_room_sid_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.room_sid_changed)
  return _msg;
}

// .livekit.proto.ParticipantMetadataChanged participant_metadata_changed = 17;
inline bool RoomEvent::_internal_has_participant_metadata_changed() const {
  return message_case() == kParticipantMetadataChanged;
}
inline bool RoomEvent::has_participant_metadata_changed() const {
  return _internal_has_participant_metadata_changed();
}
inline void RoomEvent::set_has_participant_metadata_changed() {
  _impl_._oneof_case_[0] = kParticipantMetadataChanged;
}
inline void RoomEvent::clear_participant_metadata_changed() {
  if (_internal_has_participant_metadata_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.participant_metadata_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ParticipantMetadataChanged* RoomEvent::release_participant_metadata_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.participant_metadata_changed)
  if (_internal_has_participant_metadata_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantMetadataChanged* temp = _impl_.message_.participant_metadata_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.participant_metadata_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ParticipantMetadataChanged& RoomEvent::_internal_participant_metadata_changed() const {
  return _internal_has_participant_metadata_changed()
      ? *_impl_.message_.participant_metadata_changed_
      : reinterpret_cast< ::livekit::proto::ParticipantMetadataChanged&>(::livekit::proto::_ParticipantMetadataChanged_default_instance_);
}
inline const ::livekit::proto::ParticipantMetadataChanged& RoomEvent::participant_metadata_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.participant_metadata_changed)
  return _internal_participant_metadata_changed();
}
inline ::livekit::proto::ParticipantMetadataChanged* RoomEvent::unsafe_arena_release_participant_metadata_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.participant_metadata_changed)
  if (_internal_has_participant_metadata_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantMetadataChanged* temp = _impl_.message_.participant_metadata_changed_;
    _impl_.message_.participant_metadata_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_participant_metadata_changed(::livekit::proto::ParticipantMetadataChanged* participant_metadata_changed) {
  clear_message();
  if (participant_metadata_changed) {
    set_has_participant_metadata_changed();
    _impl_.message_.participant_metadata_changed_ = participant_metadata_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.participant_metadata_changed)
}
inline ::livekit::proto::ParticipantMetadataChanged* RoomEvent::_internal_mutable_participant_metadata_changed() {
  if (!_internal_has_participant_metadata_changed()) {
    clear_message();
    set_has_participant_metadata_changed();
    _impl_.message_.participant_metadata_changed_ = CreateMaybeMessage< ::livekit::proto::ParticipantMetadataChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.participant_metadata_changed_;
}
inline ::livekit::proto::ParticipantMetadataChanged* RoomEvent::mutable_participant_metadata_changed() {
  ::livekit::proto::ParticipantMetadataChanged* _msg = _internal_mutable_participant_metadata_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.participant_metadata_changed)
  return _msg;
}

// .livekit.proto.ParticipantNameChanged participant_name_changed = 18;
inline bool RoomEvent::_internal_has_participant_name_changed() const {
  return message_case() == kParticipantNameChanged;
}
inline bool RoomEvent::has_participant_name_changed() const {
  return _internal_has_participant_name_changed();
}
inline void RoomEvent::set_has_participant_name_changed() {
  _impl_._oneof_case_[0] = kParticipantNameChanged;
}
inline void RoomEvent::clear_participant_name_changed() {
  if (_internal_has_participant_name_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.participant_name_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ParticipantNameChanged* RoomEvent::release_participant_name_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.participant_name_changed)
  if (_internal_has_participant_name_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantNameChanged* temp = _impl_.message_.participant_name_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.participant_name_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ParticipantNameChanged& RoomEvent::_internal_participant_name_changed() const {
  return _internal_has_participant_name_changed()
      ? *_impl_.message_.participant_name_changed_
      : reinterpret_cast< ::livekit::proto::ParticipantNameChanged&>(::livekit::proto::_ParticipantNameChanged_default_instance_);
}
inline const ::livekit::proto::ParticipantNameChanged& RoomEvent::participant_name_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.participant_name_changed)
  return _internal_participant_name_changed();
}
inline ::livekit::proto::ParticipantNameChanged* RoomEvent::unsafe_arena_release_participant_name_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.participant_name_changed)
  if (_internal_has_participant_name_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantNameChanged* temp = _impl_.message_.participant_name_changed_;
    _impl_.message_.participant_name_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_participant_name_changed(::livekit::proto::ParticipantNameChanged* participant_name_changed) {
  clear_message();
  if (participant_name_changed) {
    set_has_participant_name_changed();
    _impl_.message_.participant_name_changed_ = participant_name_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.participant_name_changed)
}
inline ::livekit::proto::ParticipantNameChanged* RoomEvent::_internal_mutable_participant_name_changed() {
  if (!_internal_has_participant_name_changed()) {
    clear_message();
    set_has_participant_name_changed();
    _impl_.message_.participant_name_changed_ = CreateMaybeMessage< ::livekit::proto::ParticipantNameChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.participant_name_changed_;
}
inline ::livekit::proto::ParticipantNameChanged* RoomEvent::mutable_participant_name_changed() {
  ::livekit::proto::ParticipantNameChanged* _msg = _internal_mutable_participant_name_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.participant_name_changed)
  return _msg;
}

// .livekit.proto.ParticipantAttributesChanged participant_attributes_changed = 19;
inline bool RoomEvent::_internal_has_participant_attributes_changed() const {
  return message_case() == kParticipantAttributesChanged;
}
inline bool RoomEvent::has_participant_attributes_changed() const {
  return _internal_has_participant_attributes_changed();
}
inline void RoomEvent::set_has_participant_attributes_changed() {
  _impl_._oneof_case_[0] = kParticipantAttributesChanged;
}
inline void RoomEvent::clear_participant_attributes_changed() {
  if (_internal_has_participant_attributes_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.participant_attributes_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ParticipantAttributesChanged* RoomEvent::release_participant_attributes_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.participant_attributes_changed)
  if (_internal_has_participant_attributes_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantAttributesChanged* temp = _impl_.message_.participant_attributes_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.participant_attributes_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ParticipantAttributesChanged& RoomEvent::_internal_participant_attributes_changed() const {
  return _internal_has_participant_attributes_changed()
      ? *_impl_.message_.participant_attributes_changed_
      : reinterpret_cast< ::livekit::proto::ParticipantAttributesChanged&>(::livekit::proto::_ParticipantAttributesChanged_default_instance_);
}
inline const ::livekit::proto::ParticipantAttributesChanged& RoomEvent::participant_attributes_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.participant_attributes_changed)
  return _internal_participant_attributes_changed();
}
inline ::livekit::proto::ParticipantAttributesChanged* RoomEvent::unsafe_arena_release_participant_attributes_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.participant_attributes_changed)
  if (_internal_has_participant_attributes_changed()) {
    clear_has_message();
    ::livekit::proto::ParticipantAttributesChanged* temp = _impl_.message_.participant_attributes_changed_;
    _impl_.message_.participant_attributes_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_participant_attributes_changed(::livekit::proto::ParticipantAttributesChanged* participant_attributes_changed) {
  clear_message();
  if (participant_attributes_changed) {
    set_has_participant_attributes_changed();
    _impl_.message_.participant_attributes_changed_ = participant_attributes_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.participant_attributes_changed)
}
inline ::livekit::proto::ParticipantAttributesChanged* RoomEvent::_internal_mutable_participant_attributes_changed() {
  if (!_internal_has_participant_attributes_changed()) {
    clear_message();
    set_has_participant_attributes_changed();
    _impl_.message_.participant_attributes_changed_ = CreateMaybeMessage< ::livekit::proto::ParticipantAttributesChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.participant_attributes_changed_;
}
inline ::livekit::proto::ParticipantAttributesChanged* RoomEvent::mutable_participant_attributes_changed() {
  ::livekit::proto::ParticipantAttributesChanged* _msg = _internal_mutable_participant_attributes_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.participant_attributes_changed)
  return _msg;
}

// .livekit.proto.ConnectionQualityChanged connection_quality_changed = 20;
inline bool RoomEvent::_internal_has_connection_quality_changed() const {
  return message_case() == kConnectionQualityChanged;
}
inline bool RoomEvent::has_connection_quality_changed() const {
  return _internal_has_connection_quality_changed();
}
inline void RoomEvent::set_has_connection_quality_changed() {
  _impl_._oneof_case_[0] = kConnectionQualityChanged;
}
inline void RoomEvent::clear_connection_quality_changed() {
  if (_internal_has_connection_quality_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.connection_quality_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ConnectionQualityChanged* RoomEvent::release_connection_quality_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.connection_quality_changed)
  if (_internal_has_connection_quality_changed()) {
    clear_has_message();
    ::livekit::proto::ConnectionQualityChanged* temp = _impl_.message_.connection_quality_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.connection_quality_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ConnectionQualityChanged& RoomEvent::_internal_connection_quality_changed() const {
  return _internal_has_connection_quality_changed()
      ? *_impl_.message_.connection_quality_changed_
      : reinterpret_cast< ::livekit::proto::ConnectionQualityChanged&>(::livekit::proto::_ConnectionQualityChanged_default_instance_);
}
inline const ::livekit::proto::ConnectionQualityChanged& RoomEvent::connection_quality_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.connection_quality_changed)
  return _internal_connection_quality_changed();
}
inline ::livekit::proto::ConnectionQualityChanged* RoomEvent::unsafe_arena_release_connection_quality_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.connection_quality_changed)
  if (_internal_has_connection_quality_changed()) {
    clear_has_message();
    ::livekit::proto::ConnectionQualityChanged* temp = _impl_.message_.connection_quality_changed_;
    _impl_.message_.connection_quality_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_connection_quality_changed(::livekit::proto::ConnectionQualityChanged* connection_quality_changed) {
  clear_message();
  if (connection_quality_changed) {
    set_has_connection_quality_changed();
    _impl_.message_.connection_quality_changed_ = connection_quality_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.connection_quality_changed)
}
inline ::livekit::proto::ConnectionQualityChanged* RoomEvent::_internal_mutable_connection_quality_changed() {
  if (!_internal_has_connection_quality_changed()) {
    clear_message();
    set_has_connection_quality_changed();
    _impl_.message_.connection_quality_changed_ = CreateMaybeMessage< ::livekit::proto::ConnectionQualityChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.connection_quality_changed_;
}
inline ::livekit::proto::ConnectionQualityChanged* RoomEvent::mutable_connection_quality_changed() {
  ::livekit::proto::ConnectionQualityChanged* _msg = _internal_mutable_connection_quality_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.connection_quality_changed)
  return _msg;
}

// .livekit.proto.ConnectionStateChanged connection_state_changed = 21;
inline bool RoomEvent::_internal_has_connection_state_changed() const {
  return message_case() == kConnectionStateChanged;
}
inline bool RoomEvent::has_connection_state_changed() const {
  return _internal_has_connection_state_changed();
}
inline void RoomEvent::set_has_connection_state_changed() {
  _impl_._oneof_case_[0] = kConnectionStateChanged;
}
inline void RoomEvent::clear_connection_state_changed() {
  if (_internal_has_connection_state_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.connection_state_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ConnectionStateChanged* RoomEvent::release_connection_state_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.connection_state_changed)
  if (_internal_has_connection_state_changed()) {
    clear_has_message();
    ::livekit::proto::ConnectionStateChanged* temp = _impl_.message_.connection_state_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.connection_state_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ConnectionStateChanged& RoomEvent::_internal_connection_state_changed() const {
  return _internal_has_connection_state_changed()
      ? *_impl_.message_.connection_state_changed_
      : reinterpret_cast< ::livekit::proto::ConnectionStateChanged&>(::livekit::proto::_ConnectionStateChanged_default_instance_);
}
inline const ::livekit::proto::ConnectionStateChanged& RoomEvent::connection_state_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.connection_state_changed)
  return _internal_connection_state_changed();
}
inline ::livekit::proto::ConnectionStateChanged* RoomEvent::unsafe_arena_release_connection_state_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.connection_state_changed)
  if (_internal_has_connection_state_changed()) {
    clear_has_message();
    ::livekit::proto::ConnectionStateChanged* temp = _impl_.message_.connection_state_changed_;
    _impl_.message_.connection_state_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_connection_state_changed(::livekit::proto::ConnectionStateChanged* connection_state_changed) {
  clear_message();
  if (connection_state_changed) {
    set_has_connection_state_changed();
    _impl_.message_.connection_state_changed_ = connection_state_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.connection_state_changed)
}
inline ::livekit::proto::ConnectionStateChanged* RoomEvent::_internal_mutable_connection_state_changed() {
  if (!_internal_has_connection_state_changed()) {
    clear_message();
    set_has_connection_state_changed();
    _impl_.message_.connection_state_changed_ = CreateMaybeMessage< ::livekit::proto::ConnectionStateChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.connection_state_changed_;
}
inline ::livekit::proto::ConnectionStateChanged* RoomEvent::mutable_connection_state_changed() {
  ::livekit::proto::ConnectionStateChanged* _msg = _internal_mutable_connection_state_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.connection_state_changed)
  return _msg;
}

// .livekit.proto.Disconnected disconnected = 22;
inline bool RoomEvent::_internal_has_disconnected() const {
  return message_case() == kDisconnected;
}
inline bool RoomEvent::has_disconnected() const {
  return _internal_has_disconnected();
}
inline void RoomEvent::set_has_disconnected() {
  _impl_._oneof_case_[0] = kDisconnected;
}
inline void RoomEvent::clear_disconnected() {
  if (_internal_has_disconnected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.disconnected_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::Disconnected* RoomEvent::release_disconnected() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.disconnected)
  if (_internal_has_disconnected()) {
    clear_has_message();
    ::livekit::proto::Disconnected* temp = _impl_.message_.disconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::Disconnected& RoomEvent::_internal_disconnected() const {
  return _internal_has_disconnected()
      ? *_impl_.message_.disconnected_
      : reinterpret_cast< ::livekit::proto::Disconnected&>(::livekit::proto::_Disconnected_default_instance_);
}
inline const ::livekit::proto::Disconnected& RoomEvent::disconnected() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.disconnected)
  return _internal_disconnected();
}
inline ::livekit::proto::Disconnected* RoomEvent::unsafe_arena_release_disconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.disconnected)
  if (_internal_has_disconnected()) {
    clear_has_message();
    ::livekit::proto::Disconnected* temp = _impl_.message_.disconnected_;
    _impl_.message_.disconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_disconnected(::livekit::proto::Disconnected* disconnected) {
  clear_message();
  if (disconnected) {
    set_has_disconnected();
    _impl_.message_.disconnected_ = disconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.disconnected)
}
inline ::livekit::proto::Disconnected* RoomEvent::_internal_mutable_disconnected() {
  if (!_internal_has_disconnected()) {
    clear_message();
    set_has_disconnected();
    _impl_.message_.disconnected_ = CreateMaybeMessage< ::livekit::proto::Disconnected >(GetArenaForAllocation());
  }
  return _impl_.message_.disconnected_;
}
inline ::livekit::proto::Disconnected* RoomEvent::mutable_disconnected() {
  ::livekit::proto::Disconnected* _msg = _internal_mutable_disconnected();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.disconnected)
  return _msg;
}

// .livekit.proto.Reconnecting reconnecting = 23;
inline bool RoomEvent::_internal_has_reconnecting() const {
  return message_case() == kReconnecting;
}
inline bool RoomEvent::has_reconnecting() const {
  return _internal_has_reconnecting();
}
inline void RoomEvent::set_has_reconnecting() {
  _impl_._oneof_case_[0] = kReconnecting;
}
inline void RoomEvent::clear_reconnecting() {
  if (_internal_has_reconnecting()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.reconnecting_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::Reconnecting* RoomEvent::release_reconnecting() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.reconnecting)
  if (_internal_has_reconnecting()) {
    clear_has_message();
    ::livekit::proto::Reconnecting* temp = _impl_.message_.reconnecting_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.reconnecting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::Reconnecting& RoomEvent::_internal_reconnecting() const {
  return _internal_has_reconnecting()
      ? *_impl_.message_.reconnecting_
      : reinterpret_cast< ::livekit::proto::Reconnecting&>(::livekit::proto::_Reconnecting_default_instance_);
}
inline const ::livekit::proto::Reconnecting& RoomEvent::reconnecting() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.reconnecting)
  return _internal_reconnecting();
}
inline ::livekit::proto::Reconnecting* RoomEvent::unsafe_arena_release_reconnecting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.reconnecting)
  if (_internal_has_reconnecting()) {
    clear_has_message();
    ::livekit::proto::Reconnecting* temp = _impl_.message_.reconnecting_;
    _impl_.message_.reconnecting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_reconnecting(::livekit::proto::Reconnecting* reconnecting) {
  clear_message();
  if (reconnecting) {
    set_has_reconnecting();
    _impl_.message_.reconnecting_ = reconnecting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.reconnecting)
}
inline ::livekit::proto::Reconnecting* RoomEvent::_internal_mutable_reconnecting() {
  if (!_internal_has_reconnecting()) {
    clear_message();
    set_has_reconnecting();
    _impl_.message_.reconnecting_ = CreateMaybeMessage< ::livekit::proto::Reconnecting >(GetArenaForAllocation());
  }
  return _impl_.message_.reconnecting_;
}
inline ::livekit::proto::Reconnecting* RoomEvent::mutable_reconnecting() {
  ::livekit::proto::Reconnecting* _msg = _internal_mutable_reconnecting();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.reconnecting)
  return _msg;
}

// .livekit.proto.Reconnected reconnected = 24;
inline bool RoomEvent::_internal_has_reconnected() const {
  return message_case() == kReconnected;
}
inline bool RoomEvent::has_reconnected() const {
  return _internal_has_reconnected();
}
inline void RoomEvent::set_has_reconnected() {
  _impl_._oneof_case_[0] = kReconnected;
}
inline void RoomEvent::clear_reconnected() {
  if (_internal_has_reconnected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.reconnected_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::Reconnected* RoomEvent::release_reconnected() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.reconnected)
  if (_internal_has_reconnected()) {
    clear_has_message();
    ::livekit::proto::Reconnected* temp = _impl_.message_.reconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.reconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::Reconnected& RoomEvent::_internal_reconnected() const {
  return _internal_has_reconnected()
      ? *_impl_.message_.reconnected_
      : reinterpret_cast< ::livekit::proto::Reconnected&>(::livekit::proto::_Reconnected_default_instance_);
}
inline const ::livekit::proto::Reconnected& RoomEvent::reconnected() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.reconnected)
  return _internal_reconnected();
}
inline ::livekit::proto::Reconnected* RoomEvent::unsafe_arena_release_reconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.reconnected)
  if (_internal_has_reconnected()) {
    clear_has_message();
    ::livekit::proto::Reconnected* temp = _impl_.message_.reconnected_;
    _impl_.message_.reconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_reconnected(::livekit::proto::Reconnected* reconnected) {
  clear_message();
  if (reconnected) {
    set_has_reconnected();
    _impl_.message_.reconnected_ = reconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.reconnected)
}
inline ::livekit::proto::Reconnected* RoomEvent::_internal_mutable_reconnected() {
  if (!_internal_has_reconnected()) {
    clear_message();
    set_has_reconnected();
    _impl_.message_.reconnected_ = CreateMaybeMessage< ::livekit::proto::Reconnected >(GetArenaForAllocation());
  }
  return _impl_.message_.reconnected_;
}
inline ::livekit::proto::Reconnected* RoomEvent::mutable_reconnected() {
  ::livekit::proto::Reconnected* _msg = _internal_mutable_reconnected();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.reconnected)
  return _msg;
}

// .livekit.proto.E2eeStateChanged e2ee_state_changed = 25;
inline bool RoomEvent::_internal_has_e2ee_state_changed() const {
  return message_case() == kE2EeStateChanged;
}
inline bool RoomEvent::has_e2ee_state_changed() const {
  return _internal_has_e2ee_state_changed();
}
inline void RoomEvent::set_has_e2ee_state_changed() {
  _impl_._oneof_case_[0] = kE2EeStateChanged;
}
inline void RoomEvent::clear_e2ee_state_changed() {
  if (_internal_has_e2ee_state_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.e2ee_state_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::E2eeStateChanged* RoomEvent::release_e2ee_state_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.e2ee_state_changed)
  if (_internal_has_e2ee_state_changed()) {
    clear_has_message();
    ::livekit::proto::E2eeStateChanged* temp = _impl_.message_.e2ee_state_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.e2ee_state_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::E2eeStateChanged& RoomEvent::_internal_e2ee_state_changed() const {
  return _internal_has_e2ee_state_changed()
      ? *_impl_.message_.e2ee_state_changed_
      : reinterpret_cast< ::livekit::proto::E2eeStateChanged&>(::livekit::proto::_E2eeStateChanged_default_instance_);
}
inline const ::livekit::proto::E2eeStateChanged& RoomEvent::e2ee_state_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.e2ee_state_changed)
  return _internal_e2ee_state_changed();
}
inline ::livekit::proto::E2eeStateChanged* RoomEvent::unsafe_arena_release_e2ee_state_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.e2ee_state_changed)
  if (_internal_has_e2ee_state_changed()) {
    clear_has_message();
    ::livekit::proto::E2eeStateChanged* temp = _impl_.message_.e2ee_state_changed_;
    _impl_.message_.e2ee_state_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_e2ee_state_changed(::livekit::proto::E2eeStateChanged* e2ee_state_changed) {
  clear_message();
  if (e2ee_state_changed) {
    set_has_e2ee_state_changed();
    _impl_.message_.e2ee_state_changed_ = e2ee_state_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.e2ee_state_changed)
}
inline ::livekit::proto::E2eeStateChanged* RoomEvent::_internal_mutable_e2ee_state_changed() {
  if (!_internal_has_e2ee_state_changed()) {
    clear_message();
    set_has_e2ee_state_changed();
    _impl_.message_.e2ee_state_changed_ = CreateMaybeMessage< ::livekit::proto::E2eeStateChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.e2ee_state_changed_;
}
inline ::livekit::proto::E2eeStateChanged* RoomEvent::mutable_e2ee_state_changed() {
  ::livekit::proto::E2eeStateChanged* _msg = _internal_mutable_e2ee_state_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.e2ee_state_changed)
  return _msg;
}

// .livekit.proto.RoomEOS eos = 26;
inline bool RoomEvent::_internal_has_eos() const {
  return message_case() == kEos;
}
inline bool RoomEvent::has_eos() const {
  return _internal_has_eos();
}
inline void RoomEvent::set_has_eos() {
  _impl_._oneof_case_[0] = kEos;
}
inline void RoomEvent::clear_eos() {
  if (_internal_has_eos()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.eos_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RoomEOS* RoomEvent::release_eos() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::RoomEOS* temp = _impl_.message_.eos_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RoomEOS& RoomEvent::_internal_eos() const {
  return _internal_has_eos()
      ? *_impl_.message_.eos_
      : reinterpret_cast< ::livekit::proto::RoomEOS&>(::livekit::proto::_RoomEOS_default_instance_);
}
inline const ::livekit::proto::RoomEOS& RoomEvent::eos() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.eos)
  return _internal_eos();
}
inline ::livekit::proto::RoomEOS* RoomEvent::unsafe_arena_release_eos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.eos)
  if (_internal_has_eos()) {
    clear_has_message();
    ::livekit::proto::RoomEOS* temp = _impl_.message_.eos_;
    _impl_.message_.eos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_eos(::livekit::proto::RoomEOS* eos) {
  clear_message();
  if (eos) {
    set_has_eos();
    _impl_.message_.eos_ = eos;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.eos)
}
inline ::livekit::proto::RoomEOS* RoomEvent::_internal_mutable_eos() {
  if (!_internal_has_eos()) {
    clear_message();
    set_has_eos();
    _impl_.message_.eos_ = CreateMaybeMessage< ::livekit::proto::RoomEOS >(GetArenaForAllocation());
  }
  return _impl_.message_.eos_;
}
inline ::livekit::proto::RoomEOS* RoomEvent::mutable_eos() {
  ::livekit::proto::RoomEOS* _msg = _internal_mutable_eos();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.eos)
  return _msg;
}

// .livekit.proto.DataPacketReceived data_packet_received = 27;
inline bool RoomEvent::_internal_has_data_packet_received() const {
  return message_case() == kDataPacketReceived;
}
inline bool RoomEvent::has_data_packet_received() const {
  return _internal_has_data_packet_received();
}
inline void RoomEvent::set_has_data_packet_received() {
  _impl_._oneof_case_[0] = kDataPacketReceived;
}
inline void RoomEvent::clear_data_packet_received() {
  if (_internal_has_data_packet_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.data_packet_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::DataPacketReceived* RoomEvent::release_data_packet_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.data_packet_received)
  if (_internal_has_data_packet_received()) {
    clear_has_message();
    ::livekit::proto::DataPacketReceived* temp = _impl_.message_.data_packet_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.data_packet_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataPacketReceived& RoomEvent::_internal_data_packet_received() const {
  return _internal_has_data_packet_received()
      ? *_impl_.message_.data_packet_received_
      : reinterpret_cast< ::livekit::proto::DataPacketReceived&>(::livekit::proto::_DataPacketReceived_default_instance_);
}
inline const ::livekit::proto::DataPacketReceived& RoomEvent::data_packet_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.data_packet_received)
  return _internal_data_packet_received();
}
inline ::livekit::proto::DataPacketReceived* RoomEvent::unsafe_arena_release_data_packet_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.data_packet_received)
  if (_internal_has_data_packet_received()) {
    clear_has_message();
    ::livekit::proto::DataPacketReceived* temp = _impl_.message_.data_packet_received_;
    _impl_.message_.data_packet_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_data_packet_received(::livekit::proto::DataPacketReceived* data_packet_received) {
  clear_message();
  if (data_packet_received) {
    set_has_data_packet_received();
    _impl_.message_.data_packet_received_ = data_packet_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.data_packet_received)
}
inline ::livekit::proto::DataPacketReceived* RoomEvent::_internal_mutable_data_packet_received() {
  if (!_internal_has_data_packet_received()) {
    clear_message();
    set_has_data_packet_received();
    _impl_.message_.data_packet_received_ = CreateMaybeMessage< ::livekit::proto::DataPacketReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.data_packet_received_;
}
inline ::livekit::proto::DataPacketReceived* RoomEvent::mutable_data_packet_received() {
  ::livekit::proto::DataPacketReceived* _msg = _internal_mutable_data_packet_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.data_packet_received)
  return _msg;
}

// .livekit.proto.TranscriptionReceived transcription_received = 28;
inline bool RoomEvent::_internal_has_transcription_received() const {
  return message_case() == kTranscriptionReceived;
}
inline bool RoomEvent::has_transcription_received() const {
  return _internal_has_transcription_received();
}
inline void RoomEvent::set_has_transcription_received() {
  _impl_._oneof_case_[0] = kTranscriptionReceived;
}
inline void RoomEvent::clear_transcription_received() {
  if (_internal_has_transcription_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.transcription_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::TranscriptionReceived* RoomEvent::release_transcription_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.transcription_received)
  if (_internal_has_transcription_received()) {
    clear_has_message();
    ::livekit::proto::TranscriptionReceived* temp = _impl_.message_.transcription_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.transcription_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::TranscriptionReceived& RoomEvent::_internal_transcription_received() const {
  return _internal_has_transcription_received()
      ? *_impl_.message_.transcription_received_
      : reinterpret_cast< ::livekit::proto::TranscriptionReceived&>(::livekit::proto::_TranscriptionReceived_default_instance_);
}
inline const ::livekit::proto::TranscriptionReceived& RoomEvent::transcription_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.transcription_received)
  return _internal_transcription_received();
}
inline ::livekit::proto::TranscriptionReceived* RoomEvent::unsafe_arena_release_transcription_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.transcription_received)
  if (_internal_has_transcription_received()) {
    clear_has_message();
    ::livekit::proto::TranscriptionReceived* temp = _impl_.message_.transcription_received_;
    _impl_.message_.transcription_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_transcription_received(::livekit::proto::TranscriptionReceived* transcription_received) {
  clear_message();
  if (transcription_received) {
    set_has_transcription_received();
    _impl_.message_.transcription_received_ = transcription_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.transcription_received)
}
inline ::livekit::proto::TranscriptionReceived* RoomEvent::_internal_mutable_transcription_received() {
  if (!_internal_has_transcription_received()) {
    clear_message();
    set_has_transcription_received();
    _impl_.message_.transcription_received_ = CreateMaybeMessage< ::livekit::proto::TranscriptionReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.transcription_received_;
}
inline ::livekit::proto::TranscriptionReceived* RoomEvent::mutable_transcription_received() {
  ::livekit::proto::TranscriptionReceived* _msg = _internal_mutable_transcription_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.transcription_received)
  return _msg;
}

// .livekit.proto.ChatMessageReceived chat_message = 29;
inline bool RoomEvent::_internal_has_chat_message() const {
  return message_case() == kChatMessage;
}
inline bool RoomEvent::has_chat_message() const {
  return _internal_has_chat_message();
}
inline void RoomEvent::set_has_chat_message() {
  _impl_._oneof_case_[0] = kChatMessage;
}
inline void RoomEvent::clear_chat_message() {
  if (_internal_has_chat_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.chat_message_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::ChatMessageReceived* RoomEvent::release_chat_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
    ::livekit::proto::ChatMessageReceived* temp = _impl_.message_.chat_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::ChatMessageReceived& RoomEvent::_internal_chat_message() const {
  return _internal_has_chat_message()
      ? *_impl_.message_.chat_message_
      : reinterpret_cast< ::livekit::proto::ChatMessageReceived&>(::livekit::proto::_ChatMessageReceived_default_instance_);
}
inline const ::livekit::proto::ChatMessageReceived& RoomEvent::chat_message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.chat_message)
  return _internal_chat_message();
}
inline ::livekit::proto::ChatMessageReceived* RoomEvent::unsafe_arena_release_chat_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.chat_message)
  if (_internal_has_chat_message()) {
    clear_has_message();
    ::livekit::proto::ChatMessageReceived* temp = _impl_.message_.chat_message_;
    _impl_.message_.chat_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_chat_message(::livekit::proto::ChatMessageReceived* chat_message) {
  clear_message();
  if (chat_message) {
    set_has_chat_message();
    _impl_.message_.chat_message_ = chat_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.chat_message)
}
inline ::livekit::proto::ChatMessageReceived* RoomEvent::_internal_mutable_chat_message() {
  if (!_internal_has_chat_message()) {
    clear_message();
    set_has_chat_message();
    _impl_.message_.chat_message_ = CreateMaybeMessage< ::livekit::proto::ChatMessageReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.chat_message_;
}
inline ::livekit::proto::ChatMessageReceived* RoomEvent::mutable_chat_message() {
  ::livekit::proto::ChatMessageReceived* _msg = _internal_mutable_chat_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.chat_message)
  return _msg;
}

// .livekit.proto.DataStreamHeaderReceived stream_header_received = 30;
inline bool RoomEvent::_internal_has_stream_header_received() const {
  return message_case() == kStreamHeaderReceived;
}
inline bool RoomEvent::has_stream_header_received() const {
  return _internal_has_stream_header_received();
}
inline void RoomEvent::set_has_stream_header_received() {
  _impl_._oneof_case_[0] = kStreamHeaderReceived;
}
inline void RoomEvent::clear_stream_header_received() {
  if (_internal_has_stream_header_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stream_header_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::DataStreamHeaderReceived* RoomEvent::release_stream_header_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.stream_header_received)
  if (_internal_has_stream_header_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamHeaderReceived* temp = _impl_.message_.stream_header_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stream_header_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataStreamHeaderReceived& RoomEvent::_internal_stream_header_received() const {
  return _internal_has_stream_header_received()
      ? *_impl_.message_.stream_header_received_
      : reinterpret_cast< ::livekit::proto::DataStreamHeaderReceived&>(::livekit::proto::_DataStreamHeaderReceived_default_instance_);
}
inline const ::livekit::proto::DataStreamHeaderReceived& RoomEvent::stream_header_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.stream_header_received)
  return _internal_stream_header_received();
}
inline ::livekit::proto::DataStreamHeaderReceived* RoomEvent::unsafe_arena_release_stream_header_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.stream_header_received)
  if (_internal_has_stream_header_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamHeaderReceived* temp = _impl_.message_.stream_header_received_;
    _impl_.message_.stream_header_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_stream_header_received(::livekit::proto::DataStreamHeaderReceived* stream_header_received) {
  clear_message();
  if (stream_header_received) {
    set_has_stream_header_received();
    _impl_.message_.stream_header_received_ = stream_header_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.stream_header_received)
}
inline ::livekit::proto::DataStreamHeaderReceived* RoomEvent::_internal_mutable_stream_header_received() {
  if (!_internal_has_stream_header_received()) {
    clear_message();
    set_has_stream_header_received();
    _impl_.message_.stream_header_received_ = CreateMaybeMessage< ::livekit::proto::DataStreamHeaderReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.stream_header_received_;
}
inline ::livekit::proto::DataStreamHeaderReceived* RoomEvent::mutable_stream_header_received() {
  ::livekit::proto::DataStreamHeaderReceived* _msg = _internal_mutable_stream_header_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.stream_header_received)
  return _msg;
}

// .livekit.proto.DataStreamChunkReceived stream_chunk_received = 31;
inline bool RoomEvent::_internal_has_stream_chunk_received() const {
  return message_case() == kStreamChunkReceived;
}
inline bool RoomEvent::has_stream_chunk_received() const {
  return _internal_has_stream_chunk_received();
}
inline void RoomEvent::set_has_stream_chunk_received() {
  _impl_._oneof_case_[0] = kStreamChunkReceived;
}
inline void RoomEvent::clear_stream_chunk_received() {
  if (_internal_has_stream_chunk_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stream_chunk_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::DataStreamChunkReceived* RoomEvent::release_stream_chunk_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.stream_chunk_received)
  if (_internal_has_stream_chunk_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamChunkReceived* temp = _impl_.message_.stream_chunk_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stream_chunk_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataStreamChunkReceived& RoomEvent::_internal_stream_chunk_received() const {
  return _internal_has_stream_chunk_received()
      ? *_impl_.message_.stream_chunk_received_
      : reinterpret_cast< ::livekit::proto::DataStreamChunkReceived&>(::livekit::proto::_DataStreamChunkReceived_default_instance_);
}
inline const ::livekit::proto::DataStreamChunkReceived& RoomEvent::stream_chunk_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.stream_chunk_received)
  return _internal_stream_chunk_received();
}
inline ::livekit::proto::DataStreamChunkReceived* RoomEvent::unsafe_arena_release_stream_chunk_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.stream_chunk_received)
  if (_internal_has_stream_chunk_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamChunkReceived* temp = _impl_.message_.stream_chunk_received_;
    _impl_.message_.stream_chunk_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_stream_chunk_received(::livekit::proto::DataStreamChunkReceived* stream_chunk_received) {
  clear_message();
  if (stream_chunk_received) {
    set_has_stream_chunk_received();
    _impl_.message_.stream_chunk_received_ = stream_chunk_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.stream_chunk_received)
}
inline ::livekit::proto::DataStreamChunkReceived* RoomEvent::_internal_mutable_stream_chunk_received() {
  if (!_internal_has_stream_chunk_received()) {
    clear_message();
    set_has_stream_chunk_received();
    _impl_.message_.stream_chunk_received_ = CreateMaybeMessage< ::livekit::proto::DataStreamChunkReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.stream_chunk_received_;
}
inline ::livekit::proto::DataStreamChunkReceived* RoomEvent::mutable_stream_chunk_received() {
  ::livekit::proto::DataStreamChunkReceived* _msg = _internal_mutable_stream_chunk_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.stream_chunk_received)
  return _msg;
}

// .livekit.proto.DataStreamTrailerReceived stream_trailer_received = 32;
inline bool RoomEvent::_internal_has_stream_trailer_received() const {
  return message_case() == kStreamTrailerReceived;
}
inline bool RoomEvent::has_stream_trailer_received() const {
  return _internal_has_stream_trailer_received();
}
inline void RoomEvent::set_has_stream_trailer_received() {
  _impl_._oneof_case_[0] = kStreamTrailerReceived;
}
inline void RoomEvent::clear_stream_trailer_received() {
  if (_internal_has_stream_trailer_received()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.stream_trailer_received_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::DataStreamTrailerReceived* RoomEvent::release_stream_trailer_received() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.stream_trailer_received)
  if (_internal_has_stream_trailer_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamTrailerReceived* temp = _impl_.message_.stream_trailer_received_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.stream_trailer_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataStreamTrailerReceived& RoomEvent::_internal_stream_trailer_received() const {
  return _internal_has_stream_trailer_received()
      ? *_impl_.message_.stream_trailer_received_
      : reinterpret_cast< ::livekit::proto::DataStreamTrailerReceived&>(::livekit::proto::_DataStreamTrailerReceived_default_instance_);
}
inline const ::livekit::proto::DataStreamTrailerReceived& RoomEvent::stream_trailer_received() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.stream_trailer_received)
  return _internal_stream_trailer_received();
}
inline ::livekit::proto::DataStreamTrailerReceived* RoomEvent::unsafe_arena_release_stream_trailer_received() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.stream_trailer_received)
  if (_internal_has_stream_trailer_received()) {
    clear_has_message();
    ::livekit::proto::DataStreamTrailerReceived* temp = _impl_.message_.stream_trailer_received_;
    _impl_.message_.stream_trailer_received_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_stream_trailer_received(::livekit::proto::DataStreamTrailerReceived* stream_trailer_received) {
  clear_message();
  if (stream_trailer_received) {
    set_has_stream_trailer_received();
    _impl_.message_.stream_trailer_received_ = stream_trailer_received;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.stream_trailer_received)
}
inline ::livekit::proto::DataStreamTrailerReceived* RoomEvent::_internal_mutable_stream_trailer_received() {
  if (!_internal_has_stream_trailer_received()) {
    clear_message();
    set_has_stream_trailer_received();
    _impl_.message_.stream_trailer_received_ = CreateMaybeMessage< ::livekit::proto::DataStreamTrailerReceived >(GetArenaForAllocation());
  }
  return _impl_.message_.stream_trailer_received_;
}
inline ::livekit::proto::DataStreamTrailerReceived* RoomEvent::mutable_stream_trailer_received() {
  ::livekit::proto::DataStreamTrailerReceived* _msg = _internal_mutable_stream_trailer_received();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.stream_trailer_received)
  return _msg;
}

// .livekit.proto.DataChannelBufferedAmountLowThresholdChanged data_channel_low_threshold_changed = 33;
inline bool RoomEvent::_internal_has_data_channel_low_threshold_changed() const {
  return message_case() == kDataChannelLowThresholdChanged;
}
inline bool RoomEvent::has_data_channel_low_threshold_changed() const {
  return _internal_has_data_channel_low_threshold_changed();
}
inline void RoomEvent::set_has_data_channel_low_threshold_changed() {
  _impl_._oneof_case_[0] = kDataChannelLowThresholdChanged;
}
inline void RoomEvent::clear_data_channel_low_threshold_changed() {
  if (_internal_has_data_channel_low_threshold_changed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.data_channel_low_threshold_changed_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* RoomEvent::release_data_channel_low_threshold_changed() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomEvent.data_channel_low_threshold_changed)
  if (_internal_has_data_channel_low_threshold_changed()) {
    clear_has_message();
    ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* temp = _impl_.message_.data_channel_low_threshold_changed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.data_channel_low_threshold_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged& RoomEvent::_internal_data_channel_low_threshold_changed() const {
  return _internal_has_data_channel_low_threshold_changed()
      ? *_impl_.message_.data_channel_low_threshold_changed_
      : reinterpret_cast< ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged&>(::livekit::proto::_DataChannelBufferedAmountLowThresholdChanged_default_instance_);
}
inline const ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged& RoomEvent::data_channel_low_threshold_changed() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomEvent.data_channel_low_threshold_changed)
  return _internal_data_channel_low_threshold_changed();
}
inline ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* RoomEvent::unsafe_arena_release_data_channel_low_threshold_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.RoomEvent.data_channel_low_threshold_changed)
  if (_internal_has_data_channel_low_threshold_changed()) {
    clear_has_message();
    ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* temp = _impl_.message_.data_channel_low_threshold_changed_;
    _impl_.message_.data_channel_low_threshold_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RoomEvent::unsafe_arena_set_allocated_data_channel_low_threshold_changed(::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* data_channel_low_threshold_changed) {
  clear_message();
  if (data_channel_low_threshold_changed) {
    set_has_data_channel_low_threshold_changed();
    _impl_.message_.data_channel_low_threshold_changed_ = data_channel_low_threshold_changed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.RoomEvent.data_channel_low_threshold_changed)
}
inline ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* RoomEvent::_internal_mutable_data_channel_low_threshold_changed() {
  if (!_internal_has_data_channel_low_threshold_changed()) {
    clear_message();
    set_has_data_channel_low_threshold_changed();
    _impl_.message_.data_channel_low_threshold_changed_ = CreateMaybeMessage< ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged >(GetArenaForAllocation());
  }
  return _impl_.message_.data_channel_low_threshold_changed_;
}
inline ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* RoomEvent::mutable_data_channel_low_threshold_changed() {
  ::livekit::proto::DataChannelBufferedAmountLowThresholdChanged* _msg = _internal_mutable_data_channel_low_threshold_changed();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomEvent.data_channel_low_threshold_changed)
  return _msg;
}

inline bool RoomEvent::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void RoomEvent::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline RoomEvent::MessageCase RoomEvent::message_case() const {
  return RoomEvent::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomInfo

// optional string sid = 1;
inline bool RoomInfo::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoomInfo::has_sid() const {
  return _internal_has_sid();
}
inline void RoomInfo::clear_sid() {
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomInfo::sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomInfo.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RoomInfo.sid)
}
inline std::string* RoomInfo::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomInfo.sid)
  return _s;
}
inline const std::string& RoomInfo::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void RoomInfo::_internal_set_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomInfo.sid)
  if (!_internal_has_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoomInfo::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomInfo.sid)
}

// required string name = 2;
inline bool RoomInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RoomInfo::has_name() const {
  return _internal_has_name();
}
inline void RoomInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RoomInfo::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RoomInfo.name)
}
inline std::string* RoomInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomInfo.name)
  return _s;
}
inline const std::string& RoomInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RoomInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoomInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomInfo.name)
}

// required string metadata = 3;
inline bool RoomInfo::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RoomInfo::has_metadata() const {
  return _internal_has_metadata();
}
inline void RoomInfo::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RoomInfo::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomInfo.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_metadata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RoomInfo.metadata)
}
inline std::string* RoomInfo::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomInfo.metadata)
  return _s;
}
inline const std::string& RoomInfo::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void RoomInfo::_internal_set_metadata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomInfo.metadata)
  if (!_internal_has_metadata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.metadata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoomInfo::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomInfo.metadata)
}

// required uint64 lossy_dc_buffered_amount_low_threshold = 4;
inline bool RoomInfo::_internal_has_lossy_dc_buffered_amount_low_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RoomInfo::has_lossy_dc_buffered_amount_low_threshold() const {
  return _internal_has_lossy_dc_buffered_amount_low_threshold();
}
inline void RoomInfo::clear_lossy_dc_buffered_amount_low_threshold() {
  _impl_.lossy_dc_buffered_amount_low_threshold_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t RoomInfo::_internal_lossy_dc_buffered_amount_low_threshold() const {
  return _impl_.lossy_dc_buffered_amount_low_threshold_;
}
inline uint64_t RoomInfo::lossy_dc_buffered_amount_low_threshold() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomInfo.lossy_dc_buffered_amount_low_threshold)
  return _internal_lossy_dc_buffered_amount_low_threshold();
}
inline void RoomInfo::_internal_set_lossy_dc_buffered_amount_low_threshold(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.lossy_dc_buffered_amount_low_threshold_ = value;
}
inline void RoomInfo::set_lossy_dc_buffered_amount_low_threshold(uint64_t value) {
  _internal_set_lossy_dc_buffered_amount_low_threshold(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomInfo.lossy_dc_buffered_amount_low_threshold)
}

// required uint64 reliable_dc_buffered_amount_low_threshold = 5;
inline bool RoomInfo::_internal_has_reliable_dc_buffered_amount_low_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RoomInfo::has_reliable_dc_buffered_amount_low_threshold() const {
  return _internal_has_reliable_dc_buffered_amount_low_threshold();
}
inline void RoomInfo::clear_reliable_dc_buffered_amount_low_threshold() {
  _impl_.reliable_dc_buffered_amount_low_threshold_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t RoomInfo::_internal_reliable_dc_buffered_amount_low_threshold() const {
  return _impl_.reliable_dc_buffered_amount_low_threshold_;
}
inline uint64_t RoomInfo::reliable_dc_buffered_amount_low_threshold() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomInfo.reliable_dc_buffered_amount_low_threshold)
  return _internal_reliable_dc_buffered_amount_low_threshold();
}
inline void RoomInfo::_internal_set_reliable_dc_buffered_amount_low_threshold(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.reliable_dc_buffered_amount_low_threshold_ = value;
}
inline void RoomInfo::set_reliable_dc_buffered_amount_low_threshold(uint64_t value) {
  _internal_set_reliable_dc_buffered_amount_low_threshold(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RoomInfo.reliable_dc_buffered_amount_low_threshold)
}

// -------------------------------------------------------------------

// OwnedRoom

// required .livekit.proto.FfiOwnedHandle handle = 1;
inline bool OwnedRoom::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool OwnedRoom::has_handle() const {
  return _internal_has_handle();
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedRoom::_internal_handle() const {
  const ::livekit::proto::FfiOwnedHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::FfiOwnedHandle&>(
      ::livekit::proto::_FfiOwnedHandle_default_instance_);
}
inline const ::livekit::proto::FfiOwnedHandle& OwnedRoom::handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedRoom.handle)
  return _internal_handle();
}
inline void OwnedRoom::unsafe_arena_set_allocated_handle(
    ::livekit::proto::FfiOwnedHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedRoom.handle)
}
inline ::livekit::proto::FfiOwnedHandle* OwnedRoom::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedRoom::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedRoom.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::FfiOwnedHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedRoom::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::FfiOwnedHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::livekit::proto::FfiOwnedHandle* OwnedRoom::mutable_handle() {
  ::livekit::proto::FfiOwnedHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedRoom.handle)
  return _msg;
}
inline void OwnedRoom::set_allocated_handle(::livekit::proto::FfiOwnedHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedRoom.handle)
}

// required .livekit.proto.RoomInfo info = 2;
inline bool OwnedRoom::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool OwnedRoom::has_info() const {
  return _internal_has_info();
}
inline void OwnedRoom::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::RoomInfo& OwnedRoom::_internal_info() const {
  const ::livekit::proto::RoomInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::RoomInfo&>(
      ::livekit::proto::_RoomInfo_default_instance_);
}
inline const ::livekit::proto::RoomInfo& OwnedRoom::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.OwnedRoom.info)
  return _internal_info();
}
inline void OwnedRoom::unsafe_arena_set_allocated_info(
    ::livekit::proto::RoomInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.OwnedRoom.info)
}
inline ::livekit::proto::RoomInfo* OwnedRoom::release_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::RoomInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::RoomInfo* OwnedRoom::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.OwnedRoom.info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::RoomInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::RoomInfo* OwnedRoom::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::RoomInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::RoomInfo* OwnedRoom::mutable_info() {
  ::livekit::proto::RoomInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.OwnedRoom.info)
  return _msg;
}
inline void OwnedRoom::set_allocated_info(::livekit::proto::RoomInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.OwnedRoom.info)
}

// -------------------------------------------------------------------

// ParticipantConnected

// required .livekit.proto.OwnedParticipant info = 1;
inline bool ParticipantConnected::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool ParticipantConnected::has_info() const {
  return _internal_has_info();
}
inline const ::livekit::proto::OwnedParticipant& ParticipantConnected::_internal_info() const {
  const ::livekit::proto::OwnedParticipant* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedParticipant&>(
      ::livekit::proto::_OwnedParticipant_default_instance_);
}
inline const ::livekit::proto::OwnedParticipant& ParticipantConnected::info() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantConnected.info)
  return _internal_info();
}
inline void ParticipantConnected::unsafe_arena_set_allocated_info(
    ::livekit::proto::OwnedParticipant* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ParticipantConnected.info)
}
inline ::livekit::proto::OwnedParticipant* ParticipantConnected::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ParticipantConnected::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantConnected.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::OwnedParticipant* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedParticipant* ParticipantConnected::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedParticipant>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::livekit::proto::OwnedParticipant* ParticipantConnected::mutable_info() {
  ::livekit::proto::OwnedParticipant* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantConnected.info)
  return _msg;
}
inline void ParticipantConnected::set_allocated_info(::livekit::proto::OwnedParticipant* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantConnected.info)
}

// -------------------------------------------------------------------

// ParticipantDisconnected

// required string participant_identity = 1;
inline bool ParticipantDisconnected::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParticipantDisconnected::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ParticipantDisconnected::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantDisconnected::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantDisconnected.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantDisconnected::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantDisconnected.participant_identity)
}
inline std::string* ParticipantDisconnected::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantDisconnected.participant_identity)
  return _s;
}
inline const std::string& ParticipantDisconnected::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ParticipantDisconnected::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantDisconnected::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantDisconnected::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantDisconnected.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantDisconnected::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantDisconnected.participant_identity)
}

// required .livekit.proto.DisconnectReason disconnect_reason = 2;
inline bool ParticipantDisconnected::_internal_has_disconnect_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParticipantDisconnected::has_disconnect_reason() const {
  return _internal_has_disconnect_reason();
}
inline void ParticipantDisconnected::clear_disconnect_reason() {
  _impl_.disconnect_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::DisconnectReason ParticipantDisconnected::_internal_disconnect_reason() const {
  return static_cast< ::livekit::proto::DisconnectReason >(_impl_.disconnect_reason_);
}
inline ::livekit::proto::DisconnectReason ParticipantDisconnected::disconnect_reason() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantDisconnected.disconnect_reason)
  return _internal_disconnect_reason();
}
inline void ParticipantDisconnected::_internal_set_disconnect_reason(::livekit::proto::DisconnectReason value) {
  assert(::livekit::proto::DisconnectReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.disconnect_reason_ = value;
}
inline void ParticipantDisconnected::set_disconnect_reason(::livekit::proto::DisconnectReason value) {
  _internal_set_disconnect_reason(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantDisconnected.disconnect_reason)
}

// -------------------------------------------------------------------

// LocalTrackPublished

// required string track_sid = 1;
inline bool LocalTrackPublished::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTrackPublished::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void LocalTrackPublished::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalTrackPublished::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackPublished.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTrackPublished::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackPublished.track_sid)
}
inline std::string* LocalTrackPublished::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LocalTrackPublished.track_sid)
  return _s;
}
inline const std::string& LocalTrackPublished::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void LocalTrackPublished::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalTrackPublished::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalTrackPublished::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.LocalTrackPublished.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocalTrackPublished::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LocalTrackPublished.track_sid)
}

// -------------------------------------------------------------------

// LocalTrackUnpublished

// required string publication_sid = 1;
inline bool LocalTrackUnpublished::_internal_has_publication_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTrackUnpublished::has_publication_sid() const {
  return _internal_has_publication_sid();
}
inline void LocalTrackUnpublished::clear_publication_sid() {
  _impl_.publication_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalTrackUnpublished::publication_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackUnpublished.publication_sid)
  return _internal_publication_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTrackUnpublished::set_publication_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publication_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackUnpublished.publication_sid)
}
inline std::string* LocalTrackUnpublished::mutable_publication_sid() {
  std::string* _s = _internal_mutable_publication_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LocalTrackUnpublished.publication_sid)
  return _s;
}
inline const std::string& LocalTrackUnpublished::_internal_publication_sid() const {
  return _impl_.publication_sid_.Get();
}
inline void LocalTrackUnpublished::_internal_set_publication_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publication_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalTrackUnpublished::_internal_mutable_publication_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publication_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalTrackUnpublished::release_publication_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.LocalTrackUnpublished.publication_sid)
  if (!_internal_has_publication_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publication_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publication_sid_.IsDefault()) {
    _impl_.publication_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocalTrackUnpublished::set_allocated_publication_sid(std::string* publication_sid) {
  if (publication_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publication_sid_.SetAllocated(publication_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publication_sid_.IsDefault()) {
    _impl_.publication_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LocalTrackUnpublished.publication_sid)
}

// -------------------------------------------------------------------

// LocalTrackSubscribed

// required string track_sid = 2;
inline bool LocalTrackSubscribed::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTrackSubscribed::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void LocalTrackSubscribed::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalTrackSubscribed::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.LocalTrackSubscribed.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTrackSubscribed::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.LocalTrackSubscribed.track_sid)
}
inline std::string* LocalTrackSubscribed::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.LocalTrackSubscribed.track_sid)
  return _s;
}
inline const std::string& LocalTrackSubscribed::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void LocalTrackSubscribed::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* LocalTrackSubscribed::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* LocalTrackSubscribed::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.LocalTrackSubscribed.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocalTrackSubscribed::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.LocalTrackSubscribed.track_sid)
}

// -------------------------------------------------------------------

// TrackPublished

// required string participant_identity = 1;
inline bool TrackPublished::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackPublished::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackPublished::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackPublished::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublished.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackPublished::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackPublished.participant_identity)
}
inline std::string* TrackPublished::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublished.participant_identity)
  return _s;
}
inline const std::string& TrackPublished::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackPublished::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackPublished::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackPublished::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublished.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackPublished::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublished.participant_identity)
}

// required .livekit.proto.OwnedTrackPublication publication = 2;
inline bool TrackPublished::_internal_has_publication() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.publication_ != nullptr);
  return value;
}
inline bool TrackPublished::has_publication() const {
  return _internal_has_publication();
}
inline const ::livekit::proto::OwnedTrackPublication& TrackPublished::_internal_publication() const {
  const ::livekit::proto::OwnedTrackPublication* p = _impl_.publication_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedTrackPublication&>(
      ::livekit::proto::_OwnedTrackPublication_default_instance_);
}
inline const ::livekit::proto::OwnedTrackPublication& TrackPublished::publication() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackPublished.publication)
  return _internal_publication();
}
inline void TrackPublished::unsafe_arena_set_allocated_publication(
    ::livekit::proto::OwnedTrackPublication* publication) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.publication_);
  }
  _impl_.publication_ = publication;
  if (publication) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.TrackPublished.publication)
}
inline ::livekit::proto::OwnedTrackPublication* TrackPublished::release_publication() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedTrackPublication* temp = _impl_.publication_;
  _impl_.publication_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedTrackPublication* TrackPublished::unsafe_arena_release_publication() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackPublished.publication)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedTrackPublication* temp = _impl_.publication_;
  _impl_.publication_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedTrackPublication* TrackPublished::_internal_mutable_publication() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.publication_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedTrackPublication>(GetArenaForAllocation());
    _impl_.publication_ = p;
  }
  return _impl_.publication_;
}
inline ::livekit::proto::OwnedTrackPublication* TrackPublished::mutable_publication() {
  ::livekit::proto::OwnedTrackPublication* _msg = _internal_mutable_publication();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackPublished.publication)
  return _msg;
}
inline void TrackPublished::set_allocated_publication(::livekit::proto::OwnedTrackPublication* publication) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.publication_);
  }
  if (publication) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(publication));
    if (message_arena != submessage_arena) {
      publication = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publication, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.publication_ = publication;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackPublished.publication)
}

// -------------------------------------------------------------------

// TrackUnpublished

// required string participant_identity = 1;
inline bool TrackUnpublished::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackUnpublished::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackUnpublished::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackUnpublished::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnpublished.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnpublished::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnpublished.participant_identity)
}
inline std::string* TrackUnpublished::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnpublished.participant_identity)
  return _s;
}
inline const std::string& TrackUnpublished::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackUnpublished::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnpublished::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnpublished::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnpublished.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnpublished::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnpublished.participant_identity)
}

// required string publication_sid = 2;
inline bool TrackUnpublished::_internal_has_publication_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackUnpublished::has_publication_sid() const {
  return _internal_has_publication_sid();
}
inline void TrackUnpublished::clear_publication_sid() {
  _impl_.publication_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackUnpublished::publication_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnpublished.publication_sid)
  return _internal_publication_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnpublished::set_publication_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.publication_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnpublished.publication_sid)
}
inline std::string* TrackUnpublished::mutable_publication_sid() {
  std::string* _s = _internal_mutable_publication_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnpublished.publication_sid)
  return _s;
}
inline const std::string& TrackUnpublished::_internal_publication_sid() const {
  return _impl_.publication_sid_.Get();
}
inline void TrackUnpublished::_internal_set_publication_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.publication_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnpublished::_internal_mutable_publication_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.publication_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnpublished::release_publication_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnpublished.publication_sid)
  if (!_internal_has_publication_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.publication_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publication_sid_.IsDefault()) {
    _impl_.publication_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnpublished::set_allocated_publication_sid(std::string* publication_sid) {
  if (publication_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.publication_sid_.SetAllocated(publication_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publication_sid_.IsDefault()) {
    _impl_.publication_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnpublished.publication_sid)
}

// -------------------------------------------------------------------

// TrackSubscribed

// required string participant_identity = 1;
inline bool TrackSubscribed::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackSubscribed::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackSubscribed::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackSubscribed::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackSubscribed.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackSubscribed::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackSubscribed.participant_identity)
}
inline std::string* TrackSubscribed::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackSubscribed.participant_identity)
  return _s;
}
inline const std::string& TrackSubscribed::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackSubscribed::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackSubscribed::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackSubscribed::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackSubscribed.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackSubscribed::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackSubscribed.participant_identity)
}

// required .livekit.proto.OwnedTrack track = 2;
inline bool TrackSubscribed::_internal_has_track() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
  return value;
}
inline bool TrackSubscribed::has_track() const {
  return _internal_has_track();
}
inline const ::livekit::proto::OwnedTrack& TrackSubscribed::_internal_track() const {
  const ::livekit::proto::OwnedTrack* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedTrack&>(
      ::livekit::proto::_OwnedTrack_default_instance_);
}
inline const ::livekit::proto::OwnedTrack& TrackSubscribed::track() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackSubscribed.track)
  return _internal_track();
}
inline void TrackSubscribed::unsafe_arena_set_allocated_track(
    ::livekit::proto::OwnedTrack* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.TrackSubscribed.track)
}
inline ::livekit::proto::OwnedTrack* TrackSubscribed::release_track() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedTrack* TrackSubscribed::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackSubscribed.track)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedTrack* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedTrack* TrackSubscribed::_internal_mutable_track() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedTrack>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::livekit::proto::OwnedTrack* TrackSubscribed::mutable_track() {
  ::livekit::proto::OwnedTrack* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackSubscribed.track)
  return _msg;
}
inline void TrackSubscribed::set_allocated_track(::livekit::proto::OwnedTrack* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track));
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackSubscribed.track)
}

// -------------------------------------------------------------------

// TrackUnsubscribed

// required string participant_identity = 1;
inline bool TrackUnsubscribed::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackUnsubscribed::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackUnsubscribed::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackUnsubscribed::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnsubscribed.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnsubscribed::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnsubscribed.participant_identity)
}
inline std::string* TrackUnsubscribed::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnsubscribed.participant_identity)
  return _s;
}
inline const std::string& TrackUnsubscribed::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackUnsubscribed::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnsubscribed::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnsubscribed::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnsubscribed.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnsubscribed::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnsubscribed.participant_identity)
}

// required string track_sid = 2;
inline bool TrackUnsubscribed::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackUnsubscribed::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void TrackUnsubscribed::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackUnsubscribed::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnsubscribed.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnsubscribed::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnsubscribed.track_sid)
}
inline std::string* TrackUnsubscribed::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnsubscribed.track_sid)
  return _s;
}
inline const std::string& TrackUnsubscribed::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackUnsubscribed::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnsubscribed::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnsubscribed::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnsubscribed.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnsubscribed::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnsubscribed.track_sid)
}

// -------------------------------------------------------------------

// TrackSubscriptionFailed

// required string participant_identity = 1;
inline bool TrackSubscriptionFailed::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackSubscriptionFailed::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackSubscriptionFailed::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackSubscriptionFailed::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackSubscriptionFailed.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackSubscriptionFailed::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackSubscriptionFailed.participant_identity)
}
inline std::string* TrackSubscriptionFailed::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackSubscriptionFailed.participant_identity)
  return _s;
}
inline const std::string& TrackSubscriptionFailed::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackSubscriptionFailed::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackSubscriptionFailed.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackSubscriptionFailed::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackSubscriptionFailed.participant_identity)
}

// required string track_sid = 2;
inline bool TrackSubscriptionFailed::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackSubscriptionFailed::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void TrackSubscriptionFailed::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackSubscriptionFailed::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackSubscriptionFailed.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackSubscriptionFailed::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackSubscriptionFailed.track_sid)
}
inline std::string* TrackSubscriptionFailed::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackSubscriptionFailed.track_sid)
  return _s;
}
inline const std::string& TrackSubscriptionFailed::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackSubscriptionFailed::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackSubscriptionFailed.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackSubscriptionFailed::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackSubscriptionFailed.track_sid)
}

// required string error = 3;
inline bool TrackSubscriptionFailed::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackSubscriptionFailed::has_error() const {
  return _internal_has_error();
}
inline void TrackSubscriptionFailed::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TrackSubscriptionFailed::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackSubscriptionFailed.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackSubscriptionFailed::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackSubscriptionFailed.error)
}
inline std::string* TrackSubscriptionFailed::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackSubscriptionFailed.error)
  return _s;
}
inline const std::string& TrackSubscriptionFailed::_internal_error() const {
  return _impl_.error_.Get();
}
inline void TrackSubscriptionFailed::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackSubscriptionFailed::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackSubscriptionFailed.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackSubscriptionFailed::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackSubscriptionFailed.error)
}

// -------------------------------------------------------------------

// TrackMuted

// required string participant_identity = 1;
inline bool TrackMuted::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackMuted::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackMuted::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackMuted::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackMuted.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackMuted::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackMuted.participant_identity)
}
inline std::string* TrackMuted::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackMuted.participant_identity)
  return _s;
}
inline const std::string& TrackMuted::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackMuted::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackMuted::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackMuted::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackMuted.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackMuted::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackMuted.participant_identity)
}

// required string track_sid = 2;
inline bool TrackMuted::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackMuted::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void TrackMuted::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackMuted::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackMuted.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackMuted::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackMuted.track_sid)
}
inline std::string* TrackMuted::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackMuted.track_sid)
  return _s;
}
inline const std::string& TrackMuted::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackMuted::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackMuted::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackMuted::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackMuted.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackMuted::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackMuted.track_sid)
}

// -------------------------------------------------------------------

// TrackUnmuted

// required string participant_identity = 1;
inline bool TrackUnmuted::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackUnmuted::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TrackUnmuted::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TrackUnmuted::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnmuted.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnmuted::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnmuted.participant_identity)
}
inline std::string* TrackUnmuted::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnmuted.participant_identity)
  return _s;
}
inline const std::string& TrackUnmuted::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TrackUnmuted::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnmuted::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnmuted::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnmuted.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnmuted::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnmuted.participant_identity)
}

// required string track_sid = 2;
inline bool TrackUnmuted::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackUnmuted::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void TrackUnmuted::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TrackUnmuted::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TrackUnmuted.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrackUnmuted::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TrackUnmuted.track_sid)
}
inline std::string* TrackUnmuted::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TrackUnmuted.track_sid)
  return _s;
}
inline const std::string& TrackUnmuted::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TrackUnmuted::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TrackUnmuted::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TrackUnmuted::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TrackUnmuted.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TrackUnmuted::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TrackUnmuted.track_sid)
}

// -------------------------------------------------------------------

// E2eeStateChanged

// required string participant_identity = 1;
inline bool E2eeStateChanged::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool E2eeStateChanged::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void E2eeStateChanged::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& E2eeStateChanged::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeStateChanged.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eeStateChanged::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.E2eeStateChanged.participant_identity)
}
inline std::string* E2eeStateChanged::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeStateChanged.participant_identity)
  return _s;
}
inline const std::string& E2eeStateChanged::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void E2eeStateChanged::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eeStateChanged::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eeStateChanged::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeStateChanged.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void E2eeStateChanged::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeStateChanged.participant_identity)
}

// required .livekit.proto.EncryptionState state = 2;
inline bool E2eeStateChanged::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool E2eeStateChanged::has_state() const {
  return _internal_has_state();
}
inline void E2eeStateChanged::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::EncryptionState E2eeStateChanged::_internal_state() const {
  return static_cast< ::livekit::proto::EncryptionState >(_impl_.state_);
}
inline ::livekit::proto::EncryptionState E2eeStateChanged::state() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeStateChanged.state)
  return _internal_state();
}
inline void E2eeStateChanged::_internal_set_state(::livekit::proto::EncryptionState value) {
  assert(::livekit::proto::EncryptionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_ = value;
}
inline void E2eeStateChanged::set_state(::livekit::proto::EncryptionState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.proto.E2eeStateChanged.state)
}

// -------------------------------------------------------------------

// ActiveSpeakersChanged

// repeated string participant_identities = 1;
inline int ActiveSpeakersChanged::_internal_participant_identities_size() const {
  return _impl_.participant_identities_.size();
}
inline int ActiveSpeakersChanged::participant_identities_size() const {
  return _internal_participant_identities_size();
}
inline void ActiveSpeakersChanged::clear_participant_identities() {
  _impl_.participant_identities_.Clear();
}
inline std::string* ActiveSpeakersChanged::add_participant_identities() {
  std::string* _s = _internal_add_participant_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.ActiveSpeakersChanged.participant_identities)
  return _s;
}
inline const std::string& ActiveSpeakersChanged::_internal_participant_identities(int index) const {
  return _impl_.participant_identities_.Get(index);
}
inline const std::string& ActiveSpeakersChanged::participant_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ActiveSpeakersChanged.participant_identities)
  return _internal_participant_identities(index);
}
inline std::string* ActiveSpeakersChanged::mutable_participant_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ActiveSpeakersChanged.participant_identities)
  return _impl_.participant_identities_.Mutable(index);
}
inline void ActiveSpeakersChanged::set_participant_identities(int index, const std::string& value) {
  _impl_.participant_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::set_participant_identities(int index, std::string&& value) {
  _impl_.participant_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::set_participant_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::set_participant_identities(int index, const char* value, size_t size) {
  _impl_.participant_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline std::string* ActiveSpeakersChanged::_internal_add_participant_identities() {
  return _impl_.participant_identities_.Add();
}
inline void ActiveSpeakersChanged::add_participant_identities(const std::string& value) {
  _impl_.participant_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::add_participant_identities(std::string&& value) {
  _impl_.participant_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::add_participant_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.participant_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline void ActiveSpeakersChanged::add_participant_identities(const char* value, size_t size) {
  _impl_.participant_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.ActiveSpeakersChanged.participant_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ActiveSpeakersChanged::participant_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ActiveSpeakersChanged.participant_identities)
  return _impl_.participant_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ActiveSpeakersChanged::mutable_participant_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ActiveSpeakersChanged.participant_identities)
  return &_impl_.participant_identities_;
}

// -------------------------------------------------------------------

// RoomMetadataChanged

// required string metadata = 1;
inline bool RoomMetadataChanged::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoomMetadataChanged::has_metadata() const {
  return _internal_has_metadata();
}
inline void RoomMetadataChanged::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomMetadataChanged::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomMetadataChanged.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomMetadataChanged::set_metadata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RoomMetadataChanged.metadata)
}
inline std::string* RoomMetadataChanged::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomMetadataChanged.metadata)
  return _s;
}
inline const std::string& RoomMetadataChanged::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void RoomMetadataChanged::_internal_set_metadata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomMetadataChanged::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomMetadataChanged::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomMetadataChanged.metadata)
  if (!_internal_has_metadata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.metadata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoomMetadataChanged::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomMetadataChanged.metadata)
}

// -------------------------------------------------------------------

// RoomSidChanged

// required string sid = 1;
inline bool RoomSidChanged::_internal_has_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RoomSidChanged::has_sid() const {
  return _internal_has_sid();
}
inline void RoomSidChanged::clear_sid() {
  _impl_.sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomSidChanged::sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RoomSidChanged.sid)
  return _internal_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomSidChanged::set_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RoomSidChanged.sid)
}
inline std::string* RoomSidChanged::mutable_sid() {
  std::string* _s = _internal_mutable_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RoomSidChanged.sid)
  return _s;
}
inline const std::string& RoomSidChanged::_internal_sid() const {
  return _impl_.sid_.Get();
}
inline void RoomSidChanged::_internal_set_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sid_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomSidChanged::_internal_mutable_sid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sid_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomSidChanged::release_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.RoomSidChanged.sid)
  if (!_internal_has_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RoomSidChanged::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sid_.SetAllocated(sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sid_.IsDefault()) {
    _impl_.sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RoomSidChanged.sid)
}

// -------------------------------------------------------------------

// ParticipantMetadataChanged

// required string participant_identity = 1;
inline bool ParticipantMetadataChanged::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParticipantMetadataChanged::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ParticipantMetadataChanged::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantMetadataChanged::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantMetadataChanged.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantMetadataChanged::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantMetadataChanged.participant_identity)
}
inline std::string* ParticipantMetadataChanged::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantMetadataChanged.participant_identity)
  return _s;
}
inline const std::string& ParticipantMetadataChanged::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ParticipantMetadataChanged::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantMetadataChanged::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantMetadataChanged::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantMetadataChanged.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantMetadataChanged::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantMetadataChanged.participant_identity)
}

// required string metadata = 2;
inline bool ParticipantMetadataChanged::_internal_has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParticipantMetadataChanged::has_metadata() const {
  return _internal_has_metadata();
}
inline void ParticipantMetadataChanged::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ParticipantMetadataChanged::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantMetadataChanged.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantMetadataChanged::set_metadata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantMetadataChanged.metadata)
}
inline std::string* ParticipantMetadataChanged::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantMetadataChanged.metadata)
  return _s;
}
inline const std::string& ParticipantMetadataChanged::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void ParticipantMetadataChanged::_internal_set_metadata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantMetadataChanged::_internal_mutable_metadata() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantMetadataChanged::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantMetadataChanged.metadata)
  if (!_internal_has_metadata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.metadata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantMetadataChanged::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantMetadataChanged.metadata)
}

// -------------------------------------------------------------------

// ParticipantAttributesChanged

// required string participant_identity = 1;
inline bool ParticipantAttributesChanged::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParticipantAttributesChanged::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ParticipantAttributesChanged::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantAttributesChanged::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantAttributesChanged.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantAttributesChanged::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantAttributesChanged.participant_identity)
}
inline std::string* ParticipantAttributesChanged::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantAttributesChanged.participant_identity)
  return _s;
}
inline const std::string& ParticipantAttributesChanged::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ParticipantAttributesChanged::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantAttributesChanged::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantAttributesChanged::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantAttributesChanged.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantAttributesChanged::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantAttributesChanged.participant_identity)
}

// repeated .livekit.proto.AttributesEntry attributes = 2;
inline int ParticipantAttributesChanged::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int ParticipantAttributesChanged::attributes_size() const {
  return _internal_attributes_size();
}
inline void ParticipantAttributesChanged::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantAttributesChanged.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
ParticipantAttributesChanged::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ParticipantAttributesChanged.attributes)
  return &_impl_.attributes_;
}
inline const ::livekit::proto::AttributesEntry& ParticipantAttributesChanged::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const ::livekit::proto::AttributesEntry& ParticipantAttributesChanged::attributes(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantAttributesChanged.attributes)
  return _internal_attributes(index);
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::add_attributes() {
  ::livekit::proto::AttributesEntry* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:livekit.proto.ParticipantAttributesChanged.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
ParticipantAttributesChanged::attributes() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ParticipantAttributesChanged.attributes)
  return _impl_.attributes_;
}

// repeated .livekit.proto.AttributesEntry changed_attributes = 3;
inline int ParticipantAttributesChanged::_internal_changed_attributes_size() const {
  return _impl_.changed_attributes_.size();
}
inline int ParticipantAttributesChanged::changed_attributes_size() const {
  return _internal_changed_attributes_size();
}
inline void ParticipantAttributesChanged::clear_changed_attributes() {
  _impl_.changed_attributes_.Clear();
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::mutable_changed_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantAttributesChanged.changed_attributes)
  return _impl_.changed_attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >*
ParticipantAttributesChanged::mutable_changed_attributes() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.ParticipantAttributesChanged.changed_attributes)
  return &_impl_.changed_attributes_;
}
inline const ::livekit::proto::AttributesEntry& ParticipantAttributesChanged::_internal_changed_attributes(int index) const {
  return _impl_.changed_attributes_.Get(index);
}
inline const ::livekit::proto::AttributesEntry& ParticipantAttributesChanged::changed_attributes(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantAttributesChanged.changed_attributes)
  return _internal_changed_attributes(index);
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::_internal_add_changed_attributes() {
  return _impl_.changed_attributes_.Add();
}
inline ::livekit::proto::AttributesEntry* ParticipantAttributesChanged::add_changed_attributes() {
  ::livekit::proto::AttributesEntry* _add = _internal_add_changed_attributes();
  // @@protoc_insertion_point(field_add:livekit.proto.ParticipantAttributesChanged.changed_attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::AttributesEntry >&
ParticipantAttributesChanged::changed_attributes() const {
  // @@protoc_insertion_point(field_list:livekit.proto.ParticipantAttributesChanged.changed_attributes)
  return _impl_.changed_attributes_;
}

// -------------------------------------------------------------------

// ParticipantNameChanged

// required string participant_identity = 1;
inline bool ParticipantNameChanged::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParticipantNameChanged::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ParticipantNameChanged::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParticipantNameChanged::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantNameChanged.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantNameChanged::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantNameChanged.participant_identity)
}
inline std::string* ParticipantNameChanged::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantNameChanged.participant_identity)
  return _s;
}
inline const std::string& ParticipantNameChanged::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ParticipantNameChanged::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantNameChanged::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantNameChanged::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantNameChanged.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantNameChanged::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantNameChanged.participant_identity)
}

// required string name = 2;
inline bool ParticipantNameChanged::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParticipantNameChanged::has_name() const {
  return _internal_has_name();
}
inline void ParticipantNameChanged::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ParticipantNameChanged::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ParticipantNameChanged.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParticipantNameChanged::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ParticipantNameChanged.name)
}
inline std::string* ParticipantNameChanged::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ParticipantNameChanged.name)
  return _s;
}
inline const std::string& ParticipantNameChanged::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ParticipantNameChanged::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ParticipantNameChanged::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ParticipantNameChanged::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.ParticipantNameChanged.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ParticipantNameChanged::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ParticipantNameChanged.name)
}

// -------------------------------------------------------------------

// ConnectionQualityChanged

// required string participant_identity = 1;
inline bool ConnectionQualityChanged::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionQualityChanged::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ConnectionQualityChanged::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectionQualityChanged::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectionQualityChanged.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConnectionQualityChanged::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectionQualityChanged.participant_identity)
}
inline std::string* ConnectionQualityChanged::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ConnectionQualityChanged.participant_identity)
  return _s;
}
inline const std::string& ConnectionQualityChanged::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ConnectionQualityChanged::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ConnectionQualityChanged::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ConnectionQualityChanged::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ConnectionQualityChanged.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConnectionQualityChanged::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ConnectionQualityChanged.participant_identity)
}

// required .livekit.proto.ConnectionQuality quality = 2;
inline bool ConnectionQualityChanged::_internal_has_quality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionQualityChanged::has_quality() const {
  return _internal_has_quality();
}
inline void ConnectionQualityChanged::clear_quality() {
  _impl_.quality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::ConnectionQuality ConnectionQualityChanged::_internal_quality() const {
  return static_cast< ::livekit::proto::ConnectionQuality >(_impl_.quality_);
}
inline ::livekit::proto::ConnectionQuality ConnectionQualityChanged::quality() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectionQualityChanged.quality)
  return _internal_quality();
}
inline void ConnectionQualityChanged::_internal_set_quality(::livekit::proto::ConnectionQuality value) {
  assert(::livekit::proto::ConnectionQuality_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.quality_ = value;
}
inline void ConnectionQualityChanged::set_quality(::livekit::proto::ConnectionQuality value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectionQualityChanged.quality)
}

// -------------------------------------------------------------------

// UserPacket

// required .livekit.proto.OwnedBuffer data = 1;
inline bool UserPacket::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline bool UserPacket::has_data() const {
  return _internal_has_data();
}
inline void UserPacket::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::OwnedBuffer& UserPacket::_internal_data() const {
  const ::livekit::proto::OwnedBuffer* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::OwnedBuffer&>(
      ::livekit::proto::_OwnedBuffer_default_instance_);
}
inline const ::livekit::proto::OwnedBuffer& UserPacket::data() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UserPacket.data)
  return _internal_data();
}
inline void UserPacket::unsafe_arena_set_allocated_data(
    ::livekit::proto::OwnedBuffer* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.UserPacket.data)
}
inline ::livekit::proto::OwnedBuffer* UserPacket::release_data() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedBuffer* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::OwnedBuffer* UserPacket::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:livekit.proto.UserPacket.data)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::OwnedBuffer* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::livekit::proto::OwnedBuffer* UserPacket::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::OwnedBuffer>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::livekit::proto::OwnedBuffer* UserPacket::mutable_data() {
  ::livekit::proto::OwnedBuffer* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:livekit.proto.UserPacket.data)
  return _msg;
}
inline void UserPacket::set_allocated_data(::livekit::proto::OwnedBuffer* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.UserPacket.data)
}

// optional string topic = 2;
inline bool UserPacket::_internal_has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserPacket::has_topic() const {
  return _internal_has_topic();
}
inline void UserPacket::clear_topic() {
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserPacket::topic() const {
  // @@protoc_insertion_point(field_get:livekit.proto.UserPacket.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPacket::set_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.UserPacket.topic)
}
inline std::string* UserPacket::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.proto.UserPacket.topic)
  return _s;
}
inline const std::string& UserPacket::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void UserPacket::_internal_set_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* UserPacket::_internal_mutable_topic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* UserPacket::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.proto.UserPacket.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserPacket::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.UserPacket.topic)
}

// -------------------------------------------------------------------

// ChatMessage

// required string id = 1;
inline bool ChatMessage::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatMessage::has_id() const {
  return _internal_has_id();
}
inline void ChatMessage::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatMessage::id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.id)
}
inline std::string* ChatMessage::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ChatMessage.id)
  return _s;
}
inline const std::string& ChatMessage::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ChatMessage::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.ChatMessage.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ChatMessage.id)
}

// required int64 timestamp = 2;
inline bool ChatMessage::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChatMessage::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ChatMessage::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ChatMessage::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t ChatMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.timestamp)
  return _internal_timestamp();
}
inline void ChatMessage::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ = value;
}
inline void ChatMessage::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.timestamp)
}

// required string message = 3;
inline bool ChatMessage::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChatMessage::has_message() const {
  return _internal_has_message();
}
inline void ChatMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChatMessage::message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.message)
}
inline std::string* ChatMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ChatMessage.message)
  return _s;
}
inline const std::string& ChatMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatMessage::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.ChatMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ChatMessage.message)
}

// optional int64 edit_timestamp = 4;
inline bool ChatMessage::_internal_has_edit_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChatMessage::has_edit_timestamp() const {
  return _internal_has_edit_timestamp();
}
inline void ChatMessage::clear_edit_timestamp() {
  _impl_.edit_timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t ChatMessage::_internal_edit_timestamp() const {
  return _impl_.edit_timestamp_;
}
inline int64_t ChatMessage::edit_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.edit_timestamp)
  return _internal_edit_timestamp();
}
inline void ChatMessage::_internal_set_edit_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.edit_timestamp_ = value;
}
inline void ChatMessage::set_edit_timestamp(int64_t value) {
  _internal_set_edit_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.edit_timestamp)
}

// optional bool deleted = 5;
inline bool ChatMessage::_internal_has_deleted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChatMessage::has_deleted() const {
  return _internal_has_deleted();
}
inline void ChatMessage::clear_deleted() {
  _impl_.deleted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ChatMessage::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool ChatMessage::deleted() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.deleted)
  return _internal_deleted();
}
inline void ChatMessage::_internal_set_deleted(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.deleted_ = value;
}
inline void ChatMessage::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.deleted)
}

// optional bool generated = 6;
inline bool ChatMessage::_internal_has_generated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChatMessage::has_generated() const {
  return _internal_has_generated();
}
inline void ChatMessage::clear_generated() {
  _impl_.generated_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ChatMessage::_internal_generated() const {
  return _impl_.generated_;
}
inline bool ChatMessage::generated() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessage.generated)
  return _internal_generated();
}
inline void ChatMessage::_internal_set_generated(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.generated_ = value;
}
inline void ChatMessage::set_generated(bool value) {
  _internal_set_generated(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessage.generated)
}

// -------------------------------------------------------------------

// ChatMessageReceived

// required .livekit.proto.ChatMessage message = 1;
inline bool ChatMessageReceived::_internal_has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.message_ != nullptr);
  return value;
}
inline bool ChatMessageReceived::has_message() const {
  return _internal_has_message();
}
inline void ChatMessageReceived::clear_message() {
  if (_impl_.message_ != nullptr) _impl_.message_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::ChatMessage& ChatMessageReceived::_internal_message() const {
  const ::livekit::proto::ChatMessage* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::ChatMessage&>(
      ::livekit::proto::_ChatMessage_default_instance_);
}
inline const ::livekit::proto::ChatMessage& ChatMessageReceived::message() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessageReceived.message)
  return _internal_message();
}
inline void ChatMessageReceived::unsafe_arena_set_allocated_message(
    ::livekit::proto::ChatMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.ChatMessageReceived.message)
}
inline ::livekit::proto::ChatMessage* ChatMessageReceived::release_message() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::ChatMessage* ChatMessageReceived::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:livekit.proto.ChatMessageReceived.message)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::ChatMessage* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::livekit::proto::ChatMessage* ChatMessageReceived::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::ChatMessage>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::livekit::proto::ChatMessage* ChatMessageReceived::mutable_message() {
  ::livekit::proto::ChatMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ChatMessageReceived.message)
  return _msg;
}
inline void ChatMessageReceived::set_allocated_message(::livekit::proto::ChatMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ChatMessageReceived.message)
}

// required string participant_identity = 2;
inline bool ChatMessageReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChatMessageReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void ChatMessageReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatMessageReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ChatMessageReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessageReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.ChatMessageReceived.participant_identity)
}
inline std::string* ChatMessageReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.ChatMessageReceived.participant_identity)
  return _s;
}
inline const std::string& ChatMessageReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void ChatMessageReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessageReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessageReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.ChatMessageReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChatMessageReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.ChatMessageReceived.participant_identity)
}

// -------------------------------------------------------------------

// SipDTMF

// required uint32 code = 1;
inline bool SipDTMF::_internal_has_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SipDTMF::has_code() const {
  return _internal_has_code();
}
inline void SipDTMF::clear_code() {
  _impl_.code_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SipDTMF::_internal_code() const {
  return _impl_.code_;
}
inline uint32_t SipDTMF::code() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SipDTMF.code)
  return _internal_code();
}
inline void SipDTMF::_internal_set_code(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.code_ = value;
}
inline void SipDTMF::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SipDTMF.code)
}

// optional string digit = 2;
inline bool SipDTMF::_internal_has_digit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SipDTMF::has_digit() const {
  return _internal_has_digit();
}
inline void SipDTMF::clear_digit() {
  _impl_.digit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SipDTMF::digit() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SipDTMF.digit)
  return _internal_digit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipDTMF::set_digit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.digit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SipDTMF.digit)
}
inline std::string* SipDTMF::mutable_digit() {
  std::string* _s = _internal_mutable_digit();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SipDTMF.digit)
  return _s;
}
inline const std::string& SipDTMF::_internal_digit() const {
  return _impl_.digit_.Get();
}
inline void SipDTMF::_internal_set_digit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.digit_.Set(value, GetArenaForAllocation());
}
inline std::string* SipDTMF::_internal_mutable_digit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.digit_.Mutable(GetArenaForAllocation());
}
inline std::string* SipDTMF::release_digit() {
  // @@protoc_insertion_point(field_release:livekit.proto.SipDTMF.digit)
  if (!_internal_has_digit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.digit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digit_.IsDefault()) {
    _impl_.digit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SipDTMF::set_allocated_digit(std::string* digit) {
  if (digit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.digit_.SetAllocated(digit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.digit_.IsDefault()) {
    _impl_.digit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SipDTMF.digit)
}

// -------------------------------------------------------------------

// DataPacketReceived

// required .livekit.proto.DataPacketKind kind = 1;
inline bool DataPacketReceived::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataPacketReceived::has_kind() const {
  return _internal_has_kind();
}
inline void DataPacketReceived::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::DataPacketKind DataPacketReceived::_internal_kind() const {
  return static_cast< ::livekit::proto::DataPacketKind >(_impl_.kind_);
}
inline ::livekit::proto::DataPacketKind DataPacketReceived::kind() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataPacketReceived.kind)
  return _internal_kind();
}
inline void DataPacketReceived::_internal_set_kind(::livekit::proto::DataPacketKind value) {
  assert(::livekit::proto::DataPacketKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_ = value;
}
inline void DataPacketReceived::set_kind(::livekit::proto::DataPacketKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataPacketReceived.kind)
}

// required string participant_identity = 2;
inline bool DataPacketReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataPacketReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void DataPacketReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataPacketReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataPacketReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataPacketReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataPacketReceived.participant_identity)
}
inline std::string* DataPacketReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataPacketReceived.participant_identity)
  return _s;
}
inline const std::string& DataPacketReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void DataPacketReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* DataPacketReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* DataPacketReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataPacketReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataPacketReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataPacketReceived.participant_identity)
}

// .livekit.proto.UserPacket user = 4;
inline bool DataPacketReceived::_internal_has_user() const {
  return value_case() == kUser;
}
inline bool DataPacketReceived::has_user() const {
  return _internal_has_user();
}
inline void DataPacketReceived::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void DataPacketReceived::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.user_;
    }
    clear_has_value();
  }
}
inline ::livekit::proto::UserPacket* DataPacketReceived::release_user() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataPacketReceived.user)
  if (_internal_has_user()) {
    clear_has_value();
    ::livekit::proto::UserPacket* temp = _impl_.value_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::UserPacket& DataPacketReceived::_internal_user() const {
  return _internal_has_user()
      ? *_impl_.value_.user_
      : reinterpret_cast< ::livekit::proto::UserPacket&>(::livekit::proto::_UserPacket_default_instance_);
}
inline const ::livekit::proto::UserPacket& DataPacketReceived::user() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataPacketReceived.user)
  return _internal_user();
}
inline ::livekit::proto::UserPacket* DataPacketReceived::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.DataPacketReceived.user)
  if (_internal_has_user()) {
    clear_has_value();
    ::livekit::proto::UserPacket* temp = _impl_.value_.user_;
    _impl_.value_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacketReceived::unsafe_arena_set_allocated_user(::livekit::proto::UserPacket* user) {
  clear_value();
  if (user) {
    set_has_user();
    _impl_.value_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataPacketReceived.user)
}
inline ::livekit::proto::UserPacket* DataPacketReceived::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_value();
    set_has_user();
    _impl_.value_.user_ = CreateMaybeMessage< ::livekit::proto::UserPacket >(GetArenaForAllocation());
  }
  return _impl_.value_.user_;
}
inline ::livekit::proto::UserPacket* DataPacketReceived::mutable_user() {
  ::livekit::proto::UserPacket* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataPacketReceived.user)
  return _msg;
}

// .livekit.proto.SipDTMF sip_dtmf = 5;
inline bool DataPacketReceived::_internal_has_sip_dtmf() const {
  return value_case() == kSipDtmf;
}
inline bool DataPacketReceived::has_sip_dtmf() const {
  return _internal_has_sip_dtmf();
}
inline void DataPacketReceived::set_has_sip_dtmf() {
  _impl_._oneof_case_[0] = kSipDtmf;
}
inline void DataPacketReceived::clear_sip_dtmf() {
  if (_internal_has_sip_dtmf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sip_dtmf_;
    }
    clear_has_value();
  }
}
inline ::livekit::proto::SipDTMF* DataPacketReceived::release_sip_dtmf() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataPacketReceived.sip_dtmf)
  if (_internal_has_sip_dtmf()) {
    clear_has_value();
    ::livekit::proto::SipDTMF* temp = _impl_.value_.sip_dtmf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sip_dtmf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::SipDTMF& DataPacketReceived::_internal_sip_dtmf() const {
  return _internal_has_sip_dtmf()
      ? *_impl_.value_.sip_dtmf_
      : reinterpret_cast< ::livekit::proto::SipDTMF&>(::livekit::proto::_SipDTMF_default_instance_);
}
inline const ::livekit::proto::SipDTMF& DataPacketReceived::sip_dtmf() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataPacketReceived.sip_dtmf)
  return _internal_sip_dtmf();
}
inline ::livekit::proto::SipDTMF* DataPacketReceived::unsafe_arena_release_sip_dtmf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.DataPacketReceived.sip_dtmf)
  if (_internal_has_sip_dtmf()) {
    clear_has_value();
    ::livekit::proto::SipDTMF* temp = _impl_.value_.sip_dtmf_;
    _impl_.value_.sip_dtmf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataPacketReceived::unsafe_arena_set_allocated_sip_dtmf(::livekit::proto::SipDTMF* sip_dtmf) {
  clear_value();
  if (sip_dtmf) {
    set_has_sip_dtmf();
    _impl_.value_.sip_dtmf_ = sip_dtmf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataPacketReceived.sip_dtmf)
}
inline ::livekit::proto::SipDTMF* DataPacketReceived::_internal_mutable_sip_dtmf() {
  if (!_internal_has_sip_dtmf()) {
    clear_value();
    set_has_sip_dtmf();
    _impl_.value_.sip_dtmf_ = CreateMaybeMessage< ::livekit::proto::SipDTMF >(GetArenaForAllocation());
  }
  return _impl_.value_.sip_dtmf_;
}
inline ::livekit::proto::SipDTMF* DataPacketReceived::mutable_sip_dtmf() {
  ::livekit::proto::SipDTMF* _msg = _internal_mutable_sip_dtmf();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataPacketReceived.sip_dtmf)
  return _msg;
}

inline bool DataPacketReceived::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void DataPacketReceived::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline DataPacketReceived::ValueCase DataPacketReceived::value_case() const {
  return DataPacketReceived::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TranscriptionReceived

// optional string participant_identity = 1;
inline bool TranscriptionReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TranscriptionReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void TranscriptionReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranscriptionReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionReceived.participant_identity)
}
inline std::string* TranscriptionReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionReceived.participant_identity)
  return _s;
}
inline const std::string& TranscriptionReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void TranscriptionReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.TranscriptionReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranscriptionReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TranscriptionReceived.participant_identity)
}

// optional string track_sid = 2;
inline bool TranscriptionReceived::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TranscriptionReceived::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void TranscriptionReceived::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranscriptionReceived::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionReceived.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TranscriptionReceived::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.TranscriptionReceived.track_sid)
}
inline std::string* TranscriptionReceived::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionReceived.track_sid)
  return _s;
}
inline const std::string& TranscriptionReceived::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void TranscriptionReceived::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* TranscriptionReceived::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* TranscriptionReceived::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.TranscriptionReceived.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TranscriptionReceived::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.TranscriptionReceived.track_sid)
}

// repeated .livekit.proto.TranscriptionSegment segments = 3;
inline int TranscriptionReceived::_internal_segments_size() const {
  return _impl_.segments_.size();
}
inline int TranscriptionReceived::segments_size() const {
  return _internal_segments_size();
}
inline void TranscriptionReceived::clear_segments() {
  _impl_.segments_.Clear();
}
inline ::livekit::proto::TranscriptionSegment* TranscriptionReceived::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.TranscriptionReceived.segments)
  return _impl_.segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >*
TranscriptionReceived::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.TranscriptionReceived.segments)
  return &_impl_.segments_;
}
inline const ::livekit::proto::TranscriptionSegment& TranscriptionReceived::_internal_segments(int index) const {
  return _impl_.segments_.Get(index);
}
inline const ::livekit::proto::TranscriptionSegment& TranscriptionReceived::segments(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.TranscriptionReceived.segments)
  return _internal_segments(index);
}
inline ::livekit::proto::TranscriptionSegment* TranscriptionReceived::_internal_add_segments() {
  return _impl_.segments_.Add();
}
inline ::livekit::proto::TranscriptionSegment* TranscriptionReceived::add_segments() {
  ::livekit::proto::TranscriptionSegment* _add = _internal_add_segments();
  // @@protoc_insertion_point(field_add:livekit.proto.TranscriptionReceived.segments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::TranscriptionSegment >&
TranscriptionReceived::segments() const {
  // @@protoc_insertion_point(field_list:livekit.proto.TranscriptionReceived.segments)
  return _impl_.segments_;
}

// -------------------------------------------------------------------

// ConnectionStateChanged

// required .livekit.proto.ConnectionState state = 1;
inline bool ConnectionStateChanged::_internal_has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectionStateChanged::has_state() const {
  return _internal_has_state();
}
inline void ConnectionStateChanged::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::ConnectionState ConnectionStateChanged::_internal_state() const {
  return static_cast< ::livekit::proto::ConnectionState >(_impl_.state_);
}
inline ::livekit::proto::ConnectionState ConnectionStateChanged::state() const {
  // @@protoc_insertion_point(field_get:livekit.proto.ConnectionStateChanged.state)
  return _internal_state();
}
inline void ConnectionStateChanged::_internal_set_state(::livekit::proto::ConnectionState value) {
  assert(::livekit::proto::ConnectionState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.state_ = value;
}
inline void ConnectionStateChanged::set_state(::livekit::proto::ConnectionState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:livekit.proto.ConnectionStateChanged.state)
}

// -------------------------------------------------------------------

// Connected

// -------------------------------------------------------------------

// Disconnected

// required .livekit.proto.DisconnectReason reason = 1;
inline bool Disconnected::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Disconnected::has_reason() const {
  return _internal_has_reason();
}
inline void Disconnected::clear_reason() {
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::proto::DisconnectReason Disconnected::_internal_reason() const {
  return static_cast< ::livekit::proto::DisconnectReason >(_impl_.reason_);
}
inline ::livekit::proto::DisconnectReason Disconnected::reason() const {
  // @@protoc_insertion_point(field_get:livekit.proto.Disconnected.reason)
  return _internal_reason();
}
inline void Disconnected::_internal_set_reason(::livekit::proto::DisconnectReason value) {
  assert(::livekit::proto::DisconnectReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_ = value;
}
inline void Disconnected::set_reason(::livekit::proto::DisconnectReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:livekit.proto.Disconnected.reason)
}

// -------------------------------------------------------------------

// Reconnecting

// -------------------------------------------------------------------

// Reconnected

// -------------------------------------------------------------------

// RoomEOS

// -------------------------------------------------------------------

// DataStream_TextHeader

// required .livekit.proto.DataStream.OperationType operation_type = 1;
inline bool DataStream_TextHeader::_internal_has_operation_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataStream_TextHeader::has_operation_type() const {
  return _internal_has_operation_type();
}
inline void DataStream_TextHeader::clear_operation_type() {
  _impl_.operation_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::DataStream_OperationType DataStream_TextHeader::_internal_operation_type() const {
  return static_cast< ::livekit::proto::DataStream_OperationType >(_impl_.operation_type_);
}
inline ::livekit::proto::DataStream_OperationType DataStream_TextHeader::operation_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.TextHeader.operation_type)
  return _internal_operation_type();
}
inline void DataStream_TextHeader::_internal_set_operation_type(::livekit::proto::DataStream_OperationType value) {
  assert(::livekit::proto::DataStream_OperationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operation_type_ = value;
}
inline void DataStream_TextHeader::set_operation_type(::livekit::proto::DataStream_OperationType value) {
  _internal_set_operation_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.operation_type)
}

// optional int32 version = 2;
inline bool DataStream_TextHeader::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataStream_TextHeader::has_version() const {
  return _internal_has_version();
}
inline void DataStream_TextHeader::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DataStream_TextHeader::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DataStream_TextHeader::version() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.TextHeader.version)
  return _internal_version();
}
inline void DataStream_TextHeader::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_ = value;
}
inline void DataStream_TextHeader::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.version)
}

// optional string reply_to_stream_id = 3;
inline bool DataStream_TextHeader::_internal_has_reply_to_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_TextHeader::has_reply_to_stream_id() const {
  return _internal_has_reply_to_stream_id();
}
inline void DataStream_TextHeader::clear_reply_to_stream_id() {
  _impl_.reply_to_stream_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_TextHeader::reply_to_stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.TextHeader.reply_to_stream_id)
  return _internal_reply_to_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_TextHeader::set_reply_to_stream_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.reply_to_stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.reply_to_stream_id)
}
inline std::string* DataStream_TextHeader::mutable_reply_to_stream_id() {
  std::string* _s = _internal_mutable_reply_to_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.TextHeader.reply_to_stream_id)
  return _s;
}
inline const std::string& DataStream_TextHeader::_internal_reply_to_stream_id() const {
  return _impl_.reply_to_stream_id_.Get();
}
inline void DataStream_TextHeader::_internal_set_reply_to_stream_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reply_to_stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_TextHeader::_internal_mutable_reply_to_stream_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.reply_to_stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_TextHeader::release_reply_to_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.TextHeader.reply_to_stream_id)
  if (!_internal_has_reply_to_stream_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.reply_to_stream_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_stream_id_.IsDefault()) {
    _impl_.reply_to_stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_TextHeader::set_allocated_reply_to_stream_id(std::string* reply_to_stream_id) {
  if (reply_to_stream_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.reply_to_stream_id_.SetAllocated(reply_to_stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_to_stream_id_.IsDefault()) {
    _impl_.reply_to_stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.TextHeader.reply_to_stream_id)
}

// repeated string attached_stream_ids = 4;
inline int DataStream_TextHeader::_internal_attached_stream_ids_size() const {
  return _impl_.attached_stream_ids_.size();
}
inline int DataStream_TextHeader::attached_stream_ids_size() const {
  return _internal_attached_stream_ids_size();
}
inline void DataStream_TextHeader::clear_attached_stream_ids() {
  _impl_.attached_stream_ids_.Clear();
}
inline std::string* DataStream_TextHeader::add_attached_stream_ids() {
  std::string* _s = _internal_add_attached_stream_ids();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.DataStream.TextHeader.attached_stream_ids)
  return _s;
}
inline const std::string& DataStream_TextHeader::_internal_attached_stream_ids(int index) const {
  return _impl_.attached_stream_ids_.Get(index);
}
inline const std::string& DataStream_TextHeader::attached_stream_ids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.TextHeader.attached_stream_ids)
  return _internal_attached_stream_ids(index);
}
inline std::string* DataStream_TextHeader::mutable_attached_stream_ids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.TextHeader.attached_stream_ids)
  return _impl_.attached_stream_ids_.Mutable(index);
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const std::string& value) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, std::string&& value) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attached_stream_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::set_attached_stream_ids(int index, const char* value, size_t size) {
  _impl_.attached_stream_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline std::string* DataStream_TextHeader::_internal_add_attached_stream_ids() {
  return _impl_.attached_stream_ids_.Add();
}
inline void DataStream_TextHeader::add_attached_stream_ids(const std::string& value) {
  _impl_.attached_stream_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(std::string&& value) {
  _impl_.attached_stream_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.attached_stream_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline void DataStream_TextHeader::add_attached_stream_ids(const char* value, size_t size) {
  _impl_.attached_stream_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.DataStream.TextHeader.attached_stream_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataStream_TextHeader::attached_stream_ids() const {
  // @@protoc_insertion_point(field_list:livekit.proto.DataStream.TextHeader.attached_stream_ids)
  return _impl_.attached_stream_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataStream_TextHeader::mutable_attached_stream_ids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.DataStream.TextHeader.attached_stream_ids)
  return &_impl_.attached_stream_ids_;
}

// optional bool generated = 5;
inline bool DataStream_TextHeader::_internal_has_generated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataStream_TextHeader::has_generated() const {
  return _internal_has_generated();
}
inline void DataStream_TextHeader::clear_generated() {
  _impl_.generated_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DataStream_TextHeader::_internal_generated() const {
  return _impl_.generated_;
}
inline bool DataStream_TextHeader::generated() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.TextHeader.generated)
  return _internal_generated();
}
inline void DataStream_TextHeader::_internal_set_generated(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.generated_ = value;
}
inline void DataStream_TextHeader::set_generated(bool value) {
  _internal_set_generated(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.TextHeader.generated)
}

// -------------------------------------------------------------------

// DataStream_ByteHeader

// required string name = 1;
inline bool DataStream_ByteHeader::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_ByteHeader::has_name() const {
  return _internal_has_name();
}
inline void DataStream_ByteHeader::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_ByteHeader::name() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.ByteHeader.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_ByteHeader::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.ByteHeader.name)
}
inline std::string* DataStream_ByteHeader::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.ByteHeader.name)
  return _s;
}
inline const std::string& DataStream_ByteHeader::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DataStream_ByteHeader::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_ByteHeader::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_ByteHeader::release_name() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.ByteHeader.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_ByteHeader::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.ByteHeader.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataStream_Header

// required string stream_id = 1;
inline bool DataStream_Header::_internal_has_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_Header::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void DataStream_Header::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_Header::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_stream_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Header.stream_id)
}
inline std::string* DataStream_Header::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Header.stream_id)
  return _s;
}
inline const std::string& DataStream_Header::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Header::_internal_set_stream_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_stream_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Header.stream_id)
  if (!_internal_has_stream_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Header::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Header.stream_id)
}

// required int64 timestamp = 2;
inline bool DataStream_Header::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataStream_Header::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void DataStream_Header::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t DataStream_Header::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t DataStream_Header::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.timestamp)
  return _internal_timestamp();
}
inline void DataStream_Header::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ = value;
}
inline void DataStream_Header::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Header.timestamp)
}

// required string mime_type = 3;
inline bool DataStream_Header::_internal_has_mime_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataStream_Header::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void DataStream_Header::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataStream_Header::mime_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Header.mime_type)
}
inline std::string* DataStream_Header::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Header.mime_type)
  return _s;
}
inline const std::string& DataStream_Header::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void DataStream_Header::_internal_set_mime_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_mime_type() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_mime_type() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Header.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Header::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Header.mime_type)
}

// required string topic = 4;
inline bool DataStream_Header::_internal_has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataStream_Header::has_topic() const {
  return _internal_has_topic();
}
inline void DataStream_Header::clear_topic() {
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataStream_Header::topic() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Header::set_topic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Header.topic)
}
inline std::string* DataStream_Header::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Header.topic)
  return _s;
}
inline const std::string& DataStream_Header::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void DataStream_Header::_internal_set_topic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Header::_internal_mutable_topic() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Header::release_topic() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Header.topic)
  if (!_internal_has_topic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.topic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Header::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Header.topic)
}

// optional uint64 total_length = 5;
inline bool DataStream_Header::_internal_has_total_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataStream_Header::has_total_length() const {
  return _internal_has_total_length();
}
inline void DataStream_Header::clear_total_length() {
  _impl_.total_length_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t DataStream_Header::_internal_total_length() const {
  return _impl_.total_length_;
}
inline uint64_t DataStream_Header::total_length() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.total_length)
  return _internal_total_length();
}
inline void DataStream_Header::_internal_set_total_length(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.total_length_ = value;
}
inline void DataStream_Header::set_total_length(uint64_t value) {
  _internal_set_total_length(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Header.total_length)
}

// map<string, string> attributes = 6;
inline int DataStream_Header::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int DataStream_Header::attributes_size() const {
  return _internal_attributes_size();
}
inline void DataStream_Header::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Header::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Header::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.proto.DataStream.Header.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Header::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Header::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.proto.DataStream.Header.attributes)
  return _internal_mutable_attributes();
}

// .livekit.proto.DataStream.TextHeader text_header = 7;
inline bool DataStream_Header::_internal_has_text_header() const {
  return content_header_case() == kTextHeader;
}
inline bool DataStream_Header::has_text_header() const {
  return _internal_has_text_header();
}
inline void DataStream_Header::set_has_text_header() {
  _impl_._oneof_case_[0] = kTextHeader;
}
inline void DataStream_Header::clear_text_header() {
  if (_internal_has_text_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_header_.text_header_;
    }
    clear_has_content_header();
  }
}
inline ::livekit::proto::DataStream_TextHeader* DataStream_Header::release_text_header() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Header.text_header)
  if (_internal_has_text_header()) {
    clear_has_content_header();
    ::livekit::proto::DataStream_TextHeader* temp = _impl_.content_header_.text_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_header_.text_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataStream_TextHeader& DataStream_Header::_internal_text_header() const {
  return _internal_has_text_header()
      ? *_impl_.content_header_.text_header_
      : reinterpret_cast< ::livekit::proto::DataStream_TextHeader&>(::livekit::proto::_DataStream_TextHeader_default_instance_);
}
inline const ::livekit::proto::DataStream_TextHeader& DataStream_Header::text_header() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.text_header)
  return _internal_text_header();
}
inline ::livekit::proto::DataStream_TextHeader* DataStream_Header::unsafe_arena_release_text_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.DataStream.Header.text_header)
  if (_internal_has_text_header()) {
    clear_has_content_header();
    ::livekit::proto::DataStream_TextHeader* temp = _impl_.content_header_.text_header_;
    _impl_.content_header_.text_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataStream_Header::unsafe_arena_set_allocated_text_header(::livekit::proto::DataStream_TextHeader* text_header) {
  clear_content_header();
  if (text_header) {
    set_has_text_header();
    _impl_.content_header_.text_header_ = text_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataStream.Header.text_header)
}
inline ::livekit::proto::DataStream_TextHeader* DataStream_Header::_internal_mutable_text_header() {
  if (!_internal_has_text_header()) {
    clear_content_header();
    set_has_text_header();
    _impl_.content_header_.text_header_ = CreateMaybeMessage< ::livekit::proto::DataStream_TextHeader >(GetArenaForAllocation());
  }
  return _impl_.content_header_.text_header_;
}
inline ::livekit::proto::DataStream_TextHeader* DataStream_Header::mutable_text_header() {
  ::livekit::proto::DataStream_TextHeader* _msg = _internal_mutable_text_header();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Header.text_header)
  return _msg;
}

// .livekit.proto.DataStream.ByteHeader byte_header = 8;
inline bool DataStream_Header::_internal_has_byte_header() const {
  return content_header_case() == kByteHeader;
}
inline bool DataStream_Header::has_byte_header() const {
  return _internal_has_byte_header();
}
inline void DataStream_Header::set_has_byte_header() {
  _impl_._oneof_case_[0] = kByteHeader;
}
inline void DataStream_Header::clear_byte_header() {
  if (_internal_has_byte_header()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_header_.byte_header_;
    }
    clear_has_content_header();
  }
}
inline ::livekit::proto::DataStream_ByteHeader* DataStream_Header::release_byte_header() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Header.byte_header)
  if (_internal_has_byte_header()) {
    clear_has_content_header();
    ::livekit::proto::DataStream_ByteHeader* temp = _impl_.content_header_.byte_header_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_header_.byte_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::DataStream_ByteHeader& DataStream_Header::_internal_byte_header() const {
  return _internal_has_byte_header()
      ? *_impl_.content_header_.byte_header_
      : reinterpret_cast< ::livekit::proto::DataStream_ByteHeader&>(::livekit::proto::_DataStream_ByteHeader_default_instance_);
}
inline const ::livekit::proto::DataStream_ByteHeader& DataStream_Header::byte_header() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Header.byte_header)
  return _internal_byte_header();
}
inline ::livekit::proto::DataStream_ByteHeader* DataStream_Header::unsafe_arena_release_byte_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.DataStream.Header.byte_header)
  if (_internal_has_byte_header()) {
    clear_has_content_header();
    ::livekit::proto::DataStream_ByteHeader* temp = _impl_.content_header_.byte_header_;
    _impl_.content_header_.byte_header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataStream_Header::unsafe_arena_set_allocated_byte_header(::livekit::proto::DataStream_ByteHeader* byte_header) {
  clear_content_header();
  if (byte_header) {
    set_has_byte_header();
    _impl_.content_header_.byte_header_ = byte_header;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataStream.Header.byte_header)
}
inline ::livekit::proto::DataStream_ByteHeader* DataStream_Header::_internal_mutable_byte_header() {
  if (!_internal_has_byte_header()) {
    clear_content_header();
    set_has_byte_header();
    _impl_.content_header_.byte_header_ = CreateMaybeMessage< ::livekit::proto::DataStream_ByteHeader >(GetArenaForAllocation());
  }
  return _impl_.content_header_.byte_header_;
}
inline ::livekit::proto::DataStream_ByteHeader* DataStream_Header::mutable_byte_header() {
  ::livekit::proto::DataStream_ByteHeader* _msg = _internal_mutable_byte_header();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Header.byte_header)
  return _msg;
}

inline bool DataStream_Header::has_content_header() const {
  return content_header_case() != CONTENT_HEADER_NOT_SET;
}
inline void DataStream_Header::clear_has_content_header() {
  _impl_._oneof_case_[0] = CONTENT_HEADER_NOT_SET;
}
inline DataStream_Header::ContentHeaderCase DataStream_Header::content_header_case() const {
  return DataStream_Header::ContentHeaderCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataStream_Chunk

// required string stream_id = 1;
inline bool DataStream_Chunk::_internal_has_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void DataStream_Chunk::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_Chunk::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Chunk.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_stream_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Chunk.stream_id)
}
inline std::string* DataStream_Chunk::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Chunk.stream_id)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Chunk::_internal_set_stream_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_stream_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Chunk.stream_id)
  if (!_internal_has_stream_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Chunk::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Chunk.stream_id)
}

// required uint64 chunk_index = 2;
inline bool DataStream_Chunk::_internal_has_chunk_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_chunk_index() const {
  return _internal_has_chunk_index();
}
inline void DataStream_Chunk::clear_chunk_index() {
  _impl_.chunk_index_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t DataStream_Chunk::_internal_chunk_index() const {
  return _impl_.chunk_index_;
}
inline uint64_t DataStream_Chunk::chunk_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Chunk.chunk_index)
  return _internal_chunk_index();
}
inline void DataStream_Chunk::_internal_set_chunk_index(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.chunk_index_ = value;
}
inline void DataStream_Chunk::set_chunk_index(uint64_t value) {
  _internal_set_chunk_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Chunk.chunk_index)
}

// required bytes content = 3;
inline bool DataStream_Chunk::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_content() const {
  return _internal_has_content();
}
inline void DataStream_Chunk::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataStream_Chunk::content() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Chunk.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Chunk.content)
}
inline std::string* DataStream_Chunk::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Chunk.content)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_content() const {
  return _impl_.content_.Get();
}
inline void DataStream_Chunk::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_content() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Chunk.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Chunk::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Chunk.content)
}

// optional int32 version = 4;
inline bool DataStream_Chunk::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_version() const {
  return _internal_has_version();
}
inline void DataStream_Chunk::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t DataStream_Chunk::_internal_version() const {
  return _impl_.version_;
}
inline int32_t DataStream_Chunk::version() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Chunk.version)
  return _internal_version();
}
inline void DataStream_Chunk::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.version_ = value;
}
inline void DataStream_Chunk::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Chunk.version)
}

// optional bytes iv = 5;
inline bool DataStream_Chunk::_internal_has_iv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataStream_Chunk::has_iv() const {
  return _internal_has_iv();
}
inline void DataStream_Chunk::clear_iv() {
  _impl_.iv_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataStream_Chunk::iv() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Chunk.iv)
  return _internal_iv();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Chunk::set_iv(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.iv_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Chunk.iv)
}
inline std::string* DataStream_Chunk::mutable_iv() {
  std::string* _s = _internal_mutable_iv();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Chunk.iv)
  return _s;
}
inline const std::string& DataStream_Chunk::_internal_iv() const {
  return _impl_.iv_.Get();
}
inline void DataStream_Chunk::_internal_set_iv(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.iv_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::_internal_mutable_iv() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.iv_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Chunk::release_iv() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Chunk.iv)
  if (!_internal_has_iv()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.iv_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Chunk::set_allocated_iv(std::string* iv) {
  if (iv != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.iv_.SetAllocated(iv, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iv_.IsDefault()) {
    _impl_.iv_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Chunk.iv)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataStream_Trailer

// required string stream_id = 1;
inline bool DataStream_Trailer::_internal_has_stream_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStream_Trailer::has_stream_id() const {
  return _internal_has_stream_id();
}
inline void DataStream_Trailer::clear_stream_id() {
  _impl_.stream_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStream_Trailer::stream_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Trailer.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Trailer::set_stream_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Trailer.stream_id)
}
inline std::string* DataStream_Trailer::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Trailer.stream_id)
  return _s;
}
inline const std::string& DataStream_Trailer::_internal_stream_id() const {
  return _impl_.stream_id_.Get();
}
inline void DataStream_Trailer::_internal_set_stream_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::_internal_mutable_stream_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::release_stream_id() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Trailer.stream_id)
  if (!_internal_has_stream_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stream_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Trailer::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stream_id_.IsDefault()) {
    _impl_.stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Trailer.stream_id)
}

// required string reason = 2;
inline bool DataStream_Trailer::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataStream_Trailer::has_reason() const {
  return _internal_has_reason();
}
inline void DataStream_Trailer::clear_reason() {
  _impl_.reason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataStream_Trailer::reason() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStream.Trailer.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStream_Trailer::set_reason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.reason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStream.Trailer.reason)
}
inline std::string* DataStream_Trailer::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStream.Trailer.reason)
  return _s;
}
inline const std::string& DataStream_Trailer::_internal_reason() const {
  return _impl_.reason_.Get();
}
inline void DataStream_Trailer::_internal_set_reason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.reason_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::_internal_mutable_reason() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.reason_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStream_Trailer::release_reason() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStream.Trailer.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStream_Trailer::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reason_.SetAllocated(reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStream.Trailer.reason)
}

// map<string, string> attributes = 3;
inline int DataStream_Trailer::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int DataStream_Trailer::attributes_size() const {
  return _internal_attributes_size();
}
inline void DataStream_Trailer::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Trailer::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DataStream_Trailer::attributes() const {
  // @@protoc_insertion_point(field_map:livekit.proto.DataStream.Trailer.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Trailer::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DataStream_Trailer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.proto.DataStream.Trailer.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// DataStream

// -------------------------------------------------------------------

// DataStreamHeaderReceived

// required string participant_identity = 1;
inline bool DataStreamHeaderReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStreamHeaderReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void DataStreamHeaderReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStreamHeaderReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamHeaderReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStreamHeaderReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStreamHeaderReceived.participant_identity)
}
inline std::string* DataStreamHeaderReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamHeaderReceived.participant_identity)
  return _s;
}
inline const std::string& DataStreamHeaderReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void DataStreamHeaderReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStreamHeaderReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStreamHeaderReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamHeaderReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStreamHeaderReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamHeaderReceived.participant_identity)
}

// required .livekit.proto.DataStream.Header header = 2;
inline bool DataStreamHeaderReceived::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool DataStreamHeaderReceived::has_header() const {
  return _internal_has_header();
}
inline void DataStreamHeaderReceived::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Header& DataStreamHeaderReceived::_internal_header() const {
  const ::livekit::proto::DataStream_Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Header&>(
      ::livekit::proto::_DataStream_Header_default_instance_);
}
inline const ::livekit::proto::DataStream_Header& DataStreamHeaderReceived::header() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamHeaderReceived.header)
  return _internal_header();
}
inline void DataStreamHeaderReceived::unsafe_arena_set_allocated_header(
    ::livekit::proto::DataStream_Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataStreamHeaderReceived.header)
}
inline ::livekit::proto::DataStream_Header* DataStreamHeaderReceived::release_header() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Header* DataStreamHeaderReceived::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamHeaderReceived.header)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Header* DataStreamHeaderReceived::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::livekit::proto::DataStream_Header* DataStreamHeaderReceived::mutable_header() {
  ::livekit::proto::DataStream_Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamHeaderReceived.header)
  return _msg;
}
inline void DataStreamHeaderReceived::set_allocated_header(::livekit::proto::DataStream_Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamHeaderReceived.header)
}

// -------------------------------------------------------------------

// DataStreamChunkReceived

// required string participant_identity = 1;
inline bool DataStreamChunkReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStreamChunkReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void DataStreamChunkReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStreamChunkReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamChunkReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStreamChunkReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStreamChunkReceived.participant_identity)
}
inline std::string* DataStreamChunkReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamChunkReceived.participant_identity)
  return _s;
}
inline const std::string& DataStreamChunkReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void DataStreamChunkReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStreamChunkReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStreamChunkReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamChunkReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStreamChunkReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamChunkReceived.participant_identity)
}

// required .livekit.proto.DataStream.Chunk chunk = 2;
inline bool DataStreamChunkReceived::_internal_has_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunk_ != nullptr);
  return value;
}
inline bool DataStreamChunkReceived::has_chunk() const {
  return _internal_has_chunk();
}
inline void DataStreamChunkReceived::clear_chunk() {
  if (_impl_.chunk_ != nullptr) _impl_.chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Chunk& DataStreamChunkReceived::_internal_chunk() const {
  const ::livekit::proto::DataStream_Chunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Chunk&>(
      ::livekit::proto::_DataStream_Chunk_default_instance_);
}
inline const ::livekit::proto::DataStream_Chunk& DataStreamChunkReceived::chunk() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamChunkReceived.chunk)
  return _internal_chunk();
}
inline void DataStreamChunkReceived::unsafe_arena_set_allocated_chunk(
    ::livekit::proto::DataStream_Chunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataStreamChunkReceived.chunk)
}
inline ::livekit::proto::DataStream_Chunk* DataStreamChunkReceived::release_chunk() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Chunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Chunk* DataStreamChunkReceived::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamChunkReceived.chunk)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Chunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Chunk* DataStreamChunkReceived::_internal_mutable_chunk() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Chunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::livekit::proto::DataStream_Chunk* DataStreamChunkReceived::mutable_chunk() {
  ::livekit::proto::DataStream_Chunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamChunkReceived.chunk)
  return _msg;
}
inline void DataStreamChunkReceived::set_allocated_chunk(::livekit::proto::DataStream_Chunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chunk_;
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chunk);
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamChunkReceived.chunk)
}

// -------------------------------------------------------------------

// DataStreamTrailerReceived

// required string participant_identity = 1;
inline bool DataStreamTrailerReceived::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataStreamTrailerReceived::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void DataStreamTrailerReceived::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataStreamTrailerReceived::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamTrailerReceived.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataStreamTrailerReceived::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.DataStreamTrailerReceived.participant_identity)
}
inline std::string* DataStreamTrailerReceived::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamTrailerReceived.participant_identity)
  return _s;
}
inline const std::string& DataStreamTrailerReceived::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void DataStreamTrailerReceived::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* DataStreamTrailerReceived::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* DataStreamTrailerReceived::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamTrailerReceived.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DataStreamTrailerReceived::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamTrailerReceived.participant_identity)
}

// required .livekit.proto.DataStream.Trailer trailer = 2;
inline bool DataStreamTrailerReceived::_internal_has_trailer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trailer_ != nullptr);
  return value;
}
inline bool DataStreamTrailerReceived::has_trailer() const {
  return _internal_has_trailer();
}
inline void DataStreamTrailerReceived::clear_trailer() {
  if (_impl_.trailer_ != nullptr) _impl_.trailer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Trailer& DataStreamTrailerReceived::_internal_trailer() const {
  const ::livekit::proto::DataStream_Trailer* p = _impl_.trailer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Trailer&>(
      ::livekit::proto::_DataStream_Trailer_default_instance_);
}
inline const ::livekit::proto::DataStream_Trailer& DataStreamTrailerReceived::trailer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataStreamTrailerReceived.trailer)
  return _internal_trailer();
}
inline void DataStreamTrailerReceived::unsafe_arena_set_allocated_trailer(
    ::livekit::proto::DataStream_Trailer* trailer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trailer_);
  }
  _impl_.trailer_ = trailer;
  if (trailer) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.DataStreamTrailerReceived.trailer)
}
inline ::livekit::proto::DataStream_Trailer* DataStreamTrailerReceived::release_trailer() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Trailer* temp = _impl_.trailer_;
  _impl_.trailer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Trailer* DataStreamTrailerReceived::unsafe_arena_release_trailer() {
  // @@protoc_insertion_point(field_release:livekit.proto.DataStreamTrailerReceived.trailer)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Trailer* temp = _impl_.trailer_;
  _impl_.trailer_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Trailer* DataStreamTrailerReceived::_internal_mutable_trailer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trailer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Trailer>(GetArenaForAllocation());
    _impl_.trailer_ = p;
  }
  return _impl_.trailer_;
}
inline ::livekit::proto::DataStream_Trailer* DataStreamTrailerReceived::mutable_trailer() {
  ::livekit::proto::DataStream_Trailer* _msg = _internal_mutable_trailer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.DataStreamTrailerReceived.trailer)
  return _msg;
}
inline void DataStreamTrailerReceived::set_allocated_trailer(::livekit::proto::DataStream_Trailer* trailer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trailer_;
  }
  if (trailer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trailer);
    if (message_arena != submessage_arena) {
      trailer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trailer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trailer_ = trailer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.DataStreamTrailerReceived.trailer)
}

// -------------------------------------------------------------------

// SendStreamHeaderRequest

// required uint64 local_participant_handle = 1;
inline bool SendStreamHeaderRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendStreamHeaderRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SendStreamHeaderRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t SendStreamHeaderRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SendStreamHeaderRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SendStreamHeaderRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.local_participant_handle_ = value;
}
inline void SendStreamHeaderRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderRequest.local_participant_handle)
}

// required .livekit.proto.DataStream.Header header = 2;
inline bool SendStreamHeaderRequest::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline bool SendStreamHeaderRequest::has_header() const {
  return _internal_has_header();
}
inline void SendStreamHeaderRequest::clear_header() {
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Header& SendStreamHeaderRequest::_internal_header() const {
  const ::livekit::proto::DataStream_Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Header&>(
      ::livekit::proto::_DataStream_Header_default_instance_);
}
inline const ::livekit::proto::DataStream_Header& SendStreamHeaderRequest::header() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderRequest.header)
  return _internal_header();
}
inline void SendStreamHeaderRequest::unsafe_arena_set_allocated_header(
    ::livekit::proto::DataStream_Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.SendStreamHeaderRequest.header)
}
inline ::livekit::proto::DataStream_Header* SendStreamHeaderRequest::release_header() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Header* SendStreamHeaderRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamHeaderRequest.header)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Header* SendStreamHeaderRequest::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Header>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::livekit::proto::DataStream_Header* SendStreamHeaderRequest::mutable_header() {
  ::livekit::proto::DataStream_Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamHeaderRequest.header)
  return _msg;
}
inline void SendStreamHeaderRequest::set_allocated_header(::livekit::proto::DataStream_Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamHeaderRequest.header)
}

// repeated string destination_identities = 3;
inline int SendStreamHeaderRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int SendStreamHeaderRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void SendStreamHeaderRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* SendStreamHeaderRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.SendStreamHeaderRequest.destination_identities)
  return _s;
}
inline const std::string& SendStreamHeaderRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& SendStreamHeaderRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* SendStreamHeaderRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamHeaderRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void SendStreamHeaderRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline std::string* SendStreamHeaderRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void SendStreamHeaderRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline void SendStreamHeaderRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.SendStreamHeaderRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendStreamHeaderRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SendStreamHeaderRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendStreamHeaderRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SendStreamHeaderRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// required string sender_identity = 4;
inline bool SendStreamHeaderRequest::_internal_has_sender_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamHeaderRequest::has_sender_identity() const {
  return _internal_has_sender_identity();
}
inline void SendStreamHeaderRequest::clear_sender_identity() {
  _impl_.sender_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamHeaderRequest::sender_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderRequest.sender_identity)
  return _internal_sender_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamHeaderRequest::set_sender_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sender_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderRequest.sender_identity)
}
inline std::string* SendStreamHeaderRequest::mutable_sender_identity() {
  std::string* _s = _internal_mutable_sender_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamHeaderRequest.sender_identity)
  return _s;
}
inline const std::string& SendStreamHeaderRequest::_internal_sender_identity() const {
  return _impl_.sender_identity_.Get();
}
inline void SendStreamHeaderRequest::_internal_set_sender_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sender_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamHeaderRequest::_internal_mutable_sender_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sender_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamHeaderRequest::release_sender_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamHeaderRequest.sender_identity)
  if (!_internal_has_sender_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sender_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamHeaderRequest::set_allocated_sender_identity(std::string* sender_identity) {
  if (sender_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sender_identity_.SetAllocated(sender_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamHeaderRequest.sender_identity)
}

// -------------------------------------------------------------------

// SendStreamChunkRequest

// required uint64 local_participant_handle = 1;
inline bool SendStreamChunkRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendStreamChunkRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SendStreamChunkRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t SendStreamChunkRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SendStreamChunkRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SendStreamChunkRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.local_participant_handle_ = value;
}
inline void SendStreamChunkRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkRequest.local_participant_handle)
}

// required .livekit.proto.DataStream.Chunk chunk = 2;
inline bool SendStreamChunkRequest::_internal_has_chunk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chunk_ != nullptr);
  return value;
}
inline bool SendStreamChunkRequest::has_chunk() const {
  return _internal_has_chunk();
}
inline void SendStreamChunkRequest::clear_chunk() {
  if (_impl_.chunk_ != nullptr) _impl_.chunk_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Chunk& SendStreamChunkRequest::_internal_chunk() const {
  const ::livekit::proto::DataStream_Chunk* p = _impl_.chunk_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Chunk&>(
      ::livekit::proto::_DataStream_Chunk_default_instance_);
}
inline const ::livekit::proto::DataStream_Chunk& SendStreamChunkRequest::chunk() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkRequest.chunk)
  return _internal_chunk();
}
inline void SendStreamChunkRequest::unsafe_arena_set_allocated_chunk(
    ::livekit::proto::DataStream_Chunk* chunk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chunk_);
  }
  _impl_.chunk_ = chunk;
  if (chunk) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.SendStreamChunkRequest.chunk)
}
inline ::livekit::proto::DataStream_Chunk* SendStreamChunkRequest::release_chunk() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Chunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Chunk* SendStreamChunkRequest::unsafe_arena_release_chunk() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamChunkRequest.chunk)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Chunk* temp = _impl_.chunk_;
  _impl_.chunk_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Chunk* SendStreamChunkRequest::_internal_mutable_chunk() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.chunk_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Chunk>(GetArenaForAllocation());
    _impl_.chunk_ = p;
  }
  return _impl_.chunk_;
}
inline ::livekit::proto::DataStream_Chunk* SendStreamChunkRequest::mutable_chunk() {
  ::livekit::proto::DataStream_Chunk* _msg = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamChunkRequest.chunk)
  return _msg;
}
inline void SendStreamChunkRequest::set_allocated_chunk(::livekit::proto::DataStream_Chunk* chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.chunk_;
  }
  if (chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chunk);
    if (message_arena != submessage_arena) {
      chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chunk, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chunk_ = chunk;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamChunkRequest.chunk)
}

// repeated string destination_identities = 3;
inline int SendStreamChunkRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int SendStreamChunkRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void SendStreamChunkRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* SendStreamChunkRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.SendStreamChunkRequest.destination_identities)
  return _s;
}
inline const std::string& SendStreamChunkRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& SendStreamChunkRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* SendStreamChunkRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamChunkRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void SendStreamChunkRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline std::string* SendStreamChunkRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void SendStreamChunkRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline void SendStreamChunkRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.SendStreamChunkRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendStreamChunkRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SendStreamChunkRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendStreamChunkRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SendStreamChunkRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// required string sender_identity = 4;
inline bool SendStreamChunkRequest::_internal_has_sender_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamChunkRequest::has_sender_identity() const {
  return _internal_has_sender_identity();
}
inline void SendStreamChunkRequest::clear_sender_identity() {
  _impl_.sender_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamChunkRequest::sender_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkRequest.sender_identity)
  return _internal_sender_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamChunkRequest::set_sender_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sender_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkRequest.sender_identity)
}
inline std::string* SendStreamChunkRequest::mutable_sender_identity() {
  std::string* _s = _internal_mutable_sender_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamChunkRequest.sender_identity)
  return _s;
}
inline const std::string& SendStreamChunkRequest::_internal_sender_identity() const {
  return _impl_.sender_identity_.Get();
}
inline void SendStreamChunkRequest::_internal_set_sender_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sender_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamChunkRequest::_internal_mutable_sender_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sender_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamChunkRequest::release_sender_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamChunkRequest.sender_identity)
  if (!_internal_has_sender_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sender_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamChunkRequest::set_allocated_sender_identity(std::string* sender_identity) {
  if (sender_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sender_identity_.SetAllocated(sender_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamChunkRequest.sender_identity)
}

// -------------------------------------------------------------------

// SendStreamTrailerRequest

// required uint64 local_participant_handle = 1;
inline bool SendStreamTrailerRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendStreamTrailerRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SendStreamTrailerRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t SendStreamTrailerRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SendStreamTrailerRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SendStreamTrailerRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.local_participant_handle_ = value;
}
inline void SendStreamTrailerRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerRequest.local_participant_handle)
}

// required .livekit.proto.DataStream.Trailer trailer = 2;
inline bool SendStreamTrailerRequest::_internal_has_trailer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trailer_ != nullptr);
  return value;
}
inline bool SendStreamTrailerRequest::has_trailer() const {
  return _internal_has_trailer();
}
inline void SendStreamTrailerRequest::clear_trailer() {
  if (_impl_.trailer_ != nullptr) _impl_.trailer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::livekit::proto::DataStream_Trailer& SendStreamTrailerRequest::_internal_trailer() const {
  const ::livekit::proto::DataStream_Trailer* p = _impl_.trailer_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::DataStream_Trailer&>(
      ::livekit::proto::_DataStream_Trailer_default_instance_);
}
inline const ::livekit::proto::DataStream_Trailer& SendStreamTrailerRequest::trailer() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerRequest.trailer)
  return _internal_trailer();
}
inline void SendStreamTrailerRequest::unsafe_arena_set_allocated_trailer(
    ::livekit::proto::DataStream_Trailer* trailer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trailer_);
  }
  _impl_.trailer_ = trailer;
  if (trailer) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.SendStreamTrailerRequest.trailer)
}
inline ::livekit::proto::DataStream_Trailer* SendStreamTrailerRequest::release_trailer() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Trailer* temp = _impl_.trailer_;
  _impl_.trailer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::DataStream_Trailer* SendStreamTrailerRequest::unsafe_arena_release_trailer() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamTrailerRequest.trailer)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::livekit::proto::DataStream_Trailer* temp = _impl_.trailer_;
  _impl_.trailer_ = nullptr;
  return temp;
}
inline ::livekit::proto::DataStream_Trailer* SendStreamTrailerRequest::_internal_mutable_trailer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.trailer_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::DataStream_Trailer>(GetArenaForAllocation());
    _impl_.trailer_ = p;
  }
  return _impl_.trailer_;
}
inline ::livekit::proto::DataStream_Trailer* SendStreamTrailerRequest::mutable_trailer() {
  ::livekit::proto::DataStream_Trailer* _msg = _internal_mutable_trailer();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamTrailerRequest.trailer)
  return _msg;
}
inline void SendStreamTrailerRequest::set_allocated_trailer(::livekit::proto::DataStream_Trailer* trailer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trailer_;
  }
  if (trailer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trailer);
    if (message_arena != submessage_arena) {
      trailer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trailer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.trailer_ = trailer;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamTrailerRequest.trailer)
}

// repeated string destination_identities = 3;
inline int SendStreamTrailerRequest::_internal_destination_identities_size() const {
  return _impl_.destination_identities_.size();
}
inline int SendStreamTrailerRequest::destination_identities_size() const {
  return _internal_destination_identities_size();
}
inline void SendStreamTrailerRequest::clear_destination_identities() {
  _impl_.destination_identities_.Clear();
}
inline std::string* SendStreamTrailerRequest::add_destination_identities() {
  std::string* _s = _internal_add_destination_identities();
  // @@protoc_insertion_point(field_add_mutable:livekit.proto.SendStreamTrailerRequest.destination_identities)
  return _s;
}
inline const std::string& SendStreamTrailerRequest::_internal_destination_identities(int index) const {
  return _impl_.destination_identities_.Get(index);
}
inline const std::string& SendStreamTrailerRequest::destination_identities(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerRequest.destination_identities)
  return _internal_destination_identities(index);
}
inline std::string* SendStreamTrailerRequest::mutable_destination_identities(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamTrailerRequest.destination_identities)
  return _impl_.destination_identities_.Mutable(index);
}
inline void SendStreamTrailerRequest::set_destination_identities(int index, const std::string& value) {
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::set_destination_identities(int index, std::string&& value) {
  _impl_.destination_identities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::set_destination_identities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::set_destination_identities(int index, const char* value, size_t size) {
  _impl_.destination_identities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline std::string* SendStreamTrailerRequest::_internal_add_destination_identities() {
  return _impl_.destination_identities_.Add();
}
inline void SendStreamTrailerRequest::add_destination_identities(const std::string& value) {
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::add_destination_identities(std::string&& value) {
  _impl_.destination_identities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::add_destination_identities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.destination_identities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline void SendStreamTrailerRequest::add_destination_identities(const char* value, size_t size) {
  _impl_.destination_identities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.proto.SendStreamTrailerRequest.destination_identities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SendStreamTrailerRequest::destination_identities() const {
  // @@protoc_insertion_point(field_list:livekit.proto.SendStreamTrailerRequest.destination_identities)
  return _impl_.destination_identities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SendStreamTrailerRequest::mutable_destination_identities() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.SendStreamTrailerRequest.destination_identities)
  return &_impl_.destination_identities_;
}

// required string sender_identity = 4;
inline bool SendStreamTrailerRequest::_internal_has_sender_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamTrailerRequest::has_sender_identity() const {
  return _internal_has_sender_identity();
}
inline void SendStreamTrailerRequest::clear_sender_identity() {
  _impl_.sender_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamTrailerRequest::sender_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerRequest.sender_identity)
  return _internal_sender_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamTrailerRequest::set_sender_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sender_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerRequest.sender_identity)
}
inline std::string* SendStreamTrailerRequest::mutable_sender_identity() {
  std::string* _s = _internal_mutable_sender_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamTrailerRequest.sender_identity)
  return _s;
}
inline const std::string& SendStreamTrailerRequest::_internal_sender_identity() const {
  return _impl_.sender_identity_.Get();
}
inline void SendStreamTrailerRequest::_internal_set_sender_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sender_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamTrailerRequest::_internal_mutable_sender_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sender_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamTrailerRequest::release_sender_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamTrailerRequest.sender_identity)
  if (!_internal_has_sender_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sender_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamTrailerRequest::set_allocated_sender_identity(std::string* sender_identity) {
  if (sender_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sender_identity_.SetAllocated(sender_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_identity_.IsDefault()) {
    _impl_.sender_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamTrailerRequest.sender_identity)
}

// -------------------------------------------------------------------

// SendStreamHeaderResponse

// required uint64 async_id = 1;
inline bool SendStreamHeaderResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamHeaderResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamHeaderResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SendStreamHeaderResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamHeaderResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderResponse.async_id)
  return _internal_async_id();
}
inline void SendStreamHeaderResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SendStreamHeaderResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderResponse.async_id)
}

// -------------------------------------------------------------------

// SendStreamChunkResponse

// required uint64 async_id = 1;
inline bool SendStreamChunkResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamChunkResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamChunkResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SendStreamChunkResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamChunkResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkResponse.async_id)
  return _internal_async_id();
}
inline void SendStreamChunkResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SendStreamChunkResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkResponse.async_id)
}

// -------------------------------------------------------------------

// SendStreamTrailerResponse

// required uint64 async_id = 1;
inline bool SendStreamTrailerResponse::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamTrailerResponse::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamTrailerResponse::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SendStreamTrailerResponse::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamTrailerResponse::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerResponse.async_id)
  return _internal_async_id();
}
inline void SendStreamTrailerResponse::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.async_id_ = value;
}
inline void SendStreamTrailerResponse::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerResponse.async_id)
}

// -------------------------------------------------------------------

// SendStreamHeaderCallback

// required uint64 async_id = 1;
inline bool SendStreamHeaderCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendStreamHeaderCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamHeaderCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SendStreamHeaderCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamHeaderCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderCallback.async_id)
  return _internal_async_id();
}
inline void SendStreamHeaderCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SendStreamHeaderCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderCallback.async_id)
}

// optional string error = 2;
inline bool SendStreamHeaderCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamHeaderCallback::has_error() const {
  return _internal_has_error();
}
inline void SendStreamHeaderCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamHeaderCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamHeaderCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamHeaderCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamHeaderCallback.error)
}
inline std::string* SendStreamHeaderCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamHeaderCallback.error)
  return _s;
}
inline const std::string& SendStreamHeaderCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SendStreamHeaderCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamHeaderCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamHeaderCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamHeaderCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamHeaderCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamHeaderCallback.error)
}

// -------------------------------------------------------------------

// SendStreamChunkCallback

// required uint64 async_id = 1;
inline bool SendStreamChunkCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendStreamChunkCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamChunkCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SendStreamChunkCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamChunkCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkCallback.async_id)
  return _internal_async_id();
}
inline void SendStreamChunkCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SendStreamChunkCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkCallback.async_id)
}

// optional string error = 2;
inline bool SendStreamChunkCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamChunkCallback::has_error() const {
  return _internal_has_error();
}
inline void SendStreamChunkCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamChunkCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamChunkCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamChunkCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamChunkCallback.error)
}
inline std::string* SendStreamChunkCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamChunkCallback.error)
  return _s;
}
inline const std::string& SendStreamChunkCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SendStreamChunkCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamChunkCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamChunkCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamChunkCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamChunkCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamChunkCallback.error)
}

// -------------------------------------------------------------------

// SendStreamTrailerCallback

// required uint64 async_id = 1;
inline bool SendStreamTrailerCallback::_internal_has_async_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SendStreamTrailerCallback::has_async_id() const {
  return _internal_has_async_id();
}
inline void SendStreamTrailerCallback::clear_async_id() {
  _impl_.async_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SendStreamTrailerCallback::_internal_async_id() const {
  return _impl_.async_id_;
}
inline uint64_t SendStreamTrailerCallback::async_id() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerCallback.async_id)
  return _internal_async_id();
}
inline void SendStreamTrailerCallback::_internal_set_async_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.async_id_ = value;
}
inline void SendStreamTrailerCallback::set_async_id(uint64_t value) {
  _internal_set_async_id(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerCallback.async_id)
}

// optional string error = 2;
inline bool SendStreamTrailerCallback::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendStreamTrailerCallback::has_error() const {
  return _internal_has_error();
}
inline void SendStreamTrailerCallback::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendStreamTrailerCallback::error() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SendStreamTrailerCallback.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendStreamTrailerCallback::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SendStreamTrailerCallback.error)
}
inline std::string* SendStreamTrailerCallback::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SendStreamTrailerCallback.error)
  return _s;
}
inline const std::string& SendStreamTrailerCallback::_internal_error() const {
  return _impl_.error_.Get();
}
inline void SendStreamTrailerCallback::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* SendStreamTrailerCallback::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* SendStreamTrailerCallback::release_error() {
  // @@protoc_insertion_point(field_release:livekit.proto.SendStreamTrailerCallback.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendStreamTrailerCallback::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SendStreamTrailerCallback.error)
}

// -------------------------------------------------------------------

// SetDataChannelBufferedAmountLowThresholdRequest

// required uint64 local_participant_handle = 1;
inline bool SetDataChannelBufferedAmountLowThresholdRequest::_internal_has_local_participant_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetDataChannelBufferedAmountLowThresholdRequest::has_local_participant_handle() const {
  return _internal_has_local_participant_handle();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::clear_local_participant_handle() {
  _impl_.local_participant_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SetDataChannelBufferedAmountLowThresholdRequest::_internal_local_participant_handle() const {
  return _impl_.local_participant_handle_;
}
inline uint64_t SetDataChannelBufferedAmountLowThresholdRequest::local_participant_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.local_participant_handle)
  return _internal_local_participant_handle();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::_internal_set_local_participant_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.local_participant_handle_ = value;
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::set_local_participant_handle(uint64_t value) {
  _internal_set_local_participant_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.local_participant_handle)
}

// required uint64 threshold = 2;
inline bool SetDataChannelBufferedAmountLowThresholdRequest::_internal_has_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetDataChannelBufferedAmountLowThresholdRequest::has_threshold() const {
  return _internal_has_threshold();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::clear_threshold() {
  _impl_.threshold_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SetDataChannelBufferedAmountLowThresholdRequest::_internal_threshold() const {
  return _impl_.threshold_;
}
inline uint64_t SetDataChannelBufferedAmountLowThresholdRequest::threshold() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.threshold)
  return _internal_threshold();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::_internal_set_threshold(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.threshold_ = value;
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::set_threshold(uint64_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.threshold)
}

// required .livekit.proto.DataPacketKind kind = 3;
inline bool SetDataChannelBufferedAmountLowThresholdRequest::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetDataChannelBufferedAmountLowThresholdRequest::has_kind() const {
  return _internal_has_kind();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::livekit::proto::DataPacketKind SetDataChannelBufferedAmountLowThresholdRequest::_internal_kind() const {
  return static_cast< ::livekit::proto::DataPacketKind >(_impl_.kind_);
}
inline ::livekit::proto::DataPacketKind SetDataChannelBufferedAmountLowThresholdRequest::kind() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.kind)
  return _internal_kind();
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::_internal_set_kind(::livekit::proto::DataPacketKind value) {
  assert(::livekit::proto::DataPacketKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_ = value;
}
inline void SetDataChannelBufferedAmountLowThresholdRequest::set_kind(::livekit::proto::DataPacketKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetDataChannelBufferedAmountLowThresholdRequest.kind)
}

// -------------------------------------------------------------------

// SetDataChannelBufferedAmountLowThresholdResponse

// -------------------------------------------------------------------

// DataChannelBufferedAmountLowThresholdChanged

// required .livekit.proto.DataPacketKind kind = 1;
inline bool DataChannelBufferedAmountLowThresholdChanged::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataChannelBufferedAmountLowThresholdChanged::has_kind() const {
  return _internal_has_kind();
}
inline void DataChannelBufferedAmountLowThresholdChanged::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::DataPacketKind DataChannelBufferedAmountLowThresholdChanged::_internal_kind() const {
  return static_cast< ::livekit::proto::DataPacketKind >(_impl_.kind_);
}
inline ::livekit::proto::DataPacketKind DataChannelBufferedAmountLowThresholdChanged::kind() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataChannelBufferedAmountLowThresholdChanged.kind)
  return _internal_kind();
}
inline void DataChannelBufferedAmountLowThresholdChanged::_internal_set_kind(::livekit::proto::DataPacketKind value) {
  assert(::livekit::proto::DataPacketKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_ = value;
}
inline void DataChannelBufferedAmountLowThresholdChanged::set_kind(::livekit::proto::DataPacketKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataChannelBufferedAmountLowThresholdChanged.kind)
}

// required uint64 threshold = 2;
inline bool DataChannelBufferedAmountLowThresholdChanged::_internal_has_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataChannelBufferedAmountLowThresholdChanged::has_threshold() const {
  return _internal_has_threshold();
}
inline void DataChannelBufferedAmountLowThresholdChanged::clear_threshold() {
  _impl_.threshold_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DataChannelBufferedAmountLowThresholdChanged::_internal_threshold() const {
  return _impl_.threshold_;
}
inline uint64_t DataChannelBufferedAmountLowThresholdChanged::threshold() const {
  // @@protoc_insertion_point(field_get:livekit.proto.DataChannelBufferedAmountLowThresholdChanged.threshold)
  return _internal_threshold();
}
inline void DataChannelBufferedAmountLowThresholdChanged::_internal_set_threshold(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.threshold_ = value;
}
inline void DataChannelBufferedAmountLowThresholdChanged::set_threshold(uint64_t value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:livekit.proto.DataChannelBufferedAmountLowThresholdChanged.threshold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::proto::DataStream_OperationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::DataStream_OperationType>() {
  return ::livekit::proto::DataStream_OperationType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::IceTransportType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::IceTransportType>() {
  return ::livekit::proto::IceTransportType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::ContinualGatheringPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::ContinualGatheringPolicy>() {
  return ::livekit::proto::ContinualGatheringPolicy_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::ConnectionQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::ConnectionQuality>() {
  return ::livekit::proto::ConnectionQuality_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::ConnectionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::ConnectionState>() {
  return ::livekit::proto::ConnectionState_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::DataPacketKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::DataPacketKind>() {
  return ::livekit::proto::DataPacketKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_room_2eproto
