// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: e2ee.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_e2ee_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_e2ee_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_e2ee_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_e2ee_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_e2ee_2eproto;
namespace livekit {
namespace proto {
class E2eeManagerGetFrameCryptorsRequest;
struct E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal;
extern E2eeManagerGetFrameCryptorsRequestDefaultTypeInternal _E2eeManagerGetFrameCryptorsRequest_default_instance_;
class E2eeManagerGetFrameCryptorsResponse;
struct E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal;
extern E2eeManagerGetFrameCryptorsResponseDefaultTypeInternal _E2eeManagerGetFrameCryptorsResponse_default_instance_;
class E2eeManagerSetEnabledRequest;
struct E2eeManagerSetEnabledRequestDefaultTypeInternal;
extern E2eeManagerSetEnabledRequestDefaultTypeInternal _E2eeManagerSetEnabledRequest_default_instance_;
class E2eeManagerSetEnabledResponse;
struct E2eeManagerSetEnabledResponseDefaultTypeInternal;
extern E2eeManagerSetEnabledResponseDefaultTypeInternal _E2eeManagerSetEnabledResponse_default_instance_;
class E2eeOptions;
struct E2eeOptionsDefaultTypeInternal;
extern E2eeOptionsDefaultTypeInternal _E2eeOptions_default_instance_;
class E2eeRequest;
struct E2eeRequestDefaultTypeInternal;
extern E2eeRequestDefaultTypeInternal _E2eeRequest_default_instance_;
class E2eeResponse;
struct E2eeResponseDefaultTypeInternal;
extern E2eeResponseDefaultTypeInternal _E2eeResponse_default_instance_;
class FrameCryptor;
struct FrameCryptorDefaultTypeInternal;
extern FrameCryptorDefaultTypeInternal _FrameCryptor_default_instance_;
class FrameCryptorSetEnabledRequest;
struct FrameCryptorSetEnabledRequestDefaultTypeInternal;
extern FrameCryptorSetEnabledRequestDefaultTypeInternal _FrameCryptorSetEnabledRequest_default_instance_;
class FrameCryptorSetEnabledResponse;
struct FrameCryptorSetEnabledResponseDefaultTypeInternal;
extern FrameCryptorSetEnabledResponseDefaultTypeInternal _FrameCryptorSetEnabledResponse_default_instance_;
class FrameCryptorSetKeyIndexRequest;
struct FrameCryptorSetKeyIndexRequestDefaultTypeInternal;
extern FrameCryptorSetKeyIndexRequestDefaultTypeInternal _FrameCryptorSetKeyIndexRequest_default_instance_;
class FrameCryptorSetKeyIndexResponse;
struct FrameCryptorSetKeyIndexResponseDefaultTypeInternal;
extern FrameCryptorSetKeyIndexResponseDefaultTypeInternal _FrameCryptorSetKeyIndexResponse_default_instance_;
class GetKeyRequest;
struct GetKeyRequestDefaultTypeInternal;
extern GetKeyRequestDefaultTypeInternal _GetKeyRequest_default_instance_;
class GetKeyResponse;
struct GetKeyResponseDefaultTypeInternal;
extern GetKeyResponseDefaultTypeInternal _GetKeyResponse_default_instance_;
class GetSharedKeyRequest;
struct GetSharedKeyRequestDefaultTypeInternal;
extern GetSharedKeyRequestDefaultTypeInternal _GetSharedKeyRequest_default_instance_;
class GetSharedKeyResponse;
struct GetSharedKeyResponseDefaultTypeInternal;
extern GetSharedKeyResponseDefaultTypeInternal _GetSharedKeyResponse_default_instance_;
class KeyProviderOptions;
struct KeyProviderOptionsDefaultTypeInternal;
extern KeyProviderOptionsDefaultTypeInternal _KeyProviderOptions_default_instance_;
class RatchetKeyRequest;
struct RatchetKeyRequestDefaultTypeInternal;
extern RatchetKeyRequestDefaultTypeInternal _RatchetKeyRequest_default_instance_;
class RatchetKeyResponse;
struct RatchetKeyResponseDefaultTypeInternal;
extern RatchetKeyResponseDefaultTypeInternal _RatchetKeyResponse_default_instance_;
class RatchetSharedKeyRequest;
struct RatchetSharedKeyRequestDefaultTypeInternal;
extern RatchetSharedKeyRequestDefaultTypeInternal _RatchetSharedKeyRequest_default_instance_;
class RatchetSharedKeyResponse;
struct RatchetSharedKeyResponseDefaultTypeInternal;
extern RatchetSharedKeyResponseDefaultTypeInternal _RatchetSharedKeyResponse_default_instance_;
class SetKeyRequest;
struct SetKeyRequestDefaultTypeInternal;
extern SetKeyRequestDefaultTypeInternal _SetKeyRequest_default_instance_;
class SetKeyResponse;
struct SetKeyResponseDefaultTypeInternal;
extern SetKeyResponseDefaultTypeInternal _SetKeyResponse_default_instance_;
class SetSharedKeyRequest;
struct SetSharedKeyRequestDefaultTypeInternal;
extern SetSharedKeyRequestDefaultTypeInternal _SetSharedKeyRequest_default_instance_;
class SetSharedKeyResponse;
struct SetSharedKeyResponseDefaultTypeInternal;
extern SetSharedKeyResponseDefaultTypeInternal _SetSharedKeyResponse_default_instance_;
}  // namespace proto
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* Arena::CreateMaybeMessage<::livekit::proto::E2eeManagerGetFrameCryptorsRequest>(Arena*);
template<> ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* Arena::CreateMaybeMessage<::livekit::proto::E2eeManagerGetFrameCryptorsResponse>(Arena*);
template<> ::livekit::proto::E2eeManagerSetEnabledRequest* Arena::CreateMaybeMessage<::livekit::proto::E2eeManagerSetEnabledRequest>(Arena*);
template<> ::livekit::proto::E2eeManagerSetEnabledResponse* Arena::CreateMaybeMessage<::livekit::proto::E2eeManagerSetEnabledResponse>(Arena*);
template<> ::livekit::proto::E2eeOptions* Arena::CreateMaybeMessage<::livekit::proto::E2eeOptions>(Arena*);
template<> ::livekit::proto::E2eeRequest* Arena::CreateMaybeMessage<::livekit::proto::E2eeRequest>(Arena*);
template<> ::livekit::proto::E2eeResponse* Arena::CreateMaybeMessage<::livekit::proto::E2eeResponse>(Arena*);
template<> ::livekit::proto::FrameCryptor* Arena::CreateMaybeMessage<::livekit::proto::FrameCryptor>(Arena*);
template<> ::livekit::proto::FrameCryptorSetEnabledRequest* Arena::CreateMaybeMessage<::livekit::proto::FrameCryptorSetEnabledRequest>(Arena*);
template<> ::livekit::proto::FrameCryptorSetEnabledResponse* Arena::CreateMaybeMessage<::livekit::proto::FrameCryptorSetEnabledResponse>(Arena*);
template<> ::livekit::proto::FrameCryptorSetKeyIndexRequest* Arena::CreateMaybeMessage<::livekit::proto::FrameCryptorSetKeyIndexRequest>(Arena*);
template<> ::livekit::proto::FrameCryptorSetKeyIndexResponse* Arena::CreateMaybeMessage<::livekit::proto::FrameCryptorSetKeyIndexResponse>(Arena*);
template<> ::livekit::proto::GetKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::GetKeyRequest>(Arena*);
template<> ::livekit::proto::GetKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::GetKeyResponse>(Arena*);
template<> ::livekit::proto::GetSharedKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::GetSharedKeyRequest>(Arena*);
template<> ::livekit::proto::GetSharedKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::GetSharedKeyResponse>(Arena*);
template<> ::livekit::proto::KeyProviderOptions* Arena::CreateMaybeMessage<::livekit::proto::KeyProviderOptions>(Arena*);
template<> ::livekit::proto::RatchetKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::RatchetKeyRequest>(Arena*);
template<> ::livekit::proto::RatchetKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::RatchetKeyResponse>(Arena*);
template<> ::livekit::proto::RatchetSharedKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::RatchetSharedKeyRequest>(Arena*);
template<> ::livekit::proto::RatchetSharedKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::RatchetSharedKeyResponse>(Arena*);
template<> ::livekit::proto::SetKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::SetKeyRequest>(Arena*);
template<> ::livekit::proto::SetKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::SetKeyResponse>(Arena*);
template<> ::livekit::proto::SetSharedKeyRequest* Arena::CreateMaybeMessage<::livekit::proto::SetSharedKeyRequest>(Arena*);
template<> ::livekit::proto::SetSharedKeyResponse* Arena::CreateMaybeMessage<::livekit::proto::SetSharedKeyResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {
namespace proto {

enum EncryptionType : int {
  NONE = 0,
  GCM = 1,
  CUSTOM = 2
};
bool EncryptionType_IsValid(int value);
constexpr EncryptionType EncryptionType_MIN = NONE;
constexpr EncryptionType EncryptionType_MAX = CUSTOM;
constexpr int EncryptionType_ARRAYSIZE = EncryptionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionType_descriptor();
template<typename T>
inline const std::string& EncryptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncryptionType_descriptor(), enum_t_value);
}
inline bool EncryptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionType>(
    EncryptionType_descriptor(), name, value);
}
enum EncryptionState : int {
  NEW = 0,
  OK = 1,
  ENCRYPTION_FAILED = 2,
  DECRYPTION_FAILED = 3,
  MISSING_KEY = 4,
  KEY_RATCHETED = 5,
  INTERNAL_ERROR = 6
};
bool EncryptionState_IsValid(int value);
constexpr EncryptionState EncryptionState_MIN = NEW;
constexpr EncryptionState EncryptionState_MAX = INTERNAL_ERROR;
constexpr int EncryptionState_ARRAYSIZE = EncryptionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionState_descriptor();
template<typename T>
inline const std::string& EncryptionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncryptionState_descriptor(), enum_t_value);
}
inline bool EncryptionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionState>(
    EncryptionState_descriptor(), name, value);
}
// ===================================================================

class FrameCryptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.FrameCryptor) */ {
 public:
  inline FrameCryptor() : FrameCryptor(nullptr) {}
  ~FrameCryptor() override;
  explicit PROTOBUF_CONSTEXPR FrameCryptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameCryptor(const FrameCryptor& from);
  FrameCryptor(FrameCryptor&& from) noexcept
    : FrameCryptor() {
    *this = ::std::move(from);
  }

  inline FrameCryptor& operator=(const FrameCryptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameCryptor& operator=(FrameCryptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameCryptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameCryptor* internal_default_instance() {
    return reinterpret_cast<const FrameCryptor*>(
               &_FrameCryptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FrameCryptor& a, FrameCryptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameCryptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameCryptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameCryptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameCryptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameCryptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameCryptor& from) {
    FrameCryptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameCryptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FrameCryptor";
  }
  protected:
  explicit FrameCryptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kKeyIndexFieldNumber = 3,
    kEnabledFieldNumber = 4,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // required int32 key_index = 3;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // required bool enabled = 4;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.FrameCryptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    int32_t key_index_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class KeyProviderOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.KeyProviderOptions) */ {
 public:
  inline KeyProviderOptions() : KeyProviderOptions(nullptr) {}
  ~KeyProviderOptions() override;
  explicit PROTOBUF_CONSTEXPR KeyProviderOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyProviderOptions(const KeyProviderOptions& from);
  KeyProviderOptions(KeyProviderOptions&& from) noexcept
    : KeyProviderOptions() {
    *this = ::std::move(from);
  }

  inline KeyProviderOptions& operator=(const KeyProviderOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyProviderOptions& operator=(KeyProviderOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyProviderOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyProviderOptions* internal_default_instance() {
    return reinterpret_cast<const KeyProviderOptions*>(
               &_KeyProviderOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KeyProviderOptions& a, KeyProviderOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyProviderOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyProviderOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyProviderOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyProviderOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyProviderOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyProviderOptions& from) {
    KeyProviderOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyProviderOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.KeyProviderOptions";
  }
  protected:
  explicit KeyProviderOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSharedKeyFieldNumber = 1,
    kRatchetSaltFieldNumber = 3,
    kRatchetWindowSizeFieldNumber = 2,
    kFailureToleranceFieldNumber = 4,
  };
  // optional bytes shared_key = 1;
  bool has_shared_key() const;
  private:
  bool _internal_has_shared_key() const;
  public:
  void clear_shared_key();
  const std::string& shared_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shared_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shared_key();
  PROTOBUF_NODISCARD std::string* release_shared_key();
  void set_allocated_shared_key(std::string* shared_key);
  private:
  const std::string& _internal_shared_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shared_key(const std::string& value);
  std::string* _internal_mutable_shared_key();
  public:

  // required bytes ratchet_salt = 3;
  bool has_ratchet_salt() const;
  private:
  bool _internal_has_ratchet_salt() const;
  public:
  void clear_ratchet_salt();
  const std::string& ratchet_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ratchet_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ratchet_salt();
  PROTOBUF_NODISCARD std::string* release_ratchet_salt();
  void set_allocated_ratchet_salt(std::string* ratchet_salt);
  private:
  const std::string& _internal_ratchet_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ratchet_salt(const std::string& value);
  std::string* _internal_mutable_ratchet_salt();
  public:

  // required int32 ratchet_window_size = 2;
  bool has_ratchet_window_size() const;
  private:
  bool _internal_has_ratchet_window_size() const;
  public:
  void clear_ratchet_window_size();
  int32_t ratchet_window_size() const;
  void set_ratchet_window_size(int32_t value);
  private:
  int32_t _internal_ratchet_window_size() const;
  void _internal_set_ratchet_window_size(int32_t value);
  public:

  // required int32 failure_tolerance = 4;
  bool has_failure_tolerance() const;
  private:
  bool _internal_has_failure_tolerance() const;
  public:
  void clear_failure_tolerance();
  int32_t failure_tolerance() const;
  void set_failure_tolerance(int32_t value);
  private:
  int32_t _internal_failure_tolerance() const;
  void _internal_set_failure_tolerance(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.KeyProviderOptions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ratchet_salt_;
    int32_t ratchet_window_size_;
    int32_t failure_tolerance_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeOptions) */ {
 public:
  inline E2eeOptions() : E2eeOptions(nullptr) {}
  ~E2eeOptions() override;
  explicit PROTOBUF_CONSTEXPR E2eeOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeOptions(const E2eeOptions& from);
  E2eeOptions(E2eeOptions&& from) noexcept
    : E2eeOptions() {
    *this = ::std::move(from);
  }

  inline E2eeOptions& operator=(const E2eeOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeOptions& operator=(E2eeOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeOptions* internal_default_instance() {
    return reinterpret_cast<const E2eeOptions*>(
               &_E2eeOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(E2eeOptions& a, E2eeOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeOptions& from) {
    E2eeOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeOptions";
  }
  protected:
  explicit E2eeOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyProviderOptionsFieldNumber = 2,
    kEncryptionTypeFieldNumber = 1,
  };
  // required .livekit.proto.KeyProviderOptions key_provider_options = 2;
  bool has_key_provider_options() const;
  private:
  bool _internal_has_key_provider_options() const;
  public:
  void clear_key_provider_options();
  const ::livekit::proto::KeyProviderOptions& key_provider_options() const;
  PROTOBUF_NODISCARD ::livekit::proto::KeyProviderOptions* release_key_provider_options();
  ::livekit::proto::KeyProviderOptions* mutable_key_provider_options();
  void set_allocated_key_provider_options(::livekit::proto::KeyProviderOptions* key_provider_options);
  private:
  const ::livekit::proto::KeyProviderOptions& _internal_key_provider_options() const;
  ::livekit::proto::KeyProviderOptions* _internal_mutable_key_provider_options();
  public:
  void unsafe_arena_set_allocated_key_provider_options(
      ::livekit::proto::KeyProviderOptions* key_provider_options);
  ::livekit::proto::KeyProviderOptions* unsafe_arena_release_key_provider_options();

  // required .livekit.proto.EncryptionType encryption_type = 1;
  bool has_encryption_type() const;
  private:
  bool _internal_has_encryption_type() const;
  public:
  void clear_encryption_type();
  ::livekit::proto::EncryptionType encryption_type() const;
  void set_encryption_type(::livekit::proto::EncryptionType value);
  private:
  ::livekit::proto::EncryptionType _internal_encryption_type() const;
  void _internal_set_encryption_type(::livekit::proto::EncryptionType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeOptions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::livekit::proto::KeyProviderOptions* key_provider_options_;
    int encryption_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeManagerSetEnabledRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeManagerSetEnabledRequest) */ {
 public:
  inline E2eeManagerSetEnabledRequest() : E2eeManagerSetEnabledRequest(nullptr) {}
  ~E2eeManagerSetEnabledRequest() override;
  explicit PROTOBUF_CONSTEXPR E2eeManagerSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeManagerSetEnabledRequest(const E2eeManagerSetEnabledRequest& from);
  E2eeManagerSetEnabledRequest(E2eeManagerSetEnabledRequest&& from) noexcept
    : E2eeManagerSetEnabledRequest() {
    *this = ::std::move(from);
  }

  inline E2eeManagerSetEnabledRequest& operator=(const E2eeManagerSetEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeManagerSetEnabledRequest& operator=(E2eeManagerSetEnabledRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeManagerSetEnabledRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeManagerSetEnabledRequest* internal_default_instance() {
    return reinterpret_cast<const E2eeManagerSetEnabledRequest*>(
               &_E2eeManagerSetEnabledRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(E2eeManagerSetEnabledRequest& a, E2eeManagerSetEnabledRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeManagerSetEnabledRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeManagerSetEnabledRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeManagerSetEnabledRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeManagerSetEnabledRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeManagerSetEnabledRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeManagerSetEnabledRequest& from) {
    E2eeManagerSetEnabledRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeManagerSetEnabledRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeManagerSetEnabledRequest";
  }
  protected:
  explicit E2eeManagerSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // required bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeManagerSetEnabledRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeManagerSetEnabledResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeManagerSetEnabledResponse) */ {
 public:
  inline E2eeManagerSetEnabledResponse() : E2eeManagerSetEnabledResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR E2eeManagerSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeManagerSetEnabledResponse(const E2eeManagerSetEnabledResponse& from);
  E2eeManagerSetEnabledResponse(E2eeManagerSetEnabledResponse&& from) noexcept
    : E2eeManagerSetEnabledResponse() {
    *this = ::std::move(from);
  }

  inline E2eeManagerSetEnabledResponse& operator=(const E2eeManagerSetEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeManagerSetEnabledResponse& operator=(E2eeManagerSetEnabledResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeManagerSetEnabledResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeManagerSetEnabledResponse* internal_default_instance() {
    return reinterpret_cast<const E2eeManagerSetEnabledResponse*>(
               &_E2eeManagerSetEnabledResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(E2eeManagerSetEnabledResponse& a, E2eeManagerSetEnabledResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeManagerSetEnabledResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeManagerSetEnabledResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeManagerSetEnabledResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeManagerSetEnabledResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const E2eeManagerSetEnabledResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const E2eeManagerSetEnabledResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeManagerSetEnabledResponse";
  }
  protected:
  explicit E2eeManagerSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeManagerSetEnabledResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeManagerGetFrameCryptorsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeManagerGetFrameCryptorsRequest) */ {
 public:
  inline E2eeManagerGetFrameCryptorsRequest() : E2eeManagerGetFrameCryptorsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeManagerGetFrameCryptorsRequest(const E2eeManagerGetFrameCryptorsRequest& from);
  E2eeManagerGetFrameCryptorsRequest(E2eeManagerGetFrameCryptorsRequest&& from) noexcept
    : E2eeManagerGetFrameCryptorsRequest() {
    *this = ::std::move(from);
  }

  inline E2eeManagerGetFrameCryptorsRequest& operator=(const E2eeManagerGetFrameCryptorsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeManagerGetFrameCryptorsRequest& operator=(E2eeManagerGetFrameCryptorsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeManagerGetFrameCryptorsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeManagerGetFrameCryptorsRequest* internal_default_instance() {
    return reinterpret_cast<const E2eeManagerGetFrameCryptorsRequest*>(
               &_E2eeManagerGetFrameCryptorsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(E2eeManagerGetFrameCryptorsRequest& a, E2eeManagerGetFrameCryptorsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeManagerGetFrameCryptorsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeManagerGetFrameCryptorsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeManagerGetFrameCryptorsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeManagerGetFrameCryptorsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const E2eeManagerGetFrameCryptorsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const E2eeManagerGetFrameCryptorsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeManagerGetFrameCryptorsRequest";
  }
  protected:
  explicit E2eeManagerGetFrameCryptorsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeManagerGetFrameCryptorsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeManagerGetFrameCryptorsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeManagerGetFrameCryptorsResponse) */ {
 public:
  inline E2eeManagerGetFrameCryptorsResponse() : E2eeManagerGetFrameCryptorsResponse(nullptr) {}
  ~E2eeManagerGetFrameCryptorsResponse() override;
  explicit PROTOBUF_CONSTEXPR E2eeManagerGetFrameCryptorsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeManagerGetFrameCryptorsResponse(const E2eeManagerGetFrameCryptorsResponse& from);
  E2eeManagerGetFrameCryptorsResponse(E2eeManagerGetFrameCryptorsResponse&& from) noexcept
    : E2eeManagerGetFrameCryptorsResponse() {
    *this = ::std::move(from);
  }

  inline E2eeManagerGetFrameCryptorsResponse& operator=(const E2eeManagerGetFrameCryptorsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeManagerGetFrameCryptorsResponse& operator=(E2eeManagerGetFrameCryptorsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeManagerGetFrameCryptorsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eeManagerGetFrameCryptorsResponse* internal_default_instance() {
    return reinterpret_cast<const E2eeManagerGetFrameCryptorsResponse*>(
               &_E2eeManagerGetFrameCryptorsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(E2eeManagerGetFrameCryptorsResponse& a, E2eeManagerGetFrameCryptorsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeManagerGetFrameCryptorsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeManagerGetFrameCryptorsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeManagerGetFrameCryptorsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeManagerGetFrameCryptorsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeManagerGetFrameCryptorsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeManagerGetFrameCryptorsResponse& from) {
    E2eeManagerGetFrameCryptorsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeManagerGetFrameCryptorsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeManagerGetFrameCryptorsResponse";
  }
  protected:
  explicit E2eeManagerGetFrameCryptorsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameCryptorsFieldNumber = 1,
  };
  // repeated .livekit.proto.FrameCryptor frame_cryptors = 1;
  int frame_cryptors_size() const;
  private:
  int _internal_frame_cryptors_size() const;
  public:
  void clear_frame_cryptors();
  ::livekit::proto::FrameCryptor* mutable_frame_cryptors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::FrameCryptor >*
      mutable_frame_cryptors();
  private:
  const ::livekit::proto::FrameCryptor& _internal_frame_cryptors(int index) const;
  ::livekit::proto::FrameCryptor* _internal_add_frame_cryptors();
  public:
  const ::livekit::proto::FrameCryptor& frame_cryptors(int index) const;
  ::livekit::proto::FrameCryptor* add_frame_cryptors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::FrameCryptor >&
      frame_cryptors() const;

  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeManagerGetFrameCryptorsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::FrameCryptor > frame_cryptors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class FrameCryptorSetEnabledRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.FrameCryptorSetEnabledRequest) */ {
 public:
  inline FrameCryptorSetEnabledRequest() : FrameCryptorSetEnabledRequest(nullptr) {}
  ~FrameCryptorSetEnabledRequest() override;
  explicit PROTOBUF_CONSTEXPR FrameCryptorSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameCryptorSetEnabledRequest(const FrameCryptorSetEnabledRequest& from);
  FrameCryptorSetEnabledRequest(FrameCryptorSetEnabledRequest&& from) noexcept
    : FrameCryptorSetEnabledRequest() {
    *this = ::std::move(from);
  }

  inline FrameCryptorSetEnabledRequest& operator=(const FrameCryptorSetEnabledRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameCryptorSetEnabledRequest& operator=(FrameCryptorSetEnabledRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameCryptorSetEnabledRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameCryptorSetEnabledRequest* internal_default_instance() {
    return reinterpret_cast<const FrameCryptorSetEnabledRequest*>(
               &_FrameCryptorSetEnabledRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FrameCryptorSetEnabledRequest& a, FrameCryptorSetEnabledRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameCryptorSetEnabledRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameCryptorSetEnabledRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameCryptorSetEnabledRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameCryptorSetEnabledRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameCryptorSetEnabledRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameCryptorSetEnabledRequest& from) {
    FrameCryptorSetEnabledRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameCryptorSetEnabledRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FrameCryptorSetEnabledRequest";
  }
  protected:
  explicit FrameCryptorSetEnabledRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kEnabledFieldNumber = 3,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // required bool enabled = 3;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.FrameCryptorSetEnabledRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class FrameCryptorSetEnabledResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.FrameCryptorSetEnabledResponse) */ {
 public:
  inline FrameCryptorSetEnabledResponse() : FrameCryptorSetEnabledResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FrameCryptorSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameCryptorSetEnabledResponse(const FrameCryptorSetEnabledResponse& from);
  FrameCryptorSetEnabledResponse(FrameCryptorSetEnabledResponse&& from) noexcept
    : FrameCryptorSetEnabledResponse() {
    *this = ::std::move(from);
  }

  inline FrameCryptorSetEnabledResponse& operator=(const FrameCryptorSetEnabledResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameCryptorSetEnabledResponse& operator=(FrameCryptorSetEnabledResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameCryptorSetEnabledResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameCryptorSetEnabledResponse* internal_default_instance() {
    return reinterpret_cast<const FrameCryptorSetEnabledResponse*>(
               &_FrameCryptorSetEnabledResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FrameCryptorSetEnabledResponse& a, FrameCryptorSetEnabledResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameCryptorSetEnabledResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameCryptorSetEnabledResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameCryptorSetEnabledResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameCryptorSetEnabledResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FrameCryptorSetEnabledResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FrameCryptorSetEnabledResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FrameCryptorSetEnabledResponse";
  }
  protected:
  explicit FrameCryptorSetEnabledResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.FrameCryptorSetEnabledResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class FrameCryptorSetKeyIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.FrameCryptorSetKeyIndexRequest) */ {
 public:
  inline FrameCryptorSetKeyIndexRequest() : FrameCryptorSetKeyIndexRequest(nullptr) {}
  ~FrameCryptorSetKeyIndexRequest() override;
  explicit PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameCryptorSetKeyIndexRequest(const FrameCryptorSetKeyIndexRequest& from);
  FrameCryptorSetKeyIndexRequest(FrameCryptorSetKeyIndexRequest&& from) noexcept
    : FrameCryptorSetKeyIndexRequest() {
    *this = ::std::move(from);
  }

  inline FrameCryptorSetKeyIndexRequest& operator=(const FrameCryptorSetKeyIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameCryptorSetKeyIndexRequest& operator=(FrameCryptorSetKeyIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameCryptorSetKeyIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameCryptorSetKeyIndexRequest* internal_default_instance() {
    return reinterpret_cast<const FrameCryptorSetKeyIndexRequest*>(
               &_FrameCryptorSetKeyIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FrameCryptorSetKeyIndexRequest& a, FrameCryptorSetKeyIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameCryptorSetKeyIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameCryptorSetKeyIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameCryptorSetKeyIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameCryptorSetKeyIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameCryptorSetKeyIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameCryptorSetKeyIndexRequest& from) {
    FrameCryptorSetKeyIndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameCryptorSetKeyIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FrameCryptorSetKeyIndexRequest";
  }
  protected:
  explicit FrameCryptorSetKeyIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kTrackSidFieldNumber = 2,
    kKeyIndexFieldNumber = 3,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required string track_sid = 2;
  bool has_track_sid() const;
  private:
  bool _internal_has_track_sid() const;
  public:
  void clear_track_sid();
  const std::string& track_sid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_track_sid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_track_sid();
  PROTOBUF_NODISCARD std::string* release_track_sid();
  void set_allocated_track_sid(std::string* track_sid);
  private:
  const std::string& _internal_track_sid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_sid(const std::string& value);
  std::string* _internal_mutable_track_sid();
  public:

  // required int32 key_index = 3;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.FrameCryptorSetKeyIndexRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr track_sid_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class FrameCryptorSetKeyIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.FrameCryptorSetKeyIndexResponse) */ {
 public:
  inline FrameCryptorSetKeyIndexResponse() : FrameCryptorSetKeyIndexResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR FrameCryptorSetKeyIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameCryptorSetKeyIndexResponse(const FrameCryptorSetKeyIndexResponse& from);
  FrameCryptorSetKeyIndexResponse(FrameCryptorSetKeyIndexResponse&& from) noexcept
    : FrameCryptorSetKeyIndexResponse() {
    *this = ::std::move(from);
  }

  inline FrameCryptorSetKeyIndexResponse& operator=(const FrameCryptorSetKeyIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameCryptorSetKeyIndexResponse& operator=(FrameCryptorSetKeyIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameCryptorSetKeyIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameCryptorSetKeyIndexResponse* internal_default_instance() {
    return reinterpret_cast<const FrameCryptorSetKeyIndexResponse*>(
               &_FrameCryptorSetKeyIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FrameCryptorSetKeyIndexResponse& a, FrameCryptorSetKeyIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameCryptorSetKeyIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameCryptorSetKeyIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameCryptorSetKeyIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameCryptorSetKeyIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FrameCryptorSetKeyIndexResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FrameCryptorSetKeyIndexResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.FrameCryptorSetKeyIndexResponse";
  }
  protected:
  explicit FrameCryptorSetKeyIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.FrameCryptorSetKeyIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class SetSharedKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetSharedKeyRequest) */ {
 public:
  inline SetSharedKeyRequest() : SetSharedKeyRequest(nullptr) {}
  ~SetSharedKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSharedKeyRequest(const SetSharedKeyRequest& from);
  SetSharedKeyRequest(SetSharedKeyRequest&& from) noexcept
    : SetSharedKeyRequest() {
    *this = ::std::move(from);
  }

  inline SetSharedKeyRequest& operator=(const SetSharedKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSharedKeyRequest& operator=(SetSharedKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSharedKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSharedKeyRequest* internal_default_instance() {
    return reinterpret_cast<const SetSharedKeyRequest*>(
               &_SetSharedKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetSharedKeyRequest& a, SetSharedKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSharedKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSharedKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSharedKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSharedKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSharedKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSharedKeyRequest& from) {
    SetSharedKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSharedKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetSharedKeyRequest";
  }
  protected:
  explicit SetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSharedKeyFieldNumber = 1,
    kKeyIndexFieldNumber = 2,
  };
  // required bytes shared_key = 1;
  bool has_shared_key() const;
  private:
  bool _internal_has_shared_key() const;
  public:
  void clear_shared_key();
  const std::string& shared_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shared_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shared_key();
  PROTOBUF_NODISCARD std::string* release_shared_key();
  void set_allocated_shared_key(std::string* shared_key);
  private:
  const std::string& _internal_shared_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shared_key(const std::string& value);
  std::string* _internal_mutable_shared_key();
  public:

  // required int32 key_index = 2;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetSharedKeyRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_key_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class SetSharedKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SetSharedKeyResponse) */ {
 public:
  inline SetSharedKeyResponse() : SetSharedKeyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSharedKeyResponse(const SetSharedKeyResponse& from);
  SetSharedKeyResponse(SetSharedKeyResponse&& from) noexcept
    : SetSharedKeyResponse() {
    *this = ::std::move(from);
  }

  inline SetSharedKeyResponse& operator=(const SetSharedKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSharedKeyResponse& operator=(SetSharedKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSharedKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSharedKeyResponse* internal_default_instance() {
    return reinterpret_cast<const SetSharedKeyResponse*>(
               &_SetSharedKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetSharedKeyResponse& a, SetSharedKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSharedKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSharedKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSharedKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSharedKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetSharedKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetSharedKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetSharedKeyResponse";
  }
  protected:
  explicit SetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SetSharedKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class RatchetSharedKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RatchetSharedKeyRequest) */ {
 public:
  inline RatchetSharedKeyRequest() : RatchetSharedKeyRequest(nullptr) {}
  ~RatchetSharedKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RatchetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RatchetSharedKeyRequest(const RatchetSharedKeyRequest& from);
  RatchetSharedKeyRequest(RatchetSharedKeyRequest&& from) noexcept
    : RatchetSharedKeyRequest() {
    *this = ::std::move(from);
  }

  inline RatchetSharedKeyRequest& operator=(const RatchetSharedKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatchetSharedKeyRequest& operator=(RatchetSharedKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RatchetSharedKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RatchetSharedKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RatchetSharedKeyRequest*>(
               &_RatchetSharedKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RatchetSharedKeyRequest& a, RatchetSharedKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RatchetSharedKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatchetSharedKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RatchetSharedKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RatchetSharedKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RatchetSharedKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RatchetSharedKeyRequest& from) {
    RatchetSharedKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatchetSharedKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RatchetSharedKeyRequest";
  }
  protected:
  explicit RatchetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIndexFieldNumber = 1,
  };
  // required int32 key_index = 1;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RatchetSharedKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class RatchetSharedKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RatchetSharedKeyResponse) */ {
 public:
  inline RatchetSharedKeyResponse() : RatchetSharedKeyResponse(nullptr) {}
  ~RatchetSharedKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RatchetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RatchetSharedKeyResponse(const RatchetSharedKeyResponse& from);
  RatchetSharedKeyResponse(RatchetSharedKeyResponse&& from) noexcept
    : RatchetSharedKeyResponse() {
    *this = ::std::move(from);
  }

  inline RatchetSharedKeyResponse& operator=(const RatchetSharedKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatchetSharedKeyResponse& operator=(RatchetSharedKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RatchetSharedKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RatchetSharedKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RatchetSharedKeyResponse*>(
               &_RatchetSharedKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RatchetSharedKeyResponse& a, RatchetSharedKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RatchetSharedKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatchetSharedKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RatchetSharedKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RatchetSharedKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RatchetSharedKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RatchetSharedKeyResponse& from) {
    RatchetSharedKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatchetSharedKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RatchetSharedKeyResponse";
  }
  protected:
  explicit RatchetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewKeyFieldNumber = 1,
  };
  // optional bytes new_key = 1;
  bool has_new_key() const;
  private:
  bool _internal_has_new_key() const;
  public:
  void clear_new_key();
  const std::string& new_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_key();
  PROTOBUF_NODISCARD std::string* release_new_key();
  void set_allocated_new_key(std::string* new_key);
  private:
  const std::string& _internal_new_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_key(const std::string& value);
  std::string* _internal_mutable_new_key();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RatchetSharedKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class GetSharedKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSharedKeyRequest) */ {
 public:
  inline GetSharedKeyRequest() : GetSharedKeyRequest(nullptr) {}
  ~GetSharedKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSharedKeyRequest(const GetSharedKeyRequest& from);
  GetSharedKeyRequest(GetSharedKeyRequest&& from) noexcept
    : GetSharedKeyRequest() {
    *this = ::std::move(from);
  }

  inline GetSharedKeyRequest& operator=(const GetSharedKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSharedKeyRequest& operator=(GetSharedKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSharedKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSharedKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetSharedKeyRequest*>(
               &_GetSharedKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetSharedKeyRequest& a, GetSharedKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSharedKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSharedKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSharedKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSharedKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSharedKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSharedKeyRequest& from) {
    GetSharedKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSharedKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSharedKeyRequest";
  }
  protected:
  explicit GetSharedKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIndexFieldNumber = 1,
  };
  // required int32 key_index = 1;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetSharedKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class GetSharedKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetSharedKeyResponse) */ {
 public:
  inline GetSharedKeyResponse() : GetSharedKeyResponse(nullptr) {}
  ~GetSharedKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSharedKeyResponse(const GetSharedKeyResponse& from);
  GetSharedKeyResponse(GetSharedKeyResponse&& from) noexcept
    : GetSharedKeyResponse() {
    *this = ::std::move(from);
  }

  inline GetSharedKeyResponse& operator=(const GetSharedKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSharedKeyResponse& operator=(GetSharedKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSharedKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSharedKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GetSharedKeyResponse*>(
               &_GetSharedKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetSharedKeyResponse& a, GetSharedKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSharedKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSharedKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSharedKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSharedKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSharedKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSharedKeyResponse& from) {
    GetSharedKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSharedKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetSharedKeyResponse";
  }
  protected:
  explicit GetSharedKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetSharedKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class SetKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.SetKeyRequest) */ {
 public:
  inline SetKeyRequest() : SetKeyRequest(nullptr) {}
  ~SetKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR SetKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetKeyRequest(const SetKeyRequest& from);
  SetKeyRequest(SetKeyRequest&& from) noexcept
    : SetKeyRequest() {
    *this = ::std::move(from);
  }

  inline SetKeyRequest& operator=(const SetKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetKeyRequest& operator=(SetKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetKeyRequest* internal_default_instance() {
    return reinterpret_cast<const SetKeyRequest*>(
               &_SetKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetKeyRequest& a, SetKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetKeyRequest& from) {
    SetKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetKeyRequest";
  }
  protected:
  explicit SetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kKeyFieldNumber = 2,
    kKeyIndexFieldNumber = 3,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required int32 key_index = 3;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.SetKeyRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class SetKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:livekit.proto.SetKeyResponse) */ {
 public:
  inline SetKeyResponse() : SetKeyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetKeyResponse(const SetKeyResponse& from);
  SetKeyResponse(SetKeyResponse&& from) noexcept
    : SetKeyResponse() {
    *this = ::std::move(from);
  }

  inline SetKeyResponse& operator=(const SetKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetKeyResponse& operator=(SetKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetKeyResponse* internal_default_instance() {
    return reinterpret_cast<const SetKeyResponse*>(
               &_SetKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetKeyResponse& a, SetKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetKeyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.SetKeyResponse";
  }
  protected:
  explicit SetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:livekit.proto.SetKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class RatchetKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RatchetKeyRequest) */ {
 public:
  inline RatchetKeyRequest() : RatchetKeyRequest(nullptr) {}
  ~RatchetKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RatchetKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RatchetKeyRequest(const RatchetKeyRequest& from);
  RatchetKeyRequest(RatchetKeyRequest&& from) noexcept
    : RatchetKeyRequest() {
    *this = ::std::move(from);
  }

  inline RatchetKeyRequest& operator=(const RatchetKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatchetKeyRequest& operator=(RatchetKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RatchetKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RatchetKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RatchetKeyRequest*>(
               &_RatchetKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RatchetKeyRequest& a, RatchetKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RatchetKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatchetKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RatchetKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RatchetKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RatchetKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RatchetKeyRequest& from) {
    RatchetKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatchetKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RatchetKeyRequest";
  }
  protected:
  explicit RatchetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kKeyIndexFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required int32 key_index = 2;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RatchetKeyRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class RatchetKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.RatchetKeyResponse) */ {
 public:
  inline RatchetKeyResponse() : RatchetKeyResponse(nullptr) {}
  ~RatchetKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RatchetKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RatchetKeyResponse(const RatchetKeyResponse& from);
  RatchetKeyResponse(RatchetKeyResponse&& from) noexcept
    : RatchetKeyResponse() {
    *this = ::std::move(from);
  }

  inline RatchetKeyResponse& operator=(const RatchetKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RatchetKeyResponse& operator=(RatchetKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RatchetKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RatchetKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RatchetKeyResponse*>(
               &_RatchetKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RatchetKeyResponse& a, RatchetKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RatchetKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RatchetKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RatchetKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RatchetKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RatchetKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RatchetKeyResponse& from) {
    RatchetKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RatchetKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.RatchetKeyResponse";
  }
  protected:
  explicit RatchetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewKeyFieldNumber = 1,
  };
  // optional bytes new_key = 1;
  bool has_new_key() const;
  private:
  bool _internal_has_new_key() const;
  public:
  void clear_new_key();
  const std::string& new_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_key();
  PROTOBUF_NODISCARD std::string* release_new_key();
  void set_allocated_new_key(std::string* new_key);
  private:
  const std::string& _internal_new_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_key(const std::string& value);
  std::string* _internal_mutable_new_key();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.RatchetKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class GetKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetKeyRequest) */ {
 public:
  inline GetKeyRequest() : GetKeyRequest(nullptr) {}
  ~GetKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR GetKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKeyRequest(const GetKeyRequest& from);
  GetKeyRequest(GetKeyRequest&& from) noexcept
    : GetKeyRequest() {
    *this = ::std::move(from);
  }

  inline GetKeyRequest& operator=(const GetKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyRequest& operator=(GetKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyRequest*>(
               &_GetKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetKeyRequest& a, GetKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetKeyRequest& from) {
    GetKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetKeyRequest";
  }
  protected:
  explicit GetKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantIdentityFieldNumber = 1,
    kKeyIndexFieldNumber = 2,
  };
  // required string participant_identity = 1;
  bool has_participant_identity() const;
  private:
  bool _internal_has_participant_identity() const;
  public:
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // required int32 key_index = 2;
  bool has_key_index() const;
  private:
  bool _internal_has_key_index() const;
  public:
  void clear_key_index();
  int32_t key_index() const;
  void set_key_index(int32_t value);
  private:
  int32_t _internal_key_index() const;
  void _internal_set_key_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetKeyRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int32_t key_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class GetKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.GetKeyResponse) */ {
 public:
  inline GetKeyResponse() : GetKeyResponse(nullptr) {}
  ~GetKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR GetKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKeyResponse(const GetKeyResponse& from);
  GetKeyResponse(GetKeyResponse&& from) noexcept
    : GetKeyResponse() {
    *this = ::std::move(from);
  }

  inline GetKeyResponse& operator=(const GetKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKeyResponse& operator=(GetKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyResponse*>(
               &_GetKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetKeyResponse& a, GetKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetKeyResponse& from) {
    GetKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.GetKeyResponse";
  }
  protected:
  explicit GetKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:livekit.proto.GetKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeRequest) */ {
 public:
  inline E2eeRequest() : E2eeRequest(nullptr) {}
  ~E2eeRequest() override;
  explicit PROTOBUF_CONSTEXPR E2eeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeRequest(const E2eeRequest& from);
  E2eeRequest(E2eeRequest&& from) noexcept
    : E2eeRequest() {
    *this = ::std::move(from);
  }

  inline E2eeRequest& operator=(const E2eeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeRequest& operator=(E2eeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeRequest& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kManagerSetEnabled = 2,
    kManagerGetFrameCryptors = 3,
    kCryptorSetEnabled = 4,
    kCryptorSetKeyIndex = 5,
    kSetSharedKey = 6,
    kRatchetSharedKey = 7,
    kGetSharedKey = 8,
    kSetKey = 9,
    kRatchetKey = 10,
    kGetKey = 11,
    MESSAGE_NOT_SET = 0,
  };

  static inline const E2eeRequest* internal_default_instance() {
    return reinterpret_cast<const E2eeRequest*>(
               &_E2eeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(E2eeRequest& a, E2eeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeRequest& from) {
    E2eeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeRequest";
  }
  protected:
  explicit E2eeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomHandleFieldNumber = 1,
    kManagerSetEnabledFieldNumber = 2,
    kManagerGetFrameCryptorsFieldNumber = 3,
    kCryptorSetEnabledFieldNumber = 4,
    kCryptorSetKeyIndexFieldNumber = 5,
    kSetSharedKeyFieldNumber = 6,
    kRatchetSharedKeyFieldNumber = 7,
    kGetSharedKeyFieldNumber = 8,
    kSetKeyFieldNumber = 9,
    kRatchetKeyFieldNumber = 10,
    kGetKeyFieldNumber = 11,
  };
  // required uint64 room_handle = 1;
  bool has_room_handle() const;
  private:
  bool _internal_has_room_handle() const;
  public:
  void clear_room_handle();
  uint64_t room_handle() const;
  void set_room_handle(uint64_t value);
  private:
  uint64_t _internal_room_handle() const;
  void _internal_set_room_handle(uint64_t value);
  public:

  // .livekit.proto.E2eeManagerSetEnabledRequest manager_set_enabled = 2;
  bool has_manager_set_enabled() const;
  private:
  bool _internal_has_manager_set_enabled() const;
  public:
  void clear_manager_set_enabled();
  const ::livekit::proto::E2eeManagerSetEnabledRequest& manager_set_enabled() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeManagerSetEnabledRequest* release_manager_set_enabled();
  ::livekit::proto::E2eeManagerSetEnabledRequest* mutable_manager_set_enabled();
  void set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledRequest* manager_set_enabled);
  private:
  const ::livekit::proto::E2eeManagerSetEnabledRequest& _internal_manager_set_enabled() const;
  ::livekit::proto::E2eeManagerSetEnabledRequest* _internal_mutable_manager_set_enabled();
  public:
  void unsafe_arena_set_allocated_manager_set_enabled(
      ::livekit::proto::E2eeManagerSetEnabledRequest* manager_set_enabled);
  ::livekit::proto::E2eeManagerSetEnabledRequest* unsafe_arena_release_manager_set_enabled();

  // .livekit.proto.E2eeManagerGetFrameCryptorsRequest manager_get_frame_cryptors = 3;
  bool has_manager_get_frame_cryptors() const;
  private:
  bool _internal_has_manager_get_frame_cryptors() const;
  public:
  void clear_manager_get_frame_cryptors();
  const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest& manager_get_frame_cryptors() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* release_manager_get_frame_cryptors();
  ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* mutable_manager_get_frame_cryptors();
  void set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsRequest* manager_get_frame_cryptors);
  private:
  const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest& _internal_manager_get_frame_cryptors() const;
  ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* _internal_mutable_manager_get_frame_cryptors();
  public:
  void unsafe_arena_set_allocated_manager_get_frame_cryptors(
      ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* manager_get_frame_cryptors);
  ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* unsafe_arena_release_manager_get_frame_cryptors();

  // .livekit.proto.FrameCryptorSetEnabledRequest cryptor_set_enabled = 4;
  bool has_cryptor_set_enabled() const;
  private:
  bool _internal_has_cryptor_set_enabled() const;
  public:
  void clear_cryptor_set_enabled();
  const ::livekit::proto::FrameCryptorSetEnabledRequest& cryptor_set_enabled() const;
  PROTOBUF_NODISCARD ::livekit::proto::FrameCryptorSetEnabledRequest* release_cryptor_set_enabled();
  ::livekit::proto::FrameCryptorSetEnabledRequest* mutable_cryptor_set_enabled();
  void set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledRequest* cryptor_set_enabled);
  private:
  const ::livekit::proto::FrameCryptorSetEnabledRequest& _internal_cryptor_set_enabled() const;
  ::livekit::proto::FrameCryptorSetEnabledRequest* _internal_mutable_cryptor_set_enabled();
  public:
  void unsafe_arena_set_allocated_cryptor_set_enabled(
      ::livekit::proto::FrameCryptorSetEnabledRequest* cryptor_set_enabled);
  ::livekit::proto::FrameCryptorSetEnabledRequest* unsafe_arena_release_cryptor_set_enabled();

  // .livekit.proto.FrameCryptorSetKeyIndexRequest cryptor_set_key_index = 5;
  bool has_cryptor_set_key_index() const;
  private:
  bool _internal_has_cryptor_set_key_index() const;
  public:
  void clear_cryptor_set_key_index();
  const ::livekit::proto::FrameCryptorSetKeyIndexRequest& cryptor_set_key_index() const;
  PROTOBUF_NODISCARD ::livekit::proto::FrameCryptorSetKeyIndexRequest* release_cryptor_set_key_index();
  ::livekit::proto::FrameCryptorSetKeyIndexRequest* mutable_cryptor_set_key_index();
  void set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexRequest* cryptor_set_key_index);
  private:
  const ::livekit::proto::FrameCryptorSetKeyIndexRequest& _internal_cryptor_set_key_index() const;
  ::livekit::proto::FrameCryptorSetKeyIndexRequest* _internal_mutable_cryptor_set_key_index();
  public:
  void unsafe_arena_set_allocated_cryptor_set_key_index(
      ::livekit::proto::FrameCryptorSetKeyIndexRequest* cryptor_set_key_index);
  ::livekit::proto::FrameCryptorSetKeyIndexRequest* unsafe_arena_release_cryptor_set_key_index();

  // .livekit.proto.SetSharedKeyRequest set_shared_key = 6;
  bool has_set_shared_key() const;
  private:
  bool _internal_has_set_shared_key() const;
  public:
  void clear_set_shared_key();
  const ::livekit::proto::SetSharedKeyRequest& set_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::SetSharedKeyRequest* release_set_shared_key();
  ::livekit::proto::SetSharedKeyRequest* mutable_set_shared_key();
  void set_allocated_set_shared_key(::livekit::proto::SetSharedKeyRequest* set_shared_key);
  private:
  const ::livekit::proto::SetSharedKeyRequest& _internal_set_shared_key() const;
  ::livekit::proto::SetSharedKeyRequest* _internal_mutable_set_shared_key();
  public:
  void unsafe_arena_set_allocated_set_shared_key(
      ::livekit::proto::SetSharedKeyRequest* set_shared_key);
  ::livekit::proto::SetSharedKeyRequest* unsafe_arena_release_set_shared_key();

  // .livekit.proto.RatchetSharedKeyRequest ratchet_shared_key = 7;
  bool has_ratchet_shared_key() const;
  private:
  bool _internal_has_ratchet_shared_key() const;
  public:
  void clear_ratchet_shared_key();
  const ::livekit::proto::RatchetSharedKeyRequest& ratchet_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::RatchetSharedKeyRequest* release_ratchet_shared_key();
  ::livekit::proto::RatchetSharedKeyRequest* mutable_ratchet_shared_key();
  void set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyRequest* ratchet_shared_key);
  private:
  const ::livekit::proto::RatchetSharedKeyRequest& _internal_ratchet_shared_key() const;
  ::livekit::proto::RatchetSharedKeyRequest* _internal_mutable_ratchet_shared_key();
  public:
  void unsafe_arena_set_allocated_ratchet_shared_key(
      ::livekit::proto::RatchetSharedKeyRequest* ratchet_shared_key);
  ::livekit::proto::RatchetSharedKeyRequest* unsafe_arena_release_ratchet_shared_key();

  // .livekit.proto.GetSharedKeyRequest get_shared_key = 8;
  bool has_get_shared_key() const;
  private:
  bool _internal_has_get_shared_key() const;
  public:
  void clear_get_shared_key();
  const ::livekit::proto::GetSharedKeyRequest& get_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::GetSharedKeyRequest* release_get_shared_key();
  ::livekit::proto::GetSharedKeyRequest* mutable_get_shared_key();
  void set_allocated_get_shared_key(::livekit::proto::GetSharedKeyRequest* get_shared_key);
  private:
  const ::livekit::proto::GetSharedKeyRequest& _internal_get_shared_key() const;
  ::livekit::proto::GetSharedKeyRequest* _internal_mutable_get_shared_key();
  public:
  void unsafe_arena_set_allocated_get_shared_key(
      ::livekit::proto::GetSharedKeyRequest* get_shared_key);
  ::livekit::proto::GetSharedKeyRequest* unsafe_arena_release_get_shared_key();

  // .livekit.proto.SetKeyRequest set_key = 9;
  bool has_set_key() const;
  private:
  bool _internal_has_set_key() const;
  public:
  void clear_set_key();
  const ::livekit::proto::SetKeyRequest& set_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::SetKeyRequest* release_set_key();
  ::livekit::proto::SetKeyRequest* mutable_set_key();
  void set_allocated_set_key(::livekit::proto::SetKeyRequest* set_key);
  private:
  const ::livekit::proto::SetKeyRequest& _internal_set_key() const;
  ::livekit::proto::SetKeyRequest* _internal_mutable_set_key();
  public:
  void unsafe_arena_set_allocated_set_key(
      ::livekit::proto::SetKeyRequest* set_key);
  ::livekit::proto::SetKeyRequest* unsafe_arena_release_set_key();

  // .livekit.proto.RatchetKeyRequest ratchet_key = 10;
  bool has_ratchet_key() const;
  private:
  bool _internal_has_ratchet_key() const;
  public:
  void clear_ratchet_key();
  const ::livekit::proto::RatchetKeyRequest& ratchet_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::RatchetKeyRequest* release_ratchet_key();
  ::livekit::proto::RatchetKeyRequest* mutable_ratchet_key();
  void set_allocated_ratchet_key(::livekit::proto::RatchetKeyRequest* ratchet_key);
  private:
  const ::livekit::proto::RatchetKeyRequest& _internal_ratchet_key() const;
  ::livekit::proto::RatchetKeyRequest* _internal_mutable_ratchet_key();
  public:
  void unsafe_arena_set_allocated_ratchet_key(
      ::livekit::proto::RatchetKeyRequest* ratchet_key);
  ::livekit::proto::RatchetKeyRequest* unsafe_arena_release_ratchet_key();

  // .livekit.proto.GetKeyRequest get_key = 11;
  bool has_get_key() const;
  private:
  bool _internal_has_get_key() const;
  public:
  void clear_get_key();
  const ::livekit::proto::GetKeyRequest& get_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::GetKeyRequest* release_get_key();
  ::livekit::proto::GetKeyRequest* mutable_get_key();
  void set_allocated_get_key(::livekit::proto::GetKeyRequest* get_key);
  private:
  const ::livekit::proto::GetKeyRequest& _internal_get_key() const;
  ::livekit::proto::GetKeyRequest* _internal_mutable_get_key();
  public:
  void unsafe_arena_set_allocated_get_key(
      ::livekit::proto::GetKeyRequest* get_key);
  ::livekit::proto::GetKeyRequest* unsafe_arena_release_get_key();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeRequest)
 private:
  class _Internal;
  void set_has_manager_set_enabled();
  void set_has_manager_get_frame_cryptors();
  void set_has_cryptor_set_enabled();
  void set_has_cryptor_set_key_index();
  void set_has_set_shared_key();
  void set_has_ratchet_shared_key();
  void set_has_get_shared_key();
  void set_has_set_key();
  void set_has_ratchet_key();
  void set_has_get_key();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t room_handle_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::E2eeManagerSetEnabledRequest* manager_set_enabled_;
      ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* manager_get_frame_cryptors_;
      ::livekit::proto::FrameCryptorSetEnabledRequest* cryptor_set_enabled_;
      ::livekit::proto::FrameCryptorSetKeyIndexRequest* cryptor_set_key_index_;
      ::livekit::proto::SetSharedKeyRequest* set_shared_key_;
      ::livekit::proto::RatchetSharedKeyRequest* ratchet_shared_key_;
      ::livekit::proto::GetSharedKeyRequest* get_shared_key_;
      ::livekit::proto::SetKeyRequest* set_key_;
      ::livekit::proto::RatchetKeyRequest* ratchet_key_;
      ::livekit::proto::GetKeyRequest* get_key_;
    } message_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// -------------------------------------------------------------------

class E2eeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.proto.E2eeResponse) */ {
 public:
  inline E2eeResponse() : E2eeResponse(nullptr) {}
  ~E2eeResponse() override;
  explicit PROTOBUF_CONSTEXPR E2eeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eeResponse(const E2eeResponse& from);
  E2eeResponse(E2eeResponse&& from) noexcept
    : E2eeResponse() {
    *this = ::std::move(from);
  }

  inline E2eeResponse& operator=(const E2eeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eeResponse& operator=(E2eeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eeResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kManagerSetEnabled = 1,
    kManagerGetFrameCryptors = 2,
    kCryptorSetEnabled = 3,
    kCryptorSetKeyIndex = 4,
    kSetSharedKey = 5,
    kRatchetSharedKey = 6,
    kGetSharedKey = 7,
    kSetKey = 8,
    kRatchetKey = 9,
    kGetKey = 10,
    MESSAGE_NOT_SET = 0,
  };

  static inline const E2eeResponse* internal_default_instance() {
    return reinterpret_cast<const E2eeResponse*>(
               &_E2eeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(E2eeResponse& a, E2eeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eeResponse& from) {
    E2eeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.proto.E2eeResponse";
  }
  protected:
  explicit E2eeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagerSetEnabledFieldNumber = 1,
    kManagerGetFrameCryptorsFieldNumber = 2,
    kCryptorSetEnabledFieldNumber = 3,
    kCryptorSetKeyIndexFieldNumber = 4,
    kSetSharedKeyFieldNumber = 5,
    kRatchetSharedKeyFieldNumber = 6,
    kGetSharedKeyFieldNumber = 7,
    kSetKeyFieldNumber = 8,
    kRatchetKeyFieldNumber = 9,
    kGetKeyFieldNumber = 10,
  };
  // .livekit.proto.E2eeManagerSetEnabledResponse manager_set_enabled = 1;
  bool has_manager_set_enabled() const;
  private:
  bool _internal_has_manager_set_enabled() const;
  public:
  void clear_manager_set_enabled();
  const ::livekit::proto::E2eeManagerSetEnabledResponse& manager_set_enabled() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeManagerSetEnabledResponse* release_manager_set_enabled();
  ::livekit::proto::E2eeManagerSetEnabledResponse* mutable_manager_set_enabled();
  void set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledResponse* manager_set_enabled);
  private:
  const ::livekit::proto::E2eeManagerSetEnabledResponse& _internal_manager_set_enabled() const;
  ::livekit::proto::E2eeManagerSetEnabledResponse* _internal_mutable_manager_set_enabled();
  public:
  void unsafe_arena_set_allocated_manager_set_enabled(
      ::livekit::proto::E2eeManagerSetEnabledResponse* manager_set_enabled);
  ::livekit::proto::E2eeManagerSetEnabledResponse* unsafe_arena_release_manager_set_enabled();

  // .livekit.proto.E2eeManagerGetFrameCryptorsResponse manager_get_frame_cryptors = 2;
  bool has_manager_get_frame_cryptors() const;
  private:
  bool _internal_has_manager_get_frame_cryptors() const;
  public:
  void clear_manager_get_frame_cryptors();
  const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse& manager_get_frame_cryptors() const;
  PROTOBUF_NODISCARD ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* release_manager_get_frame_cryptors();
  ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* mutable_manager_get_frame_cryptors();
  void set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsResponse* manager_get_frame_cryptors);
  private:
  const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse& _internal_manager_get_frame_cryptors() const;
  ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* _internal_mutable_manager_get_frame_cryptors();
  public:
  void unsafe_arena_set_allocated_manager_get_frame_cryptors(
      ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* manager_get_frame_cryptors);
  ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* unsafe_arena_release_manager_get_frame_cryptors();

  // .livekit.proto.FrameCryptorSetEnabledResponse cryptor_set_enabled = 3;
  bool has_cryptor_set_enabled() const;
  private:
  bool _internal_has_cryptor_set_enabled() const;
  public:
  void clear_cryptor_set_enabled();
  const ::livekit::proto::FrameCryptorSetEnabledResponse& cryptor_set_enabled() const;
  PROTOBUF_NODISCARD ::livekit::proto::FrameCryptorSetEnabledResponse* release_cryptor_set_enabled();
  ::livekit::proto::FrameCryptorSetEnabledResponse* mutable_cryptor_set_enabled();
  void set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledResponse* cryptor_set_enabled);
  private:
  const ::livekit::proto::FrameCryptorSetEnabledResponse& _internal_cryptor_set_enabled() const;
  ::livekit::proto::FrameCryptorSetEnabledResponse* _internal_mutable_cryptor_set_enabled();
  public:
  void unsafe_arena_set_allocated_cryptor_set_enabled(
      ::livekit::proto::FrameCryptorSetEnabledResponse* cryptor_set_enabled);
  ::livekit::proto::FrameCryptorSetEnabledResponse* unsafe_arena_release_cryptor_set_enabled();

  // .livekit.proto.FrameCryptorSetKeyIndexResponse cryptor_set_key_index = 4;
  bool has_cryptor_set_key_index() const;
  private:
  bool _internal_has_cryptor_set_key_index() const;
  public:
  void clear_cryptor_set_key_index();
  const ::livekit::proto::FrameCryptorSetKeyIndexResponse& cryptor_set_key_index() const;
  PROTOBUF_NODISCARD ::livekit::proto::FrameCryptorSetKeyIndexResponse* release_cryptor_set_key_index();
  ::livekit::proto::FrameCryptorSetKeyIndexResponse* mutable_cryptor_set_key_index();
  void set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexResponse* cryptor_set_key_index);
  private:
  const ::livekit::proto::FrameCryptorSetKeyIndexResponse& _internal_cryptor_set_key_index() const;
  ::livekit::proto::FrameCryptorSetKeyIndexResponse* _internal_mutable_cryptor_set_key_index();
  public:
  void unsafe_arena_set_allocated_cryptor_set_key_index(
      ::livekit::proto::FrameCryptorSetKeyIndexResponse* cryptor_set_key_index);
  ::livekit::proto::FrameCryptorSetKeyIndexResponse* unsafe_arena_release_cryptor_set_key_index();

  // .livekit.proto.SetSharedKeyResponse set_shared_key = 5;
  bool has_set_shared_key() const;
  private:
  bool _internal_has_set_shared_key() const;
  public:
  void clear_set_shared_key();
  const ::livekit::proto::SetSharedKeyResponse& set_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::SetSharedKeyResponse* release_set_shared_key();
  ::livekit::proto::SetSharedKeyResponse* mutable_set_shared_key();
  void set_allocated_set_shared_key(::livekit::proto::SetSharedKeyResponse* set_shared_key);
  private:
  const ::livekit::proto::SetSharedKeyResponse& _internal_set_shared_key() const;
  ::livekit::proto::SetSharedKeyResponse* _internal_mutable_set_shared_key();
  public:
  void unsafe_arena_set_allocated_set_shared_key(
      ::livekit::proto::SetSharedKeyResponse* set_shared_key);
  ::livekit::proto::SetSharedKeyResponse* unsafe_arena_release_set_shared_key();

  // .livekit.proto.RatchetSharedKeyResponse ratchet_shared_key = 6;
  bool has_ratchet_shared_key() const;
  private:
  bool _internal_has_ratchet_shared_key() const;
  public:
  void clear_ratchet_shared_key();
  const ::livekit::proto::RatchetSharedKeyResponse& ratchet_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::RatchetSharedKeyResponse* release_ratchet_shared_key();
  ::livekit::proto::RatchetSharedKeyResponse* mutable_ratchet_shared_key();
  void set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyResponse* ratchet_shared_key);
  private:
  const ::livekit::proto::RatchetSharedKeyResponse& _internal_ratchet_shared_key() const;
  ::livekit::proto::RatchetSharedKeyResponse* _internal_mutable_ratchet_shared_key();
  public:
  void unsafe_arena_set_allocated_ratchet_shared_key(
      ::livekit::proto::RatchetSharedKeyResponse* ratchet_shared_key);
  ::livekit::proto::RatchetSharedKeyResponse* unsafe_arena_release_ratchet_shared_key();

  // .livekit.proto.GetSharedKeyResponse get_shared_key = 7;
  bool has_get_shared_key() const;
  private:
  bool _internal_has_get_shared_key() const;
  public:
  void clear_get_shared_key();
  const ::livekit::proto::GetSharedKeyResponse& get_shared_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::GetSharedKeyResponse* release_get_shared_key();
  ::livekit::proto::GetSharedKeyResponse* mutable_get_shared_key();
  void set_allocated_get_shared_key(::livekit::proto::GetSharedKeyResponse* get_shared_key);
  private:
  const ::livekit::proto::GetSharedKeyResponse& _internal_get_shared_key() const;
  ::livekit::proto::GetSharedKeyResponse* _internal_mutable_get_shared_key();
  public:
  void unsafe_arena_set_allocated_get_shared_key(
      ::livekit::proto::GetSharedKeyResponse* get_shared_key);
  ::livekit::proto::GetSharedKeyResponse* unsafe_arena_release_get_shared_key();

  // .livekit.proto.SetKeyResponse set_key = 8;
  bool has_set_key() const;
  private:
  bool _internal_has_set_key() const;
  public:
  void clear_set_key();
  const ::livekit::proto::SetKeyResponse& set_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::SetKeyResponse* release_set_key();
  ::livekit::proto::SetKeyResponse* mutable_set_key();
  void set_allocated_set_key(::livekit::proto::SetKeyResponse* set_key);
  private:
  const ::livekit::proto::SetKeyResponse& _internal_set_key() const;
  ::livekit::proto::SetKeyResponse* _internal_mutable_set_key();
  public:
  void unsafe_arena_set_allocated_set_key(
      ::livekit::proto::SetKeyResponse* set_key);
  ::livekit::proto::SetKeyResponse* unsafe_arena_release_set_key();

  // .livekit.proto.RatchetKeyResponse ratchet_key = 9;
  bool has_ratchet_key() const;
  private:
  bool _internal_has_ratchet_key() const;
  public:
  void clear_ratchet_key();
  const ::livekit::proto::RatchetKeyResponse& ratchet_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::RatchetKeyResponse* release_ratchet_key();
  ::livekit::proto::RatchetKeyResponse* mutable_ratchet_key();
  void set_allocated_ratchet_key(::livekit::proto::RatchetKeyResponse* ratchet_key);
  private:
  const ::livekit::proto::RatchetKeyResponse& _internal_ratchet_key() const;
  ::livekit::proto::RatchetKeyResponse* _internal_mutable_ratchet_key();
  public:
  void unsafe_arena_set_allocated_ratchet_key(
      ::livekit::proto::RatchetKeyResponse* ratchet_key);
  ::livekit::proto::RatchetKeyResponse* unsafe_arena_release_ratchet_key();

  // .livekit.proto.GetKeyResponse get_key = 10;
  bool has_get_key() const;
  private:
  bool _internal_has_get_key() const;
  public:
  void clear_get_key();
  const ::livekit::proto::GetKeyResponse& get_key() const;
  PROTOBUF_NODISCARD ::livekit::proto::GetKeyResponse* release_get_key();
  ::livekit::proto::GetKeyResponse* mutable_get_key();
  void set_allocated_get_key(::livekit::proto::GetKeyResponse* get_key);
  private:
  const ::livekit::proto::GetKeyResponse& _internal_get_key() const;
  ::livekit::proto::GetKeyResponse* _internal_mutable_get_key();
  public:
  void unsafe_arena_set_allocated_get_key(
      ::livekit::proto::GetKeyResponse* get_key);
  ::livekit::proto::GetKeyResponse* unsafe_arena_release_get_key();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.proto.E2eeResponse)
 private:
  class _Internal;
  void set_has_manager_set_enabled();
  void set_has_manager_get_frame_cryptors();
  void set_has_cryptor_set_enabled();
  void set_has_cryptor_set_key_index();
  void set_has_set_shared_key();
  void set_has_ratchet_shared_key();
  void set_has_get_shared_key();
  void set_has_set_key();
  void set_has_ratchet_key();
  void set_has_get_key();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::proto::E2eeManagerSetEnabledResponse* manager_set_enabled_;
      ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* manager_get_frame_cryptors_;
      ::livekit::proto::FrameCryptorSetEnabledResponse* cryptor_set_enabled_;
      ::livekit::proto::FrameCryptorSetKeyIndexResponse* cryptor_set_key_index_;
      ::livekit::proto::SetSharedKeyResponse* set_shared_key_;
      ::livekit::proto::RatchetSharedKeyResponse* ratchet_shared_key_;
      ::livekit::proto::GetSharedKeyResponse* get_shared_key_;
      ::livekit::proto::SetKeyResponse* set_key_;
      ::livekit::proto::RatchetKeyResponse* ratchet_key_;
      ::livekit::proto::GetKeyResponse* get_key_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2ee_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameCryptor

// required string participant_identity = 1;
inline bool FrameCryptor::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameCryptor::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void FrameCryptor::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameCryptor::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptor.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptor::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptor.participant_identity)
}
inline std::string* FrameCryptor::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptor.participant_identity)
  return _s;
}
inline const std::string& FrameCryptor::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void FrameCryptor::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptor::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptor::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptor.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptor::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptor.participant_identity)
}

// required string track_sid = 2;
inline bool FrameCryptor::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameCryptor::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void FrameCryptor::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FrameCryptor::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptor.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptor::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptor.track_sid)
}
inline std::string* FrameCryptor::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptor.track_sid)
  return _s;
}
inline const std::string& FrameCryptor::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void FrameCryptor::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptor::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptor::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptor.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptor::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptor.track_sid)
}

// required int32 key_index = 3;
inline bool FrameCryptor::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FrameCryptor::has_key_index() const {
  return _internal_has_key_index();
}
inline void FrameCryptor::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t FrameCryptor::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t FrameCryptor::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptor.key_index)
  return _internal_key_index();
}
inline void FrameCryptor::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_index_ = value;
}
inline void FrameCryptor::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptor.key_index)
}

// required bool enabled = 4;
inline bool FrameCryptor::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FrameCryptor::has_enabled() const {
  return _internal_has_enabled();
}
inline void FrameCryptor::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool FrameCryptor::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool FrameCryptor::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptor.enabled)
  return _internal_enabled();
}
inline void FrameCryptor::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.enabled_ = value;
}
inline void FrameCryptor::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptor.enabled)
}

// -------------------------------------------------------------------

// KeyProviderOptions

// optional bytes shared_key = 1;
inline bool KeyProviderOptions::_internal_has_shared_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyProviderOptions::has_shared_key() const {
  return _internal_has_shared_key();
}
inline void KeyProviderOptions::clear_shared_key() {
  _impl_.shared_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyProviderOptions::shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.KeyProviderOptions.shared_key)
  return _internal_shared_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyProviderOptions::set_shared_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.shared_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.KeyProviderOptions.shared_key)
}
inline std::string* KeyProviderOptions::mutable_shared_key() {
  std::string* _s = _internal_mutable_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.KeyProviderOptions.shared_key)
  return _s;
}
inline const std::string& KeyProviderOptions::_internal_shared_key() const {
  return _impl_.shared_key_.Get();
}
inline void KeyProviderOptions::_internal_set_shared_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shared_key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyProviderOptions::_internal_mutable_shared_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.shared_key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyProviderOptions::release_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.KeyProviderOptions.shared_key)
  if (!_internal_has_shared_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.shared_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shared_key_.IsDefault()) {
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyProviderOptions::set_allocated_shared_key(std::string* shared_key) {
  if (shared_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.shared_key_.SetAllocated(shared_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shared_key_.IsDefault()) {
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.KeyProviderOptions.shared_key)
}

// required int32 ratchet_window_size = 2;
inline bool KeyProviderOptions::_internal_has_ratchet_window_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyProviderOptions::has_ratchet_window_size() const {
  return _internal_has_ratchet_window_size();
}
inline void KeyProviderOptions::clear_ratchet_window_size() {
  _impl_.ratchet_window_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t KeyProviderOptions::_internal_ratchet_window_size() const {
  return _impl_.ratchet_window_size_;
}
inline int32_t KeyProviderOptions::ratchet_window_size() const {
  // @@protoc_insertion_point(field_get:livekit.proto.KeyProviderOptions.ratchet_window_size)
  return _internal_ratchet_window_size();
}
inline void KeyProviderOptions::_internal_set_ratchet_window_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ratchet_window_size_ = value;
}
inline void KeyProviderOptions::set_ratchet_window_size(int32_t value) {
  _internal_set_ratchet_window_size(value);
  // @@protoc_insertion_point(field_set:livekit.proto.KeyProviderOptions.ratchet_window_size)
}

// required bytes ratchet_salt = 3;
inline bool KeyProviderOptions::_internal_has_ratchet_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyProviderOptions::has_ratchet_salt() const {
  return _internal_has_ratchet_salt();
}
inline void KeyProviderOptions::clear_ratchet_salt() {
  _impl_.ratchet_salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyProviderOptions::ratchet_salt() const {
  // @@protoc_insertion_point(field_get:livekit.proto.KeyProviderOptions.ratchet_salt)
  return _internal_ratchet_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyProviderOptions::set_ratchet_salt(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ratchet_salt_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.KeyProviderOptions.ratchet_salt)
}
inline std::string* KeyProviderOptions::mutable_ratchet_salt() {
  std::string* _s = _internal_mutable_ratchet_salt();
  // @@protoc_insertion_point(field_mutable:livekit.proto.KeyProviderOptions.ratchet_salt)
  return _s;
}
inline const std::string& KeyProviderOptions::_internal_ratchet_salt() const {
  return _impl_.ratchet_salt_.Get();
}
inline void KeyProviderOptions::_internal_set_ratchet_salt(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ratchet_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyProviderOptions::_internal_mutable_ratchet_salt() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ratchet_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyProviderOptions::release_ratchet_salt() {
  // @@protoc_insertion_point(field_release:livekit.proto.KeyProviderOptions.ratchet_salt)
  if (!_internal_has_ratchet_salt()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ratchet_salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ratchet_salt_.IsDefault()) {
    _impl_.ratchet_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyProviderOptions::set_allocated_ratchet_salt(std::string* ratchet_salt) {
  if (ratchet_salt != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ratchet_salt_.SetAllocated(ratchet_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ratchet_salt_.IsDefault()) {
    _impl_.ratchet_salt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.KeyProviderOptions.ratchet_salt)
}

// required int32 failure_tolerance = 4;
inline bool KeyProviderOptions::_internal_has_failure_tolerance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeyProviderOptions::has_failure_tolerance() const {
  return _internal_has_failure_tolerance();
}
inline void KeyProviderOptions::clear_failure_tolerance() {
  _impl_.failure_tolerance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t KeyProviderOptions::_internal_failure_tolerance() const {
  return _impl_.failure_tolerance_;
}
inline int32_t KeyProviderOptions::failure_tolerance() const {
  // @@protoc_insertion_point(field_get:livekit.proto.KeyProviderOptions.failure_tolerance)
  return _internal_failure_tolerance();
}
inline void KeyProviderOptions::_internal_set_failure_tolerance(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.failure_tolerance_ = value;
}
inline void KeyProviderOptions::set_failure_tolerance(int32_t value) {
  _internal_set_failure_tolerance(value);
  // @@protoc_insertion_point(field_set:livekit.proto.KeyProviderOptions.failure_tolerance)
}

// -------------------------------------------------------------------

// E2eeOptions

// required .livekit.proto.EncryptionType encryption_type = 1;
inline bool E2eeOptions::_internal_has_encryption_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool E2eeOptions::has_encryption_type() const {
  return _internal_has_encryption_type();
}
inline void E2eeOptions::clear_encryption_type() {
  _impl_.encryption_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::livekit::proto::EncryptionType E2eeOptions::_internal_encryption_type() const {
  return static_cast< ::livekit::proto::EncryptionType >(_impl_.encryption_type_);
}
inline ::livekit::proto::EncryptionType E2eeOptions::encryption_type() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeOptions.encryption_type)
  return _internal_encryption_type();
}
inline void E2eeOptions::_internal_set_encryption_type(::livekit::proto::EncryptionType value) {
  assert(::livekit::proto::EncryptionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encryption_type_ = value;
}
inline void E2eeOptions::set_encryption_type(::livekit::proto::EncryptionType value) {
  _internal_set_encryption_type(value);
  // @@protoc_insertion_point(field_set:livekit.proto.E2eeOptions.encryption_type)
}

// required .livekit.proto.KeyProviderOptions key_provider_options = 2;
inline bool E2eeOptions::_internal_has_key_provider_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_provider_options_ != nullptr);
  return value;
}
inline bool E2eeOptions::has_key_provider_options() const {
  return _internal_has_key_provider_options();
}
inline void E2eeOptions::clear_key_provider_options() {
  if (_impl_.key_provider_options_ != nullptr) _impl_.key_provider_options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::livekit::proto::KeyProviderOptions& E2eeOptions::_internal_key_provider_options() const {
  const ::livekit::proto::KeyProviderOptions* p = _impl_.key_provider_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::proto::KeyProviderOptions&>(
      ::livekit::proto::_KeyProviderOptions_default_instance_);
}
inline const ::livekit::proto::KeyProviderOptions& E2eeOptions::key_provider_options() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeOptions.key_provider_options)
  return _internal_key_provider_options();
}
inline void E2eeOptions::unsafe_arena_set_allocated_key_provider_options(
    ::livekit::proto::KeyProviderOptions* key_provider_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_provider_options_);
  }
  _impl_.key_provider_options_ = key_provider_options;
  if (key_provider_options) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeOptions.key_provider_options)
}
inline ::livekit::proto::KeyProviderOptions* E2eeOptions::release_key_provider_options() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::KeyProviderOptions* temp = _impl_.key_provider_options_;
  _impl_.key_provider_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::proto::KeyProviderOptions* E2eeOptions::unsafe_arena_release_key_provider_options() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeOptions.key_provider_options)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::proto::KeyProviderOptions* temp = _impl_.key_provider_options_;
  _impl_.key_provider_options_ = nullptr;
  return temp;
}
inline ::livekit::proto::KeyProviderOptions* E2eeOptions::_internal_mutable_key_provider_options() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_provider_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::proto::KeyProviderOptions>(GetArenaForAllocation());
    _impl_.key_provider_options_ = p;
  }
  return _impl_.key_provider_options_;
}
inline ::livekit::proto::KeyProviderOptions* E2eeOptions::mutable_key_provider_options() {
  ::livekit::proto::KeyProviderOptions* _msg = _internal_mutable_key_provider_options();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeOptions.key_provider_options)
  return _msg;
}
inline void E2eeOptions::set_allocated_key_provider_options(::livekit::proto::KeyProviderOptions* key_provider_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_provider_options_;
  }
  if (key_provider_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_provider_options);
    if (message_arena != submessage_arena) {
      key_provider_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_provider_options, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_provider_options_ = key_provider_options;
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.E2eeOptions.key_provider_options)
}

// -------------------------------------------------------------------

// E2eeManagerSetEnabledRequest

// required bool enabled = 1;
inline bool E2eeManagerSetEnabledRequest::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool E2eeManagerSetEnabledRequest::has_enabled() const {
  return _internal_has_enabled();
}
inline void E2eeManagerSetEnabledRequest::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool E2eeManagerSetEnabledRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool E2eeManagerSetEnabledRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeManagerSetEnabledRequest.enabled)
  return _internal_enabled();
}
inline void E2eeManagerSetEnabledRequest::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.enabled_ = value;
}
inline void E2eeManagerSetEnabledRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.E2eeManagerSetEnabledRequest.enabled)
}

// -------------------------------------------------------------------

// E2eeManagerSetEnabledResponse

// -------------------------------------------------------------------

// E2eeManagerGetFrameCryptorsRequest

// -------------------------------------------------------------------

// E2eeManagerGetFrameCryptorsResponse

// repeated .livekit.proto.FrameCryptor frame_cryptors = 1;
inline int E2eeManagerGetFrameCryptorsResponse::_internal_frame_cryptors_size() const {
  return _impl_.frame_cryptors_.size();
}
inline int E2eeManagerGetFrameCryptorsResponse::frame_cryptors_size() const {
  return _internal_frame_cryptors_size();
}
inline void E2eeManagerGetFrameCryptorsResponse::clear_frame_cryptors() {
  _impl_.frame_cryptors_.Clear();
}
inline ::livekit::proto::FrameCryptor* E2eeManagerGetFrameCryptorsResponse::mutable_frame_cryptors(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeManagerGetFrameCryptorsResponse.frame_cryptors)
  return _impl_.frame_cryptors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::FrameCryptor >*
E2eeManagerGetFrameCryptorsResponse::mutable_frame_cryptors() {
  // @@protoc_insertion_point(field_mutable_list:livekit.proto.E2eeManagerGetFrameCryptorsResponse.frame_cryptors)
  return &_impl_.frame_cryptors_;
}
inline const ::livekit::proto::FrameCryptor& E2eeManagerGetFrameCryptorsResponse::_internal_frame_cryptors(int index) const {
  return _impl_.frame_cryptors_.Get(index);
}
inline const ::livekit::proto::FrameCryptor& E2eeManagerGetFrameCryptorsResponse::frame_cryptors(int index) const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeManagerGetFrameCryptorsResponse.frame_cryptors)
  return _internal_frame_cryptors(index);
}
inline ::livekit::proto::FrameCryptor* E2eeManagerGetFrameCryptorsResponse::_internal_add_frame_cryptors() {
  return _impl_.frame_cryptors_.Add();
}
inline ::livekit::proto::FrameCryptor* E2eeManagerGetFrameCryptorsResponse::add_frame_cryptors() {
  ::livekit::proto::FrameCryptor* _add = _internal_add_frame_cryptors();
  // @@protoc_insertion_point(field_add:livekit.proto.E2eeManagerGetFrameCryptorsResponse.frame_cryptors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::livekit::proto::FrameCryptor >&
E2eeManagerGetFrameCryptorsResponse::frame_cryptors() const {
  // @@protoc_insertion_point(field_list:livekit.proto.E2eeManagerGetFrameCryptorsResponse.frame_cryptors)
  return _impl_.frame_cryptors_;
}

// -------------------------------------------------------------------

// FrameCryptorSetEnabledRequest

// required string participant_identity = 1;
inline bool FrameCryptorSetEnabledRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameCryptorSetEnabledRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void FrameCryptorSetEnabledRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameCryptorSetEnabledRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetEnabledRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptorSetEnabledRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetEnabledRequest.participant_identity)
}
inline std::string* FrameCryptorSetEnabledRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptorSetEnabledRequest.participant_identity)
  return _s;
}
inline const std::string& FrameCryptorSetEnabledRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void FrameCryptorSetEnabledRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptorSetEnabledRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptorSetEnabledRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptorSetEnabledRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptorSetEnabledRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptorSetEnabledRequest.participant_identity)
}

// required string track_sid = 2;
inline bool FrameCryptorSetEnabledRequest::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameCryptorSetEnabledRequest::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void FrameCryptorSetEnabledRequest::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FrameCryptorSetEnabledRequest::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetEnabledRequest.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptorSetEnabledRequest::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetEnabledRequest.track_sid)
}
inline std::string* FrameCryptorSetEnabledRequest::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptorSetEnabledRequest.track_sid)
  return _s;
}
inline const std::string& FrameCryptorSetEnabledRequest::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void FrameCryptorSetEnabledRequest::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptorSetEnabledRequest::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptorSetEnabledRequest::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptorSetEnabledRequest.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptorSetEnabledRequest::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptorSetEnabledRequest.track_sid)
}

// required bool enabled = 3;
inline bool FrameCryptorSetEnabledRequest::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FrameCryptorSetEnabledRequest::has_enabled() const {
  return _internal_has_enabled();
}
inline void FrameCryptorSetEnabledRequest::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool FrameCryptorSetEnabledRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool FrameCryptorSetEnabledRequest::enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetEnabledRequest.enabled)
  return _internal_enabled();
}
inline void FrameCryptorSetEnabledRequest::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enabled_ = value;
}
inline void FrameCryptorSetEnabledRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetEnabledRequest.enabled)
}

// -------------------------------------------------------------------

// FrameCryptorSetEnabledResponse

// -------------------------------------------------------------------

// FrameCryptorSetKeyIndexRequest

// required string participant_identity = 1;
inline bool FrameCryptorSetKeyIndexRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameCryptorSetKeyIndexRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void FrameCryptorSetKeyIndexRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameCryptorSetKeyIndexRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptorSetKeyIndexRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity)
}
inline std::string* FrameCryptorSetKeyIndexRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity)
  return _s;
}
inline const std::string& FrameCryptorSetKeyIndexRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void FrameCryptorSetKeyIndexRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptorSetKeyIndexRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptorSetKeyIndexRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptorSetKeyIndexRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptorSetKeyIndexRequest.participant_identity)
}

// required string track_sid = 2;
inline bool FrameCryptorSetKeyIndexRequest::_internal_has_track_sid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameCryptorSetKeyIndexRequest::has_track_sid() const {
  return _internal_has_track_sid();
}
inline void FrameCryptorSetKeyIndexRequest::clear_track_sid() {
  _impl_.track_sid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FrameCryptorSetKeyIndexRequest::track_sid() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid)
  return _internal_track_sid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameCryptorSetKeyIndexRequest::set_track_sid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.track_sid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid)
}
inline std::string* FrameCryptorSetKeyIndexRequest::mutable_track_sid() {
  std::string* _s = _internal_mutable_track_sid();
  // @@protoc_insertion_point(field_mutable:livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid)
  return _s;
}
inline const std::string& FrameCryptorSetKeyIndexRequest::_internal_track_sid() const {
  return _impl_.track_sid_.Get();
}
inline void FrameCryptorSetKeyIndexRequest::_internal_set_track_sid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_sid_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameCryptorSetKeyIndexRequest::_internal_mutable_track_sid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.track_sid_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameCryptorSetKeyIndexRequest::release_track_sid() {
  // @@protoc_insertion_point(field_release:livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid)
  if (!_internal_has_track_sid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.track_sid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameCryptorSetKeyIndexRequest::set_allocated_track_sid(std::string* track_sid) {
  if (track_sid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.track_sid_.SetAllocated(track_sid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.track_sid_.IsDefault()) {
    _impl_.track_sid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.FrameCryptorSetKeyIndexRequest.track_sid)
}

// required int32 key_index = 3;
inline bool FrameCryptorSetKeyIndexRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FrameCryptorSetKeyIndexRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void FrameCryptorSetKeyIndexRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t FrameCryptorSetKeyIndexRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t FrameCryptorSetKeyIndexRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.FrameCryptorSetKeyIndexRequest.key_index)
  return _internal_key_index();
}
inline void FrameCryptorSetKeyIndexRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_index_ = value;
}
inline void FrameCryptorSetKeyIndexRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.FrameCryptorSetKeyIndexRequest.key_index)
}

// -------------------------------------------------------------------

// FrameCryptorSetKeyIndexResponse

// -------------------------------------------------------------------

// SetSharedKeyRequest

// required bytes shared_key = 1;
inline bool SetSharedKeyRequest::_internal_has_shared_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetSharedKeyRequest::has_shared_key() const {
  return _internal_has_shared_key();
}
inline void SetSharedKeyRequest::clear_shared_key() {
  _impl_.shared_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetSharedKeyRequest::shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetSharedKeyRequest.shared_key)
  return _internal_shared_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSharedKeyRequest::set_shared_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.shared_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetSharedKeyRequest.shared_key)
}
inline std::string* SetSharedKeyRequest::mutable_shared_key() {
  std::string* _s = _internal_mutable_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetSharedKeyRequest.shared_key)
  return _s;
}
inline const std::string& SetSharedKeyRequest::_internal_shared_key() const {
  return _impl_.shared_key_.Get();
}
inline void SetSharedKeyRequest::_internal_set_shared_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shared_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSharedKeyRequest::_internal_mutable_shared_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.shared_key_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSharedKeyRequest::release_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetSharedKeyRequest.shared_key)
  if (!_internal_has_shared_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.shared_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shared_key_.IsDefault()) {
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetSharedKeyRequest::set_allocated_shared_key(std::string* shared_key) {
  if (shared_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.shared_key_.SetAllocated(shared_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shared_key_.IsDefault()) {
    _impl_.shared_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetSharedKeyRequest.shared_key)
}

// required int32 key_index = 2;
inline bool SetSharedKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetSharedKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void SetSharedKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SetSharedKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t SetSharedKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetSharedKeyRequest.key_index)
  return _internal_key_index();
}
inline void SetSharedKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_index_ = value;
}
inline void SetSharedKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetSharedKeyRequest.key_index)
}

// -------------------------------------------------------------------

// SetSharedKeyResponse

// -------------------------------------------------------------------

// RatchetSharedKeyRequest

// required int32 key_index = 1;
inline bool RatchetSharedKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatchetSharedKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void RatchetSharedKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t RatchetSharedKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t RatchetSharedKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RatchetSharedKeyRequest.key_index)
  return _internal_key_index();
}
inline void RatchetSharedKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_index_ = value;
}
inline void RatchetSharedKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RatchetSharedKeyRequest.key_index)
}

// -------------------------------------------------------------------

// RatchetSharedKeyResponse

// optional bytes new_key = 1;
inline bool RatchetSharedKeyResponse::_internal_has_new_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatchetSharedKeyResponse::has_new_key() const {
  return _internal_has_new_key();
}
inline void RatchetSharedKeyResponse::clear_new_key() {
  _impl_.new_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatchetSharedKeyResponse::new_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RatchetSharedKeyResponse.new_key)
  return _internal_new_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RatchetSharedKeyResponse::set_new_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RatchetSharedKeyResponse.new_key)
}
inline std::string* RatchetSharedKeyResponse::mutable_new_key() {
  std::string* _s = _internal_mutable_new_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RatchetSharedKeyResponse.new_key)
  return _s;
}
inline const std::string& RatchetSharedKeyResponse::_internal_new_key() const {
  return _impl_.new_key_.Get();
}
inline void RatchetSharedKeyResponse::_internal_set_new_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RatchetSharedKeyResponse::_internal_mutable_new_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RatchetSharedKeyResponse::release_new_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.RatchetSharedKeyResponse.new_key)
  if (!_internal_has_new_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_key_.IsDefault()) {
    _impl_.new_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RatchetSharedKeyResponse::set_allocated_new_key(std::string* new_key) {
  if (new_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_key_.SetAllocated(new_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_key_.IsDefault()) {
    _impl_.new_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RatchetSharedKeyResponse.new_key)
}

// -------------------------------------------------------------------

// GetSharedKeyRequest

// required int32 key_index = 1;
inline bool GetSharedKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSharedKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void GetSharedKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t GetSharedKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t GetSharedKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSharedKeyRequest.key_index)
  return _internal_key_index();
}
inline void GetSharedKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_index_ = value;
}
inline void GetSharedKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetSharedKeyRequest.key_index)
}

// -------------------------------------------------------------------

// GetSharedKeyResponse

// optional bytes key = 1;
inline bool GetSharedKeyResponse::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetSharedKeyResponse::has_key() const {
  return _internal_has_key();
}
inline void GetSharedKeyResponse::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetSharedKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetSharedKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSharedKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.GetSharedKeyResponse.key)
}
inline std::string* GetSharedKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetSharedKeyResponse.key)
  return _s;
}
inline const std::string& GetSharedKeyResponse::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetSharedKeyResponse::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSharedKeyResponse::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSharedKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetSharedKeyResponse.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetSharedKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.GetSharedKeyResponse.key)
}

// -------------------------------------------------------------------

// SetKeyRequest

// required string participant_identity = 1;
inline bool SetKeyRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SetKeyRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void SetKeyRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SetKeyRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetKeyRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetKeyRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetKeyRequest.participant_identity)
}
inline std::string* SetKeyRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetKeyRequest.participant_identity)
  return _s;
}
inline const std::string& SetKeyRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void SetKeyRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SetKeyRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SetKeyRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetKeyRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetKeyRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetKeyRequest.participant_identity)
}

// required bytes key = 2;
inline bool SetKeyRequest::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetKeyRequest::has_key() const {
  return _internal_has_key();
}
inline void SetKeyRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SetKeyRequest::key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetKeyRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetKeyRequest::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.SetKeyRequest.key)
}
inline std::string* SetKeyRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.SetKeyRequest.key)
  return _s;
}
inline const std::string& SetKeyRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SetKeyRequest::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SetKeyRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* SetKeyRequest::release_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.SetKeyRequest.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SetKeyRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.SetKeyRequest.key)
}

// required int32 key_index = 3;
inline bool SetKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SetKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void SetKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SetKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t SetKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.SetKeyRequest.key_index)
  return _internal_key_index();
}
inline void SetKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_index_ = value;
}
inline void SetKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.SetKeyRequest.key_index)
}

// -------------------------------------------------------------------

// SetKeyResponse

// -------------------------------------------------------------------

// RatchetKeyRequest

// required string participant_identity = 1;
inline bool RatchetKeyRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatchetKeyRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void RatchetKeyRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatchetKeyRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RatchetKeyRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RatchetKeyRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RatchetKeyRequest.participant_identity)
}
inline std::string* RatchetKeyRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RatchetKeyRequest.participant_identity)
  return _s;
}
inline const std::string& RatchetKeyRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void RatchetKeyRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* RatchetKeyRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* RatchetKeyRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.RatchetKeyRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RatchetKeyRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RatchetKeyRequest.participant_identity)
}

// required int32 key_index = 2;
inline bool RatchetKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RatchetKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void RatchetKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t RatchetKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t RatchetKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RatchetKeyRequest.key_index)
  return _internal_key_index();
}
inline void RatchetKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_index_ = value;
}
inline void RatchetKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.RatchetKeyRequest.key_index)
}

// -------------------------------------------------------------------

// RatchetKeyResponse

// optional bytes new_key = 1;
inline bool RatchetKeyResponse::_internal_has_new_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RatchetKeyResponse::has_new_key() const {
  return _internal_has_new_key();
}
inline void RatchetKeyResponse::clear_new_key() {
  _impl_.new_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RatchetKeyResponse::new_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.RatchetKeyResponse.new_key)
  return _internal_new_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RatchetKeyResponse::set_new_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.new_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.RatchetKeyResponse.new_key)
}
inline std::string* RatchetKeyResponse::mutable_new_key() {
  std::string* _s = _internal_mutable_new_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.RatchetKeyResponse.new_key)
  return _s;
}
inline const std::string& RatchetKeyResponse::_internal_new_key() const {
  return _impl_.new_key_.Get();
}
inline void RatchetKeyResponse::_internal_set_new_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.new_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RatchetKeyResponse::_internal_mutable_new_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.new_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RatchetKeyResponse::release_new_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.RatchetKeyResponse.new_key)
  if (!_internal_has_new_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.new_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_key_.IsDefault()) {
    _impl_.new_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RatchetKeyResponse::set_allocated_new_key(std::string* new_key) {
  if (new_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.new_key_.SetAllocated(new_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_key_.IsDefault()) {
    _impl_.new_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.RatchetKeyResponse.new_key)
}

// -------------------------------------------------------------------

// GetKeyRequest

// required string participant_identity = 1;
inline bool GetKeyRequest::_internal_has_participant_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetKeyRequest::has_participant_identity() const {
  return _internal_has_participant_identity();
}
inline void GetKeyRequest::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetKeyRequest::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetKeyRequest.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKeyRequest::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.GetKeyRequest.participant_identity)
}
inline std::string* GetKeyRequest::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetKeyRequest.participant_identity)
  return _s;
}
inline const std::string& GetKeyRequest::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void GetKeyRequest::_internal_set_participant_identity(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* GetKeyRequest::_internal_mutable_participant_identity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* GetKeyRequest::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetKeyRequest.participant_identity)
  if (!_internal_has_participant_identity()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.participant_identity_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetKeyRequest::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.GetKeyRequest.participant_identity)
}

// required int32 key_index = 2;
inline bool GetKeyRequest::_internal_has_key_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetKeyRequest::has_key_index() const {
  return _internal_has_key_index();
}
inline void GetKeyRequest::clear_key_index() {
  _impl_.key_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t GetKeyRequest::_internal_key_index() const {
  return _impl_.key_index_;
}
inline int32_t GetKeyRequest::key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetKeyRequest.key_index)
  return _internal_key_index();
}
inline void GetKeyRequest::_internal_set_key_index(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_index_ = value;
}
inline void GetKeyRequest::set_key_index(int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:livekit.proto.GetKeyRequest.key_index)
}

// -------------------------------------------------------------------

// GetKeyResponse

// optional bytes key = 1;
inline bool GetKeyResponse::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetKeyResponse::has_key() const {
  return _internal_has_key();
}
inline void GetKeyResponse::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.GetKeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.proto.GetKeyResponse.key)
}
inline std::string* GetKeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.GetKeyResponse.key)
  return _s;
}
inline const std::string& GetKeyResponse::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetKeyResponse::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetKeyResponse::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.GetKeyResponse.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetKeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.proto.GetKeyResponse.key)
}

// -------------------------------------------------------------------

// E2eeRequest

// required uint64 room_handle = 1;
inline bool E2eeRequest::_internal_has_room_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool E2eeRequest::has_room_handle() const {
  return _internal_has_room_handle();
}
inline void E2eeRequest::clear_room_handle() {
  _impl_.room_handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t E2eeRequest::_internal_room_handle() const {
  return _impl_.room_handle_;
}
inline uint64_t E2eeRequest::room_handle() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.room_handle)
  return _internal_room_handle();
}
inline void E2eeRequest::_internal_set_room_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.room_handle_ = value;
}
inline void E2eeRequest::set_room_handle(uint64_t value) {
  _internal_set_room_handle(value);
  // @@protoc_insertion_point(field_set:livekit.proto.E2eeRequest.room_handle)
}

// .livekit.proto.E2eeManagerSetEnabledRequest manager_set_enabled = 2;
inline bool E2eeRequest::_internal_has_manager_set_enabled() const {
  return message_case() == kManagerSetEnabled;
}
inline bool E2eeRequest::has_manager_set_enabled() const {
  return _internal_has_manager_set_enabled();
}
inline void E2eeRequest::set_has_manager_set_enabled() {
  _impl_._oneof_case_[0] = kManagerSetEnabled;
}
inline void E2eeRequest::clear_manager_set_enabled() {
  if (_internal_has_manager_set_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.manager_set_enabled_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::E2eeManagerSetEnabledRequest* E2eeRequest::release_manager_set_enabled() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.manager_set_enabled)
  if (_internal_has_manager_set_enabled()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerSetEnabledRequest* temp = _impl_.message_.manager_set_enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.manager_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::E2eeManagerSetEnabledRequest& E2eeRequest::_internal_manager_set_enabled() const {
  return _internal_has_manager_set_enabled()
      ? *_impl_.message_.manager_set_enabled_
      : reinterpret_cast< ::livekit::proto::E2eeManagerSetEnabledRequest&>(::livekit::proto::_E2eeManagerSetEnabledRequest_default_instance_);
}
inline const ::livekit::proto::E2eeManagerSetEnabledRequest& E2eeRequest::manager_set_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.manager_set_enabled)
  return _internal_manager_set_enabled();
}
inline ::livekit::proto::E2eeManagerSetEnabledRequest* E2eeRequest::unsafe_arena_release_manager_set_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.manager_set_enabled)
  if (_internal_has_manager_set_enabled()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerSetEnabledRequest* temp = _impl_.message_.manager_set_enabled_;
    _impl_.message_.manager_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledRequest* manager_set_enabled) {
  clear_message();
  if (manager_set_enabled) {
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = manager_set_enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.manager_set_enabled)
}
inline ::livekit::proto::E2eeManagerSetEnabledRequest* E2eeRequest::_internal_mutable_manager_set_enabled() {
  if (!_internal_has_manager_set_enabled()) {
    clear_message();
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = CreateMaybeMessage< ::livekit::proto::E2eeManagerSetEnabledRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.manager_set_enabled_;
}
inline ::livekit::proto::E2eeManagerSetEnabledRequest* E2eeRequest::mutable_manager_set_enabled() {
  ::livekit::proto::E2eeManagerSetEnabledRequest* _msg = _internal_mutable_manager_set_enabled();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.manager_set_enabled)
  return _msg;
}

// .livekit.proto.E2eeManagerGetFrameCryptorsRequest manager_get_frame_cryptors = 3;
inline bool E2eeRequest::_internal_has_manager_get_frame_cryptors() const {
  return message_case() == kManagerGetFrameCryptors;
}
inline bool E2eeRequest::has_manager_get_frame_cryptors() const {
  return _internal_has_manager_get_frame_cryptors();
}
inline void E2eeRequest::set_has_manager_get_frame_cryptors() {
  _impl_._oneof_case_[0] = kManagerGetFrameCryptors;
}
inline void E2eeRequest::clear_manager_get_frame_cryptors() {
  if (_internal_has_manager_get_frame_cryptors()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.manager_get_frame_cryptors_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* E2eeRequest::release_manager_get_frame_cryptors() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
  if (_internal_has_manager_get_frame_cryptors()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* temp = _impl_.message_.manager_get_frame_cryptors_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.manager_get_frame_cryptors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest& E2eeRequest::_internal_manager_get_frame_cryptors() const {
  return _internal_has_manager_get_frame_cryptors()
      ? *_impl_.message_.manager_get_frame_cryptors_
      : reinterpret_cast< ::livekit::proto::E2eeManagerGetFrameCryptorsRequest&>(::livekit::proto::_E2eeManagerGetFrameCryptorsRequest_default_instance_);
}
inline const ::livekit::proto::E2eeManagerGetFrameCryptorsRequest& E2eeRequest::manager_get_frame_cryptors() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
  return _internal_manager_get_frame_cryptors();
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* E2eeRequest::unsafe_arena_release_manager_get_frame_cryptors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
  if (_internal_has_manager_get_frame_cryptors()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* temp = _impl_.message_.manager_get_frame_cryptors_;
    _impl_.message_.manager_get_frame_cryptors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsRequest* manager_get_frame_cryptors) {
  clear_message();
  if (manager_get_frame_cryptors) {
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = manager_get_frame_cryptors;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* E2eeRequest::_internal_mutable_manager_get_frame_cryptors() {
  if (!_internal_has_manager_get_frame_cryptors()) {
    clear_message();
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = CreateMaybeMessage< ::livekit::proto::E2eeManagerGetFrameCryptorsRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.manager_get_frame_cryptors_;
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* E2eeRequest::mutable_manager_get_frame_cryptors() {
  ::livekit::proto::E2eeManagerGetFrameCryptorsRequest* _msg = _internal_mutable_manager_get_frame_cryptors();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.manager_get_frame_cryptors)
  return _msg;
}

// .livekit.proto.FrameCryptorSetEnabledRequest cryptor_set_enabled = 4;
inline bool E2eeRequest::_internal_has_cryptor_set_enabled() const {
  return message_case() == kCryptorSetEnabled;
}
inline bool E2eeRequest::has_cryptor_set_enabled() const {
  return _internal_has_cryptor_set_enabled();
}
inline void E2eeRequest::set_has_cryptor_set_enabled() {
  _impl_._oneof_case_[0] = kCryptorSetEnabled;
}
inline void E2eeRequest::clear_cryptor_set_enabled() {
  if (_internal_has_cryptor_set_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.cryptor_set_enabled_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::FrameCryptorSetEnabledRequest* E2eeRequest::release_cryptor_set_enabled() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.cryptor_set_enabled)
  if (_internal_has_cryptor_set_enabled()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetEnabledRequest* temp = _impl_.message_.cryptor_set_enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.cryptor_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::FrameCryptorSetEnabledRequest& E2eeRequest::_internal_cryptor_set_enabled() const {
  return _internal_has_cryptor_set_enabled()
      ? *_impl_.message_.cryptor_set_enabled_
      : reinterpret_cast< ::livekit::proto::FrameCryptorSetEnabledRequest&>(::livekit::proto::_FrameCryptorSetEnabledRequest_default_instance_);
}
inline const ::livekit::proto::FrameCryptorSetEnabledRequest& E2eeRequest::cryptor_set_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.cryptor_set_enabled)
  return _internal_cryptor_set_enabled();
}
inline ::livekit::proto::FrameCryptorSetEnabledRequest* E2eeRequest::unsafe_arena_release_cryptor_set_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.cryptor_set_enabled)
  if (_internal_has_cryptor_set_enabled()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetEnabledRequest* temp = _impl_.message_.cryptor_set_enabled_;
    _impl_.message_.cryptor_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledRequest* cryptor_set_enabled) {
  clear_message();
  if (cryptor_set_enabled) {
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = cryptor_set_enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.cryptor_set_enabled)
}
inline ::livekit::proto::FrameCryptorSetEnabledRequest* E2eeRequest::_internal_mutable_cryptor_set_enabled() {
  if (!_internal_has_cryptor_set_enabled()) {
    clear_message();
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = CreateMaybeMessage< ::livekit::proto::FrameCryptorSetEnabledRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.cryptor_set_enabled_;
}
inline ::livekit::proto::FrameCryptorSetEnabledRequest* E2eeRequest::mutable_cryptor_set_enabled() {
  ::livekit::proto::FrameCryptorSetEnabledRequest* _msg = _internal_mutable_cryptor_set_enabled();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.cryptor_set_enabled)
  return _msg;
}

// .livekit.proto.FrameCryptorSetKeyIndexRequest cryptor_set_key_index = 5;
inline bool E2eeRequest::_internal_has_cryptor_set_key_index() const {
  return message_case() == kCryptorSetKeyIndex;
}
inline bool E2eeRequest::has_cryptor_set_key_index() const {
  return _internal_has_cryptor_set_key_index();
}
inline void E2eeRequest::set_has_cryptor_set_key_index() {
  _impl_._oneof_case_[0] = kCryptorSetKeyIndex;
}
inline void E2eeRequest::clear_cryptor_set_key_index() {
  if (_internal_has_cryptor_set_key_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.cryptor_set_key_index_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::FrameCryptorSetKeyIndexRequest* E2eeRequest::release_cryptor_set_key_index() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.cryptor_set_key_index)
  if (_internal_has_cryptor_set_key_index()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetKeyIndexRequest* temp = _impl_.message_.cryptor_set_key_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.cryptor_set_key_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::FrameCryptorSetKeyIndexRequest& E2eeRequest::_internal_cryptor_set_key_index() const {
  return _internal_has_cryptor_set_key_index()
      ? *_impl_.message_.cryptor_set_key_index_
      : reinterpret_cast< ::livekit::proto::FrameCryptorSetKeyIndexRequest&>(::livekit::proto::_FrameCryptorSetKeyIndexRequest_default_instance_);
}
inline const ::livekit::proto::FrameCryptorSetKeyIndexRequest& E2eeRequest::cryptor_set_key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.cryptor_set_key_index)
  return _internal_cryptor_set_key_index();
}
inline ::livekit::proto::FrameCryptorSetKeyIndexRequest* E2eeRequest::unsafe_arena_release_cryptor_set_key_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.cryptor_set_key_index)
  if (_internal_has_cryptor_set_key_index()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetKeyIndexRequest* temp = _impl_.message_.cryptor_set_key_index_;
    _impl_.message_.cryptor_set_key_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexRequest* cryptor_set_key_index) {
  clear_message();
  if (cryptor_set_key_index) {
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = cryptor_set_key_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.cryptor_set_key_index)
}
inline ::livekit::proto::FrameCryptorSetKeyIndexRequest* E2eeRequest::_internal_mutable_cryptor_set_key_index() {
  if (!_internal_has_cryptor_set_key_index()) {
    clear_message();
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = CreateMaybeMessage< ::livekit::proto::FrameCryptorSetKeyIndexRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.cryptor_set_key_index_;
}
inline ::livekit::proto::FrameCryptorSetKeyIndexRequest* E2eeRequest::mutable_cryptor_set_key_index() {
  ::livekit::proto::FrameCryptorSetKeyIndexRequest* _msg = _internal_mutable_cryptor_set_key_index();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.cryptor_set_key_index)
  return _msg;
}

// .livekit.proto.SetSharedKeyRequest set_shared_key = 6;
inline bool E2eeRequest::_internal_has_set_shared_key() const {
  return message_case() == kSetSharedKey;
}
inline bool E2eeRequest::has_set_shared_key() const {
  return _internal_has_set_shared_key();
}
inline void E2eeRequest::set_has_set_shared_key() {
  _impl_._oneof_case_[0] = kSetSharedKey;
}
inline void E2eeRequest::clear_set_shared_key() {
  if (_internal_has_set_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.set_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::SetSharedKeyRequest* E2eeRequest::release_set_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.set_shared_key)
  if (_internal_has_set_shared_key()) {
    clear_has_message();
    ::livekit::proto::SetSharedKeyRequest* temp = _impl_.message_.set_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.set_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::SetSharedKeyRequest& E2eeRequest::_internal_set_shared_key() const {
  return _internal_has_set_shared_key()
      ? *_impl_.message_.set_shared_key_
      : reinterpret_cast< ::livekit::proto::SetSharedKeyRequest&>(::livekit::proto::_SetSharedKeyRequest_default_instance_);
}
inline const ::livekit::proto::SetSharedKeyRequest& E2eeRequest::set_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.set_shared_key)
  return _internal_set_shared_key();
}
inline ::livekit::proto::SetSharedKeyRequest* E2eeRequest::unsafe_arena_release_set_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.set_shared_key)
  if (_internal_has_set_shared_key()) {
    clear_has_message();
    ::livekit::proto::SetSharedKeyRequest* temp = _impl_.message_.set_shared_key_;
    _impl_.message_.set_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_set_shared_key(::livekit::proto::SetSharedKeyRequest* set_shared_key) {
  clear_message();
  if (set_shared_key) {
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = set_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.set_shared_key)
}
inline ::livekit::proto::SetSharedKeyRequest* E2eeRequest::_internal_mutable_set_shared_key() {
  if (!_internal_has_set_shared_key()) {
    clear_message();
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = CreateMaybeMessage< ::livekit::proto::SetSharedKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.set_shared_key_;
}
inline ::livekit::proto::SetSharedKeyRequest* E2eeRequest::mutable_set_shared_key() {
  ::livekit::proto::SetSharedKeyRequest* _msg = _internal_mutable_set_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.set_shared_key)
  return _msg;
}

// .livekit.proto.RatchetSharedKeyRequest ratchet_shared_key = 7;
inline bool E2eeRequest::_internal_has_ratchet_shared_key() const {
  return message_case() == kRatchetSharedKey;
}
inline bool E2eeRequest::has_ratchet_shared_key() const {
  return _internal_has_ratchet_shared_key();
}
inline void E2eeRequest::set_has_ratchet_shared_key() {
  _impl_._oneof_case_[0] = kRatchetSharedKey;
}
inline void E2eeRequest::clear_ratchet_shared_key() {
  if (_internal_has_ratchet_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ratchet_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RatchetSharedKeyRequest* E2eeRequest::release_ratchet_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.ratchet_shared_key)
  if (_internal_has_ratchet_shared_key()) {
    clear_has_message();
    ::livekit::proto::RatchetSharedKeyRequest* temp = _impl_.message_.ratchet_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ratchet_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RatchetSharedKeyRequest& E2eeRequest::_internal_ratchet_shared_key() const {
  return _internal_has_ratchet_shared_key()
      ? *_impl_.message_.ratchet_shared_key_
      : reinterpret_cast< ::livekit::proto::RatchetSharedKeyRequest&>(::livekit::proto::_RatchetSharedKeyRequest_default_instance_);
}
inline const ::livekit::proto::RatchetSharedKeyRequest& E2eeRequest::ratchet_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.ratchet_shared_key)
  return _internal_ratchet_shared_key();
}
inline ::livekit::proto::RatchetSharedKeyRequest* E2eeRequest::unsafe_arena_release_ratchet_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.ratchet_shared_key)
  if (_internal_has_ratchet_shared_key()) {
    clear_has_message();
    ::livekit::proto::RatchetSharedKeyRequest* temp = _impl_.message_.ratchet_shared_key_;
    _impl_.message_.ratchet_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyRequest* ratchet_shared_key) {
  clear_message();
  if (ratchet_shared_key) {
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = ratchet_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.ratchet_shared_key)
}
inline ::livekit::proto::RatchetSharedKeyRequest* E2eeRequest::_internal_mutable_ratchet_shared_key() {
  if (!_internal_has_ratchet_shared_key()) {
    clear_message();
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = CreateMaybeMessage< ::livekit::proto::RatchetSharedKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.ratchet_shared_key_;
}
inline ::livekit::proto::RatchetSharedKeyRequest* E2eeRequest::mutable_ratchet_shared_key() {
  ::livekit::proto::RatchetSharedKeyRequest* _msg = _internal_mutable_ratchet_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.ratchet_shared_key)
  return _msg;
}

// .livekit.proto.GetSharedKeyRequest get_shared_key = 8;
inline bool E2eeRequest::_internal_has_get_shared_key() const {
  return message_case() == kGetSharedKey;
}
inline bool E2eeRequest::has_get_shared_key() const {
  return _internal_has_get_shared_key();
}
inline void E2eeRequest::set_has_get_shared_key() {
  _impl_._oneof_case_[0] = kGetSharedKey;
}
inline void E2eeRequest::clear_get_shared_key() {
  if (_internal_has_get_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.get_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::GetSharedKeyRequest* E2eeRequest::release_get_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.get_shared_key)
  if (_internal_has_get_shared_key()) {
    clear_has_message();
    ::livekit::proto::GetSharedKeyRequest* temp = _impl_.message_.get_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.get_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::GetSharedKeyRequest& E2eeRequest::_internal_get_shared_key() const {
  return _internal_has_get_shared_key()
      ? *_impl_.message_.get_shared_key_
      : reinterpret_cast< ::livekit::proto::GetSharedKeyRequest&>(::livekit::proto::_GetSharedKeyRequest_default_instance_);
}
inline const ::livekit::proto::GetSharedKeyRequest& E2eeRequest::get_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.get_shared_key)
  return _internal_get_shared_key();
}
inline ::livekit::proto::GetSharedKeyRequest* E2eeRequest::unsafe_arena_release_get_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.get_shared_key)
  if (_internal_has_get_shared_key()) {
    clear_has_message();
    ::livekit::proto::GetSharedKeyRequest* temp = _impl_.message_.get_shared_key_;
    _impl_.message_.get_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_get_shared_key(::livekit::proto::GetSharedKeyRequest* get_shared_key) {
  clear_message();
  if (get_shared_key) {
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = get_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.get_shared_key)
}
inline ::livekit::proto::GetSharedKeyRequest* E2eeRequest::_internal_mutable_get_shared_key() {
  if (!_internal_has_get_shared_key()) {
    clear_message();
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = CreateMaybeMessage< ::livekit::proto::GetSharedKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.get_shared_key_;
}
inline ::livekit::proto::GetSharedKeyRequest* E2eeRequest::mutable_get_shared_key() {
  ::livekit::proto::GetSharedKeyRequest* _msg = _internal_mutable_get_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.get_shared_key)
  return _msg;
}

// .livekit.proto.SetKeyRequest set_key = 9;
inline bool E2eeRequest::_internal_has_set_key() const {
  return message_case() == kSetKey;
}
inline bool E2eeRequest::has_set_key() const {
  return _internal_has_set_key();
}
inline void E2eeRequest::set_has_set_key() {
  _impl_._oneof_case_[0] = kSetKey;
}
inline void E2eeRequest::clear_set_key() {
  if (_internal_has_set_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.set_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::SetKeyRequest* E2eeRequest::release_set_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.set_key)
  if (_internal_has_set_key()) {
    clear_has_message();
    ::livekit::proto::SetKeyRequest* temp = _impl_.message_.set_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.set_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::SetKeyRequest& E2eeRequest::_internal_set_key() const {
  return _internal_has_set_key()
      ? *_impl_.message_.set_key_
      : reinterpret_cast< ::livekit::proto::SetKeyRequest&>(::livekit::proto::_SetKeyRequest_default_instance_);
}
inline const ::livekit::proto::SetKeyRequest& E2eeRequest::set_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.set_key)
  return _internal_set_key();
}
inline ::livekit::proto::SetKeyRequest* E2eeRequest::unsafe_arena_release_set_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.set_key)
  if (_internal_has_set_key()) {
    clear_has_message();
    ::livekit::proto::SetKeyRequest* temp = _impl_.message_.set_key_;
    _impl_.message_.set_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_set_key(::livekit::proto::SetKeyRequest* set_key) {
  clear_message();
  if (set_key) {
    set_has_set_key();
    _impl_.message_.set_key_ = set_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.set_key)
}
inline ::livekit::proto::SetKeyRequest* E2eeRequest::_internal_mutable_set_key() {
  if (!_internal_has_set_key()) {
    clear_message();
    set_has_set_key();
    _impl_.message_.set_key_ = CreateMaybeMessage< ::livekit::proto::SetKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.set_key_;
}
inline ::livekit::proto::SetKeyRequest* E2eeRequest::mutable_set_key() {
  ::livekit::proto::SetKeyRequest* _msg = _internal_mutable_set_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.set_key)
  return _msg;
}

// .livekit.proto.RatchetKeyRequest ratchet_key = 10;
inline bool E2eeRequest::_internal_has_ratchet_key() const {
  return message_case() == kRatchetKey;
}
inline bool E2eeRequest::has_ratchet_key() const {
  return _internal_has_ratchet_key();
}
inline void E2eeRequest::set_has_ratchet_key() {
  _impl_._oneof_case_[0] = kRatchetKey;
}
inline void E2eeRequest::clear_ratchet_key() {
  if (_internal_has_ratchet_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ratchet_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RatchetKeyRequest* E2eeRequest::release_ratchet_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.ratchet_key)
  if (_internal_has_ratchet_key()) {
    clear_has_message();
    ::livekit::proto::RatchetKeyRequest* temp = _impl_.message_.ratchet_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ratchet_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RatchetKeyRequest& E2eeRequest::_internal_ratchet_key() const {
  return _internal_has_ratchet_key()
      ? *_impl_.message_.ratchet_key_
      : reinterpret_cast< ::livekit::proto::RatchetKeyRequest&>(::livekit::proto::_RatchetKeyRequest_default_instance_);
}
inline const ::livekit::proto::RatchetKeyRequest& E2eeRequest::ratchet_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.ratchet_key)
  return _internal_ratchet_key();
}
inline ::livekit::proto::RatchetKeyRequest* E2eeRequest::unsafe_arena_release_ratchet_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.ratchet_key)
  if (_internal_has_ratchet_key()) {
    clear_has_message();
    ::livekit::proto::RatchetKeyRequest* temp = _impl_.message_.ratchet_key_;
    _impl_.message_.ratchet_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_ratchet_key(::livekit::proto::RatchetKeyRequest* ratchet_key) {
  clear_message();
  if (ratchet_key) {
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = ratchet_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.ratchet_key)
}
inline ::livekit::proto::RatchetKeyRequest* E2eeRequest::_internal_mutable_ratchet_key() {
  if (!_internal_has_ratchet_key()) {
    clear_message();
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = CreateMaybeMessage< ::livekit::proto::RatchetKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.ratchet_key_;
}
inline ::livekit::proto::RatchetKeyRequest* E2eeRequest::mutable_ratchet_key() {
  ::livekit::proto::RatchetKeyRequest* _msg = _internal_mutable_ratchet_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.ratchet_key)
  return _msg;
}

// .livekit.proto.GetKeyRequest get_key = 11;
inline bool E2eeRequest::_internal_has_get_key() const {
  return message_case() == kGetKey;
}
inline bool E2eeRequest::has_get_key() const {
  return _internal_has_get_key();
}
inline void E2eeRequest::set_has_get_key() {
  _impl_._oneof_case_[0] = kGetKey;
}
inline void E2eeRequest::clear_get_key() {
  if (_internal_has_get_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.get_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::GetKeyRequest* E2eeRequest::release_get_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeRequest.get_key)
  if (_internal_has_get_key()) {
    clear_has_message();
    ::livekit::proto::GetKeyRequest* temp = _impl_.message_.get_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.get_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::GetKeyRequest& E2eeRequest::_internal_get_key() const {
  return _internal_has_get_key()
      ? *_impl_.message_.get_key_
      : reinterpret_cast< ::livekit::proto::GetKeyRequest&>(::livekit::proto::_GetKeyRequest_default_instance_);
}
inline const ::livekit::proto::GetKeyRequest& E2eeRequest::get_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeRequest.get_key)
  return _internal_get_key();
}
inline ::livekit::proto::GetKeyRequest* E2eeRequest::unsafe_arena_release_get_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeRequest.get_key)
  if (_internal_has_get_key()) {
    clear_has_message();
    ::livekit::proto::GetKeyRequest* temp = _impl_.message_.get_key_;
    _impl_.message_.get_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeRequest::unsafe_arena_set_allocated_get_key(::livekit::proto::GetKeyRequest* get_key) {
  clear_message();
  if (get_key) {
    set_has_get_key();
    _impl_.message_.get_key_ = get_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeRequest.get_key)
}
inline ::livekit::proto::GetKeyRequest* E2eeRequest::_internal_mutable_get_key() {
  if (!_internal_has_get_key()) {
    clear_message();
    set_has_get_key();
    _impl_.message_.get_key_ = CreateMaybeMessage< ::livekit::proto::GetKeyRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.get_key_;
}
inline ::livekit::proto::GetKeyRequest* E2eeRequest::mutable_get_key() {
  ::livekit::proto::GetKeyRequest* _msg = _internal_mutable_get_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeRequest.get_key)
  return _msg;
}

inline bool E2eeRequest::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void E2eeRequest::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline E2eeRequest::MessageCase E2eeRequest::message_case() const {
  return E2eeRequest::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// E2eeResponse

// .livekit.proto.E2eeManagerSetEnabledResponse manager_set_enabled = 1;
inline bool E2eeResponse::_internal_has_manager_set_enabled() const {
  return message_case() == kManagerSetEnabled;
}
inline bool E2eeResponse::has_manager_set_enabled() const {
  return _internal_has_manager_set_enabled();
}
inline void E2eeResponse::set_has_manager_set_enabled() {
  _impl_._oneof_case_[0] = kManagerSetEnabled;
}
inline void E2eeResponse::clear_manager_set_enabled() {
  if (_internal_has_manager_set_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.manager_set_enabled_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::E2eeManagerSetEnabledResponse* E2eeResponse::release_manager_set_enabled() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.manager_set_enabled)
  if (_internal_has_manager_set_enabled()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerSetEnabledResponse* temp = _impl_.message_.manager_set_enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.manager_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::E2eeManagerSetEnabledResponse& E2eeResponse::_internal_manager_set_enabled() const {
  return _internal_has_manager_set_enabled()
      ? *_impl_.message_.manager_set_enabled_
      : reinterpret_cast< ::livekit::proto::E2eeManagerSetEnabledResponse&>(::livekit::proto::_E2eeManagerSetEnabledResponse_default_instance_);
}
inline const ::livekit::proto::E2eeManagerSetEnabledResponse& E2eeResponse::manager_set_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.manager_set_enabled)
  return _internal_manager_set_enabled();
}
inline ::livekit::proto::E2eeManagerSetEnabledResponse* E2eeResponse::unsafe_arena_release_manager_set_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.manager_set_enabled)
  if (_internal_has_manager_set_enabled()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerSetEnabledResponse* temp = _impl_.message_.manager_set_enabled_;
    _impl_.message_.manager_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_manager_set_enabled(::livekit::proto::E2eeManagerSetEnabledResponse* manager_set_enabled) {
  clear_message();
  if (manager_set_enabled) {
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = manager_set_enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.manager_set_enabled)
}
inline ::livekit::proto::E2eeManagerSetEnabledResponse* E2eeResponse::_internal_mutable_manager_set_enabled() {
  if (!_internal_has_manager_set_enabled()) {
    clear_message();
    set_has_manager_set_enabled();
    _impl_.message_.manager_set_enabled_ = CreateMaybeMessage< ::livekit::proto::E2eeManagerSetEnabledResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.manager_set_enabled_;
}
inline ::livekit::proto::E2eeManagerSetEnabledResponse* E2eeResponse::mutable_manager_set_enabled() {
  ::livekit::proto::E2eeManagerSetEnabledResponse* _msg = _internal_mutable_manager_set_enabled();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.manager_set_enabled)
  return _msg;
}

// .livekit.proto.E2eeManagerGetFrameCryptorsResponse manager_get_frame_cryptors = 2;
inline bool E2eeResponse::_internal_has_manager_get_frame_cryptors() const {
  return message_case() == kManagerGetFrameCryptors;
}
inline bool E2eeResponse::has_manager_get_frame_cryptors() const {
  return _internal_has_manager_get_frame_cryptors();
}
inline void E2eeResponse::set_has_manager_get_frame_cryptors() {
  _impl_._oneof_case_[0] = kManagerGetFrameCryptors;
}
inline void E2eeResponse::clear_manager_get_frame_cryptors() {
  if (_internal_has_manager_get_frame_cryptors()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.manager_get_frame_cryptors_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* E2eeResponse::release_manager_get_frame_cryptors() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
  if (_internal_has_manager_get_frame_cryptors()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* temp = _impl_.message_.manager_get_frame_cryptors_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.manager_get_frame_cryptors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse& E2eeResponse::_internal_manager_get_frame_cryptors() const {
  return _internal_has_manager_get_frame_cryptors()
      ? *_impl_.message_.manager_get_frame_cryptors_
      : reinterpret_cast< ::livekit::proto::E2eeManagerGetFrameCryptorsResponse&>(::livekit::proto::_E2eeManagerGetFrameCryptorsResponse_default_instance_);
}
inline const ::livekit::proto::E2eeManagerGetFrameCryptorsResponse& E2eeResponse::manager_get_frame_cryptors() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
  return _internal_manager_get_frame_cryptors();
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* E2eeResponse::unsafe_arena_release_manager_get_frame_cryptors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
  if (_internal_has_manager_get_frame_cryptors()) {
    clear_has_message();
    ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* temp = _impl_.message_.manager_get_frame_cryptors_;
    _impl_.message_.manager_get_frame_cryptors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_manager_get_frame_cryptors(::livekit::proto::E2eeManagerGetFrameCryptorsResponse* manager_get_frame_cryptors) {
  clear_message();
  if (manager_get_frame_cryptors) {
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = manager_get_frame_cryptors;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* E2eeResponse::_internal_mutable_manager_get_frame_cryptors() {
  if (!_internal_has_manager_get_frame_cryptors()) {
    clear_message();
    set_has_manager_get_frame_cryptors();
    _impl_.message_.manager_get_frame_cryptors_ = CreateMaybeMessage< ::livekit::proto::E2eeManagerGetFrameCryptorsResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.manager_get_frame_cryptors_;
}
inline ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* E2eeResponse::mutable_manager_get_frame_cryptors() {
  ::livekit::proto::E2eeManagerGetFrameCryptorsResponse* _msg = _internal_mutable_manager_get_frame_cryptors();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.manager_get_frame_cryptors)
  return _msg;
}

// .livekit.proto.FrameCryptorSetEnabledResponse cryptor_set_enabled = 3;
inline bool E2eeResponse::_internal_has_cryptor_set_enabled() const {
  return message_case() == kCryptorSetEnabled;
}
inline bool E2eeResponse::has_cryptor_set_enabled() const {
  return _internal_has_cryptor_set_enabled();
}
inline void E2eeResponse::set_has_cryptor_set_enabled() {
  _impl_._oneof_case_[0] = kCryptorSetEnabled;
}
inline void E2eeResponse::clear_cryptor_set_enabled() {
  if (_internal_has_cryptor_set_enabled()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.cryptor_set_enabled_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::FrameCryptorSetEnabledResponse* E2eeResponse::release_cryptor_set_enabled() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.cryptor_set_enabled)
  if (_internal_has_cryptor_set_enabled()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetEnabledResponse* temp = _impl_.message_.cryptor_set_enabled_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.cryptor_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::FrameCryptorSetEnabledResponse& E2eeResponse::_internal_cryptor_set_enabled() const {
  return _internal_has_cryptor_set_enabled()
      ? *_impl_.message_.cryptor_set_enabled_
      : reinterpret_cast< ::livekit::proto::FrameCryptorSetEnabledResponse&>(::livekit::proto::_FrameCryptorSetEnabledResponse_default_instance_);
}
inline const ::livekit::proto::FrameCryptorSetEnabledResponse& E2eeResponse::cryptor_set_enabled() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.cryptor_set_enabled)
  return _internal_cryptor_set_enabled();
}
inline ::livekit::proto::FrameCryptorSetEnabledResponse* E2eeResponse::unsafe_arena_release_cryptor_set_enabled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.cryptor_set_enabled)
  if (_internal_has_cryptor_set_enabled()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetEnabledResponse* temp = _impl_.message_.cryptor_set_enabled_;
    _impl_.message_.cryptor_set_enabled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_cryptor_set_enabled(::livekit::proto::FrameCryptorSetEnabledResponse* cryptor_set_enabled) {
  clear_message();
  if (cryptor_set_enabled) {
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = cryptor_set_enabled;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.cryptor_set_enabled)
}
inline ::livekit::proto::FrameCryptorSetEnabledResponse* E2eeResponse::_internal_mutable_cryptor_set_enabled() {
  if (!_internal_has_cryptor_set_enabled()) {
    clear_message();
    set_has_cryptor_set_enabled();
    _impl_.message_.cryptor_set_enabled_ = CreateMaybeMessage< ::livekit::proto::FrameCryptorSetEnabledResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.cryptor_set_enabled_;
}
inline ::livekit::proto::FrameCryptorSetEnabledResponse* E2eeResponse::mutable_cryptor_set_enabled() {
  ::livekit::proto::FrameCryptorSetEnabledResponse* _msg = _internal_mutable_cryptor_set_enabled();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.cryptor_set_enabled)
  return _msg;
}

// .livekit.proto.FrameCryptorSetKeyIndexResponse cryptor_set_key_index = 4;
inline bool E2eeResponse::_internal_has_cryptor_set_key_index() const {
  return message_case() == kCryptorSetKeyIndex;
}
inline bool E2eeResponse::has_cryptor_set_key_index() const {
  return _internal_has_cryptor_set_key_index();
}
inline void E2eeResponse::set_has_cryptor_set_key_index() {
  _impl_._oneof_case_[0] = kCryptorSetKeyIndex;
}
inline void E2eeResponse::clear_cryptor_set_key_index() {
  if (_internal_has_cryptor_set_key_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.cryptor_set_key_index_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::FrameCryptorSetKeyIndexResponse* E2eeResponse::release_cryptor_set_key_index() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.cryptor_set_key_index)
  if (_internal_has_cryptor_set_key_index()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetKeyIndexResponse* temp = _impl_.message_.cryptor_set_key_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.cryptor_set_key_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::FrameCryptorSetKeyIndexResponse& E2eeResponse::_internal_cryptor_set_key_index() const {
  return _internal_has_cryptor_set_key_index()
      ? *_impl_.message_.cryptor_set_key_index_
      : reinterpret_cast< ::livekit::proto::FrameCryptorSetKeyIndexResponse&>(::livekit::proto::_FrameCryptorSetKeyIndexResponse_default_instance_);
}
inline const ::livekit::proto::FrameCryptorSetKeyIndexResponse& E2eeResponse::cryptor_set_key_index() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.cryptor_set_key_index)
  return _internal_cryptor_set_key_index();
}
inline ::livekit::proto::FrameCryptorSetKeyIndexResponse* E2eeResponse::unsafe_arena_release_cryptor_set_key_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.cryptor_set_key_index)
  if (_internal_has_cryptor_set_key_index()) {
    clear_has_message();
    ::livekit::proto::FrameCryptorSetKeyIndexResponse* temp = _impl_.message_.cryptor_set_key_index_;
    _impl_.message_.cryptor_set_key_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_cryptor_set_key_index(::livekit::proto::FrameCryptorSetKeyIndexResponse* cryptor_set_key_index) {
  clear_message();
  if (cryptor_set_key_index) {
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = cryptor_set_key_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.cryptor_set_key_index)
}
inline ::livekit::proto::FrameCryptorSetKeyIndexResponse* E2eeResponse::_internal_mutable_cryptor_set_key_index() {
  if (!_internal_has_cryptor_set_key_index()) {
    clear_message();
    set_has_cryptor_set_key_index();
    _impl_.message_.cryptor_set_key_index_ = CreateMaybeMessage< ::livekit::proto::FrameCryptorSetKeyIndexResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.cryptor_set_key_index_;
}
inline ::livekit::proto::FrameCryptorSetKeyIndexResponse* E2eeResponse::mutable_cryptor_set_key_index() {
  ::livekit::proto::FrameCryptorSetKeyIndexResponse* _msg = _internal_mutable_cryptor_set_key_index();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.cryptor_set_key_index)
  return _msg;
}

// .livekit.proto.SetSharedKeyResponse set_shared_key = 5;
inline bool E2eeResponse::_internal_has_set_shared_key() const {
  return message_case() == kSetSharedKey;
}
inline bool E2eeResponse::has_set_shared_key() const {
  return _internal_has_set_shared_key();
}
inline void E2eeResponse::set_has_set_shared_key() {
  _impl_._oneof_case_[0] = kSetSharedKey;
}
inline void E2eeResponse::clear_set_shared_key() {
  if (_internal_has_set_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.set_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::SetSharedKeyResponse* E2eeResponse::release_set_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.set_shared_key)
  if (_internal_has_set_shared_key()) {
    clear_has_message();
    ::livekit::proto::SetSharedKeyResponse* temp = _impl_.message_.set_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.set_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::SetSharedKeyResponse& E2eeResponse::_internal_set_shared_key() const {
  return _internal_has_set_shared_key()
      ? *_impl_.message_.set_shared_key_
      : reinterpret_cast< ::livekit::proto::SetSharedKeyResponse&>(::livekit::proto::_SetSharedKeyResponse_default_instance_);
}
inline const ::livekit::proto::SetSharedKeyResponse& E2eeResponse::set_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.set_shared_key)
  return _internal_set_shared_key();
}
inline ::livekit::proto::SetSharedKeyResponse* E2eeResponse::unsafe_arena_release_set_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.set_shared_key)
  if (_internal_has_set_shared_key()) {
    clear_has_message();
    ::livekit::proto::SetSharedKeyResponse* temp = _impl_.message_.set_shared_key_;
    _impl_.message_.set_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_set_shared_key(::livekit::proto::SetSharedKeyResponse* set_shared_key) {
  clear_message();
  if (set_shared_key) {
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = set_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.set_shared_key)
}
inline ::livekit::proto::SetSharedKeyResponse* E2eeResponse::_internal_mutable_set_shared_key() {
  if (!_internal_has_set_shared_key()) {
    clear_message();
    set_has_set_shared_key();
    _impl_.message_.set_shared_key_ = CreateMaybeMessage< ::livekit::proto::SetSharedKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.set_shared_key_;
}
inline ::livekit::proto::SetSharedKeyResponse* E2eeResponse::mutable_set_shared_key() {
  ::livekit::proto::SetSharedKeyResponse* _msg = _internal_mutable_set_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.set_shared_key)
  return _msg;
}

// .livekit.proto.RatchetSharedKeyResponse ratchet_shared_key = 6;
inline bool E2eeResponse::_internal_has_ratchet_shared_key() const {
  return message_case() == kRatchetSharedKey;
}
inline bool E2eeResponse::has_ratchet_shared_key() const {
  return _internal_has_ratchet_shared_key();
}
inline void E2eeResponse::set_has_ratchet_shared_key() {
  _impl_._oneof_case_[0] = kRatchetSharedKey;
}
inline void E2eeResponse::clear_ratchet_shared_key() {
  if (_internal_has_ratchet_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ratchet_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RatchetSharedKeyResponse* E2eeResponse::release_ratchet_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.ratchet_shared_key)
  if (_internal_has_ratchet_shared_key()) {
    clear_has_message();
    ::livekit::proto::RatchetSharedKeyResponse* temp = _impl_.message_.ratchet_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ratchet_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RatchetSharedKeyResponse& E2eeResponse::_internal_ratchet_shared_key() const {
  return _internal_has_ratchet_shared_key()
      ? *_impl_.message_.ratchet_shared_key_
      : reinterpret_cast< ::livekit::proto::RatchetSharedKeyResponse&>(::livekit::proto::_RatchetSharedKeyResponse_default_instance_);
}
inline const ::livekit::proto::RatchetSharedKeyResponse& E2eeResponse::ratchet_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.ratchet_shared_key)
  return _internal_ratchet_shared_key();
}
inline ::livekit::proto::RatchetSharedKeyResponse* E2eeResponse::unsafe_arena_release_ratchet_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.ratchet_shared_key)
  if (_internal_has_ratchet_shared_key()) {
    clear_has_message();
    ::livekit::proto::RatchetSharedKeyResponse* temp = _impl_.message_.ratchet_shared_key_;
    _impl_.message_.ratchet_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_ratchet_shared_key(::livekit::proto::RatchetSharedKeyResponse* ratchet_shared_key) {
  clear_message();
  if (ratchet_shared_key) {
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = ratchet_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.ratchet_shared_key)
}
inline ::livekit::proto::RatchetSharedKeyResponse* E2eeResponse::_internal_mutable_ratchet_shared_key() {
  if (!_internal_has_ratchet_shared_key()) {
    clear_message();
    set_has_ratchet_shared_key();
    _impl_.message_.ratchet_shared_key_ = CreateMaybeMessage< ::livekit::proto::RatchetSharedKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.ratchet_shared_key_;
}
inline ::livekit::proto::RatchetSharedKeyResponse* E2eeResponse::mutable_ratchet_shared_key() {
  ::livekit::proto::RatchetSharedKeyResponse* _msg = _internal_mutable_ratchet_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.ratchet_shared_key)
  return _msg;
}

// .livekit.proto.GetSharedKeyResponse get_shared_key = 7;
inline bool E2eeResponse::_internal_has_get_shared_key() const {
  return message_case() == kGetSharedKey;
}
inline bool E2eeResponse::has_get_shared_key() const {
  return _internal_has_get_shared_key();
}
inline void E2eeResponse::set_has_get_shared_key() {
  _impl_._oneof_case_[0] = kGetSharedKey;
}
inline void E2eeResponse::clear_get_shared_key() {
  if (_internal_has_get_shared_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.get_shared_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::GetSharedKeyResponse* E2eeResponse::release_get_shared_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.get_shared_key)
  if (_internal_has_get_shared_key()) {
    clear_has_message();
    ::livekit::proto::GetSharedKeyResponse* temp = _impl_.message_.get_shared_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.get_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::GetSharedKeyResponse& E2eeResponse::_internal_get_shared_key() const {
  return _internal_has_get_shared_key()
      ? *_impl_.message_.get_shared_key_
      : reinterpret_cast< ::livekit::proto::GetSharedKeyResponse&>(::livekit::proto::_GetSharedKeyResponse_default_instance_);
}
inline const ::livekit::proto::GetSharedKeyResponse& E2eeResponse::get_shared_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.get_shared_key)
  return _internal_get_shared_key();
}
inline ::livekit::proto::GetSharedKeyResponse* E2eeResponse::unsafe_arena_release_get_shared_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.get_shared_key)
  if (_internal_has_get_shared_key()) {
    clear_has_message();
    ::livekit::proto::GetSharedKeyResponse* temp = _impl_.message_.get_shared_key_;
    _impl_.message_.get_shared_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_get_shared_key(::livekit::proto::GetSharedKeyResponse* get_shared_key) {
  clear_message();
  if (get_shared_key) {
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = get_shared_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.get_shared_key)
}
inline ::livekit::proto::GetSharedKeyResponse* E2eeResponse::_internal_mutable_get_shared_key() {
  if (!_internal_has_get_shared_key()) {
    clear_message();
    set_has_get_shared_key();
    _impl_.message_.get_shared_key_ = CreateMaybeMessage< ::livekit::proto::GetSharedKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.get_shared_key_;
}
inline ::livekit::proto::GetSharedKeyResponse* E2eeResponse::mutable_get_shared_key() {
  ::livekit::proto::GetSharedKeyResponse* _msg = _internal_mutable_get_shared_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.get_shared_key)
  return _msg;
}

// .livekit.proto.SetKeyResponse set_key = 8;
inline bool E2eeResponse::_internal_has_set_key() const {
  return message_case() == kSetKey;
}
inline bool E2eeResponse::has_set_key() const {
  return _internal_has_set_key();
}
inline void E2eeResponse::set_has_set_key() {
  _impl_._oneof_case_[0] = kSetKey;
}
inline void E2eeResponse::clear_set_key() {
  if (_internal_has_set_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.set_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::SetKeyResponse* E2eeResponse::release_set_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.set_key)
  if (_internal_has_set_key()) {
    clear_has_message();
    ::livekit::proto::SetKeyResponse* temp = _impl_.message_.set_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.set_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::SetKeyResponse& E2eeResponse::_internal_set_key() const {
  return _internal_has_set_key()
      ? *_impl_.message_.set_key_
      : reinterpret_cast< ::livekit::proto::SetKeyResponse&>(::livekit::proto::_SetKeyResponse_default_instance_);
}
inline const ::livekit::proto::SetKeyResponse& E2eeResponse::set_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.set_key)
  return _internal_set_key();
}
inline ::livekit::proto::SetKeyResponse* E2eeResponse::unsafe_arena_release_set_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.set_key)
  if (_internal_has_set_key()) {
    clear_has_message();
    ::livekit::proto::SetKeyResponse* temp = _impl_.message_.set_key_;
    _impl_.message_.set_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_set_key(::livekit::proto::SetKeyResponse* set_key) {
  clear_message();
  if (set_key) {
    set_has_set_key();
    _impl_.message_.set_key_ = set_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.set_key)
}
inline ::livekit::proto::SetKeyResponse* E2eeResponse::_internal_mutable_set_key() {
  if (!_internal_has_set_key()) {
    clear_message();
    set_has_set_key();
    _impl_.message_.set_key_ = CreateMaybeMessage< ::livekit::proto::SetKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.set_key_;
}
inline ::livekit::proto::SetKeyResponse* E2eeResponse::mutable_set_key() {
  ::livekit::proto::SetKeyResponse* _msg = _internal_mutable_set_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.set_key)
  return _msg;
}

// .livekit.proto.RatchetKeyResponse ratchet_key = 9;
inline bool E2eeResponse::_internal_has_ratchet_key() const {
  return message_case() == kRatchetKey;
}
inline bool E2eeResponse::has_ratchet_key() const {
  return _internal_has_ratchet_key();
}
inline void E2eeResponse::set_has_ratchet_key() {
  _impl_._oneof_case_[0] = kRatchetKey;
}
inline void E2eeResponse::clear_ratchet_key() {
  if (_internal_has_ratchet_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ratchet_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::RatchetKeyResponse* E2eeResponse::release_ratchet_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.ratchet_key)
  if (_internal_has_ratchet_key()) {
    clear_has_message();
    ::livekit::proto::RatchetKeyResponse* temp = _impl_.message_.ratchet_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ratchet_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::RatchetKeyResponse& E2eeResponse::_internal_ratchet_key() const {
  return _internal_has_ratchet_key()
      ? *_impl_.message_.ratchet_key_
      : reinterpret_cast< ::livekit::proto::RatchetKeyResponse&>(::livekit::proto::_RatchetKeyResponse_default_instance_);
}
inline const ::livekit::proto::RatchetKeyResponse& E2eeResponse::ratchet_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.ratchet_key)
  return _internal_ratchet_key();
}
inline ::livekit::proto::RatchetKeyResponse* E2eeResponse::unsafe_arena_release_ratchet_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.ratchet_key)
  if (_internal_has_ratchet_key()) {
    clear_has_message();
    ::livekit::proto::RatchetKeyResponse* temp = _impl_.message_.ratchet_key_;
    _impl_.message_.ratchet_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_ratchet_key(::livekit::proto::RatchetKeyResponse* ratchet_key) {
  clear_message();
  if (ratchet_key) {
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = ratchet_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.ratchet_key)
}
inline ::livekit::proto::RatchetKeyResponse* E2eeResponse::_internal_mutable_ratchet_key() {
  if (!_internal_has_ratchet_key()) {
    clear_message();
    set_has_ratchet_key();
    _impl_.message_.ratchet_key_ = CreateMaybeMessage< ::livekit::proto::RatchetKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.ratchet_key_;
}
inline ::livekit::proto::RatchetKeyResponse* E2eeResponse::mutable_ratchet_key() {
  ::livekit::proto::RatchetKeyResponse* _msg = _internal_mutable_ratchet_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.ratchet_key)
  return _msg;
}

// .livekit.proto.GetKeyResponse get_key = 10;
inline bool E2eeResponse::_internal_has_get_key() const {
  return message_case() == kGetKey;
}
inline bool E2eeResponse::has_get_key() const {
  return _internal_has_get_key();
}
inline void E2eeResponse::set_has_get_key() {
  _impl_._oneof_case_[0] = kGetKey;
}
inline void E2eeResponse::clear_get_key() {
  if (_internal_has_get_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.get_key_;
    }
    clear_has_message();
  }
}
inline ::livekit::proto::GetKeyResponse* E2eeResponse::release_get_key() {
  // @@protoc_insertion_point(field_release:livekit.proto.E2eeResponse.get_key)
  if (_internal_has_get_key()) {
    clear_has_message();
    ::livekit::proto::GetKeyResponse* temp = _impl_.message_.get_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.get_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::proto::GetKeyResponse& E2eeResponse::_internal_get_key() const {
  return _internal_has_get_key()
      ? *_impl_.message_.get_key_
      : reinterpret_cast< ::livekit::proto::GetKeyResponse&>(::livekit::proto::_GetKeyResponse_default_instance_);
}
inline const ::livekit::proto::GetKeyResponse& E2eeResponse::get_key() const {
  // @@protoc_insertion_point(field_get:livekit.proto.E2eeResponse.get_key)
  return _internal_get_key();
}
inline ::livekit::proto::GetKeyResponse* E2eeResponse::unsafe_arena_release_get_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.proto.E2eeResponse.get_key)
  if (_internal_has_get_key()) {
    clear_has_message();
    ::livekit::proto::GetKeyResponse* temp = _impl_.message_.get_key_;
    _impl_.message_.get_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eeResponse::unsafe_arena_set_allocated_get_key(::livekit::proto::GetKeyResponse* get_key) {
  clear_message();
  if (get_key) {
    set_has_get_key();
    _impl_.message_.get_key_ = get_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.proto.E2eeResponse.get_key)
}
inline ::livekit::proto::GetKeyResponse* E2eeResponse::_internal_mutable_get_key() {
  if (!_internal_has_get_key()) {
    clear_message();
    set_has_get_key();
    _impl_.message_.get_key_ = CreateMaybeMessage< ::livekit::proto::GetKeyResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.get_key_;
}
inline ::livekit::proto::GetKeyResponse* E2eeResponse::mutable_get_key() {
  ::livekit::proto::GetKeyResponse* _msg = _internal_mutable_get_key();
  // @@protoc_insertion_point(field_mutable:livekit.proto.E2eeResponse.get_key)
  return _msg;
}

inline bool E2eeResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void E2eeResponse::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline E2eeResponse::MessageCase E2eeResponse::message_case() const {
  return E2eeResponse::MessageCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::proto::EncryptionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::EncryptionType>() {
  return ::livekit::proto::EncryptionType_descriptor();
}
template <> struct is_proto_enum< ::livekit::proto::EncryptionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::proto::EncryptionState>() {
  return ::livekit::proto::EncryptionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_e2ee_2eproto
