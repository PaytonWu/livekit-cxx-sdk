// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livekit_agent.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livekit_5fagent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livekit_5fagent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "livekit_models.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livekit_5fagent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livekit_5fagent_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livekit_5fagent_2eproto;
namespace livekit {
class AvailabilityRequest;
struct AvailabilityRequestDefaultTypeInternal;
extern AvailabilityRequestDefaultTypeInternal _AvailabilityRequest_default_instance_;
class AvailabilityResponse;
struct AvailabilityResponseDefaultTypeInternal;
extern AvailabilityResponseDefaultTypeInternal _AvailabilityResponse_default_instance_;
class AvailabilityResponse_ParticipantAttributesEntry_DoNotUse;
struct AvailabilityResponse_ParticipantAttributesEntry_DoNotUseDefaultTypeInternal;
extern AvailabilityResponse_ParticipantAttributesEntry_DoNotUseDefaultTypeInternal _AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_default_instance_;
class Job;
struct JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class JobAssignment;
struct JobAssignmentDefaultTypeInternal;
extern JobAssignmentDefaultTypeInternal _JobAssignment_default_instance_;
class JobState;
struct JobStateDefaultTypeInternal;
extern JobStateDefaultTypeInternal _JobState_default_instance_;
class JobTermination;
struct JobTerminationDefaultTypeInternal;
extern JobTerminationDefaultTypeInternal _JobTermination_default_instance_;
class MigrateJobRequest;
struct MigrateJobRequestDefaultTypeInternal;
extern MigrateJobRequestDefaultTypeInternal _MigrateJobRequest_default_instance_;
class RegisterWorkerRequest;
struct RegisterWorkerRequestDefaultTypeInternal;
extern RegisterWorkerRequestDefaultTypeInternal _RegisterWorkerRequest_default_instance_;
class RegisterWorkerResponse;
struct RegisterWorkerResponseDefaultTypeInternal;
extern RegisterWorkerResponseDefaultTypeInternal _RegisterWorkerResponse_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class SimulateJobRequest;
struct SimulateJobRequestDefaultTypeInternal;
extern SimulateJobRequestDefaultTypeInternal _SimulateJobRequest_default_instance_;
class UpdateJobStatus;
struct UpdateJobStatusDefaultTypeInternal;
extern UpdateJobStatusDefaultTypeInternal _UpdateJobStatus_default_instance_;
class UpdateWorkerStatus;
struct UpdateWorkerStatusDefaultTypeInternal;
extern UpdateWorkerStatusDefaultTypeInternal _UpdateWorkerStatus_default_instance_;
class WorkerMessage;
struct WorkerMessageDefaultTypeInternal;
extern WorkerMessageDefaultTypeInternal _WorkerMessage_default_instance_;
class WorkerPing;
struct WorkerPingDefaultTypeInternal;
extern WorkerPingDefaultTypeInternal _WorkerPing_default_instance_;
class WorkerPong;
struct WorkerPongDefaultTypeInternal;
extern WorkerPongDefaultTypeInternal _WorkerPong_default_instance_;
}  // namespace livekit
PROTOBUF_NAMESPACE_OPEN
template<> ::livekit::AvailabilityRequest* Arena::CreateMaybeMessage<::livekit::AvailabilityRequest>(Arena*);
template<> ::livekit::AvailabilityResponse* Arena::CreateMaybeMessage<::livekit::AvailabilityResponse>(Arena*);
template<> ::livekit::AvailabilityResponse_ParticipantAttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::livekit::AvailabilityResponse_ParticipantAttributesEntry_DoNotUse>(Arena*);
template<> ::livekit::Job* Arena::CreateMaybeMessage<::livekit::Job>(Arena*);
template<> ::livekit::JobAssignment* Arena::CreateMaybeMessage<::livekit::JobAssignment>(Arena*);
template<> ::livekit::JobState* Arena::CreateMaybeMessage<::livekit::JobState>(Arena*);
template<> ::livekit::JobTermination* Arena::CreateMaybeMessage<::livekit::JobTermination>(Arena*);
template<> ::livekit::MigrateJobRequest* Arena::CreateMaybeMessage<::livekit::MigrateJobRequest>(Arena*);
template<> ::livekit::RegisterWorkerRequest* Arena::CreateMaybeMessage<::livekit::RegisterWorkerRequest>(Arena*);
template<> ::livekit::RegisterWorkerResponse* Arena::CreateMaybeMessage<::livekit::RegisterWorkerResponse>(Arena*);
template<> ::livekit::ServerMessage* Arena::CreateMaybeMessage<::livekit::ServerMessage>(Arena*);
template<> ::livekit::SimulateJobRequest* Arena::CreateMaybeMessage<::livekit::SimulateJobRequest>(Arena*);
template<> ::livekit::UpdateJobStatus* Arena::CreateMaybeMessage<::livekit::UpdateJobStatus>(Arena*);
template<> ::livekit::UpdateWorkerStatus* Arena::CreateMaybeMessage<::livekit::UpdateWorkerStatus>(Arena*);
template<> ::livekit::WorkerMessage* Arena::CreateMaybeMessage<::livekit::WorkerMessage>(Arena*);
template<> ::livekit::WorkerPing* Arena::CreateMaybeMessage<::livekit::WorkerPing>(Arena*);
template<> ::livekit::WorkerPong* Arena::CreateMaybeMessage<::livekit::WorkerPong>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace livekit {

enum JobType : int {
  JT_ROOM = 0,
  JT_PUBLISHER = 1,
  JT_PARTICIPANT = 2,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobType_IsValid(int value);
constexpr JobType JobType_MIN = JT_ROOM;
constexpr JobType JobType_MAX = JT_PARTICIPANT;
constexpr int JobType_ARRAYSIZE = JobType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobType_descriptor();
template<typename T>
inline const std::string& JobType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobType_descriptor(), enum_t_value);
}
inline bool JobType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobType>(
    JobType_descriptor(), name, value);
}
enum WorkerStatus : int {
  WS_AVAILABLE = 0,
  WS_FULL = 1,
  WorkerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WorkerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WorkerStatus_IsValid(int value);
constexpr WorkerStatus WorkerStatus_MIN = WS_AVAILABLE;
constexpr WorkerStatus WorkerStatus_MAX = WS_FULL;
constexpr int WorkerStatus_ARRAYSIZE = WorkerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkerStatus_descriptor();
template<typename T>
inline const std::string& WorkerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkerStatus_descriptor(), enum_t_value);
}
inline bool WorkerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkerStatus>(
    WorkerStatus_descriptor(), name, value);
}
enum JobStatus : int {
  JS_PENDING = 0,
  JS_RUNNING = 1,
  JS_SUCCESS = 2,
  JS_FAILED = 3,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JobStatus_IsValid(int value);
constexpr JobStatus JobStatus_MIN = JS_PENDING;
constexpr JobStatus JobStatus_MAX = JS_FAILED;
constexpr int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobStatus_descriptor();
template<typename T>
inline const std::string& JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobStatus_descriptor(), enum_t_value);
}
inline bool JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
// ===================================================================

class Job final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.Job) */ {
 public:
  inline Job() : Job(nullptr) {}
  ~Job() override;
  explicit PROTOBUF_CONSTEXPR Job(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Job(const Job& from);
  Job(Job&& from) noexcept
    : Job() {
    *this = ::std::move(from);
  }

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }
  inline Job& operator=(Job&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Job& default_instance() {
    return *internal_default_instance();
  }
  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Job& a, Job& b) {
    a.Swap(&b);
  }
  inline void Swap(Job* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Job* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Job* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Job>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Job& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Job& from) {
    Job::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Job* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.Job";
  }
  protected:
  explicit Job(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNamespaceFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kAgentNameFieldNumber = 7,
    kDispatchIdFieldNumber = 9,
    kRoomFieldNumber = 3,
    kParticipantFieldNumber = 4,
    kStateFieldNumber = 8,
    kTypeFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string namespace = 5 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_namespace_();
  PROTOBUF_DEPRECATED const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_namespace_(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_namespace_();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_namespace_();
  PROTOBUF_DEPRECATED void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string metadata = 6;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // string agent_name = 7;
  void clear_agent_name();
  const std::string& agent_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_name();
  PROTOBUF_NODISCARD std::string* release_agent_name();
  void set_allocated_agent_name(std::string* agent_name);
  private:
  const std::string& _internal_agent_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_name(const std::string& value);
  std::string* _internal_mutable_agent_name();
  public:

  // string dispatch_id = 9;
  void clear_dispatch_id();
  const std::string& dispatch_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dispatch_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dispatch_id();
  PROTOBUF_NODISCARD std::string* release_dispatch_id();
  void set_allocated_dispatch_id(std::string* dispatch_id);
  private:
  const std::string& _internal_dispatch_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dispatch_id(const std::string& value);
  std::string* _internal_mutable_dispatch_id();
  public:

  // .livekit.Room room = 3;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // optional .livekit.ParticipantInfo participant = 4;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::ParticipantInfo& participant() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantInfo* release_participant();
  ::livekit::ParticipantInfo* mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* participant);
  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::ParticipantInfo* participant);
  ::livekit::ParticipantInfo* unsafe_arena_release_participant();

  // .livekit.JobState state = 8;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::livekit::JobState& state() const;
  PROTOBUF_NODISCARD ::livekit::JobState* release_state();
  ::livekit::JobState* mutable_state();
  void set_allocated_state(::livekit::JobState* state);
  private:
  const ::livekit::JobState& _internal_state() const;
  ::livekit::JobState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::livekit::JobState* state);
  ::livekit::JobState* unsafe_arena_release_state();

  // .livekit.JobType type = 2;
  void clear_type();
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);
  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.Job)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dispatch_id_;
    ::livekit::Room* room_;
    ::livekit::ParticipantInfo* participant_;
    ::livekit::JobState* state_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class JobState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.JobState) */ {
 public:
  inline JobState() : JobState(nullptr) {}
  ~JobState() override;
  explicit PROTOBUF_CONSTEXPR JobState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobState(const JobState& from);
  JobState(JobState&& from) noexcept
    : JobState() {
    *this = ::std::move(from);
  }

  inline JobState& operator=(const JobState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobState& operator=(JobState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobState& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobState* internal_default_instance() {
    return reinterpret_cast<const JobState*>(
               &_JobState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JobState& a, JobState& b) {
    a.Swap(&b);
  }
  inline void Swap(JobState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobState& from) {
    JobState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.JobState";
  }
  protected:
  explicit JobState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kParticipantIdentityFieldNumber = 6,
    kStartedAtFieldNumber = 3,
    kEndedAtFieldNumber = 4,
    kUpdatedAtFieldNumber = 5,
    kStatusFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string participant_identity = 6;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // int64 started_at = 3;
  void clear_started_at();
  int64_t started_at() const;
  void set_started_at(int64_t value);
  private:
  int64_t _internal_started_at() const;
  void _internal_set_started_at(int64_t value);
  public:

  // int64 ended_at = 4;
  void clear_ended_at();
  int64_t ended_at() const;
  void set_ended_at(int64_t value);
  private:
  int64_t _internal_ended_at() const;
  void _internal_set_ended_at(int64_t value);
  public:

  // int64 updated_at = 5;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // .livekit.JobStatus status = 1;
  void clear_status();
  ::livekit::JobStatus status() const;
  void set_status(::livekit::JobStatus value);
  private:
  ::livekit::JobStatus _internal_status() const;
  void _internal_set_status(::livekit::JobStatus value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.JobState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    int64_t started_at_;
    int64_t ended_at_;
    int64_t updated_at_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class WorkerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.WorkerMessage) */ {
 public:
  inline WorkerMessage() : WorkerMessage(nullptr) {}
  ~WorkerMessage() override;
  explicit PROTOBUF_CONSTEXPR WorkerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerMessage(const WorkerMessage& from);
  WorkerMessage(WorkerMessage&& from) noexcept
    : WorkerMessage() {
    *this = ::std::move(from);
  }

  inline WorkerMessage& operator=(const WorkerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerMessage& operator=(WorkerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kRegister = 1,
    kAvailability = 2,
    kUpdateWorker = 3,
    kUpdateJob = 4,
    kPing = 5,
    kSimulateJob = 6,
    kMigrateJob = 7,
    MESSAGE_NOT_SET = 0,
  };

  static inline const WorkerMessage* internal_default_instance() {
    return reinterpret_cast<const WorkerMessage*>(
               &_WorkerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WorkerMessage& a, WorkerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkerMessage& from) {
    WorkerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.WorkerMessage";
  }
  protected:
  explicit WorkerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterFieldNumber = 1,
    kAvailabilityFieldNumber = 2,
    kUpdateWorkerFieldNumber = 3,
    kUpdateJobFieldNumber = 4,
    kPingFieldNumber = 5,
    kSimulateJobFieldNumber = 6,
    kMigrateJobFieldNumber = 7,
  };
  // .livekit.RegisterWorkerRequest register = 1;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;
  public:
  void clear_register_();
  const ::livekit::RegisterWorkerRequest& register_() const;
  PROTOBUF_NODISCARD ::livekit::RegisterWorkerRequest* release_register_();
  ::livekit::RegisterWorkerRequest* mutable_register_();
  void set_allocated_register_(::livekit::RegisterWorkerRequest* register_);
  private:
  const ::livekit::RegisterWorkerRequest& _internal_register_() const;
  ::livekit::RegisterWorkerRequest* _internal_mutable_register_();
  public:
  void unsafe_arena_set_allocated_register_(
      ::livekit::RegisterWorkerRequest* register_);
  ::livekit::RegisterWorkerRequest* unsafe_arena_release_register_();

  // .livekit.AvailabilityResponse availability = 2;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;
  public:
  void clear_availability();
  const ::livekit::AvailabilityResponse& availability() const;
  PROTOBUF_NODISCARD ::livekit::AvailabilityResponse* release_availability();
  ::livekit::AvailabilityResponse* mutable_availability();
  void set_allocated_availability(::livekit::AvailabilityResponse* availability);
  private:
  const ::livekit::AvailabilityResponse& _internal_availability() const;
  ::livekit::AvailabilityResponse* _internal_mutable_availability();
  public:
  void unsafe_arena_set_allocated_availability(
      ::livekit::AvailabilityResponse* availability);
  ::livekit::AvailabilityResponse* unsafe_arena_release_availability();

  // .livekit.UpdateWorkerStatus update_worker = 3;
  bool has_update_worker() const;
  private:
  bool _internal_has_update_worker() const;
  public:
  void clear_update_worker();
  const ::livekit::UpdateWorkerStatus& update_worker() const;
  PROTOBUF_NODISCARD ::livekit::UpdateWorkerStatus* release_update_worker();
  ::livekit::UpdateWorkerStatus* mutable_update_worker();
  void set_allocated_update_worker(::livekit::UpdateWorkerStatus* update_worker);
  private:
  const ::livekit::UpdateWorkerStatus& _internal_update_worker() const;
  ::livekit::UpdateWorkerStatus* _internal_mutable_update_worker();
  public:
  void unsafe_arena_set_allocated_update_worker(
      ::livekit::UpdateWorkerStatus* update_worker);
  ::livekit::UpdateWorkerStatus* unsafe_arena_release_update_worker();

  // .livekit.UpdateJobStatus update_job = 4;
  bool has_update_job() const;
  private:
  bool _internal_has_update_job() const;
  public:
  void clear_update_job();
  const ::livekit::UpdateJobStatus& update_job() const;
  PROTOBUF_NODISCARD ::livekit::UpdateJobStatus* release_update_job();
  ::livekit::UpdateJobStatus* mutable_update_job();
  void set_allocated_update_job(::livekit::UpdateJobStatus* update_job);
  private:
  const ::livekit::UpdateJobStatus& _internal_update_job() const;
  ::livekit::UpdateJobStatus* _internal_mutable_update_job();
  public:
  void unsafe_arena_set_allocated_update_job(
      ::livekit::UpdateJobStatus* update_job);
  ::livekit::UpdateJobStatus* unsafe_arena_release_update_job();

  // .livekit.WorkerPing ping = 5;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::livekit::WorkerPing& ping() const;
  PROTOBUF_NODISCARD ::livekit::WorkerPing* release_ping();
  ::livekit::WorkerPing* mutable_ping();
  void set_allocated_ping(::livekit::WorkerPing* ping);
  private:
  const ::livekit::WorkerPing& _internal_ping() const;
  ::livekit::WorkerPing* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::livekit::WorkerPing* ping);
  ::livekit::WorkerPing* unsafe_arena_release_ping();

  // .livekit.SimulateJobRequest simulate_job = 6;
  bool has_simulate_job() const;
  private:
  bool _internal_has_simulate_job() const;
  public:
  void clear_simulate_job();
  const ::livekit::SimulateJobRequest& simulate_job() const;
  PROTOBUF_NODISCARD ::livekit::SimulateJobRequest* release_simulate_job();
  ::livekit::SimulateJobRequest* mutable_simulate_job();
  void set_allocated_simulate_job(::livekit::SimulateJobRequest* simulate_job);
  private:
  const ::livekit::SimulateJobRequest& _internal_simulate_job() const;
  ::livekit::SimulateJobRequest* _internal_mutable_simulate_job();
  public:
  void unsafe_arena_set_allocated_simulate_job(
      ::livekit::SimulateJobRequest* simulate_job);
  ::livekit::SimulateJobRequest* unsafe_arena_release_simulate_job();

  // .livekit.MigrateJobRequest migrate_job = 7;
  bool has_migrate_job() const;
  private:
  bool _internal_has_migrate_job() const;
  public:
  void clear_migrate_job();
  const ::livekit::MigrateJobRequest& migrate_job() const;
  PROTOBUF_NODISCARD ::livekit::MigrateJobRequest* release_migrate_job();
  ::livekit::MigrateJobRequest* mutable_migrate_job();
  void set_allocated_migrate_job(::livekit::MigrateJobRequest* migrate_job);
  private:
  const ::livekit::MigrateJobRequest& _internal_migrate_job() const;
  ::livekit::MigrateJobRequest* _internal_mutable_migrate_job();
  public:
  void unsafe_arena_set_allocated_migrate_job(
      ::livekit::MigrateJobRequest* migrate_job);
  ::livekit::MigrateJobRequest* unsafe_arena_release_migrate_job();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.WorkerMessage)
 private:
  class _Internal;
  void set_has_register_();
  void set_has_availability();
  void set_has_update_worker();
  void set_has_update_job();
  void set_has_ping();
  void set_has_simulate_job();
  void set_has_migrate_job();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::RegisterWorkerRequest* register__;
      ::livekit::AvailabilityResponse* availability_;
      ::livekit::UpdateWorkerStatus* update_worker_;
      ::livekit::UpdateJobStatus* update_job_;
      ::livekit::WorkerPing* ping_;
      ::livekit::SimulateJobRequest* simulate_job_;
      ::livekit::MigrateJobRequest* migrate_job_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kRegister = 1,
    kAvailability = 2,
    kAssignment = 3,
    kTermination = 5,
    kPong = 4,
    MESSAGE_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisterFieldNumber = 1,
    kAvailabilityFieldNumber = 2,
    kAssignmentFieldNumber = 3,
    kTerminationFieldNumber = 5,
    kPongFieldNumber = 4,
  };
  // .livekit.RegisterWorkerResponse register = 1;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;
  public:
  void clear_register_();
  const ::livekit::RegisterWorkerResponse& register_() const;
  PROTOBUF_NODISCARD ::livekit::RegisterWorkerResponse* release_register_();
  ::livekit::RegisterWorkerResponse* mutable_register_();
  void set_allocated_register_(::livekit::RegisterWorkerResponse* register_);
  private:
  const ::livekit::RegisterWorkerResponse& _internal_register_() const;
  ::livekit::RegisterWorkerResponse* _internal_mutable_register_();
  public:
  void unsafe_arena_set_allocated_register_(
      ::livekit::RegisterWorkerResponse* register_);
  ::livekit::RegisterWorkerResponse* unsafe_arena_release_register_();

  // .livekit.AvailabilityRequest availability = 2;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;
  public:
  void clear_availability();
  const ::livekit::AvailabilityRequest& availability() const;
  PROTOBUF_NODISCARD ::livekit::AvailabilityRequest* release_availability();
  ::livekit::AvailabilityRequest* mutable_availability();
  void set_allocated_availability(::livekit::AvailabilityRequest* availability);
  private:
  const ::livekit::AvailabilityRequest& _internal_availability() const;
  ::livekit::AvailabilityRequest* _internal_mutable_availability();
  public:
  void unsafe_arena_set_allocated_availability(
      ::livekit::AvailabilityRequest* availability);
  ::livekit::AvailabilityRequest* unsafe_arena_release_availability();

  // .livekit.JobAssignment assignment = 3;
  bool has_assignment() const;
  private:
  bool _internal_has_assignment() const;
  public:
  void clear_assignment();
  const ::livekit::JobAssignment& assignment() const;
  PROTOBUF_NODISCARD ::livekit::JobAssignment* release_assignment();
  ::livekit::JobAssignment* mutable_assignment();
  void set_allocated_assignment(::livekit::JobAssignment* assignment);
  private:
  const ::livekit::JobAssignment& _internal_assignment() const;
  ::livekit::JobAssignment* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::livekit::JobAssignment* assignment);
  ::livekit::JobAssignment* unsafe_arena_release_assignment();

  // .livekit.JobTermination termination = 5;
  bool has_termination() const;
  private:
  bool _internal_has_termination() const;
  public:
  void clear_termination();
  const ::livekit::JobTermination& termination() const;
  PROTOBUF_NODISCARD ::livekit::JobTermination* release_termination();
  ::livekit::JobTermination* mutable_termination();
  void set_allocated_termination(::livekit::JobTermination* termination);
  private:
  const ::livekit::JobTermination& _internal_termination() const;
  ::livekit::JobTermination* _internal_mutable_termination();
  public:
  void unsafe_arena_set_allocated_termination(
      ::livekit::JobTermination* termination);
  ::livekit::JobTermination* unsafe_arena_release_termination();

  // .livekit.WorkerPong pong = 4;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::livekit::WorkerPong& pong() const;
  PROTOBUF_NODISCARD ::livekit::WorkerPong* release_pong();
  ::livekit::WorkerPong* mutable_pong();
  void set_allocated_pong(::livekit::WorkerPong* pong);
  private:
  const ::livekit::WorkerPong& _internal_pong() const;
  ::livekit::WorkerPong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::livekit::WorkerPong* pong);
  ::livekit::WorkerPong* unsafe_arena_release_pong();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:livekit.ServerMessage)
 private:
  class _Internal;
  void set_has_register_();
  void set_has_availability();
  void set_has_assignment();
  void set_has_termination();
  void set_has_pong();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::livekit::RegisterWorkerResponse* register__;
      ::livekit::AvailabilityRequest* availability_;
      ::livekit::JobAssignment* assignment_;
      ::livekit::JobTermination* termination_;
      ::livekit::WorkerPong* pong_;
    } message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class SimulateJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.SimulateJobRequest) */ {
 public:
  inline SimulateJobRequest() : SimulateJobRequest(nullptr) {}
  ~SimulateJobRequest() override;
  explicit PROTOBUF_CONSTEXPR SimulateJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimulateJobRequest(const SimulateJobRequest& from);
  SimulateJobRequest(SimulateJobRequest&& from) noexcept
    : SimulateJobRequest() {
    *this = ::std::move(from);
  }

  inline SimulateJobRequest& operator=(const SimulateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulateJobRequest& operator=(SimulateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimulateJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimulateJobRequest* internal_default_instance() {
    return reinterpret_cast<const SimulateJobRequest*>(
               &_SimulateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SimulateJobRequest& a, SimulateJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulateJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulateJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimulateJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimulateJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimulateJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SimulateJobRequest& from) {
    SimulateJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulateJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.SimulateJobRequest";
  }
  protected:
  explicit SimulateJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 2,
    kParticipantFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .livekit.Room room = 2;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::livekit::Room& room() const;
  PROTOBUF_NODISCARD ::livekit::Room* release_room();
  ::livekit::Room* mutable_room();
  void set_allocated_room(::livekit::Room* room);
  private:
  const ::livekit::Room& _internal_room() const;
  ::livekit::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::livekit::Room* room);
  ::livekit::Room* unsafe_arena_release_room();

  // .livekit.ParticipantInfo participant = 3;
  bool has_participant() const;
  private:
  bool _internal_has_participant() const;
  public:
  void clear_participant();
  const ::livekit::ParticipantInfo& participant() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantInfo* release_participant();
  ::livekit::ParticipantInfo* mutable_participant();
  void set_allocated_participant(::livekit::ParticipantInfo* participant);
  private:
  const ::livekit::ParticipantInfo& _internal_participant() const;
  ::livekit::ParticipantInfo* _internal_mutable_participant();
  public:
  void unsafe_arena_set_allocated_participant(
      ::livekit::ParticipantInfo* participant);
  ::livekit::ParticipantInfo* unsafe_arena_release_participant();

  // .livekit.JobType type = 1;
  void clear_type();
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);
  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.SimulateJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::Room* room_;
    ::livekit::ParticipantInfo* participant_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class WorkerPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.WorkerPing) */ {
 public:
  inline WorkerPing() : WorkerPing(nullptr) {}
  ~WorkerPing() override;
  explicit PROTOBUF_CONSTEXPR WorkerPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerPing(const WorkerPing& from);
  WorkerPing(WorkerPing&& from) noexcept
    : WorkerPing() {
    *this = ::std::move(from);
  }

  inline WorkerPing& operator=(const WorkerPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerPing& operator=(WorkerPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerPing* internal_default_instance() {
    return reinterpret_cast<const WorkerPing*>(
               &_WorkerPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WorkerPing& a, WorkerPing& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkerPing& from) {
    WorkerPing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerPing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.WorkerPing";
  }
  protected:
  explicit WorkerPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.WorkerPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class WorkerPong final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.WorkerPong) */ {
 public:
  inline WorkerPong() : WorkerPong(nullptr) {}
  ~WorkerPong() override;
  explicit PROTOBUF_CONSTEXPR WorkerPong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerPong(const WorkerPong& from);
  WorkerPong(WorkerPong&& from) noexcept
    : WorkerPong() {
    *this = ::std::move(from);
  }

  inline WorkerPong& operator=(const WorkerPong& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerPong& operator=(WorkerPong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerPong& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerPong* internal_default_instance() {
    return reinterpret_cast<const WorkerPong*>(
               &_WorkerPong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WorkerPong& a, WorkerPong& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerPong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerPong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerPong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerPong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerPong& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkerPong& from) {
    WorkerPong::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerPong* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.WorkerPong";
  }
  protected:
  explicit WorkerPong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLastTimestampFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // int64 last_timestamp = 1;
  void clear_last_timestamp();
  int64_t last_timestamp() const;
  void set_last_timestamp(int64_t value);
  private:
  int64_t _internal_last_timestamp() const;
  void _internal_set_last_timestamp(int64_t value);
  public:

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.WorkerPong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t last_timestamp_;
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class RegisterWorkerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RegisterWorkerRequest) */ {
 public:
  inline RegisterWorkerRequest() : RegisterWorkerRequest(nullptr) {}
  ~RegisterWorkerRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterWorkerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterWorkerRequest(const RegisterWorkerRequest& from);
  RegisterWorkerRequest(RegisterWorkerRequest&& from) noexcept
    : RegisterWorkerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterWorkerRequest& operator=(const RegisterWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterWorkerRequest& operator=(RegisterWorkerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterWorkerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterWorkerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterWorkerRequest*>(
               &_RegisterWorkerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterWorkerRequest& a, RegisterWorkerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterWorkerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterWorkerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterWorkerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterWorkerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterWorkerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterWorkerRequest& from) {
    RegisterWorkerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterWorkerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RegisterWorkerRequest";
  }
  protected:
  explicit RegisterWorkerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 3,
    kNamespaceFieldNumber = 6,
    kAgentNameFieldNumber = 8,
    kAllowedPermissionsFieldNumber = 7,
    kTypeFieldNumber = 1,
    kPingIntervalFieldNumber = 5,
  };
  // string version = 3;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string namespace = 6;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string agent_name = 8;
  void clear_agent_name();
  const std::string& agent_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_name();
  PROTOBUF_NODISCARD std::string* release_agent_name();
  void set_allocated_agent_name(std::string* agent_name);
  private:
  const std::string& _internal_agent_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_name(const std::string& value);
  std::string* _internal_mutable_agent_name();
  public:

  // .livekit.ParticipantPermission allowed_permissions = 7;
  bool has_allowed_permissions() const;
  private:
  bool _internal_has_allowed_permissions() const;
  public:
  void clear_allowed_permissions();
  const ::livekit::ParticipantPermission& allowed_permissions() const;
  PROTOBUF_NODISCARD ::livekit::ParticipantPermission* release_allowed_permissions();
  ::livekit::ParticipantPermission* mutable_allowed_permissions();
  void set_allocated_allowed_permissions(::livekit::ParticipantPermission* allowed_permissions);
  private:
  const ::livekit::ParticipantPermission& _internal_allowed_permissions() const;
  ::livekit::ParticipantPermission* _internal_mutable_allowed_permissions();
  public:
  void unsafe_arena_set_allocated_allowed_permissions(
      ::livekit::ParticipantPermission* allowed_permissions);
  ::livekit::ParticipantPermission* unsafe_arena_release_allowed_permissions();

  // .livekit.JobType type = 1;
  void clear_type();
  ::livekit::JobType type() const;
  void set_type(::livekit::JobType value);
  private:
  ::livekit::JobType _internal_type() const;
  void _internal_set_type(::livekit::JobType value);
  public:

  // uint32 ping_interval = 5;
  void clear_ping_interval();
  uint32_t ping_interval() const;
  void set_ping_interval(uint32_t value);
  private:
  uint32_t _internal_ping_interval() const;
  void _internal_set_ping_interval(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.RegisterWorkerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_name_;
    ::livekit::ParticipantPermission* allowed_permissions_;
    int type_;
    uint32_t ping_interval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class RegisterWorkerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.RegisterWorkerResponse) */ {
 public:
  inline RegisterWorkerResponse() : RegisterWorkerResponse(nullptr) {}
  ~RegisterWorkerResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterWorkerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterWorkerResponse(const RegisterWorkerResponse& from);
  RegisterWorkerResponse(RegisterWorkerResponse&& from) noexcept
    : RegisterWorkerResponse() {
    *this = ::std::move(from);
  }

  inline RegisterWorkerResponse& operator=(const RegisterWorkerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterWorkerResponse& operator=(RegisterWorkerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterWorkerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterWorkerResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterWorkerResponse*>(
               &_RegisterWorkerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegisterWorkerResponse& a, RegisterWorkerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterWorkerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterWorkerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterWorkerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterWorkerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterWorkerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterWorkerResponse& from) {
    RegisterWorkerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterWorkerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.RegisterWorkerResponse";
  }
  protected:
  explicit RegisterWorkerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerIdFieldNumber = 1,
    kServerInfoFieldNumber = 3,
  };
  // string worker_id = 1;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // .livekit.ServerInfo server_info = 3;
  bool has_server_info() const;
  private:
  bool _internal_has_server_info() const;
  public:
  void clear_server_info();
  const ::livekit::ServerInfo& server_info() const;
  PROTOBUF_NODISCARD ::livekit::ServerInfo* release_server_info();
  ::livekit::ServerInfo* mutable_server_info();
  void set_allocated_server_info(::livekit::ServerInfo* server_info);
  private:
  const ::livekit::ServerInfo& _internal_server_info() const;
  ::livekit::ServerInfo* _internal_mutable_server_info();
  public:
  void unsafe_arena_set_allocated_server_info(
      ::livekit::ServerInfo* server_info);
  ::livekit::ServerInfo* unsafe_arena_release_server_info();

  // @@protoc_insertion_point(class_scope:livekit.RegisterWorkerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    ::livekit::ServerInfo* server_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class MigrateJobRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.MigrateJobRequest) */ {
 public:
  inline MigrateJobRequest() : MigrateJobRequest(nullptr) {}
  ~MigrateJobRequest() override;
  explicit PROTOBUF_CONSTEXPR MigrateJobRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateJobRequest(const MigrateJobRequest& from);
  MigrateJobRequest(MigrateJobRequest&& from) noexcept
    : MigrateJobRequest() {
    *this = ::std::move(from);
  }

  inline MigrateJobRequest& operator=(const MigrateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateJobRequest& operator=(MigrateJobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateJobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateJobRequest* internal_default_instance() {
    return reinterpret_cast<const MigrateJobRequest*>(
               &_MigrateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MigrateJobRequest& a, MigrateJobRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateJobRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateJobRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MigrateJobRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MigrateJobRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateJobRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MigrateJobRequest& from) {
    MigrateJobRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateJobRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.MigrateJobRequest";
  }
  protected:
  explicit MigrateJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdsFieldNumber = 2,
  };
  // repeated string job_ids = 2;
  int job_ids_size() const;
  private:
  int _internal_job_ids_size() const;
  public:
  void clear_job_ids();
  const std::string& job_ids(int index) const;
  std::string* mutable_job_ids(int index);
  void set_job_ids(int index, const std::string& value);
  void set_job_ids(int index, std::string&& value);
  void set_job_ids(int index, const char* value);
  void set_job_ids(int index, const char* value, size_t size);
  std::string* add_job_ids();
  void add_job_ids(const std::string& value);
  void add_job_ids(std::string&& value);
  void add_job_ids(const char* value);
  void add_job_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& job_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_job_ids();
  private:
  const std::string& _internal_job_ids(int index) const;
  std::string* _internal_add_job_ids();
  public:

  // @@protoc_insertion_point(class_scope:livekit.MigrateJobRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> job_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class AvailabilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AvailabilityRequest) */ {
 public:
  inline AvailabilityRequest() : AvailabilityRequest(nullptr) {}
  ~AvailabilityRequest() override;
  explicit PROTOBUF_CONSTEXPR AvailabilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailabilityRequest(const AvailabilityRequest& from);
  AvailabilityRequest(AvailabilityRequest&& from) noexcept
    : AvailabilityRequest() {
    *this = ::std::move(from);
  }

  inline AvailabilityRequest& operator=(const AvailabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailabilityRequest& operator=(AvailabilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailabilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailabilityRequest* internal_default_instance() {
    return reinterpret_cast<const AvailabilityRequest*>(
               &_AvailabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AvailabilityRequest& a, AvailabilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailabilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailabilityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailabilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailabilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailabilityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvailabilityRequest& from) {
    AvailabilityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailabilityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AvailabilityRequest";
  }
  protected:
  explicit AvailabilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobFieldNumber = 1,
    kResumingFieldNumber = 2,
  };
  // .livekit.Job job = 1;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::livekit::Job& job() const;
  PROTOBUF_NODISCARD ::livekit::Job* release_job();
  ::livekit::Job* mutable_job();
  void set_allocated_job(::livekit::Job* job);
  private:
  const ::livekit::Job& _internal_job() const;
  ::livekit::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::livekit::Job* job);
  ::livekit::Job* unsafe_arena_release_job();

  // bool resuming = 2;
  void clear_resuming();
  bool resuming() const;
  void set_resuming(bool value);
  private:
  bool _internal_resuming() const;
  void _internal_set_resuming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.AvailabilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::livekit::Job* job_;
    bool resuming_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class AvailabilityResponse_ParticipantAttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AvailabilityResponse_ParticipantAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AvailabilityResponse_ParticipantAttributesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AvailabilityResponse_ParticipantAttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR AvailabilityResponse_ParticipantAttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AvailabilityResponse_ParticipantAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AvailabilityResponse_ParticipantAttributesEntry_DoNotUse& other);
  static const AvailabilityResponse_ParticipantAttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AvailabilityResponse_ParticipantAttributesEntry_DoNotUse*>(&_AvailabilityResponse_ParticipantAttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.AvailabilityResponse.ParticipantAttributesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "livekit.AvailabilityResponse.ParticipantAttributesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};

// -------------------------------------------------------------------

class AvailabilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.AvailabilityResponse) */ {
 public:
  inline AvailabilityResponse() : AvailabilityResponse(nullptr) {}
  ~AvailabilityResponse() override;
  explicit PROTOBUF_CONSTEXPR AvailabilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailabilityResponse(const AvailabilityResponse& from);
  AvailabilityResponse(AvailabilityResponse&& from) noexcept
    : AvailabilityResponse() {
    *this = ::std::move(from);
  }

  inline AvailabilityResponse& operator=(const AvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailabilityResponse& operator=(AvailabilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailabilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailabilityResponse* internal_default_instance() {
    return reinterpret_cast<const AvailabilityResponse*>(
               &_AvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AvailabilityResponse& a, AvailabilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailabilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailabilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailabilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailabilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailabilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvailabilityResponse& from) {
    AvailabilityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailabilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.AvailabilityResponse";
  }
  protected:
  explicit AvailabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParticipantAttributesFieldNumber = 7,
    kJobIdFieldNumber = 1,
    kParticipantNameFieldNumber = 4,
    kParticipantIdentityFieldNumber = 5,
    kParticipantMetadataFieldNumber = 6,
    kAvailableFieldNumber = 2,
    kSupportsResumeFieldNumber = 3,
  };
  // map<string, string> participant_attributes = 7;
  int participant_attributes_size() const;
  private:
  int _internal_participant_attributes_size() const;
  public:
  void clear_participant_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_participant_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_participant_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      participant_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_participant_attributes();

  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string participant_name = 4;
  void clear_participant_name();
  const std::string& participant_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_name();
  PROTOBUF_NODISCARD std::string* release_participant_name();
  void set_allocated_participant_name(std::string* participant_name);
  private:
  const std::string& _internal_participant_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_name(const std::string& value);
  std::string* _internal_mutable_participant_name();
  public:

  // string participant_identity = 5;
  void clear_participant_identity();
  const std::string& participant_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_identity();
  PROTOBUF_NODISCARD std::string* release_participant_identity();
  void set_allocated_participant_identity(std::string* participant_identity);
  private:
  const std::string& _internal_participant_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_identity(const std::string& value);
  std::string* _internal_mutable_participant_identity();
  public:

  // string participant_metadata = 6;
  void clear_participant_metadata();
  const std::string& participant_metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant_metadata();
  PROTOBUF_NODISCARD std::string* release_participant_metadata();
  void set_allocated_participant_metadata(std::string* participant_metadata);
  private:
  const std::string& _internal_participant_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant_metadata(const std::string& value);
  std::string* _internal_mutable_participant_metadata();
  public:

  // bool available = 2;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // bool supports_resume = 3;
  void clear_supports_resume();
  bool supports_resume() const;
  void set_supports_resume(bool value);
  private:
  bool _internal_supports_resume() const;
  void _internal_set_supports_resume(bool value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.AvailabilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        AvailabilityResponse_ParticipantAttributesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> participant_attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_metadata_;
    bool available_;
    bool supports_resume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class UpdateJobStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateJobStatus) */ {
 public:
  inline UpdateJobStatus() : UpdateJobStatus(nullptr) {}
  ~UpdateJobStatus() override;
  explicit PROTOBUF_CONSTEXPR UpdateJobStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateJobStatus(const UpdateJobStatus& from);
  UpdateJobStatus(UpdateJobStatus&& from) noexcept
    : UpdateJobStatus() {
    *this = ::std::move(from);
  }

  inline UpdateJobStatus& operator=(const UpdateJobStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateJobStatus& operator=(UpdateJobStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateJobStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateJobStatus* internal_default_instance() {
    return reinterpret_cast<const UpdateJobStatus*>(
               &_UpdateJobStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateJobStatus& a, UpdateJobStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateJobStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateJobStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateJobStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateJobStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateJobStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateJobStatus& from) {
    UpdateJobStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateJobStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateJobStatus";
  }
  protected:
  explicit UpdateJobStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // string error = 3;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .livekit.JobStatus status = 2;
  void clear_status();
  ::livekit::JobStatus status() const;
  void set_status(::livekit::JobStatus value);
  private:
  ::livekit::JobStatus _internal_status() const;
  void _internal_set_status(::livekit::JobStatus value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateJobStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.UpdateWorkerStatus) */ {
 public:
  inline UpdateWorkerStatus() : UpdateWorkerStatus(nullptr) {}
  ~UpdateWorkerStatus() override;
  explicit PROTOBUF_CONSTEXPR UpdateWorkerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateWorkerStatus(const UpdateWorkerStatus& from);
  UpdateWorkerStatus(UpdateWorkerStatus&& from) noexcept
    : UpdateWorkerStatus() {
    *this = ::std::move(from);
  }

  inline UpdateWorkerStatus& operator=(const UpdateWorkerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkerStatus& operator=(UpdateWorkerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkerStatus* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkerStatus*>(
               &_UpdateWorkerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateWorkerStatus& a, UpdateWorkerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateWorkerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateWorkerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateWorkerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateWorkerStatus& from) {
    UpdateWorkerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateWorkerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.UpdateWorkerStatus";
  }
  protected:
  explicit UpdateWorkerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kLoadFieldNumber = 3,
    kJobCountFieldNumber = 4,
  };
  // optional .livekit.WorkerStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::livekit::WorkerStatus status() const;
  void set_status(::livekit::WorkerStatus value);
  private:
  ::livekit::WorkerStatus _internal_status() const;
  void _internal_set_status(::livekit::WorkerStatus value);
  public:

  // float load = 3;
  void clear_load();
  float load() const;
  void set_load(float value);
  private:
  float _internal_load() const;
  void _internal_set_load(float value);
  public:

  // uint32 job_count = 4;
  void clear_job_count();
  uint32_t job_count() const;
  void set_job_count(uint32_t value);
  private:
  uint32_t _internal_job_count() const;
  void _internal_set_job_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:livekit.UpdateWorkerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int status_;
    float load_;
    uint32_t job_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class JobAssignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.JobAssignment) */ {
 public:
  inline JobAssignment() : JobAssignment(nullptr) {}
  ~JobAssignment() override;
  explicit PROTOBUF_CONSTEXPR JobAssignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobAssignment(const JobAssignment& from);
  JobAssignment(JobAssignment&& from) noexcept
    : JobAssignment() {
    *this = ::std::move(from);
  }

  inline JobAssignment& operator=(const JobAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobAssignment& operator=(JobAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobAssignment* internal_default_instance() {
    return reinterpret_cast<const JobAssignment*>(
               &_JobAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(JobAssignment& a, JobAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(JobAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobAssignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobAssignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobAssignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobAssignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobAssignment& from) {
    JobAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobAssignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.JobAssignment";
  }
  protected:
  explicit JobAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kTokenFieldNumber = 3,
    kJobFieldNumber = 1,
  };
  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string token = 3;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .livekit.Job job = 1;
  bool has_job() const;
  private:
  bool _internal_has_job() const;
  public:
  void clear_job();
  const ::livekit::Job& job() const;
  PROTOBUF_NODISCARD ::livekit::Job* release_job();
  ::livekit::Job* mutable_job();
  void set_allocated_job(::livekit::Job* job);
  private:
  const ::livekit::Job& _internal_job() const;
  ::livekit::Job* _internal_mutable_job();
  public:
  void unsafe_arena_set_allocated_job(
      ::livekit::Job* job);
  ::livekit::Job* unsafe_arena_release_job();

  // @@protoc_insertion_point(class_scope:livekit.JobAssignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::livekit::Job* job_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// -------------------------------------------------------------------

class JobTermination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:livekit.JobTermination) */ {
 public:
  inline JobTermination() : JobTermination(nullptr) {}
  ~JobTermination() override;
  explicit PROTOBUF_CONSTEXPR JobTermination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JobTermination(const JobTermination& from);
  JobTermination(JobTermination&& from) noexcept
    : JobTermination() {
    *this = ::std::move(from);
  }

  inline JobTermination& operator=(const JobTermination& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobTermination& operator=(JobTermination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobTermination& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobTermination* internal_default_instance() {
    return reinterpret_cast<const JobTermination*>(
               &_JobTermination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(JobTermination& a, JobTermination& b) {
    a.Swap(&b);
  }
  inline void Swap(JobTermination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobTermination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobTermination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JobTermination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JobTermination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JobTermination& from) {
    JobTermination::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobTermination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "livekit.JobTermination";
  }
  protected:
  explicit JobTermination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJobIdFieldNumber = 1,
  };
  // string job_id = 1;
  void clear_job_id();
  const std::string& job_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_job_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* job_id);
  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(const std::string& value);
  std::string* _internal_mutable_job_id();
  public:

  // @@protoc_insertion_point(class_scope:livekit.JobTermination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr job_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_livekit_5fagent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Job

// string id = 1;
inline void Job::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Job::id() const {
  // @@protoc_insertion_point(field_get:livekit.Job.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Job.id)
}
inline std::string* Job::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:livekit.Job.id)
  return _s;
}
inline const std::string& Job::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Job::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_id() {
  // @@protoc_insertion_point(field_release:livekit.Job.id)
  return _impl_.id_.Release();
}
inline void Job::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.id)
}

// string dispatch_id = 9;
inline void Job::clear_dispatch_id() {
  _impl_.dispatch_id_.ClearToEmpty();
}
inline const std::string& Job::dispatch_id() const {
  // @@protoc_insertion_point(field_get:livekit.Job.dispatch_id)
  return _internal_dispatch_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_dispatch_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dispatch_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Job.dispatch_id)
}
inline std::string* Job::mutable_dispatch_id() {
  std::string* _s = _internal_mutable_dispatch_id();
  // @@protoc_insertion_point(field_mutable:livekit.Job.dispatch_id)
  return _s;
}
inline const std::string& Job::_internal_dispatch_id() const {
  return _impl_.dispatch_id_.Get();
}
inline void Job::_internal_set_dispatch_id(const std::string& value) {
  
  _impl_.dispatch_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_dispatch_id() {
  
  return _impl_.dispatch_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_dispatch_id() {
  // @@protoc_insertion_point(field_release:livekit.Job.dispatch_id)
  return _impl_.dispatch_id_.Release();
}
inline void Job::set_allocated_dispatch_id(std::string* dispatch_id) {
  if (dispatch_id != nullptr) {
    
  } else {
    
  }
  _impl_.dispatch_id_.SetAllocated(dispatch_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dispatch_id_.IsDefault()) {
    _impl_.dispatch_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.dispatch_id)
}

// .livekit.JobType type = 2;
inline void Job::clear_type() {
  _impl_.type_ = 0;
}
inline ::livekit::JobType Job::_internal_type() const {
  return static_cast< ::livekit::JobType >(_impl_.type_);
}
inline ::livekit::JobType Job::type() const {
  // @@protoc_insertion_point(field_get:livekit.Job.type)
  return _internal_type();
}
inline void Job::_internal_set_type(::livekit::JobType value) {
  
  _impl_.type_ = value;
}
inline void Job::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.Job.type)
}

// .livekit.Room room = 3;
inline bool Job::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool Job::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& Job::_internal_room() const {
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& Job::room() const {
  // @@protoc_insertion_point(field_get:livekit.Job.room)
  return _internal_room();
}
inline void Job::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.room)
}
inline ::livekit::Room* Job::release_room() {
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* Job::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.Job.room)
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* Job::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::Room* Job::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.Job.room)
  return _msg;
}
inline void Job::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.room)
}

// optional .livekit.ParticipantInfo participant = 4;
inline bool Job::_internal_has_participant() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.participant_ != nullptr);
  return value;
}
inline bool Job::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::ParticipantInfo& Job::_internal_participant() const {
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(
      ::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& Job::participant() const {
  // @@protoc_insertion_point(field_get:livekit.Job.participant)
  return _internal_participant();
}
inline void Job::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = participant;
  if (participant) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.participant)
}
inline ::livekit::ParticipantInfo* Job::release_participant() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantInfo* Job::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.Job.participant)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* Job::_internal_mutable_participant() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantInfo>(GetArenaForAllocation());
    _impl_.participant_ = p;
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* Job::mutable_participant() {
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.Job.participant)
  return _msg;
}
inline void Job::set_allocated_participant(::livekit::ParticipantInfo* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.participant)
}

// string namespace = 5 [deprecated = true];
inline void Job::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
}
inline const std::string& Job::namespace_() const {
  // @@protoc_insertion_point(field_get:livekit.Job.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Job.namespace)
}
inline std::string* Job::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:livekit.Job.namespace)
  return _s;
}
inline const std::string& Job::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void Job::_internal_set_namespace_(const std::string& value) {
  
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_namespace_() {
  
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_namespace_() {
  // @@protoc_insertion_point(field_release:livekit.Job.namespace)
  return _impl_.namespace__.Release();
}
inline void Job::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.namespace)
}

// string metadata = 6;
inline void Job::clear_metadata() {
  _impl_.metadata_.ClearToEmpty();
}
inline const std::string& Job::metadata() const {
  // @@protoc_insertion_point(field_get:livekit.Job.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Job.metadata)
}
inline std::string* Job::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.Job.metadata)
  return _s;
}
inline const std::string& Job::_internal_metadata() const {
  return _impl_.metadata_.Get();
}
inline void Job::_internal_set_metadata(const std::string& value) {
  
  _impl_.metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_metadata() {
  
  return _impl_.metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_metadata() {
  // @@protoc_insertion_point(field_release:livekit.Job.metadata)
  return _impl_.metadata_.Release();
}
inline void Job::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  _impl_.metadata_.SetAllocated(metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metadata_.IsDefault()) {
    _impl_.metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.metadata)
}

// string agent_name = 7;
inline void Job::clear_agent_name() {
  _impl_.agent_name_.ClearToEmpty();
}
inline const std::string& Job::agent_name() const {
  // @@protoc_insertion_point(field_get:livekit.Job.agent_name)
  return _internal_agent_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Job::set_agent_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.Job.agent_name)
}
inline std::string* Job::mutable_agent_name() {
  std::string* _s = _internal_mutable_agent_name();
  // @@protoc_insertion_point(field_mutable:livekit.Job.agent_name)
  return _s;
}
inline const std::string& Job::_internal_agent_name() const {
  return _impl_.agent_name_.Get();
}
inline void Job::_internal_set_agent_name(const std::string& value) {
  
  _impl_.agent_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Job::_internal_mutable_agent_name() {
  
  return _impl_.agent_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Job::release_agent_name() {
  // @@protoc_insertion_point(field_release:livekit.Job.agent_name)
  return _impl_.agent_name_.Release();
}
inline void Job::set_allocated_agent_name(std::string* agent_name) {
  if (agent_name != nullptr) {
    
  } else {
    
  }
  _impl_.agent_name_.SetAllocated(agent_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_name_.IsDefault()) {
    _impl_.agent_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.agent_name)
}

// .livekit.JobState state = 8;
inline bool Job::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool Job::has_state() const {
  return _internal_has_state();
}
inline void Job::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::livekit::JobState& Job::_internal_state() const {
  const ::livekit::JobState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::JobState&>(
      ::livekit::_JobState_default_instance_);
}
inline const ::livekit::JobState& Job::state() const {
  // @@protoc_insertion_point(field_get:livekit.Job.state)
  return _internal_state();
}
inline void Job::unsafe_arena_set_allocated_state(
    ::livekit::JobState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.Job.state)
}
inline ::livekit::JobState* Job::release_state() {
  
  ::livekit::JobState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::JobState* Job::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:livekit.Job.state)
  
  ::livekit::JobState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::livekit::JobState* Job::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::JobState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::livekit::JobState* Job::mutable_state() {
  ::livekit::JobState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:livekit.Job.state)
  return _msg;
}
inline void Job::set_allocated_state(::livekit::JobState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:livekit.Job.state)
}

// -------------------------------------------------------------------

// JobState

// .livekit.JobStatus status = 1;
inline void JobState::clear_status() {
  _impl_.status_ = 0;
}
inline ::livekit::JobStatus JobState::_internal_status() const {
  return static_cast< ::livekit::JobStatus >(_impl_.status_);
}
inline ::livekit::JobStatus JobState::status() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.status)
  return _internal_status();
}
inline void JobState::_internal_set_status(::livekit::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void JobState::set_status(::livekit::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.JobState.status)
}

// string error = 2;
inline void JobState::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& JobState::error() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobState::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JobState.error)
}
inline std::string* JobState::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.JobState.error)
  return _s;
}
inline const std::string& JobState::_internal_error() const {
  return _impl_.error_.Get();
}
inline void JobState::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* JobState::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* JobState::release_error() {
  // @@protoc_insertion_point(field_release:livekit.JobState.error)
  return _impl_.error_.Release();
}
inline void JobState::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JobState.error)
}

// int64 started_at = 3;
inline void JobState::clear_started_at() {
  _impl_.started_at_ = int64_t{0};
}
inline int64_t JobState::_internal_started_at() const {
  return _impl_.started_at_;
}
inline int64_t JobState::started_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.started_at)
  return _internal_started_at();
}
inline void JobState::_internal_set_started_at(int64_t value) {
  
  _impl_.started_at_ = value;
}
inline void JobState::set_started_at(int64_t value) {
  _internal_set_started_at(value);
  // @@protoc_insertion_point(field_set:livekit.JobState.started_at)
}

// int64 ended_at = 4;
inline void JobState::clear_ended_at() {
  _impl_.ended_at_ = int64_t{0};
}
inline int64_t JobState::_internal_ended_at() const {
  return _impl_.ended_at_;
}
inline int64_t JobState::ended_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.ended_at)
  return _internal_ended_at();
}
inline void JobState::_internal_set_ended_at(int64_t value) {
  
  _impl_.ended_at_ = value;
}
inline void JobState::set_ended_at(int64_t value) {
  _internal_set_ended_at(value);
  // @@protoc_insertion_point(field_set:livekit.JobState.ended_at)
}

// int64 updated_at = 5;
inline void JobState::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t JobState::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t JobState::updated_at() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.updated_at)
  return _internal_updated_at();
}
inline void JobState::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void JobState::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:livekit.JobState.updated_at)
}

// string participant_identity = 6;
inline void JobState::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& JobState::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.JobState.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobState::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JobState.participant_identity)
}
inline std::string* JobState::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.JobState.participant_identity)
  return _s;
}
inline const std::string& JobState::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void JobState::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* JobState::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* JobState::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.JobState.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void JobState::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JobState.participant_identity)
}

// -------------------------------------------------------------------

// WorkerMessage

// .livekit.RegisterWorkerRequest register = 1;
inline bool WorkerMessage::_internal_has_register_() const {
  return message_case() == kRegister;
}
inline bool WorkerMessage::has_register_() const {
  return _internal_has_register_();
}
inline void WorkerMessage::set_has_register_() {
  _impl_._oneof_case_[0] = kRegister;
}
inline void WorkerMessage::clear_register_() {
  if (_internal_has_register_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.register__;
    }
    clear_has_message();
  }
}
inline ::livekit::RegisterWorkerRequest* WorkerMessage::release_register_() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.register)
  if (_internal_has_register_()) {
    clear_has_message();
    ::livekit::RegisterWorkerRequest* temp = _impl_.message_.register__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RegisterWorkerRequest& WorkerMessage::_internal_register_() const {
  return _internal_has_register_()
      ? *_impl_.message_.register__
      : reinterpret_cast< ::livekit::RegisterWorkerRequest&>(::livekit::_RegisterWorkerRequest_default_instance_);
}
inline const ::livekit::RegisterWorkerRequest& WorkerMessage::register_() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.register)
  return _internal_register_();
}
inline ::livekit::RegisterWorkerRequest* WorkerMessage::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.register)
  if (_internal_has_register_()) {
    clear_has_message();
    ::livekit::RegisterWorkerRequest* temp = _impl_.message_.register__;
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_register_(::livekit::RegisterWorkerRequest* register_) {
  clear_message();
  if (register_) {
    set_has_register_();
    _impl_.message_.register__ = register_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.register)
}
inline ::livekit::RegisterWorkerRequest* WorkerMessage::_internal_mutable_register_() {
  if (!_internal_has_register_()) {
    clear_message();
    set_has_register_();
    _impl_.message_.register__ = CreateMaybeMessage< ::livekit::RegisterWorkerRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.register__;
}
inline ::livekit::RegisterWorkerRequest* WorkerMessage::mutable_register_() {
  ::livekit::RegisterWorkerRequest* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.register)
  return _msg;
}

// .livekit.AvailabilityResponse availability = 2;
inline bool WorkerMessage::_internal_has_availability() const {
  return message_case() == kAvailability;
}
inline bool WorkerMessage::has_availability() const {
  return _internal_has_availability();
}
inline void WorkerMessage::set_has_availability() {
  _impl_._oneof_case_[0] = kAvailability;
}
inline void WorkerMessage::clear_availability() {
  if (_internal_has_availability()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.availability_;
    }
    clear_has_message();
  }
}
inline ::livekit::AvailabilityResponse* WorkerMessage::release_availability() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.availability)
  if (_internal_has_availability()) {
    clear_has_message();
    ::livekit::AvailabilityResponse* temp = _impl_.message_.availability_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AvailabilityResponse& WorkerMessage::_internal_availability() const {
  return _internal_has_availability()
      ? *_impl_.message_.availability_
      : reinterpret_cast< ::livekit::AvailabilityResponse&>(::livekit::_AvailabilityResponse_default_instance_);
}
inline const ::livekit::AvailabilityResponse& WorkerMessage::availability() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.availability)
  return _internal_availability();
}
inline ::livekit::AvailabilityResponse* WorkerMessage::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.availability)
  if (_internal_has_availability()) {
    clear_has_message();
    ::livekit::AvailabilityResponse* temp = _impl_.message_.availability_;
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_availability(::livekit::AvailabilityResponse* availability) {
  clear_message();
  if (availability) {
    set_has_availability();
    _impl_.message_.availability_ = availability;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.availability)
}
inline ::livekit::AvailabilityResponse* WorkerMessage::_internal_mutable_availability() {
  if (!_internal_has_availability()) {
    clear_message();
    set_has_availability();
    _impl_.message_.availability_ = CreateMaybeMessage< ::livekit::AvailabilityResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.availability_;
}
inline ::livekit::AvailabilityResponse* WorkerMessage::mutable_availability() {
  ::livekit::AvailabilityResponse* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.availability)
  return _msg;
}

// .livekit.UpdateWorkerStatus update_worker = 3;
inline bool WorkerMessage::_internal_has_update_worker() const {
  return message_case() == kUpdateWorker;
}
inline bool WorkerMessage::has_update_worker() const {
  return _internal_has_update_worker();
}
inline void WorkerMessage::set_has_update_worker() {
  _impl_._oneof_case_[0] = kUpdateWorker;
}
inline void WorkerMessage::clear_update_worker() {
  if (_internal_has_update_worker()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_worker_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateWorkerStatus* WorkerMessage::release_update_worker() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.update_worker)
  if (_internal_has_update_worker()) {
    clear_has_message();
    ::livekit::UpdateWorkerStatus* temp = _impl_.message_.update_worker_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateWorkerStatus& WorkerMessage::_internal_update_worker() const {
  return _internal_has_update_worker()
      ? *_impl_.message_.update_worker_
      : reinterpret_cast< ::livekit::UpdateWorkerStatus&>(::livekit::_UpdateWorkerStatus_default_instance_);
}
inline const ::livekit::UpdateWorkerStatus& WorkerMessage::update_worker() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.update_worker)
  return _internal_update_worker();
}
inline ::livekit::UpdateWorkerStatus* WorkerMessage::unsafe_arena_release_update_worker() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.update_worker)
  if (_internal_has_update_worker()) {
    clear_has_message();
    ::livekit::UpdateWorkerStatus* temp = _impl_.message_.update_worker_;
    _impl_.message_.update_worker_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_update_worker(::livekit::UpdateWorkerStatus* update_worker) {
  clear_message();
  if (update_worker) {
    set_has_update_worker();
    _impl_.message_.update_worker_ = update_worker;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.update_worker)
}
inline ::livekit::UpdateWorkerStatus* WorkerMessage::_internal_mutable_update_worker() {
  if (!_internal_has_update_worker()) {
    clear_message();
    set_has_update_worker();
    _impl_.message_.update_worker_ = CreateMaybeMessage< ::livekit::UpdateWorkerStatus >(GetArenaForAllocation());
  }
  return _impl_.message_.update_worker_;
}
inline ::livekit::UpdateWorkerStatus* WorkerMessage::mutable_update_worker() {
  ::livekit::UpdateWorkerStatus* _msg = _internal_mutable_update_worker();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.update_worker)
  return _msg;
}

// .livekit.UpdateJobStatus update_job = 4;
inline bool WorkerMessage::_internal_has_update_job() const {
  return message_case() == kUpdateJob;
}
inline bool WorkerMessage::has_update_job() const {
  return _internal_has_update_job();
}
inline void WorkerMessage::set_has_update_job() {
  _impl_._oneof_case_[0] = kUpdateJob;
}
inline void WorkerMessage::clear_update_job() {
  if (_internal_has_update_job()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.update_job_;
    }
    clear_has_message();
  }
}
inline ::livekit::UpdateJobStatus* WorkerMessage::release_update_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.update_job)
  if (_internal_has_update_job()) {
    clear_has_message();
    ::livekit::UpdateJobStatus* temp = _impl_.message_.update_job_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.update_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::UpdateJobStatus& WorkerMessage::_internal_update_job() const {
  return _internal_has_update_job()
      ? *_impl_.message_.update_job_
      : reinterpret_cast< ::livekit::UpdateJobStatus&>(::livekit::_UpdateJobStatus_default_instance_);
}
inline const ::livekit::UpdateJobStatus& WorkerMessage::update_job() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.update_job)
  return _internal_update_job();
}
inline ::livekit::UpdateJobStatus* WorkerMessage::unsafe_arena_release_update_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.update_job)
  if (_internal_has_update_job()) {
    clear_has_message();
    ::livekit::UpdateJobStatus* temp = _impl_.message_.update_job_;
    _impl_.message_.update_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_update_job(::livekit::UpdateJobStatus* update_job) {
  clear_message();
  if (update_job) {
    set_has_update_job();
    _impl_.message_.update_job_ = update_job;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.update_job)
}
inline ::livekit::UpdateJobStatus* WorkerMessage::_internal_mutable_update_job() {
  if (!_internal_has_update_job()) {
    clear_message();
    set_has_update_job();
    _impl_.message_.update_job_ = CreateMaybeMessage< ::livekit::UpdateJobStatus >(GetArenaForAllocation());
  }
  return _impl_.message_.update_job_;
}
inline ::livekit::UpdateJobStatus* WorkerMessage::mutable_update_job() {
  ::livekit::UpdateJobStatus* _msg = _internal_mutable_update_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.update_job)
  return _msg;
}

// .livekit.WorkerPing ping = 5;
inline bool WorkerMessage::_internal_has_ping() const {
  return message_case() == kPing;
}
inline bool WorkerMessage::has_ping() const {
  return _internal_has_ping();
}
inline void WorkerMessage::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void WorkerMessage::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.ping_;
    }
    clear_has_message();
  }
}
inline ::livekit::WorkerPing* WorkerMessage::release_ping() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.ping)
  if (_internal_has_ping()) {
    clear_has_message();
    ::livekit::WorkerPing* temp = _impl_.message_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WorkerPing& WorkerMessage::_internal_ping() const {
  return _internal_has_ping()
      ? *_impl_.message_.ping_
      : reinterpret_cast< ::livekit::WorkerPing&>(::livekit::_WorkerPing_default_instance_);
}
inline const ::livekit::WorkerPing& WorkerMessage::ping() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.ping)
  return _internal_ping();
}
inline ::livekit::WorkerPing* WorkerMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.ping)
  if (_internal_has_ping()) {
    clear_has_message();
    ::livekit::WorkerPing* temp = _impl_.message_.ping_;
    _impl_.message_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_ping(::livekit::WorkerPing* ping) {
  clear_message();
  if (ping) {
    set_has_ping();
    _impl_.message_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.ping)
}
inline ::livekit::WorkerPing* WorkerMessage::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_message();
    set_has_ping();
    _impl_.message_.ping_ = CreateMaybeMessage< ::livekit::WorkerPing >(GetArenaForAllocation());
  }
  return _impl_.message_.ping_;
}
inline ::livekit::WorkerPing* WorkerMessage::mutable_ping() {
  ::livekit::WorkerPing* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.ping)
  return _msg;
}

// .livekit.SimulateJobRequest simulate_job = 6;
inline bool WorkerMessage::_internal_has_simulate_job() const {
  return message_case() == kSimulateJob;
}
inline bool WorkerMessage::has_simulate_job() const {
  return _internal_has_simulate_job();
}
inline void WorkerMessage::set_has_simulate_job() {
  _impl_._oneof_case_[0] = kSimulateJob;
}
inline void WorkerMessage::clear_simulate_job() {
  if (_internal_has_simulate_job()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.simulate_job_;
    }
    clear_has_message();
  }
}
inline ::livekit::SimulateJobRequest* WorkerMessage::release_simulate_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.simulate_job)
  if (_internal_has_simulate_job()) {
    clear_has_message();
    ::livekit::SimulateJobRequest* temp = _impl_.message_.simulate_job_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.simulate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::SimulateJobRequest& WorkerMessage::_internal_simulate_job() const {
  return _internal_has_simulate_job()
      ? *_impl_.message_.simulate_job_
      : reinterpret_cast< ::livekit::SimulateJobRequest&>(::livekit::_SimulateJobRequest_default_instance_);
}
inline const ::livekit::SimulateJobRequest& WorkerMessage::simulate_job() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.simulate_job)
  return _internal_simulate_job();
}
inline ::livekit::SimulateJobRequest* WorkerMessage::unsafe_arena_release_simulate_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.simulate_job)
  if (_internal_has_simulate_job()) {
    clear_has_message();
    ::livekit::SimulateJobRequest* temp = _impl_.message_.simulate_job_;
    _impl_.message_.simulate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_simulate_job(::livekit::SimulateJobRequest* simulate_job) {
  clear_message();
  if (simulate_job) {
    set_has_simulate_job();
    _impl_.message_.simulate_job_ = simulate_job;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.simulate_job)
}
inline ::livekit::SimulateJobRequest* WorkerMessage::_internal_mutable_simulate_job() {
  if (!_internal_has_simulate_job()) {
    clear_message();
    set_has_simulate_job();
    _impl_.message_.simulate_job_ = CreateMaybeMessage< ::livekit::SimulateJobRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.simulate_job_;
}
inline ::livekit::SimulateJobRequest* WorkerMessage::mutable_simulate_job() {
  ::livekit::SimulateJobRequest* _msg = _internal_mutable_simulate_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.simulate_job)
  return _msg;
}

// .livekit.MigrateJobRequest migrate_job = 7;
inline bool WorkerMessage::_internal_has_migrate_job() const {
  return message_case() == kMigrateJob;
}
inline bool WorkerMessage::has_migrate_job() const {
  return _internal_has_migrate_job();
}
inline void WorkerMessage::set_has_migrate_job() {
  _impl_._oneof_case_[0] = kMigrateJob;
}
inline void WorkerMessage::clear_migrate_job() {
  if (_internal_has_migrate_job()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.migrate_job_;
    }
    clear_has_message();
  }
}
inline ::livekit::MigrateJobRequest* WorkerMessage::release_migrate_job() {
  // @@protoc_insertion_point(field_release:livekit.WorkerMessage.migrate_job)
  if (_internal_has_migrate_job()) {
    clear_has_message();
    ::livekit::MigrateJobRequest* temp = _impl_.message_.migrate_job_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.migrate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::MigrateJobRequest& WorkerMessage::_internal_migrate_job() const {
  return _internal_has_migrate_job()
      ? *_impl_.message_.migrate_job_
      : reinterpret_cast< ::livekit::MigrateJobRequest&>(::livekit::_MigrateJobRequest_default_instance_);
}
inline const ::livekit::MigrateJobRequest& WorkerMessage::migrate_job() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerMessage.migrate_job)
  return _internal_migrate_job();
}
inline ::livekit::MigrateJobRequest* WorkerMessage::unsafe_arena_release_migrate_job() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.WorkerMessage.migrate_job)
  if (_internal_has_migrate_job()) {
    clear_has_message();
    ::livekit::MigrateJobRequest* temp = _impl_.message_.migrate_job_;
    _impl_.message_.migrate_job_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkerMessage::unsafe_arena_set_allocated_migrate_job(::livekit::MigrateJobRequest* migrate_job) {
  clear_message();
  if (migrate_job) {
    set_has_migrate_job();
    _impl_.message_.migrate_job_ = migrate_job;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.WorkerMessage.migrate_job)
}
inline ::livekit::MigrateJobRequest* WorkerMessage::_internal_mutable_migrate_job() {
  if (!_internal_has_migrate_job()) {
    clear_message();
    set_has_migrate_job();
    _impl_.message_.migrate_job_ = CreateMaybeMessage< ::livekit::MigrateJobRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.migrate_job_;
}
inline ::livekit::MigrateJobRequest* WorkerMessage::mutable_migrate_job() {
  ::livekit::MigrateJobRequest* _msg = _internal_mutable_migrate_job();
  // @@protoc_insertion_point(field_mutable:livekit.WorkerMessage.migrate_job)
  return _msg;
}

inline bool WorkerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void WorkerMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline WorkerMessage::MessageCase WorkerMessage::message_case() const {
  return WorkerMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerMessage

// .livekit.RegisterWorkerResponse register = 1;
inline bool ServerMessage::_internal_has_register_() const {
  return message_case() == kRegister;
}
inline bool ServerMessage::has_register_() const {
  return _internal_has_register_();
}
inline void ServerMessage::set_has_register_() {
  _impl_._oneof_case_[0] = kRegister;
}
inline void ServerMessage::clear_register_() {
  if (_internal_has_register_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.register__;
    }
    clear_has_message();
  }
}
inline ::livekit::RegisterWorkerResponse* ServerMessage::release_register_() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.register)
  if (_internal_has_register_()) {
    clear_has_message();
    ::livekit::RegisterWorkerResponse* temp = _impl_.message_.register__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::RegisterWorkerResponse& ServerMessage::_internal_register_() const {
  return _internal_has_register_()
      ? *_impl_.message_.register__
      : reinterpret_cast< ::livekit::RegisterWorkerResponse&>(::livekit::_RegisterWorkerResponse_default_instance_);
}
inline const ::livekit::RegisterWorkerResponse& ServerMessage::register_() const {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.register)
  return _internal_register_();
}
inline ::livekit::RegisterWorkerResponse* ServerMessage::unsafe_arena_release_register_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.register)
  if (_internal_has_register_()) {
    clear_has_message();
    ::livekit::RegisterWorkerResponse* temp = _impl_.message_.register__;
    _impl_.message_.register__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_register_(::livekit::RegisterWorkerResponse* register_) {
  clear_message();
  if (register_) {
    set_has_register_();
    _impl_.message_.register__ = register_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.register)
}
inline ::livekit::RegisterWorkerResponse* ServerMessage::_internal_mutable_register_() {
  if (!_internal_has_register_()) {
    clear_message();
    set_has_register_();
    _impl_.message_.register__ = CreateMaybeMessage< ::livekit::RegisterWorkerResponse >(GetArenaForAllocation());
  }
  return _impl_.message_.register__;
}
inline ::livekit::RegisterWorkerResponse* ServerMessage::mutable_register_() {
  ::livekit::RegisterWorkerResponse* _msg = _internal_mutable_register_();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.register)
  return _msg;
}

// .livekit.AvailabilityRequest availability = 2;
inline bool ServerMessage::_internal_has_availability() const {
  return message_case() == kAvailability;
}
inline bool ServerMessage::has_availability() const {
  return _internal_has_availability();
}
inline void ServerMessage::set_has_availability() {
  _impl_._oneof_case_[0] = kAvailability;
}
inline void ServerMessage::clear_availability() {
  if (_internal_has_availability()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.availability_;
    }
    clear_has_message();
  }
}
inline ::livekit::AvailabilityRequest* ServerMessage::release_availability() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.availability)
  if (_internal_has_availability()) {
    clear_has_message();
    ::livekit::AvailabilityRequest* temp = _impl_.message_.availability_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::AvailabilityRequest& ServerMessage::_internal_availability() const {
  return _internal_has_availability()
      ? *_impl_.message_.availability_
      : reinterpret_cast< ::livekit::AvailabilityRequest&>(::livekit::_AvailabilityRequest_default_instance_);
}
inline const ::livekit::AvailabilityRequest& ServerMessage::availability() const {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.availability)
  return _internal_availability();
}
inline ::livekit::AvailabilityRequest* ServerMessage::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.availability)
  if (_internal_has_availability()) {
    clear_has_message();
    ::livekit::AvailabilityRequest* temp = _impl_.message_.availability_;
    _impl_.message_.availability_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_availability(::livekit::AvailabilityRequest* availability) {
  clear_message();
  if (availability) {
    set_has_availability();
    _impl_.message_.availability_ = availability;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.availability)
}
inline ::livekit::AvailabilityRequest* ServerMessage::_internal_mutable_availability() {
  if (!_internal_has_availability()) {
    clear_message();
    set_has_availability();
    _impl_.message_.availability_ = CreateMaybeMessage< ::livekit::AvailabilityRequest >(GetArenaForAllocation());
  }
  return _impl_.message_.availability_;
}
inline ::livekit::AvailabilityRequest* ServerMessage::mutable_availability() {
  ::livekit::AvailabilityRequest* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.availability)
  return _msg;
}

// .livekit.JobAssignment assignment = 3;
inline bool ServerMessage::_internal_has_assignment() const {
  return message_case() == kAssignment;
}
inline bool ServerMessage::has_assignment() const {
  return _internal_has_assignment();
}
inline void ServerMessage::set_has_assignment() {
  _impl_._oneof_case_[0] = kAssignment;
}
inline void ServerMessage::clear_assignment() {
  if (_internal_has_assignment()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.assignment_;
    }
    clear_has_message();
  }
}
inline ::livekit::JobAssignment* ServerMessage::release_assignment() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.assignment)
  if (_internal_has_assignment()) {
    clear_has_message();
    ::livekit::JobAssignment* temp = _impl_.message_.assignment_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JobAssignment& ServerMessage::_internal_assignment() const {
  return _internal_has_assignment()
      ? *_impl_.message_.assignment_
      : reinterpret_cast< ::livekit::JobAssignment&>(::livekit::_JobAssignment_default_instance_);
}
inline const ::livekit::JobAssignment& ServerMessage::assignment() const {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.assignment)
  return _internal_assignment();
}
inline ::livekit::JobAssignment* ServerMessage::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.assignment)
  if (_internal_has_assignment()) {
    clear_has_message();
    ::livekit::JobAssignment* temp = _impl_.message_.assignment_;
    _impl_.message_.assignment_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_assignment(::livekit::JobAssignment* assignment) {
  clear_message();
  if (assignment) {
    set_has_assignment();
    _impl_.message_.assignment_ = assignment;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.assignment)
}
inline ::livekit::JobAssignment* ServerMessage::_internal_mutable_assignment() {
  if (!_internal_has_assignment()) {
    clear_message();
    set_has_assignment();
    _impl_.message_.assignment_ = CreateMaybeMessage< ::livekit::JobAssignment >(GetArenaForAllocation());
  }
  return _impl_.message_.assignment_;
}
inline ::livekit::JobAssignment* ServerMessage::mutable_assignment() {
  ::livekit::JobAssignment* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.assignment)
  return _msg;
}

// .livekit.JobTermination termination = 5;
inline bool ServerMessage::_internal_has_termination() const {
  return message_case() == kTermination;
}
inline bool ServerMessage::has_termination() const {
  return _internal_has_termination();
}
inline void ServerMessage::set_has_termination() {
  _impl_._oneof_case_[0] = kTermination;
}
inline void ServerMessage::clear_termination() {
  if (_internal_has_termination()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.termination_;
    }
    clear_has_message();
  }
}
inline ::livekit::JobTermination* ServerMessage::release_termination() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.termination)
  if (_internal_has_termination()) {
    clear_has_message();
    ::livekit::JobTermination* temp = _impl_.message_.termination_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.termination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::JobTermination& ServerMessage::_internal_termination() const {
  return _internal_has_termination()
      ? *_impl_.message_.termination_
      : reinterpret_cast< ::livekit::JobTermination&>(::livekit::_JobTermination_default_instance_);
}
inline const ::livekit::JobTermination& ServerMessage::termination() const {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.termination)
  return _internal_termination();
}
inline ::livekit::JobTermination* ServerMessage::unsafe_arena_release_termination() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.termination)
  if (_internal_has_termination()) {
    clear_has_message();
    ::livekit::JobTermination* temp = _impl_.message_.termination_;
    _impl_.message_.termination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_termination(::livekit::JobTermination* termination) {
  clear_message();
  if (termination) {
    set_has_termination();
    _impl_.message_.termination_ = termination;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.termination)
}
inline ::livekit::JobTermination* ServerMessage::_internal_mutable_termination() {
  if (!_internal_has_termination()) {
    clear_message();
    set_has_termination();
    _impl_.message_.termination_ = CreateMaybeMessage< ::livekit::JobTermination >(GetArenaForAllocation());
  }
  return _impl_.message_.termination_;
}
inline ::livekit::JobTermination* ServerMessage::mutable_termination() {
  ::livekit::JobTermination* _msg = _internal_mutable_termination();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.termination)
  return _msg;
}

// .livekit.WorkerPong pong = 4;
inline bool ServerMessage::_internal_has_pong() const {
  return message_case() == kPong;
}
inline bool ServerMessage::has_pong() const {
  return _internal_has_pong();
}
inline void ServerMessage::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void ServerMessage::clear_pong() {
  if (_internal_has_pong()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.pong_;
    }
    clear_has_message();
  }
}
inline ::livekit::WorkerPong* ServerMessage::release_pong() {
  // @@protoc_insertion_point(field_release:livekit.ServerMessage.pong)
  if (_internal_has_pong()) {
    clear_has_message();
    ::livekit::WorkerPong* temp = _impl_.message_.pong_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::livekit::WorkerPong& ServerMessage::_internal_pong() const {
  return _internal_has_pong()
      ? *_impl_.message_.pong_
      : reinterpret_cast< ::livekit::WorkerPong&>(::livekit::_WorkerPong_default_instance_);
}
inline const ::livekit::WorkerPong& ServerMessage::pong() const {
  // @@protoc_insertion_point(field_get:livekit.ServerMessage.pong)
  return _internal_pong();
}
inline ::livekit::WorkerPong* ServerMessage::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:livekit.ServerMessage.pong)
  if (_internal_has_pong()) {
    clear_has_message();
    ::livekit::WorkerPong* temp = _impl_.message_.pong_;
    _impl_.message_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_pong(::livekit::WorkerPong* pong) {
  clear_message();
  if (pong) {
    set_has_pong();
    _impl_.message_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.ServerMessage.pong)
}
inline ::livekit::WorkerPong* ServerMessage::_internal_mutable_pong() {
  if (!_internal_has_pong()) {
    clear_message();
    set_has_pong();
    _impl_.message_.pong_ = CreateMaybeMessage< ::livekit::WorkerPong >(GetArenaForAllocation());
  }
  return _impl_.message_.pong_;
}
inline ::livekit::WorkerPong* ServerMessage::mutable_pong() {
  ::livekit::WorkerPong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:livekit.ServerMessage.pong)
  return _msg;
}

inline bool ServerMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ServerMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ServerMessage::MessageCase ServerMessage::message_case() const {
  return ServerMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SimulateJobRequest

// .livekit.JobType type = 1;
inline void SimulateJobRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::livekit::JobType SimulateJobRequest::_internal_type() const {
  return static_cast< ::livekit::JobType >(_impl_.type_);
}
inline ::livekit::JobType SimulateJobRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.type)
  return _internal_type();
}
inline void SimulateJobRequest::_internal_set_type(::livekit::JobType value) {
  
  _impl_.type_ = value;
}
inline void SimulateJobRequest::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.SimulateJobRequest.type)
}

// .livekit.Room room = 2;
inline bool SimulateJobRequest::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool SimulateJobRequest::has_room() const {
  return _internal_has_room();
}
inline const ::livekit::Room& SimulateJobRequest::_internal_room() const {
  const ::livekit::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Room&>(
      ::livekit::_Room_default_instance_);
}
inline const ::livekit::Room& SimulateJobRequest::room() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.room)
  return _internal_room();
}
inline void SimulateJobRequest::unsafe_arena_set_allocated_room(
    ::livekit::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SimulateJobRequest.room)
}
inline ::livekit::Room* SimulateJobRequest::release_room() {
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Room* SimulateJobRequest::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:livekit.SimulateJobRequest.room)
  
  ::livekit::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::livekit::Room* SimulateJobRequest::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Room>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::livekit::Room* SimulateJobRequest::mutable_room() {
  ::livekit::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:livekit.SimulateJobRequest.room)
  return _msg;
}
inline void SimulateJobRequest::set_allocated_room(::livekit::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulateJobRequest.room)
}

// .livekit.ParticipantInfo participant = 3;
inline bool SimulateJobRequest::_internal_has_participant() const {
  return this != internal_default_instance() && _impl_.participant_ != nullptr;
}
inline bool SimulateJobRequest::has_participant() const {
  return _internal_has_participant();
}
inline const ::livekit::ParticipantInfo& SimulateJobRequest::_internal_participant() const {
  const ::livekit::ParticipantInfo* p = _impl_.participant_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantInfo&>(
      ::livekit::_ParticipantInfo_default_instance_);
}
inline const ::livekit::ParticipantInfo& SimulateJobRequest::participant() const {
  // @@protoc_insertion_point(field_get:livekit.SimulateJobRequest.participant)
  return _internal_participant();
}
inline void SimulateJobRequest::unsafe_arena_set_allocated_participant(
    ::livekit::ParticipantInfo* participant) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  _impl_.participant_ = participant;
  if (participant) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.SimulateJobRequest.participant)
}
inline ::livekit::ParticipantInfo* SimulateJobRequest::release_participant() {
  
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantInfo* SimulateJobRequest::unsafe_arena_release_participant() {
  // @@protoc_insertion_point(field_release:livekit.SimulateJobRequest.participant)
  
  ::livekit::ParticipantInfo* temp = _impl_.participant_;
  _impl_.participant_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantInfo* SimulateJobRequest::_internal_mutable_participant() {
  
  if (_impl_.participant_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantInfo>(GetArenaForAllocation());
    _impl_.participant_ = p;
  }
  return _impl_.participant_;
}
inline ::livekit::ParticipantInfo* SimulateJobRequest::mutable_participant() {
  ::livekit::ParticipantInfo* _msg = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:livekit.SimulateJobRequest.participant)
  return _msg;
}
inline void SimulateJobRequest::set_allocated_participant(::livekit::ParticipantInfo* participant) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.participant_);
  }
  if (participant) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(participant));
    if (message_arena != submessage_arena) {
      participant = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, participant, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.participant_ = participant;
  // @@protoc_insertion_point(field_set_allocated:livekit.SimulateJobRequest.participant)
}

// -------------------------------------------------------------------

// WorkerPing

// int64 timestamp = 1;
inline void WorkerPing::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t WorkerPing::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t WorkerPing::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPing.timestamp)
  return _internal_timestamp();
}
inline void WorkerPing::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WorkerPing::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.WorkerPing.timestamp)
}

// -------------------------------------------------------------------

// WorkerPong

// int64 last_timestamp = 1;
inline void WorkerPong::clear_last_timestamp() {
  _impl_.last_timestamp_ = int64_t{0};
}
inline int64_t WorkerPong::_internal_last_timestamp() const {
  return _impl_.last_timestamp_;
}
inline int64_t WorkerPong::last_timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPong.last_timestamp)
  return _internal_last_timestamp();
}
inline void WorkerPong::_internal_set_last_timestamp(int64_t value) {
  
  _impl_.last_timestamp_ = value;
}
inline void WorkerPong::set_last_timestamp(int64_t value) {
  _internal_set_last_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.WorkerPong.last_timestamp)
}

// int64 timestamp = 2;
inline void WorkerPong::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t WorkerPong::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t WorkerPong::timestamp() const {
  // @@protoc_insertion_point(field_get:livekit.WorkerPong.timestamp)
  return _internal_timestamp();
}
inline void WorkerPong::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WorkerPong::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:livekit.WorkerPong.timestamp)
}

// -------------------------------------------------------------------

// RegisterWorkerRequest

// .livekit.JobType type = 1;
inline void RegisterWorkerRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::livekit::JobType RegisterWorkerRequest::_internal_type() const {
  return static_cast< ::livekit::JobType >(_impl_.type_);
}
inline ::livekit::JobType RegisterWorkerRequest::type() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.type)
  return _internal_type();
}
inline void RegisterWorkerRequest::_internal_set_type(::livekit::JobType value) {
  
  _impl_.type_ = value;
}
inline void RegisterWorkerRequest::set_type(::livekit::JobType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.type)
}

// string agent_name = 8;
inline void RegisterWorkerRequest::clear_agent_name() {
  _impl_.agent_name_.ClearToEmpty();
}
inline const std::string& RegisterWorkerRequest::agent_name() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.agent_name)
  return _internal_agent_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterWorkerRequest::set_agent_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.agent_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.agent_name)
}
inline std::string* RegisterWorkerRequest::mutable_agent_name() {
  std::string* _s = _internal_mutable_agent_name();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.agent_name)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_agent_name() const {
  return _impl_.agent_name_.Get();
}
inline void RegisterWorkerRequest::_internal_set_agent_name(const std::string& value) {
  
  _impl_.agent_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::_internal_mutable_agent_name() {
  
  return _impl_.agent_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::release_agent_name() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.agent_name)
  return _impl_.agent_name_.Release();
}
inline void RegisterWorkerRequest::set_allocated_agent_name(std::string* agent_name) {
  if (agent_name != nullptr) {
    
  } else {
    
  }
  _impl_.agent_name_.SetAllocated(agent_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.agent_name_.IsDefault()) {
    _impl_.agent_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.agent_name)
}

// string version = 3;
inline void RegisterWorkerRequest::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& RegisterWorkerRequest::version() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterWorkerRequest::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.version)
}
inline std::string* RegisterWorkerRequest::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.version)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RegisterWorkerRequest::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::release_version() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.version)
  return _impl_.version_.Release();
}
inline void RegisterWorkerRequest::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.version)
}

// uint32 ping_interval = 5;
inline void RegisterWorkerRequest::clear_ping_interval() {
  _impl_.ping_interval_ = 0u;
}
inline uint32_t RegisterWorkerRequest::_internal_ping_interval() const {
  return _impl_.ping_interval_;
}
inline uint32_t RegisterWorkerRequest::ping_interval() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.ping_interval)
  return _internal_ping_interval();
}
inline void RegisterWorkerRequest::_internal_set_ping_interval(uint32_t value) {
  
  _impl_.ping_interval_ = value;
}
inline void RegisterWorkerRequest::set_ping_interval(uint32_t value) {
  _internal_set_ping_interval(value);
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.ping_interval)
}

// optional string namespace = 6;
inline bool RegisterWorkerRequest::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegisterWorkerRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void RegisterWorkerRequest::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterWorkerRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterWorkerRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerRequest.namespace)
}
inline std::string* RegisterWorkerRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.namespace)
  return _s;
}
inline const std::string& RegisterWorkerRequest::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void RegisterWorkerRequest::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterWorkerRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RegisterWorkerRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.namespace)
}

// .livekit.ParticipantPermission allowed_permissions = 7;
inline bool RegisterWorkerRequest::_internal_has_allowed_permissions() const {
  return this != internal_default_instance() && _impl_.allowed_permissions_ != nullptr;
}
inline bool RegisterWorkerRequest::has_allowed_permissions() const {
  return _internal_has_allowed_permissions();
}
inline const ::livekit::ParticipantPermission& RegisterWorkerRequest::_internal_allowed_permissions() const {
  const ::livekit::ParticipantPermission* p = _impl_.allowed_permissions_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ParticipantPermission&>(
      ::livekit::_ParticipantPermission_default_instance_);
}
inline const ::livekit::ParticipantPermission& RegisterWorkerRequest::allowed_permissions() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerRequest.allowed_permissions)
  return _internal_allowed_permissions();
}
inline void RegisterWorkerRequest::unsafe_arena_set_allocated_allowed_permissions(
    ::livekit::ParticipantPermission* allowed_permissions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allowed_permissions_);
  }
  _impl_.allowed_permissions_ = allowed_permissions;
  if (allowed_permissions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RegisterWorkerRequest.allowed_permissions)
}
inline ::livekit::ParticipantPermission* RegisterWorkerRequest::release_allowed_permissions() {
  
  ::livekit::ParticipantPermission* temp = _impl_.allowed_permissions_;
  _impl_.allowed_permissions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ParticipantPermission* RegisterWorkerRequest::unsafe_arena_release_allowed_permissions() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerRequest.allowed_permissions)
  
  ::livekit::ParticipantPermission* temp = _impl_.allowed_permissions_;
  _impl_.allowed_permissions_ = nullptr;
  return temp;
}
inline ::livekit::ParticipantPermission* RegisterWorkerRequest::_internal_mutable_allowed_permissions() {
  
  if (_impl_.allowed_permissions_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ParticipantPermission>(GetArenaForAllocation());
    _impl_.allowed_permissions_ = p;
  }
  return _impl_.allowed_permissions_;
}
inline ::livekit::ParticipantPermission* RegisterWorkerRequest::mutable_allowed_permissions() {
  ::livekit::ParticipantPermission* _msg = _internal_mutable_allowed_permissions();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerRequest.allowed_permissions)
  return _msg;
}
inline void RegisterWorkerRequest::set_allocated_allowed_permissions(::livekit::ParticipantPermission* allowed_permissions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.allowed_permissions_);
  }
  if (allowed_permissions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(allowed_permissions));
    if (message_arena != submessage_arena) {
      allowed_permissions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, allowed_permissions, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.allowed_permissions_ = allowed_permissions;
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerRequest.allowed_permissions)
}

// -------------------------------------------------------------------

// RegisterWorkerResponse

// string worker_id = 1;
inline void RegisterWorkerResponse::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& RegisterWorkerResponse::worker_id() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerResponse.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterWorkerResponse::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.RegisterWorkerResponse.worker_id)
}
inline std::string* RegisterWorkerResponse::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerResponse.worker_id)
  return _s;
}
inline const std::string& RegisterWorkerResponse::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void RegisterWorkerResponse::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterWorkerResponse::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterWorkerResponse::release_worker_id() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerResponse.worker_id)
  return _impl_.worker_id_.Release();
}
inline void RegisterWorkerResponse::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerResponse.worker_id)
}

// .livekit.ServerInfo server_info = 3;
inline bool RegisterWorkerResponse::_internal_has_server_info() const {
  return this != internal_default_instance() && _impl_.server_info_ != nullptr;
}
inline bool RegisterWorkerResponse::has_server_info() const {
  return _internal_has_server_info();
}
inline const ::livekit::ServerInfo& RegisterWorkerResponse::_internal_server_info() const {
  const ::livekit::ServerInfo* p = _impl_.server_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::ServerInfo&>(
      ::livekit::_ServerInfo_default_instance_);
}
inline const ::livekit::ServerInfo& RegisterWorkerResponse::server_info() const {
  // @@protoc_insertion_point(field_get:livekit.RegisterWorkerResponse.server_info)
  return _internal_server_info();
}
inline void RegisterWorkerResponse::unsafe_arena_set_allocated_server_info(
    ::livekit::ServerInfo* server_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  _impl_.server_info_ = server_info;
  if (server_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.RegisterWorkerResponse.server_info)
}
inline ::livekit::ServerInfo* RegisterWorkerResponse::release_server_info() {
  
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::ServerInfo* RegisterWorkerResponse::unsafe_arena_release_server_info() {
  // @@protoc_insertion_point(field_release:livekit.RegisterWorkerResponse.server_info)
  
  ::livekit::ServerInfo* temp = _impl_.server_info_;
  _impl_.server_info_ = nullptr;
  return temp;
}
inline ::livekit::ServerInfo* RegisterWorkerResponse::_internal_mutable_server_info() {
  
  if (_impl_.server_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::ServerInfo>(GetArenaForAllocation());
    _impl_.server_info_ = p;
  }
  return _impl_.server_info_;
}
inline ::livekit::ServerInfo* RegisterWorkerResponse::mutable_server_info() {
  ::livekit::ServerInfo* _msg = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:livekit.RegisterWorkerResponse.server_info)
  return _msg;
}
inline void RegisterWorkerResponse::set_allocated_server_info(::livekit::ServerInfo* server_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_info_);
  }
  if (server_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_info));
    if (message_arena != submessage_arena) {
      server_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.server_info_ = server_info;
  // @@protoc_insertion_point(field_set_allocated:livekit.RegisterWorkerResponse.server_info)
}

// -------------------------------------------------------------------

// MigrateJobRequest

// repeated string job_ids = 2;
inline int MigrateJobRequest::_internal_job_ids_size() const {
  return _impl_.job_ids_.size();
}
inline int MigrateJobRequest::job_ids_size() const {
  return _internal_job_ids_size();
}
inline void MigrateJobRequest::clear_job_ids() {
  _impl_.job_ids_.Clear();
}
inline std::string* MigrateJobRequest::add_job_ids() {
  std::string* _s = _internal_add_job_ids();
  // @@protoc_insertion_point(field_add_mutable:livekit.MigrateJobRequest.job_ids)
  return _s;
}
inline const std::string& MigrateJobRequest::_internal_job_ids(int index) const {
  return _impl_.job_ids_.Get(index);
}
inline const std::string& MigrateJobRequest::job_ids(int index) const {
  // @@protoc_insertion_point(field_get:livekit.MigrateJobRequest.job_ids)
  return _internal_job_ids(index);
}
inline std::string* MigrateJobRequest::mutable_job_ids(int index) {
  // @@protoc_insertion_point(field_mutable:livekit.MigrateJobRequest.job_ids)
  return _impl_.job_ids_.Mutable(index);
}
inline void MigrateJobRequest::set_job_ids(int index, const std::string& value) {
  _impl_.job_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::set_job_ids(int index, std::string&& value) {
  _impl_.job_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::set_job_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.job_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::set_job_ids(int index, const char* value, size_t size) {
  _impl_.job_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:livekit.MigrateJobRequest.job_ids)
}
inline std::string* MigrateJobRequest::_internal_add_job_ids() {
  return _impl_.job_ids_.Add();
}
inline void MigrateJobRequest::add_job_ids(const std::string& value) {
  _impl_.job_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::add_job_ids(std::string&& value) {
  _impl_.job_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::add_job_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.job_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:livekit.MigrateJobRequest.job_ids)
}
inline void MigrateJobRequest::add_job_ids(const char* value, size_t size) {
  _impl_.job_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:livekit.MigrateJobRequest.job_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MigrateJobRequest::job_ids() const {
  // @@protoc_insertion_point(field_list:livekit.MigrateJobRequest.job_ids)
  return _impl_.job_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MigrateJobRequest::mutable_job_ids() {
  // @@protoc_insertion_point(field_mutable_list:livekit.MigrateJobRequest.job_ids)
  return &_impl_.job_ids_;
}

// -------------------------------------------------------------------

// AvailabilityRequest

// .livekit.Job job = 1;
inline bool AvailabilityRequest::_internal_has_job() const {
  return this != internal_default_instance() && _impl_.job_ != nullptr;
}
inline bool AvailabilityRequest::has_job() const {
  return _internal_has_job();
}
inline void AvailabilityRequest::clear_job() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_ != nullptr) {
    delete _impl_.job_;
  }
  _impl_.job_ = nullptr;
}
inline const ::livekit::Job& AvailabilityRequest::_internal_job() const {
  const ::livekit::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Job&>(
      ::livekit::_Job_default_instance_);
}
inline const ::livekit::Job& AvailabilityRequest::job() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityRequest.job)
  return _internal_job();
}
inline void AvailabilityRequest::unsafe_arena_set_allocated_job(
    ::livekit::Job* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.AvailabilityRequest.job)
}
inline ::livekit::Job* AvailabilityRequest::release_job() {
  
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Job* AvailabilityRequest::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:livekit.AvailabilityRequest.job)
  
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::livekit::Job* AvailabilityRequest::_internal_mutable_job() {
  
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Job>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::livekit::Job* AvailabilityRequest::mutable_job() {
  ::livekit::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityRequest.job)
  return _msg;
}
inline void AvailabilityRequest::set_allocated_job(::livekit::Job* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityRequest.job)
}

// bool resuming = 2;
inline void AvailabilityRequest::clear_resuming() {
  _impl_.resuming_ = false;
}
inline bool AvailabilityRequest::_internal_resuming() const {
  return _impl_.resuming_;
}
inline bool AvailabilityRequest::resuming() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityRequest.resuming)
  return _internal_resuming();
}
inline void AvailabilityRequest::_internal_set_resuming(bool value) {
  
  _impl_.resuming_ = value;
}
inline void AvailabilityRequest::set_resuming(bool value) {
  _internal_set_resuming(value);
  // @@protoc_insertion_point(field_set:livekit.AvailabilityRequest.resuming)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AvailabilityResponse

// string job_id = 1;
inline void AvailabilityResponse::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& AvailabilityResponse::job_id() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvailabilityResponse::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.job_id)
}
inline std::string* AvailabilityResponse::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.job_id)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void AvailabilityResponse::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::release_job_id() {
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.job_id)
  return _impl_.job_id_.Release();
}
inline void AvailabilityResponse::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.job_id)
}

// bool available = 2;
inline void AvailabilityResponse::clear_available() {
  _impl_.available_ = false;
}
inline bool AvailabilityResponse::_internal_available() const {
  return _impl_.available_;
}
inline bool AvailabilityResponse::available() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.available)
  return _internal_available();
}
inline void AvailabilityResponse::_internal_set_available(bool value) {
  
  _impl_.available_ = value;
}
inline void AvailabilityResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.available)
}

// bool supports_resume = 3;
inline void AvailabilityResponse::clear_supports_resume() {
  _impl_.supports_resume_ = false;
}
inline bool AvailabilityResponse::_internal_supports_resume() const {
  return _impl_.supports_resume_;
}
inline bool AvailabilityResponse::supports_resume() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.supports_resume)
  return _internal_supports_resume();
}
inline void AvailabilityResponse::_internal_set_supports_resume(bool value) {
  
  _impl_.supports_resume_ = value;
}
inline void AvailabilityResponse::set_supports_resume(bool value) {
  _internal_set_supports_resume(value);
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.supports_resume)
}

// string participant_name = 4;
inline void AvailabilityResponse::clear_participant_name() {
  _impl_.participant_name_.ClearToEmpty();
}
inline const std::string& AvailabilityResponse::participant_name() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_name)
  return _internal_participant_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvailabilityResponse::set_participant_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_name)
}
inline std::string* AvailabilityResponse::mutable_participant_name() {
  std::string* _s = _internal_mutable_participant_name();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_name)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_name() const {
  return _impl_.participant_name_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_name(const std::string& value) {
  
  _impl_.participant_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::_internal_mutable_participant_name() {
  
  return _impl_.participant_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::release_participant_name() {
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_name)
  return _impl_.participant_name_.Release();
}
inline void AvailabilityResponse::set_allocated_participant_name(std::string* participant_name) {
  if (participant_name != nullptr) {
    
  } else {
    
  }
  _impl_.participant_name_.SetAllocated(participant_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_name_.IsDefault()) {
    _impl_.participant_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_name)
}

// string participant_identity = 5;
inline void AvailabilityResponse::clear_participant_identity() {
  _impl_.participant_identity_.ClearToEmpty();
}
inline const std::string& AvailabilityResponse::participant_identity() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_identity)
  return _internal_participant_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvailabilityResponse::set_participant_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_identity)
}
inline std::string* AvailabilityResponse::mutable_participant_identity() {
  std::string* _s = _internal_mutable_participant_identity();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_identity)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_identity() const {
  return _impl_.participant_identity_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_identity(const std::string& value) {
  
  _impl_.participant_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::_internal_mutable_participant_identity() {
  
  return _impl_.participant_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::release_participant_identity() {
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_identity)
  return _impl_.participant_identity_.Release();
}
inline void AvailabilityResponse::set_allocated_participant_identity(std::string* participant_identity) {
  if (participant_identity != nullptr) {
    
  } else {
    
  }
  _impl_.participant_identity_.SetAllocated(participant_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_identity_.IsDefault()) {
    _impl_.participant_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_identity)
}

// string participant_metadata = 6;
inline void AvailabilityResponse::clear_participant_metadata() {
  _impl_.participant_metadata_.ClearToEmpty();
}
inline const std::string& AvailabilityResponse::participant_metadata() const {
  // @@protoc_insertion_point(field_get:livekit.AvailabilityResponse.participant_metadata)
  return _internal_participant_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AvailabilityResponse::set_participant_metadata(ArgT0&& arg0, ArgT... args) {
 
 _impl_.participant_metadata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.AvailabilityResponse.participant_metadata)
}
inline std::string* AvailabilityResponse::mutable_participant_metadata() {
  std::string* _s = _internal_mutable_participant_metadata();
  // @@protoc_insertion_point(field_mutable:livekit.AvailabilityResponse.participant_metadata)
  return _s;
}
inline const std::string& AvailabilityResponse::_internal_participant_metadata() const {
  return _impl_.participant_metadata_.Get();
}
inline void AvailabilityResponse::_internal_set_participant_metadata(const std::string& value) {
  
  _impl_.participant_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::_internal_mutable_participant_metadata() {
  
  return _impl_.participant_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* AvailabilityResponse::release_participant_metadata() {
  // @@protoc_insertion_point(field_release:livekit.AvailabilityResponse.participant_metadata)
  return _impl_.participant_metadata_.Release();
}
inline void AvailabilityResponse::set_allocated_participant_metadata(std::string* participant_metadata) {
  if (participant_metadata != nullptr) {
    
  } else {
    
  }
  _impl_.participant_metadata_.SetAllocated(participant_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.participant_metadata_.IsDefault()) {
    _impl_.participant_metadata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.AvailabilityResponse.participant_metadata)
}

// map<string, string> participant_attributes = 7;
inline int AvailabilityResponse::_internal_participant_attributes_size() const {
  return _impl_.participant_attributes_.size();
}
inline int AvailabilityResponse::participant_attributes_size() const {
  return _internal_participant_attributes_size();
}
inline void AvailabilityResponse::clear_participant_attributes() {
  _impl_.participant_attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AvailabilityResponse::_internal_participant_attributes() const {
  return _impl_.participant_attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AvailabilityResponse::participant_attributes() const {
  // @@protoc_insertion_point(field_map:livekit.AvailabilityResponse.participant_attributes)
  return _internal_participant_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AvailabilityResponse::_internal_mutable_participant_attributes() {
  return _impl_.participant_attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AvailabilityResponse::mutable_participant_attributes() {
  // @@protoc_insertion_point(field_mutable_map:livekit.AvailabilityResponse.participant_attributes)
  return _internal_mutable_participant_attributes();
}

// -------------------------------------------------------------------

// UpdateJobStatus

// string job_id = 1;
inline void UpdateJobStatus::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& UpdateJobStatus::job_id() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobStatus::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.job_id)
}
inline std::string* UpdateJobStatus::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateJobStatus.job_id)
  return _s;
}
inline const std::string& UpdateJobStatus::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void UpdateJobStatus::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobStatus::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobStatus::release_job_id() {
  // @@protoc_insertion_point(field_release:livekit.UpdateJobStatus.job_id)
  return _impl_.job_id_.Release();
}
inline void UpdateJobStatus::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateJobStatus.job_id)
}

// .livekit.JobStatus status = 2;
inline void UpdateJobStatus::clear_status() {
  _impl_.status_ = 0;
}
inline ::livekit::JobStatus UpdateJobStatus::_internal_status() const {
  return static_cast< ::livekit::JobStatus >(_impl_.status_);
}
inline ::livekit::JobStatus UpdateJobStatus::status() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.status)
  return _internal_status();
}
inline void UpdateJobStatus::_internal_set_status(::livekit::JobStatus value) {
  
  _impl_.status_ = value;
}
inline void UpdateJobStatus::set_status(::livekit::JobStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.status)
}

// string error = 3;
inline void UpdateJobStatus::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& UpdateJobStatus::error() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateJobStatus.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateJobStatus::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.UpdateJobStatus.error)
}
inline std::string* UpdateJobStatus::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:livekit.UpdateJobStatus.error)
  return _s;
}
inline const std::string& UpdateJobStatus::_internal_error() const {
  return _impl_.error_.Get();
}
inline void UpdateJobStatus::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateJobStatus::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateJobStatus::release_error() {
  // @@protoc_insertion_point(field_release:livekit.UpdateJobStatus.error)
  return _impl_.error_.Release();
}
inline void UpdateJobStatus::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.UpdateJobStatus.error)
}

// -------------------------------------------------------------------

// UpdateWorkerStatus

// optional .livekit.WorkerStatus status = 1;
inline bool UpdateWorkerStatus::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateWorkerStatus::has_status() const {
  return _internal_has_status();
}
inline void UpdateWorkerStatus::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::livekit::WorkerStatus UpdateWorkerStatus::_internal_status() const {
  return static_cast< ::livekit::WorkerStatus >(_impl_.status_);
}
inline ::livekit::WorkerStatus UpdateWorkerStatus::status() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.status)
  return _internal_status();
}
inline void UpdateWorkerStatus::_internal_set_status(::livekit::WorkerStatus value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}
inline void UpdateWorkerStatus::set_status(::livekit::WorkerStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.status)
}

// float load = 3;
inline void UpdateWorkerStatus::clear_load() {
  _impl_.load_ = 0;
}
inline float UpdateWorkerStatus::_internal_load() const {
  return _impl_.load_;
}
inline float UpdateWorkerStatus::load() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.load)
  return _internal_load();
}
inline void UpdateWorkerStatus::_internal_set_load(float value) {
  
  _impl_.load_ = value;
}
inline void UpdateWorkerStatus::set_load(float value) {
  _internal_set_load(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.load)
}

// uint32 job_count = 4;
inline void UpdateWorkerStatus::clear_job_count() {
  _impl_.job_count_ = 0u;
}
inline uint32_t UpdateWorkerStatus::_internal_job_count() const {
  return _impl_.job_count_;
}
inline uint32_t UpdateWorkerStatus::job_count() const {
  // @@protoc_insertion_point(field_get:livekit.UpdateWorkerStatus.job_count)
  return _internal_job_count();
}
inline void UpdateWorkerStatus::_internal_set_job_count(uint32_t value) {
  
  _impl_.job_count_ = value;
}
inline void UpdateWorkerStatus::set_job_count(uint32_t value) {
  _internal_set_job_count(value);
  // @@protoc_insertion_point(field_set:livekit.UpdateWorkerStatus.job_count)
}

// -------------------------------------------------------------------

// JobAssignment

// .livekit.Job job = 1;
inline bool JobAssignment::_internal_has_job() const {
  return this != internal_default_instance() && _impl_.job_ != nullptr;
}
inline bool JobAssignment::has_job() const {
  return _internal_has_job();
}
inline void JobAssignment::clear_job() {
  if (GetArenaForAllocation() == nullptr && _impl_.job_ != nullptr) {
    delete _impl_.job_;
  }
  _impl_.job_ = nullptr;
}
inline const ::livekit::Job& JobAssignment::_internal_job() const {
  const ::livekit::Job* p = _impl_.job_;
  return p != nullptr ? *p : reinterpret_cast<const ::livekit::Job&>(
      ::livekit::_Job_default_instance_);
}
inline const ::livekit::Job& JobAssignment::job() const {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.job)
  return _internal_job();
}
inline void JobAssignment::unsafe_arena_set_allocated_job(
    ::livekit::Job* job) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.job_);
  }
  _impl_.job_ = job;
  if (job) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:livekit.JobAssignment.job)
}
inline ::livekit::Job* JobAssignment::release_job() {
  
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::livekit::Job* JobAssignment::unsafe_arena_release_job() {
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.job)
  
  ::livekit::Job* temp = _impl_.job_;
  _impl_.job_ = nullptr;
  return temp;
}
inline ::livekit::Job* JobAssignment::_internal_mutable_job() {
  
  if (_impl_.job_ == nullptr) {
    auto* p = CreateMaybeMessage<::livekit::Job>(GetArenaForAllocation());
    _impl_.job_ = p;
  }
  return _impl_.job_;
}
inline ::livekit::Job* JobAssignment::mutable_job() {
  ::livekit::Job* _msg = _internal_mutable_job();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.job)
  return _msg;
}
inline void JobAssignment::set_allocated_job(::livekit::Job* job) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.job_;
  }
  if (job) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(job);
    if (message_arena != submessage_arena) {
      job = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, job, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.job_ = job;
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.job)
}

// optional string url = 2;
inline bool JobAssignment::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JobAssignment::has_url() const {
  return _internal_has_url();
}
inline void JobAssignment::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JobAssignment::url() const {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobAssignment::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JobAssignment.url)
}
inline std::string* JobAssignment::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.url)
  return _s;
}
inline const std::string& JobAssignment::_internal_url() const {
  return _impl_.url_.Get();
}
inline void JobAssignment::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* JobAssignment::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* JobAssignment::release_url() {
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void JobAssignment::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.url)
}

// string token = 3;
inline void JobAssignment::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& JobAssignment::token() const {
  // @@protoc_insertion_point(field_get:livekit.JobAssignment.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobAssignment::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JobAssignment.token)
}
inline std::string* JobAssignment::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:livekit.JobAssignment.token)
  return _s;
}
inline const std::string& JobAssignment::_internal_token() const {
  return _impl_.token_.Get();
}
inline void JobAssignment::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* JobAssignment::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* JobAssignment::release_token() {
  // @@protoc_insertion_point(field_release:livekit.JobAssignment.token)
  return _impl_.token_.Release();
}
inline void JobAssignment::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JobAssignment.token)
}

// -------------------------------------------------------------------

// JobTermination

// string job_id = 1;
inline void JobTermination::clear_job_id() {
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& JobTermination::job_id() const {
  // @@protoc_insertion_point(field_get:livekit.JobTermination.job_id)
  return _internal_job_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JobTermination::set_job_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.job_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:livekit.JobTermination.job_id)
}
inline std::string* JobTermination::mutable_job_id() {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:livekit.JobTermination.job_id)
  return _s;
}
inline const std::string& JobTermination::_internal_job_id() const {
  return _impl_.job_id_.Get();
}
inline void JobTermination::_internal_set_job_id(const std::string& value) {
  
  _impl_.job_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JobTermination::_internal_mutable_job_id() {
  
  return _impl_.job_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JobTermination::release_job_id() {
  // @@protoc_insertion_point(field_release:livekit.JobTermination.job_id)
  return _impl_.job_id_.Release();
}
inline void JobTermination::set_allocated_job_id(std::string* job_id) {
  if (job_id != nullptr) {
    
  } else {
    
  }
  _impl_.job_id_.SetAllocated(job_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:livekit.JobTermination.job_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace livekit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::livekit::JobType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::JobType>() {
  return ::livekit::JobType_descriptor();
}
template <> struct is_proto_enum< ::livekit::WorkerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::WorkerStatus>() {
  return ::livekit::WorkerStatus_descriptor();
}
template <> struct is_proto_enum< ::livekit::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::livekit::JobStatus>() {
  return ::livekit::JobStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livekit_5fagent_2eproto
